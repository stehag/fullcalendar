/*!
 v0.0.0
Docs & License: https://fullcalendar.io
(c) 2023 Adam Shaw
*/
(function () {
  'use strict';

  function styleInject(css, ref) {
    if ( ref === void 0 ) ref = {};
    var insertAt = ref.insertAt;

    if (!css || typeof document === 'undefined') { return; }

    var head = document.head || document.getElementsByTagName('head')[0];
    var style = document.createElement('style');
    style.type = 'text/css';

    if (insertAt === 'top') {
      if (head.firstChild) {
        head.insertBefore(style, head.firstChild);
      } else {
        head.appendChild(style);
      }
    } else {
      head.appendChild(style);
    }

    if (style.styleSheet) {
      style.styleSheet.cssText = css;
    } else {
      style.appendChild(document.createTextNode(css));
    }
  }

  var css_248z$6 = "body{font-family:Lucida Grande,Helvetica,Arial,Verdana,sans-serif;font-size:13px;margin-top:40px}.fc{margin:20px auto;max-width:900px}";
  styleInject(css_248z$6);

  var n$1,l$2,u$1,i$1,t,r$1,o,f$1,e$1,c$1={},s$2=[],a$1=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function h$1(n,l){for(var u in l)n[u]=l[u];return n}function v$1(n){var l=n.parentNode;l&&l.removeChild(n);}function y$1(l,u,i){var t,r,o,f={};for(o in u)"key"==o?t=u[o]:"ref"==o?r=u[o]:f[o]=u[o];if(arguments.length>2&&(f.children=arguments.length>3?n$1.call(arguments,2):i),"function"==typeof l&&null!=l.defaultProps)for(o in l.defaultProps)void 0===f[o]&&(f[o]=l.defaultProps[o]);return p(l,f,t,r,null)}function p(n,i,t,r,o){var f={type:n,props:i,key:t,ref:r,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:null==o?++u$1:o};return null==o&&null!=l$2.vnode&&l$2.vnode(f),f}function d$1(){return {current:null}}function _(n){return n.children}function k$1(n,l,u,i,t){var r;for(r in u)"children"===r||"key"===r||r in l||g$2(n,r,null,u[r],i);for(r in l)t&&"function"!=typeof l[r]||"children"===r||"key"===r||"value"===r||"checked"===r||u[r]===l[r]||g$2(n,r,l[r],u[r],i);}function b$1(n,l,u){"-"===l[0]?n.setProperty(l,null==u?"":u):n[l]=null==u?"":"number"!=typeof u||a$1.test(l)?u:u+"px";}function g$2(n,l,u,i,t){var r;n:if("style"===l)if("string"==typeof u)n.style.cssText=u;else {if("string"==typeof i&&(n.style.cssText=i=""),i)for(l in i)u&&l in u||b$1(n.style,l,"");if(u)for(l in u)i&&u[l]===i[l]||b$1(n.style,l,u[l]);}else if("o"===l[0]&&"n"===l[1])r=l!==(l=l.replace(/Capture$/,"")),l=l.toLowerCase()in n?l.toLowerCase().slice(2):l.slice(2),n.l||(n.l={}),n.l[l+r]=u,u?i||n.addEventListener(l,r?w$3:m$2,r):n.removeEventListener(l,r?w$3:m$2,r);else if("dangerouslySetInnerHTML"!==l){if(t)l=l.replace(/xlink(H|:h)/,"h").replace(/sName$/,"s");else if("width"!==l&&"height"!==l&&"href"!==l&&"list"!==l&&"form"!==l&&"tabIndex"!==l&&"download"!==l&&l in n)try{n[l]=null==u?"":u;break n}catch(n){}"function"==typeof u||(null==u||!1===u&&-1==l.indexOf("-")?n.removeAttribute(l):n.setAttribute(l,u));}}function m$2(n){t=!0;try{return this.l[n.type+!1](l$2.event?l$2.event(n):n)}finally{t=!1;}}function w$3(n){t=!0;try{return this.l[n.type+!0](l$2.event?l$2.event(n):n)}finally{t=!1;}}function x$1(n,l){this.props=n,this.context=l;}function A(n,l){if(null==l)return n.__?A(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return "function"==typeof n.type?A(n):null}function P$1(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return P$1(n)}}function C$1(n){t?setTimeout(n):f$1(n);}function T$1(n){(!n.__d&&(n.__d=!0)&&r$1.push(n)&&!$$2.__r++||o!==l$2.debounceRendering)&&((o=l$2.debounceRendering)||C$1)($$2);}function $$2(){var n,l,u,i,t,o,f,e;for(r$1.sort(function(n,l){return n.__v.__b-l.__v.__b});n=r$1.shift();)n.__d&&(l=r$1.length,i=void 0,t=void 0,f=(o=(u=n).__v).__e,(e=u.__P)&&(i=[],(t=h$1({},o)).__v=o.__v+1,M(e,o,t,u.__n,void 0!==e.ownerSVGElement,null!=o.__h?[f]:null,i,null==f?A(o):f,o.__h),N(i,o),o.__e!=f&&P$1(o)),r$1.length>l&&r$1.sort(function(n,l){return n.__v.__b-l.__v.__b}));$$2.__r=0;}function H$1(n,l,u,i,t,r,o,f,e,a){var h,v,y,d,k,b,g,m=i&&i.__k||s$2,w=m.length;for(u.__k=[],h=0;h<l.length;h++)if(null!=(d=u.__k[h]=null==(d=l[h])||"boolean"==typeof d?null:"string"==typeof d||"number"==typeof d||"bigint"==typeof d?p(null,d,null,null,d):Array.isArray(d)?p(_,{children:d},null,null,null):d.__b>0?p(d.type,d.props,d.key,d.ref?d.ref:null,d.__v):d)){if(d.__=u,d.__b=u.__b+1,null===(y=m[h])||y&&d.key==y.key&&d.type===y.type)m[h]=void 0;else for(v=0;v<w;v++){if((y=m[v])&&d.key==y.key&&d.type===y.type){m[v]=void 0;break}y=null;}M(n,d,y=y||c$1,t,r,o,f,e,a),k=d.__e,(v=d.ref)&&y.ref!=v&&(g||(g=[]),y.ref&&g.push(y.ref,null,d),g.push(v,d.__c||k,d)),null!=k?(null==b&&(b=k),"function"==typeof d.type&&d.__k===y.__k?d.__d=e=I$1(d,e,n):e=z$1(n,d,y,m,k,e),"function"==typeof u.type&&(u.__d=e)):e&&y.__e==e&&e.parentNode!=n&&(e=A(y));}for(u.__e=b,h=w;h--;)null!=m[h]&&("function"==typeof u.type&&null!=m[h].__e&&m[h].__e==u.__d&&(u.__d=L$1(i).nextSibling),q(m[h],m[h]));if(g)for(h=0;h<g.length;h++)S(g[h],g[++h],g[++h]);}function I$1(n,l,u){for(var i,t=n.__k,r=0;t&&r<t.length;r++)(i=t[r])&&(i.__=n,l="function"==typeof i.type?I$1(i,l,u):z$1(u,i,i,t,i.__e,l));return l}function j$2(n,l){return l=l||[],null==n||"boolean"==typeof n||(Array.isArray(n)?n.some(function(n){j$2(n,l);}):l.push(n)),l}function z$1(n,l,u,i,t,r){var o,f,e;if(void 0!==l.__d)o=l.__d,l.__d=void 0;else if(null==u||t!=r||null==t.parentNode)n:if(null==r||r.parentNode!==n)n.appendChild(t),o=null;else {for(f=r,e=0;(f=f.nextSibling)&&e<i.length;e+=1)if(f==t)break n;n.insertBefore(t,r),o=r;}return void 0!==o?o:t.nextSibling}function L$1(n){var l,u,i;if(null==n.type||"string"==typeof n.type)return n.__e;if(n.__k)for(l=n.__k.length-1;l>=0;l--)if((u=n.__k[l])&&(i=L$1(u)))return i;return null}function M(n,u,i,t,r,o,f,e,c){var s,a,v,y,p,d,k,b,g,m,w,A,P,C,T,$=u.type;if(void 0!==u.constructor)return null;null!=i.__h&&(c=i.__h,e=u.__e=i.__e,u.__h=null,o=[e]),(s=l$2.__b)&&s(u);try{n:if("function"==typeof $){if(b=u.props,g=(s=$.contextType)&&t[s.__c],m=s?g?g.props.value:s.__:t,i.__c?k=(a=u.__c=i.__c).__=a.__E:("prototype"in $&&$.prototype.render?u.__c=a=new $(b,m):(u.__c=a=new x$1(b,m),a.constructor=$,a.render=B$1),g&&g.sub(a),a.props=b,a.state||(a.state={}),a.context=m,a.__n=t,v=a.__d=!0,a.__h=[],a._sb=[]),null==a.__s&&(a.__s=a.state),null!=$.getDerivedStateFromProps&&(a.__s==a.state&&(a.__s=h$1({},a.__s)),h$1(a.__s,$.getDerivedStateFromProps(b,a.__s))),y=a.props,p=a.state,a.__v=u,v)null==$.getDerivedStateFromProps&&null!=a.componentWillMount&&a.componentWillMount(),null!=a.componentDidMount&&a.__h.push(a.componentDidMount);else {if(null==$.getDerivedStateFromProps&&b!==y&&null!=a.componentWillReceiveProps&&a.componentWillReceiveProps(b,m),!a.__e&&null!=a.shouldComponentUpdate&&!1===a.shouldComponentUpdate(b,a.__s,m)||u.__v===i.__v){for(u.__v!==i.__v&&(a.props=b,a.state=a.__s,a.__d=!1),u.__e=i.__e,u.__k=i.__k,u.__k.forEach(function(n){n&&(n.__=u);}),w=0;w<a._sb.length;w++)a.__h.push(a._sb[w]);a._sb=[],a.__h.length&&f.push(a);break n}null!=a.componentWillUpdate&&a.componentWillUpdate(b,a.__s,m),null!=a.componentDidUpdate&&a.__h.push(function(){a.componentDidUpdate(y,p,d);});}if(a.context=m,a.props=b,a.__P=n,A=l$2.__r,P=0,"prototype"in $&&$.prototype.render){for(a.state=a.__s,a.__d=!1,A&&A(u),s=a.render(a.props,a.state,a.context),C=0;C<a._sb.length;C++)a.__h.push(a._sb[C]);a._sb=[];}else do{a.__d=!1,A&&A(u),s=a.render(a.props,a.state,a.context),a.state=a.__s;}while(a.__d&&++P<25);a.state=a.__s,null!=a.getChildContext&&(t=h$1(h$1({},t),a.getChildContext())),v||null==a.getSnapshotBeforeUpdate||(d=a.getSnapshotBeforeUpdate(y,p)),T=null!=s&&s.type===_&&null==s.key?s.props.children:s,H$1(n,Array.isArray(T)?T:[T],u,i,t,r,o,f,e,c),a.base=u.__e,u.__h=null,a.__h.length&&f.push(a),k&&(a.__E=a.__=null),a.__e=!1;}else null==o&&u.__v===i.__v?(u.__k=i.__k,u.__e=i.__e):u.__e=O(i.__e,u,i,t,r,o,f,c);(s=l$2.diffed)&&s(u);}catch(n){u.__v=null,(c||null!=o)&&(u.__e=e,u.__h=!!c,o[o.indexOf(e)]=null),l$2.__e(n,u,i);}}function N(n,u){l$2.__c&&l$2.__c(u,n),n.some(function(u){try{n=u.__h,u.__h=[],n.some(function(n){n.call(u);});}catch(n){l$2.__e(n,u.__v);}});}function O(l,u,i,t,r,o,f,e){var s,a,h,y=i.props,p=u.props,d=u.type,_=0;if("svg"===d&&(r=!0),null!=o)for(;_<o.length;_++)if((s=o[_])&&"setAttribute"in s==!!d&&(d?s.localName===d:3===s.nodeType)){l=s,o[_]=null;break}if(null==l){if(null===d)return document.createTextNode(p);l=r?document.createElementNS("http://www.w3.org/2000/svg",d):document.createElement(d,p.is&&p),o=null,e=!1;}if(null===d)y===p||e&&l.data===p||(l.data=p);else {if(o=o&&n$1.call(l.childNodes),a=(y=i.props||c$1).dangerouslySetInnerHTML,h=p.dangerouslySetInnerHTML,!e){if(null!=o)for(y={},_=0;_<l.attributes.length;_++)y[l.attributes[_].name]=l.attributes[_].value;(h||a)&&(h&&(a&&h.__html==a.__html||h.__html===l.innerHTML)||(l.innerHTML=h&&h.__html||""));}if(k$1(l,p,y,r,e),h)u.__k=[];else if(_=u.props.children,H$1(l,Array.isArray(_)?_:[_],u,i,t,r&&"foreignObject"!==d,o,f,o?o[0]:i.__k&&A(i,0),e),null!=o)for(_=o.length;_--;)null!=o[_]&&v$1(o[_]);e||("value"in p&&void 0!==(_=p.value)&&(_!==l.value||"progress"===d&&!_||"option"===d&&_!==y.value)&&g$2(l,"value",_,y.value,!1),"checked"in p&&void 0!==(_=p.checked)&&_!==l.checked&&g$2(l,"checked",_,y.checked,!1));}return l}function S(n,u,i){try{"function"==typeof n?n(u):n.current=u;}catch(n){l$2.__e(n,i);}}function q(n,u,i){var t,r;if(l$2.unmount&&l$2.unmount(n),(t=n.ref)&&(t.current&&t.current!==n.__e||S(t,null,u)),null!=(t=n.__c)){if(t.componentWillUnmount)try{t.componentWillUnmount();}catch(n){l$2.__e(n,u);}t.base=t.__P=null,n.__c=void 0;}if(t=n.__k)for(r=0;r<t.length;r++)t[r]&&q(t[r],u,i||"function"!=typeof n.type);i||null==n.__e||v$1(n.__e),n.__=n.__e=n.__d=void 0;}function B$1(n,l,u){return this.constructor(n,u)}function D$1(u,i,t){var r,o,f;l$2.__&&l$2.__(u,i),o=(r="function"==typeof t)?null:t&&t.__k||i.__k,f=[],M(i,u=(!r&&t||i).__k=y$1(_,null,[u]),o||c$1,c$1,void 0!==i.ownerSVGElement,!r&&t?[t]:o?null:i.firstChild?n$1.call(i.childNodes):null,f,!r&&t?t:o?o.__e:i.firstChild,r),N(f,u);}function G$1(n,l){var u={__c:l="__cC"+e$1++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n){var u,i;return this.getChildContext||(u=[],(i={})[l]=this,this.getChildContext=function(){return i},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(function(n){n.__e=!0,T$1(n);});},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u.splice(u.indexOf(n),1),l&&l.call(n);};}),n.children}};return u.Provider.__=u.Consumer.contextType=u}n$1=s$2.slice,l$2={__e:function(n,l,u,i){for(var t,r,o;l=l.__;)if((t=l.__c)&&!t.__)try{if((r=t.constructor)&&null!=r.getDerivedStateFromError&&(t.setState(r.getDerivedStateFromError(n)),o=t.__d),null!=t.componentDidCatch&&(t.componentDidCatch(n,i||{}),o=t.__d),o)return t.__E=t}catch(l){n=l;}throw n}},u$1=0,i$1=function(n){return null!=n&&void 0===n.constructor},t=!1,x$1.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=h$1({},this.state),"function"==typeof n&&(n=n(h$1({},u),this.props)),n&&h$1(u,n),null!=n&&this.__v&&(l&&this._sb.push(l),T$1(this));},x$1.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),T$1(this));},x$1.prototype.render=_,r$1=[],f$1="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,$$2.__r=0,e$1=0;

  var r,u,i,f=[],c=[],e=l$2.__b,a=l$2.__r,v=l$2.diffed,l$1=l$2.__c,m$1=l$2.unmount;function b(){for(var t;t=f.shift();)if(t.__P&&t.__H)try{t.__H.__h.forEach(k),t.__H.__h.forEach(w$2),t.__H.__h=[];}catch(r){t.__H.__h=[],l$2.__e(r,t.__v);}}l$2.__b=function(n){r=null,e&&e(n);},l$2.__r=function(n){a&&a(n);var i=(r=n.__c).__H;i&&(u===r?(i.__h=[],r.__h=[],i.__.forEach(function(n){n.__N&&(n.__=n.__N),n.__V=c,n.__N=n.i=void 0;})):(i.__h.forEach(k),i.__h.forEach(w$2),i.__h=[])),u=r;},l$2.diffed=function(t){v&&v(t);var o=t.__c;o&&o.__H&&(o.__H.__h.length&&(1!==f.push(o)&&i===l$2.requestAnimationFrame||((i=l$2.requestAnimationFrame)||j$1)(b)),o.__H.__.forEach(function(n){n.i&&(n.__H=n.i),n.__V!==c&&(n.__=n.__V),n.i=void 0,n.__V=c;})),u=r=null;},l$2.__c=function(t,r){r.some(function(t){try{t.__h.forEach(k),t.__h=t.__h.filter(function(n){return !n.__||w$2(n)});}catch(u){r.some(function(n){n.__h&&(n.__h=[]);}),r=[],l$2.__e(u,t.__v);}}),l$1&&l$1(t,r);},l$2.unmount=function(t){m$1&&m$1(t);var r,u=t.__c;u&&u.__H&&(u.__H.__.forEach(function(n){try{k(n);}catch(n){r=n;}}),u.__H=void 0,r&&l$2.__e(r,u.__v));};var g$1="function"==typeof requestAnimationFrame;function j$1(n){var t,r=function(){clearTimeout(u),g$1&&cancelAnimationFrame(t),setTimeout(n);},u=setTimeout(r,100);g$1&&(t=requestAnimationFrame(r));}function k(n){var t=r,u=n.__c;"function"==typeof u&&(n.__c=void 0,u()),r=t;}function w$2(n){var t=r;n.__c=n.__(),r=t;}

  function g(n,t){for(var e in t)n[e]=t[e];return n}function C(n,t){for(var e in n)if("__source"!==e&&!(e in t))return !0;for(var r in t)if("__source"!==r&&n[r]!==t[r])return !0;return !1}function w$1(n){this.props=n;}(w$1.prototype=new x$1).isPureReactComponent=!0,w$1.prototype.shouldComponentUpdate=function(n,t){return C(this.props,n)||C(this.state,t)};var x=l$2.__b;l$2.__b=function(n){n.type&&n.type.__f&&n.ref&&(n.props.ref=n.ref,n.ref=null),x&&x(n);};var T=l$2.__e;l$2.__e=function(n,t,e,r){if(n.then)for(var u,o=t;o=o.__;)if((u=o.__c)&&u.__c)return null==t.__e&&(t.__e=e.__e,t.__k=e.__k),u.__c(n,t);T(n,t,e,r);};var I=l$2.unmount;function L(n,t,e){return n&&(n.__c&&n.__c.__H&&(n.__c.__H.__.forEach(function(n){"function"==typeof n.__c&&n.__c();}),n.__c.__H=null),null!=(n=g({},n)).__c&&(n.__c.__P===e&&(n.__c.__P=t),n.__c=null),n.__k=n.__k&&n.__k.map(function(n){return L(n,t,e)})),n}function U(n,t,e){return n&&(n.__v=null,n.__k=n.__k&&n.__k.map(function(n){return U(n,t,e)}),n.__c&&n.__c.__P===t&&(n.__e&&e.insertBefore(n.__e,n.__d),n.__c.__e=!0,n.__c.__P=e)),n}function D(){this.__u=0,this.t=null,this.__b=null;}function F(n){var t=n.__.__c;return t&&t.__a&&t.__a(n)}function V(){this.u=null,this.o=null;}l$2.unmount=function(n){var t=n.__c;t&&t.__R&&t.__R(),t&&!0===n.__h&&(n.type=null),I&&I(n);},(D.prototype=new x$1).__c=function(n,t){var e=t.__c,r=this;null==r.t&&(r.t=[]),r.t.push(e);var u=F(r.__v),o=!1,i=function(){o||(o=!0,e.__R=null,u?u(l):l());};e.__R=i;var l=function(){if(!--r.__u){if(r.state.__a){var n=r.state.__a;r.__v.__k[0]=U(n,n.__c.__P,n.__c.__O);}var t;for(r.setState({__a:r.__b=null});t=r.t.pop();)t.forceUpdate();}},c=!0===t.__h;r.__u++||c||r.setState({__a:r.__b=r.__v.__k[0]}),n.then(i,i);},D.prototype.componentWillUnmount=function(){this.t=[];},D.prototype.render=function(n,e){if(this.__b){if(this.__v.__k){var r=document.createElement("div"),o=this.__v.__k[0].__c;this.__v.__k[0]=L(this.__b,r,o.__O=o.__P);}this.__b=null;}var i=e.__a&&y$1(_,null,n.fallback);return i&&(i.__h=null),[y$1(_,null,e.__a?null:n.children),i]};var W=function(n,t,e){if(++e[1]===e[0]&&n.o.delete(t),n.props.revealOrder&&("t"!==n.props.revealOrder[0]||!n.o.size))for(e=n.u;e;){for(;e.length>3;)e.pop()();if(e[1]<e[0])break;n.u=e=e[2];}};function P(n){return this.getChildContext=function(){return n.context},n.children}function $$1(n){var e=this,r=n.i;e.componentWillUnmount=function(){D$1(null,e.l),e.l=null,e.i=null;},e.i&&e.i!==r&&e.componentWillUnmount(),n.__v?(e.l||(e.i=r,e.l={nodeType:1,parentNode:r,childNodes:[],appendChild:function(n){this.childNodes.push(n),e.i.appendChild(n);},insertBefore:function(n,t){this.childNodes.push(n),e.i.appendChild(n);},removeChild:function(n){this.childNodes.splice(this.childNodes.indexOf(n)>>>1,1),e.i.removeChild(n);}}),D$1(y$1(P,{context:e.context},n.__v),e.l)):e.l&&e.componentWillUnmount();}function j(n,e){var r=y$1($$1,{__v:n,i:e});return r.containerInfo=e,r}(V.prototype=new x$1).__a=function(n){var t=this,e=F(t.__v),r=t.o.get(n);return r[0]++,function(u){var o=function(){t.props.revealOrder?(r.push(u),W(t,n,r)):u();};e?e(o):o();}},V.prototype.render=function(n){this.u=null,this.o=new Map;var t=j$2(n.children);n.revealOrder&&"b"===n.revealOrder[0]&&t.reverse();for(var e=t.length;e--;)this.o.set(t[e],this.u=[1,0,this.u]);return n.children},V.prototype.componentDidUpdate=V.prototype.componentDidMount=function(){var n=this;this.o.forEach(function(t,e){W(n,e,t);});};var z="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103,B=/^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,H="undefined"!=typeof document,Z=function(n){return ("undefined"!=typeof Symbol&&"symbol"==typeof Symbol()?/fil|che|rad/i:/fil|che|ra/i).test(n)};x$1.prototype.isReactComponent={},["componentWillMount","componentWillReceiveProps","componentWillUpdate"].forEach(function(t){Object.defineProperty(x$1.prototype,t,{configurable:!0,get:function(){return this["UNSAFE_"+t]},set:function(n){Object.defineProperty(this,t,{configurable:!0,writable:!0,value:n});}});});var G=l$2.event;function J(){}function K(){return this.cancelBubble}function Q(){return this.defaultPrevented}l$2.event=function(n){return G&&(n=G(n)),n.persist=J,n.isPropagationStopped=K,n.isDefaultPrevented=Q,n.nativeEvent=n};var nn={configurable:!0,get:function(){return this.class}},tn=l$2.vnode;l$2.vnode=function(n){var t=n.type,e=n.props,u=e;if("string"==typeof t){var o=-1===t.indexOf("-");for(var i in u={},e){var l=e[i];H&&"children"===i&&"noscript"===t||"value"===i&&"defaultValue"in e&&null==l||("defaultValue"===i&&"value"in e&&null==e.value?i="value":"download"===i&&!0===l?l="":/ondoubleclick/i.test(i)?i="ondblclick":/^onchange(textarea|input)/i.test(i+t)&&!Z(e.type)?i="oninput":/^onfocus$/i.test(i)?i="onfocusin":/^onblur$/i.test(i)?i="onfocusout":/^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(i)?i=i.toLowerCase():o&&B.test(i)?i=i.replace(/[A-Z0-9]/g,"-$&").toLowerCase():null===l&&(l=void 0),/^oninput$/i.test(i)&&(i=i.toLowerCase(),u[i]&&(i="oninputCapture")),u[i]=l);}"select"==t&&u.multiple&&Array.isArray(u.value)&&(u.value=j$2(e.children).forEach(function(n){n.props.selected=-1!=u.value.indexOf(n.props.value);})),"select"==t&&null!=u.defaultValue&&(u.value=j$2(e.children).forEach(function(n){n.props.selected=u.multiple?-1!=u.defaultValue.indexOf(n.props.value):u.defaultValue==n.props.value;})),n.props=u,e.class!=e.className&&(nn.enumerable="className"in e,null!=e.className&&(u.class=e.className),Object.defineProperty(u,"className",nn));}n.$$typeof=z,tn&&tn(n);};var en=l$2.__r;l$2.__r=function(n){en&&en(n),n.__c;};

  const styleTexts = [];
  const styleEls = new Map();
  function injectStyles(styleText) {
      styleTexts.push(styleText);
      styleEls.forEach((styleEl) => {
          appendStylesTo(styleEl, styleText);
      });
  }
  function ensureElHasStyles(el) {
      if (el.isConnected && typeof el.getRootNode === 'function') {
          registerStylesRoot(el.getRootNode());
      }
  }
  function registerStylesRoot(rootNode) {
      let styleEl = styleEls.get(rootNode);
      if (!styleEl || !styleEl.isConnected) {
          styleEl = rootNode.querySelector('style[data-fullcalendar]');
          if (!styleEl) {
              styleEl = document.createElement('style');
              styleEl.setAttribute('data-fullcalendar', '');
              const nonce = getNonceValue();
              if (nonce) {
                  styleEl.nonce = nonce;
              }
              const parentEl = rootNode === document ? document.head : rootNode;
              const insertBefore = rootNode === document
                  ? parentEl.querySelector('script,link[rel=stylesheet],link[as=style],style')
                  : parentEl.firstChild;
              parentEl.insertBefore(styleEl, insertBefore);
          }
          styleEls.set(rootNode, styleEl);
          hydrateStylesRoot(styleEl);
      }
  }
  function hydrateStylesRoot(styleEl) {
      for (const styleText of styleTexts) {
          appendStylesTo(styleEl, styleText);
      }
  }
  function appendStylesTo(styleEl, styleText) {
      const { sheet } = styleEl;
      const ruleCnt = sheet.cssRules.length;
      styleText.split('}').forEach((styleStr, i) => {
          styleStr = styleStr.trim();
          if (styleStr) {
              sheet.insertRule(styleStr + '}', ruleCnt + i);
          }
      });
  }
  // nonce
  // -------------------------------------------------------------------------------------------------
  let queriedNonceValue;
  function getNonceValue() {
      if (queriedNonceValue === undefined) {
          queriedNonceValue = queryNonceValue();
      }
      return queriedNonceValue;
  }
  /*
  TODO: discourage meta tag and instead put nonce attribute on placeholder <style> tag
  */
  function queryNonceValue() {
      const metaWithNonce = document.querySelector('meta[name="csp-nonce"]');
      if (metaWithNonce && metaWithNonce.hasAttribute('content')) {
          return metaWithNonce.getAttribute('content');
      }
      const elWithNonce = document.querySelector('script[nonce]');
      if (elWithNonce) {
          return elWithNonce.nonce || '';
      }
      return '';
  }
  // main
  // -------------------------------------------------------------------------------------------------
  if (typeof document !== 'undefined') {
      registerStylesRoot(document);
  }

  var css_248z$5 = ":root{--fc-small-font-size:.85em;--fc-page-bg-color:#fff;--fc-neutral-bg-color:hsla(0,0%,82%,.3);--fc-neutral-text-color:grey;--fc-border-color:#ddd;--fc-button-text-color:#fff;--fc-button-bg-color:#2c3e50;--fc-button-border-color:#2c3e50;--fc-button-hover-bg-color:#1e2b37;--fc-button-hover-border-color:#1a252f;--fc-button-active-bg-color:#1a252f;--fc-button-active-border-color:#151e27;--fc-event-bg-color:#3788d8;--fc-event-border-color:#3788d8;--fc-event-text-color:#fff;--fc-event-selected-overlay-color:rgba(0,0,0,.25);--fc-more-link-bg-color:#d0d0d0;--fc-more-link-text-color:inherit;--fc-event-resizer-thickness:8px;--fc-event-resizer-dot-total-width:8px;--fc-event-resizer-dot-border-width:1px;--fc-non-business-color:hsla(0,0%,84%,.3);--fc-bg-event-color:#8fdf82;--fc-bg-event-opacity:0.3;--fc-highlight-color:rgba(188,232,241,.3);--fc-today-bg-color:rgba(255,220,40,.15);--fc-now-indicator-color:red}.fc-not-allowed,.fc-not-allowed .fc-event{cursor:not-allowed}.fc{display:flex;flex-direction:column;font-size:1em}.fc,.fc *,.fc :after,.fc :before{box-sizing:border-box}.fc table{border-collapse:collapse;border-spacing:0;font-size:1em}.fc th{text-align:center}.fc td,.fc th{padding:0;vertical-align:top}.fc a[data-navlink]{cursor:pointer}.fc a[data-navlink]:hover{text-decoration:underline}.fc-direction-ltr{direction:ltr;text-align:left}.fc-direction-rtl{direction:rtl;text-align:right}.fc-theme-standard td,.fc-theme-standard th{border:1px solid var(--fc-border-color)}.fc-liquid-hack td,.fc-liquid-hack th{position:relative}@font-face{font-family:fcicons;font-style:normal;font-weight:400;src:url(\"data:application/x-font-ttf;charset=utf-8;base64,AAEAAAALAIAAAwAwT1MvMg8SBfAAAAC8AAAAYGNtYXAXVtKNAAABHAAAAFRnYXNwAAAAEAAAAXAAAAAIZ2x5ZgYydxIAAAF4AAAFNGhlYWQUJ7cIAAAGrAAAADZoaGVhB20DzAAABuQAAAAkaG10eCIABhQAAAcIAAAALGxvY2ED4AU6AAAHNAAAABhtYXhwAA8AjAAAB0wAAAAgbmFtZXsr690AAAdsAAABhnBvc3QAAwAAAAAI9AAAACAAAwPAAZAABQAAApkCzAAAAI8CmQLMAAAB6wAzAQkAAAAAAAAAAAAAAAAAAAABEAAAAAAAAAAAAAAAAAAAAABAAADpBgPA/8AAQAPAAEAAAAABAAAAAAAAAAAAAAAgAAAAAAADAAAAAwAAABwAAQADAAAAHAADAAEAAAAcAAQAOAAAAAoACAACAAIAAQAg6Qb//f//AAAAAAAg6QD//f//AAH/4xcEAAMAAQAAAAAAAAAAAAAAAQAB//8ADwABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAAAQAAAAAAAAAAAAIAADc5AQAAAAABAWIAjQKeAskAEwAAJSc3NjQnJiIHAQYUFwEWMjc2NCcCnuLiDQ0MJAz/AA0NAQAMJAwNDcni4gwjDQwM/wANIwz/AA0NDCMNAAAAAQFiAI0CngLJABMAACUBNjQnASYiBwYUHwEHBhQXFjI3AZ4BAA0N/wAMJAwNDeLiDQ0MJAyNAQAMIw0BAAwMDSMM4uINIwwNDQAAAAIA4gC3Ax4CngATACcAACUnNzY0JyYiDwEGFB8BFjI3NjQnISc3NjQnJiIPAQYUHwEWMjc2NCcB87e3DQ0MIw3VDQ3VDSMMDQ0BK7e3DQ0MJAzVDQ3VDCQMDQ3zuLcMJAwNDdUNIwzWDAwNIwy4twwkDA0N1Q0jDNYMDA0jDAAAAgDiALcDHgKeABMAJwAAJTc2NC8BJiIHBhQfAQcGFBcWMjchNzY0LwEmIgcGFB8BBwYUFxYyNwJJ1Q0N1Q0jDA0Nt7cNDQwjDf7V1Q0N1QwkDA0Nt7cNDQwkDLfWDCMN1Q0NDCQMt7gMIw0MDNYMIw3VDQ0MJAy3uAwjDQwMAAADAFUAAAOrA1UAMwBoAHcAABMiBgcOAQcOAQcOARURFBYXHgEXHgEXHgEzITI2Nz4BNz4BNz4BNRE0JicuAScuAScuASMFITIWFx4BFx4BFx4BFREUBgcOAQcOAQcOASMhIiYnLgEnLgEnLgE1ETQ2Nz4BNz4BNz4BMxMhMjY1NCYjISIGFRQWM9UNGAwLFQkJDgUFBQUFBQ4JCRULDBgNAlYNGAwLFQkJDgUFBQUFBQ4JCRULDBgN/aoCVgQIBAQHAwMFAQIBAQIBBQMDBwQECAT9qgQIBAQHAwMFAQIBAQIBBQMDBwQECASAAVYRGRkR/qoRGRkRA1UFBAUOCQkVDAsZDf2rDRkLDBUJCA4FBQUFBQUOCQgVDAsZDQJVDRkLDBUJCQ4FBAVVAgECBQMCBwQECAX9qwQJAwQHAwMFAQICAgIBBQMDBwQDCQQCVQUIBAQHAgMFAgEC/oAZEhEZGRESGQAAAAADAFUAAAOrA1UAMwBoAIkAABMiBgcOAQcOAQcOARURFBYXHgEXHgEXHgEzITI2Nz4BNz4BNz4BNRE0JicuAScuAScuASMFITIWFx4BFx4BFx4BFREUBgcOAQcOAQcOASMhIiYnLgEnLgEnLgE1ETQ2Nz4BNz4BNz4BMxMzFRQWMzI2PQEzMjY1NCYrATU0JiMiBh0BIyIGFRQWM9UNGAwLFQkJDgUFBQUFBQ4JCRULDBgNAlYNGAwLFQkJDgUFBQUFBQ4JCRULDBgN/aoCVgQIBAQHAwMFAQIBAQIBBQMDBwQECAT9qgQIBAQHAwMFAQIBAQIBBQMDBwQECASAgBkSEhmAERkZEYAZEhIZgBEZGREDVQUEBQ4JCRUMCxkN/asNGQsMFQkIDgUFBQUFBQ4JCBUMCxkNAlUNGQsMFQkJDgUEBVUCAQIFAwIHBAQIBf2rBAkDBAcDAwUBAgICAgEFAwMHBAMJBAJVBQgEBAcCAwUCAQL+gIASGRkSgBkSERmAEhkZEoAZERIZAAABAOIAjQMeAskAIAAAExcHBhQXFjI/ARcWMjc2NC8BNzY0JyYiDwEnJiIHBhQX4uLiDQ0MJAzi4gwkDA0N4uINDQwkDOLiDCQMDQ0CjeLiDSMMDQ3h4Q0NDCMN4uIMIw0MDOLiDAwNIwwAAAABAAAAAQAAa5n0y18PPPUACwQAAAAAANivOVsAAAAA2K85WwAAAAADqwNVAAAACAACAAAAAAAAAAEAAAPA/8AAAAQAAAAAAAOrAAEAAAAAAAAAAAAAAAAAAAALBAAAAAAAAAAAAAAAAgAAAAQAAWIEAAFiBAAA4gQAAOIEAABVBAAAVQQAAOIAAAAAAAoAFAAeAEQAagCqAOoBngJkApoAAQAAAAsAigADAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAA4ArgABAAAAAAABAAcAAAABAAAAAAACAAcAYAABAAAAAAADAAcANgABAAAAAAAEAAcAdQABAAAAAAAFAAsAFQABAAAAAAAGAAcASwABAAAAAAAKABoAigADAAEECQABAA4ABwADAAEECQACAA4AZwADAAEECQADAA4APQADAAEECQAEAA4AfAADAAEECQAFABYAIAADAAEECQAGAA4AUgADAAEECQAKADQApGZjaWNvbnMAZgBjAGkAYwBvAG4Ac1ZlcnNpb24gMS4wAFYAZQByAHMAaQBvAG4AIAAxAC4AMGZjaWNvbnMAZgBjAGkAYwBvAG4Ac2ZjaWNvbnMAZgBjAGkAYwBvAG4Ac1JlZ3VsYXIAUgBlAGcAdQBsAGEAcmZjaWNvbnMAZgBjAGkAYwBvAG4Ac0ZvbnQgZ2VuZXJhdGVkIGJ5IEljb01vb24uAEYAbwBuAHQAIABnAGUAbgBlAHIAYQB0AGUAZAAgAGIAeQAgAEkAYwBvAE0AbwBvAG4ALgAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\") format(\"truetype\")}.fc-icon{speak:none;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;display:inline-block;font-family:fcicons!important;font-style:normal;font-variant:normal;font-weight:400;height:1em;line-height:1;text-align:center;text-transform:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:1em}.fc-icon-chevron-left:before{content:\"\\e900\"}.fc-icon-chevron-right:before{content:\"\\e901\"}.fc-icon-chevrons-left:before{content:\"\\e902\"}.fc-icon-chevrons-right:before{content:\"\\e903\"}.fc-icon-minus-square:before{content:\"\\e904\"}.fc-icon-plus-square:before{content:\"\\e905\"}.fc-icon-x:before{content:\"\\e906\"}.fc .fc-button{border-radius:0;font-family:inherit;font-size:inherit;line-height:inherit;margin:0;overflow:visible;text-transform:none}.fc .fc-button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}.fc .fc-button{-webkit-appearance:button}.fc .fc-button:not(:disabled){cursor:pointer}.fc .fc-button{background-color:transparent;border:1px solid transparent;border-radius:.25em;display:inline-block;font-size:1em;font-weight:400;line-height:1.5;padding:.4em .65em;text-align:center;-webkit-user-select:none;-moz-user-select:none;user-select:none;vertical-align:middle}.fc .fc-button:hover{text-decoration:none}.fc .fc-button:focus{box-shadow:0 0 0 .2rem rgba(44,62,80,.25);outline:0}.fc .fc-button:disabled{opacity:.65}.fc .fc-button-primary{background-color:var(--fc-button-bg-color);border-color:var(--fc-button-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:hover{background-color:var(--fc-button-hover-bg-color);border-color:var(--fc-button-hover-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:disabled{background-color:var(--fc-button-bg-color);border-color:var(--fc-button-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:focus{box-shadow:0 0 0 .2rem rgba(76,91,106,.5)}.fc .fc-button-primary:not(:disabled).fc-button-active,.fc .fc-button-primary:not(:disabled):active{background-color:var(--fc-button-active-bg-color);border-color:var(--fc-button-active-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:not(:disabled).fc-button-active:focus,.fc .fc-button-primary:not(:disabled):active:focus{box-shadow:0 0 0 .2rem rgba(76,91,106,.5)}.fc .fc-button .fc-icon{font-size:1.5em;vertical-align:middle}.fc .fc-button-group{display:inline-flex;position:relative;vertical-align:middle}.fc .fc-button-group>.fc-button{flex:1 1 auto;position:relative}.fc .fc-button-group>.fc-button.fc-button-active,.fc .fc-button-group>.fc-button:active,.fc .fc-button-group>.fc-button:focus,.fc .fc-button-group>.fc-button:hover{z-index:1}.fc-direction-ltr .fc-button-group>.fc-button:not(:first-child){border-bottom-left-radius:0;border-top-left-radius:0;margin-left:-1px}.fc-direction-ltr .fc-button-group>.fc-button:not(:last-child){border-bottom-right-radius:0;border-top-right-radius:0}.fc-direction-rtl .fc-button-group>.fc-button:not(:first-child){border-bottom-right-radius:0;border-top-right-radius:0;margin-right:-1px}.fc-direction-rtl .fc-button-group>.fc-button:not(:last-child){border-bottom-left-radius:0;border-top-left-radius:0}.fc .fc-toolbar{align-items:center;display:flex;justify-content:space-between}.fc .fc-toolbar.fc-header-toolbar{margin-bottom:1.5em}.fc .fc-toolbar.fc-footer-toolbar{margin-top:1.5em}.fc .fc-toolbar-title{font-size:1.75em;margin:0}.fc-direction-ltr .fc-toolbar>*>:not(:first-child){margin-left:.75em}.fc-direction-rtl .fc-toolbar>*>:not(:first-child){margin-right:.75em}.fc-direction-rtl .fc-toolbar-ltr{flex-direction:row-reverse}.fc .fc-scroller{-webkit-overflow-scrolling:touch;position:relative}.fc .fc-scroller-liquid{height:100%}.fc .fc-scroller-liquid-absolute{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-scroller-harness{direction:ltr;overflow:hidden;position:relative}.fc .fc-scroller-harness-liquid{height:100%}.fc-direction-rtl .fc-scroller-harness>.fc-scroller{direction:rtl}.fc-theme-standard .fc-scrollgrid{border:1px solid var(--fc-border-color)}.fc .fc-scrollgrid,.fc .fc-scrollgrid table{table-layout:fixed;width:100%}.fc .fc-scrollgrid table{border-left-style:hidden;border-right-style:hidden;border-top-style:hidden}.fc .fc-scrollgrid{border-bottom-width:0;border-collapse:separate;border-right-width:0}.fc .fc-scrollgrid-liquid{height:100%}.fc .fc-scrollgrid-section,.fc .fc-scrollgrid-section table,.fc .fc-scrollgrid-section>td{height:1px}.fc .fc-scrollgrid-section-liquid>td{height:100%}.fc .fc-scrollgrid-section>*{border-left-width:0;border-top-width:0}.fc .fc-scrollgrid-section-footer>*,.fc .fc-scrollgrid-section-header>*{border-bottom-width:0}.fc .fc-scrollgrid-section-body table,.fc .fc-scrollgrid-section-footer table{border-bottom-style:hidden}.fc .fc-scrollgrid-section-sticky>*{background:var(--fc-page-bg-color);position:sticky;z-index:3}.fc .fc-scrollgrid-section-header.fc-scrollgrid-section-sticky>*{top:0}.fc .fc-scrollgrid-section-footer.fc-scrollgrid-section-sticky>*{bottom:0}.fc .fc-scrollgrid-sticky-shim{height:1px;margin-bottom:-1px}.fc-sticky{position:sticky}.fc .fc-view-harness{flex-grow:1;position:relative}.fc .fc-view-harness-active>.fc-view{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-col-header-cell-cushion{display:inline-block;padding:2px 4px}.fc .fc-bg-event,.fc .fc-highlight,.fc .fc-non-business{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-non-business{background:var(--fc-non-business-color)}.fc .fc-bg-event{background:var(--fc-bg-event-color);opacity:var(--fc-bg-event-opacity)}.fc .fc-bg-event .fc-event-title{font-size:var(--fc-small-font-size);font-style:italic;margin:.5em}.fc .fc-highlight{background:var(--fc-highlight-color)}.fc .fc-cell-shaded,.fc .fc-day-disabled{background:var(--fc-neutral-bg-color)}a.fc-event,a.fc-event:hover{text-decoration:none}.fc-event.fc-event-draggable,.fc-event[href]{cursor:pointer}.fc-event .fc-event-main{position:relative;z-index:2}.fc-event-dragging:not(.fc-event-selected){opacity:.75}.fc-event-dragging.fc-event-selected{box-shadow:0 2px 7px rgba(0,0,0,.3)}.fc-event .fc-event-resizer{display:none;position:absolute;z-index:4}.fc-event-selected .fc-event-resizer,.fc-event:hover .fc-event-resizer{display:block}.fc-event-selected .fc-event-resizer{background:var(--fc-page-bg-color);border-color:inherit;border-radius:calc(var(--fc-event-resizer-dot-total-width)/2);border-style:solid;border-width:var(--fc-event-resizer-dot-border-width);height:var(--fc-event-resizer-dot-total-width);width:var(--fc-event-resizer-dot-total-width)}.fc-event-selected .fc-event-resizer:before{bottom:-20px;content:\"\";left:-20px;position:absolute;right:-20px;top:-20px}.fc-event-selected,.fc-event:focus{box-shadow:0 2px 5px rgba(0,0,0,.2)}.fc-event-selected:before,.fc-event:focus:before{bottom:0;content:\"\";left:0;position:absolute;right:0;top:0;z-index:3}.fc-event-selected:after,.fc-event:focus:after{background:var(--fc-event-selected-overlay-color);bottom:-1px;content:\"\";left:-1px;position:absolute;right:-1px;top:-1px;z-index:1}.fc-h-event{background-color:var(--fc-event-bg-color);border:1px solid var(--fc-event-border-color);display:block}.fc-h-event .fc-event-main{color:var(--fc-event-text-color)}.fc-h-event .fc-event-main-frame{display:flex}.fc-h-event .fc-event-time{max-width:100%;overflow:hidden}.fc-h-event .fc-event-title-container{flex-grow:1;flex-shrink:1;min-width:0}.fc-h-event .fc-event-title{display:inline-block;left:0;max-width:100%;overflow:hidden;right:0;vertical-align:top}.fc-h-event.fc-event-selected:before{bottom:-10px;top:-10px}.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-start),.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-end){border-bottom-left-radius:0;border-left-width:0;border-top-left-radius:0}.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-end),.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-start){border-bottom-right-radius:0;border-right-width:0;border-top-right-radius:0}.fc-h-event:not(.fc-event-selected) .fc-event-resizer{bottom:0;top:0;width:var(--fc-event-resizer-thickness)}.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start,.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end{cursor:w-resize;left:calc(var(--fc-event-resizer-thickness)*-.5)}.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end,.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start{cursor:e-resize;right:calc(var(--fc-event-resizer-thickness)*-.5)}.fc-h-event.fc-event-selected .fc-event-resizer{margin-top:calc(var(--fc-event-resizer-dot-total-width)*-.5);top:50%}.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-start,.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-end{left:calc(var(--fc-event-resizer-dot-total-width)*-.5)}.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-end,.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-start{right:calc(var(--fc-event-resizer-dot-total-width)*-.5)}.fc .fc-popover{box-shadow:0 2px 6px rgba(0,0,0,.15);position:absolute;z-index:9999}.fc .fc-popover-header{align-items:center;display:flex;flex-direction:row;justify-content:space-between;padding:3px 4px}.fc .fc-popover-title{margin:0 2px}.fc .fc-popover-close{cursor:pointer;font-size:1.1em;opacity:.65}.fc-theme-standard .fc-popover{background:var(--fc-page-bg-color);border:1px solid var(--fc-border-color)}.fc-theme-standard .fc-popover-header{background:var(--fc-neutral-bg-color)}";
  injectStyles(css_248z$5);

  function removeElement(el) {
      if (el.parentNode) {
          el.parentNode.removeChild(el);
      }
  }
  // Querying
  // ----------------------------------------------------------------------------------------------------------------
  function elementClosest(el, selector) {
      if (el.closest) {
          return el.closest(selector);
          // really bad fallback for IE
          // from https://developer.mozilla.org/en-US/docs/Web/API/Element/closest
      }
      if (!document.documentElement.contains(el)) {
          return null;
      }
      do {
          if (elementMatches(el, selector)) {
              return el;
          }
          el = (el.parentElement || el.parentNode);
      } while (el !== null && el.nodeType === 1);
      return null;
  }
  function elementMatches(el, selector) {
      let method = el.matches || el.matchesSelector || el.msMatchesSelector;
      return method.call(el, selector);
  }
  // accepts multiple subject els
  // returns a real array. good for methods like forEach
  // TODO: accept the document
  function findElements(container, selector) {
      let containers = container instanceof HTMLElement ? [container] : container;
      let allMatches = [];
      for (let i = 0; i < containers.length; i += 1) {
          let matches = containers[i].querySelectorAll(selector);
          for (let j = 0; j < matches.length; j += 1) {
              allMatches.push(matches[j]);
          }
      }
      return allMatches;
  }
  // Style
  // ----------------------------------------------------------------------------------------------------------------
  const PIXEL_PROP_RE = /(top|left|right|bottom|width|height)$/i;
  function applyStyle(el, props) {
      for (let propName in props) {
          applyStyleProp(el, propName, props[propName]);
      }
  }
  function applyStyleProp(el, name, val) {
      if (val == null) {
          el.style[name] = '';
      }
      else if (typeof val === 'number' && PIXEL_PROP_RE.test(name)) {
          el.style[name] = `${val}px`;
      }
      else {
          el.style[name] = val;
      }
  }
  // Event Handling
  // ----------------------------------------------------------------------------------------------------------------
  // if intercepting bubbled events at the document/window/body level,
  // and want to see originating element (the 'target'), use this util instead
  // of `ev.target` because it goes within web-component boundaries.
  function getEventTargetViaRoot(ev) {
      var _a, _b;
      return (_b = (_a = ev.composedPath) === null || _a === void 0 ? void 0 : _a.call(ev)[0]) !== null && _b !== void 0 ? _b : ev.target;
  }
  // Unique ID for DOM attribute
  let guid$1 = 0;
  function getUniqueDomId() {
      guid$1 += 1;
      return 'fc-dom-' + guid$1;
  }

  // Stops a mouse/touch event from doing it's native browser action
  function preventDefault(ev) {
      ev.preventDefault();
  }
  // Event Delegation
  // ----------------------------------------------------------------------------------------------------------------
  function buildDelegationHandler(selector, handler) {
      return (ev) => {
          let matchedChild = elementClosest(ev.target, selector);
          if (matchedChild) {
              handler.call(matchedChild, ev, matchedChild);
          }
      };
  }
  function listenBySelector(container, eventType, selector, handler) {
      let attachedHandler = buildDelegationHandler(selector, handler);
      container.addEventListener(eventType, attachedHandler);
      return () => {
          container.removeEventListener(eventType, attachedHandler);
      };
  }
  function listenToHoverBySelector(container, selector, onMouseEnter, onMouseLeave) {
      let currentMatchedChild;
      return listenBySelector(container, 'mouseover', selector, (mouseOverEv, matchedChild) => {
          if (matchedChild !== currentMatchedChild) {
              currentMatchedChild = matchedChild;
              onMouseEnter(mouseOverEv, matchedChild);
              let realOnMouseLeave = (mouseLeaveEv) => {
                  currentMatchedChild = null;
                  onMouseLeave(mouseLeaveEv, matchedChild);
                  matchedChild.removeEventListener('mouseleave', realOnMouseLeave);
              };
              // listen to the next mouseleave, and then unattach
              matchedChild.addEventListener('mouseleave', realOnMouseLeave);
          }
      });
  }
  // Animation
  // ----------------------------------------------------------------------------------------------------------------
  const transitionEventNames = [
      'webkitTransitionEnd',
      'otransitionend',
      'oTransitionEnd',
      'msTransitionEnd',
      'transitionend',
  ];
  // triggered only when the next single subsequent transition finishes
  function whenTransitionDone(el, callback) {
      let realCallback = (ev) => {
          callback(ev);
          transitionEventNames.forEach((eventName) => {
              el.removeEventListener(eventName, realCallback);
          });
      };
      transitionEventNames.forEach((eventName) => {
          el.addEventListener(eventName, realCallback); // cross-browser way to determine when the transition finishes
      });
  }
  // ARIA workarounds
  // ----------------------------------------------------------------------------------------------------------------
  function createAriaClickAttrs(handler) {
      return Object.assign({ onClick: handler }, createAriaKeyboardAttrs(handler));
  }
  function createAriaKeyboardAttrs(handler) {
      return {
          tabIndex: 0,
          onKeyDown(ev) {
              if (ev.key === 'Enter' || ev.key === ' ') {
                  handler(ev);
                  ev.preventDefault(); // if space, don't scroll down page
              }
          },
      };
  }

  let guidNumber = 0;
  function guid() {
      guidNumber += 1;
      return String(guidNumber);
  }
  /* FullCalendar-specific DOM Utilities
  ----------------------------------------------------------------------------------------------------------------------*/
  // Make the mouse cursor express that an event is not allowed in the current area
  function disableCursor() {
      document.body.classList.add('fc-not-allowed');
  }
  // Returns the mouse cursor to its original look
  function enableCursor() {
      document.body.classList.remove('fc-not-allowed');
  }
  /* Selection
  ----------------------------------------------------------------------------------------------------------------------*/
  function preventSelection(el) {
      el.style.userSelect = 'none';
      el.style.webkitUserSelect = 'none';
      el.addEventListener('selectstart', preventDefault);
  }
  function allowSelection(el) {
      el.style.userSelect = '';
      el.style.webkitUserSelect = '';
      el.removeEventListener('selectstart', preventDefault);
  }
  /* Context Menu
  ----------------------------------------------------------------------------------------------------------------------*/
  function preventContextMenu(el) {
      el.addEventListener('contextmenu', preventDefault);
  }
  function allowContextMenu(el) {
      el.removeEventListener('contextmenu', preventDefault);
  }
  function parseFieldSpecs(input) {
      let specs = [];
      let tokens = [];
      let i;
      let token;
      if (typeof input === 'string') {
          tokens = input.split(/\s*,\s*/);
      }
      else if (typeof input === 'function') {
          tokens = [input];
      }
      else if (Array.isArray(input)) {
          tokens = input;
      }
      for (i = 0; i < tokens.length; i += 1) {
          token = tokens[i];
          if (typeof token === 'string') {
              specs.push(token.charAt(0) === '-' ?
                  { field: token.substring(1), order: -1 } :
                  { field: token, order: 1 });
          }
          else if (typeof token === 'function') {
              specs.push({ func: token });
          }
      }
      return specs;
  }
  function compareByFieldSpecs(obj0, obj1, fieldSpecs) {
      let i;
      let cmp;
      for (i = 0; i < fieldSpecs.length; i += 1) {
          cmp = compareByFieldSpec(obj0, obj1, fieldSpecs[i]);
          if (cmp) {
              return cmp;
          }
      }
      return 0;
  }
  function compareByFieldSpec(obj0, obj1, fieldSpec) {
      if (fieldSpec.func) {
          return fieldSpec.func(obj0, obj1);
      }
      return flexibleCompare(obj0[fieldSpec.field], obj1[fieldSpec.field])
          * (fieldSpec.order || 1);
  }
  function flexibleCompare(a, b) {
      if (!a && !b) {
          return 0;
      }
      if (b == null) {
          return -1;
      }
      if (a == null) {
          return 1;
      }
      if (typeof a === 'string' || typeof b === 'string') {
          return String(a).localeCompare(String(b));
      }
      return a - b;
  }
  /* String Utilities
  ----------------------------------------------------------------------------------------------------------------------*/
  function padStart$2(val, len) {
      let s = String(val);
      return '000'.substr(0, len - s.length) + s;
  }
  function formatWithOrdinals(formatter, args, fallbackText) {
      if (typeof formatter === 'function') {
          return formatter(...args);
      }
      if (typeof formatter === 'string') { // non-blank string
          return args.reduce((str, arg, index) => (str.replace('$' + index, arg || '')), formatter);
      }
      return fallbackText;
  }
  /* Number Utilities
  ----------------------------------------------------------------------------------------------------------------------*/
  function compareNumbers(a, b) {
      return a - b;
  }
  function isInt(n) {
      return n % 1 === 0;
  }
  /* FC-specific DOM dimension stuff
  ----------------------------------------------------------------------------------------------------------------------*/
  function computeSmallestCellWidth(cellEl) {
      let allWidthEl = cellEl.querySelector('.fc-scrollgrid-shrink-frame');
      let contentWidthEl = cellEl.querySelector('.fc-scrollgrid-shrink-cushion');
      if (!allWidthEl) {
          throw new Error('needs fc-scrollgrid-shrink-frame className'); // TODO: use const
      }
      if (!contentWidthEl) {
          throw new Error('needs fc-scrollgrid-shrink-cushion className');
      }
      return cellEl.getBoundingClientRect().width - allWidthEl.getBoundingClientRect().width + // the cell padding+border
          contentWidthEl.getBoundingClientRect().width;
  }

  const INTERNAL_UNITS = ['years', 'months', 'days', 'milliseconds'];
  const PARSE_RE = /^(-?)(?:(\d+)\.)?(\d+):(\d\d)(?::(\d\d)(?:\.(\d\d\d))?)?/;
  // Parsing and Creation
  function createDuration(input, unit) {
      if (typeof input === 'string') {
          return parseString$1(input);
      }
      if (typeof input === 'object' && input) { // non-null object
          return parseObject(input);
      }
      if (typeof input === 'number') {
          return parseObject({ [unit || 'milliseconds']: input });
      }
      return null;
  }
  function parseString$1(s) {
      let m = PARSE_RE.exec(s);
      if (m) {
          let sign = m[1] ? -1 : 1;
          return {
              years: 0,
              months: 0,
              days: sign * (m[2] ? parseInt(m[2], 10) : 0),
              milliseconds: sign * ((m[3] ? parseInt(m[3], 10) : 0) * 60 * 60 * 1000 + // hours
                  (m[4] ? parseInt(m[4], 10) : 0) * 60 * 1000 + // minutes
                  (m[5] ? parseInt(m[5], 10) : 0) * 1000 + // seconds
                  (m[6] ? parseInt(m[6], 10) : 0) // ms
              ),
          };
      }
      return null;
  }
  function parseObject(obj) {
      let duration = {
          years: obj.years || obj.year || 0,
          months: obj.months || obj.month || 0,
          days: obj.days || obj.day || 0,
          milliseconds: (obj.hours || obj.hour || 0) * 60 * 60 * 1000 + // hours
              (obj.minutes || obj.minute || 0) * 60 * 1000 + // minutes
              (obj.seconds || obj.second || 0) * 1000 + // seconds
              (obj.milliseconds || obj.millisecond || obj.ms || 0), // ms
      };
      let weeks = obj.weeks || obj.week;
      if (weeks) {
          duration.days += weeks * 7;
          duration.specifiedWeeks = true;
      }
      return duration;
  }
  // Equality
  function durationsEqual(d0, d1) {
      return d0.years === d1.years &&
          d0.months === d1.months &&
          d0.days === d1.days &&
          d0.milliseconds === d1.milliseconds;
  }
  // Simple Math
  function addDurations(d0, d1) {
      return {
          years: d0.years + d1.years,
          months: d0.months + d1.months,
          days: d0.days + d1.days,
          milliseconds: d0.milliseconds + d1.milliseconds,
      };
  }
  function subtractDurations(d1, d0) {
      return {
          years: d1.years - d0.years,
          months: d1.months - d0.months,
          days: d1.days - d0.days,
          milliseconds: d1.milliseconds - d0.milliseconds,
      };
  }
  function multiplyDuration(d, n) {
      return {
          years: d.years * n,
          months: d.months * n,
          days: d.days * n,
          milliseconds: d.milliseconds * n,
      };
  }
  // Conversions
  // "Rough" because they are based on average-case Gregorian months/years
  function asRoughYears(dur) {
      return asRoughDays(dur) / 365;
  }
  function asRoughMonths(dur) {
      return asRoughDays(dur) / 30;
  }
  function asRoughDays(dur) {
      return asRoughMs(dur) / 864e5;
  }
  function asRoughMs(dur) {
      return dur.years * (365 * 864e5) +
          dur.months * (30 * 864e5) +
          dur.days * 864e5 +
          dur.milliseconds;
  }
  // Advanced Math
  function wholeDivideDurations(numerator, denominator) {
      let res = null;
      for (let i = 0; i < INTERNAL_UNITS.length; i += 1) {
          let unit = INTERNAL_UNITS[i];
          if (denominator[unit]) {
              let localRes = numerator[unit] / denominator[unit];
              if (!isInt(localRes) || (res !== null && res !== localRes)) {
                  return null;
              }
              res = localRes;
          }
          else if (numerator[unit]) {
              // needs to divide by something but can't!
              return null;
          }
      }
      return res;
  }
  function greatestDurationDenominator(dur) {
      let ms = dur.milliseconds;
      if (ms) {
          if (ms % 1000 !== 0) {
              return { unit: 'millisecond', value: ms };
          }
          if (ms % (1000 * 60) !== 0) {
              return { unit: 'second', value: ms / 1000 };
          }
          if (ms % (1000 * 60 * 60) !== 0) {
              return { unit: 'minute', value: ms / (1000 * 60) };
          }
          if (ms) {
              return { unit: 'hour', value: ms / (1000 * 60 * 60) };
          }
      }
      if (dur.days) {
          if (dur.specifiedWeeks && dur.days % 7 === 0) {
              return { unit: 'week', value: dur.days / 7 };
          }
          return { unit: 'day', value: dur.days };
      }
      if (dur.months) {
          return { unit: 'month', value: dur.months };
      }
      if (dur.years) {
          return { unit: 'year', value: dur.years };
      }
      return { unit: 'millisecond', value: 0 };
  }

  const { hasOwnProperty: hasOwnProperty$2 } = Object.prototype;
  // Merges an array of objects into a single object.
  // The second argument allows for an array of property names who's object values will be merged together.
  function mergeProps(propObjs, complexPropsMap) {
      let dest = {};
      if (complexPropsMap) {
          for (let name in complexPropsMap) {
              if (complexPropsMap[name] === isMaybeObjectsEqual) { // implies that it's object-mergeable
                  let complexObjs = [];
                  // collect the trailing object values, stopping when a non-object is discovered
                  for (let i = propObjs.length - 1; i >= 0; i -= 1) {
                      let val = propObjs[i][name];
                      if (typeof val === 'object' && val) { // non-null object
                          complexObjs.unshift(val);
                      }
                      else if (val !== undefined) {
                          dest[name] = val; // if there were no objects, this value will be used
                          break;
                      }
                  }
                  // if the trailing values were objects, use the merged value
                  if (complexObjs.length) {
                      dest[name] = mergeProps(complexObjs);
                  }
              }
          }
      }
      // copy values into the destination, going from last to first
      for (let i = propObjs.length - 1; i >= 0; i -= 1) {
          let props = propObjs[i];
          for (let name in props) {
              if (!(name in dest)) { // if already assigned by previous props or complex props, don't reassign
                  dest[name] = props[name];
              }
          }
      }
      return dest;
  }
  function filterHash(hash, func) {
      let filtered = {};
      for (let key in hash) {
          if (func(hash[key], key)) {
              filtered[key] = hash[key];
          }
      }
      return filtered;
  }
  function mapHash(hash, func) {
      let newHash = {};
      for (let key in hash) {
          newHash[key] = func(hash[key], key);
      }
      return newHash;
  }
  function arrayToHash(a) {
      let hash = {};
      for (let item of a) {
          hash[item] = true;
      }
      return hash;
  }
  // TODO: reassess browser support
  // https://caniuse.com/?search=object.values
  function hashValuesToArray(obj) {
      let a = [];
      for (let key in obj) {
          a.push(obj[key]);
      }
      return a;
  }
  function isPropsEqual(obj0, obj1) {
      if (obj0 === obj1) {
          return true;
      }
      for (let key in obj0) {
          if (hasOwnProperty$2.call(obj0, key)) {
              if (!(key in obj1)) {
                  return false;
              }
          }
      }
      for (let key in obj1) {
          if (hasOwnProperty$2.call(obj1, key)) {
              if (obj0[key] !== obj1[key]) {
                  return false;
              }
          }
      }
      return true;
  }
  const HANDLER_RE = /^on[A-Z]/;
  function isNonHandlerPropsEqual(obj0, obj1) {
      const keys = getUnequalProps(obj0, obj1);
      for (let key of keys) {
          if (!HANDLER_RE.test(key)) {
              return false;
          }
      }
      return true;
  }
  function getUnequalProps(obj0, obj1) {
      let keys = [];
      for (let key in obj0) {
          if (hasOwnProperty$2.call(obj0, key)) {
              if (!(key in obj1)) {
                  keys.push(key);
              }
          }
      }
      for (let key in obj1) {
          if (hasOwnProperty$2.call(obj1, key)) {
              if (obj0[key] !== obj1[key]) {
                  keys.push(key);
              }
          }
      }
      return keys;
  }
  function compareObjs(oldProps, newProps, equalityFuncs = {}) {
      if (oldProps === newProps) {
          return true;
      }
      for (let key in newProps) {
          if (key in oldProps && isObjValsEqual(oldProps[key], newProps[key], equalityFuncs[key])) ;
          else {
              return false;
          }
      }
      // check for props that were omitted in the new
      for (let key in oldProps) {
          if (!(key in newProps)) {
              return false;
          }
      }
      return true;
  }
  /*
  assumed "true" equality for handler names like "onReceiveSomething"
  */
  function isObjValsEqual(val0, val1, comparator) {
      if (val0 === val1 || comparator === true) {
          return true;
      }
      if (comparator) {
          return comparator(val0, val1);
      }
      return false;
  }
  function collectFromHash(hash, startIndex = 0, endIndex, step = 1) {
      let res = [];
      if (endIndex == null) {
          endIndex = Object.keys(hash).length;
      }
      for (let i = startIndex; i < endIndex; i += step) {
          let val = hash[i];
          if (val !== undefined) { // will disregard undefined for sparse arrays
              res.push(val);
          }
      }
      return res;
  }
  function isArraysEqual(a0, a1, equalityFunc) {
      if (a0 === a1) {
          return true;
      }
      let len = a0.length;
      let i;
      if (len !== a1.length) { // not array? or not same length?
          return false;
      }
      for (i = 0; i < len; i += 1) {
          if (!(equalityFunc ? equalityFunc(a0[i], a1[i]) : a0[i] === a1[i])) {
              return false;
          }
      }
      return true;
  }

  const DAY_IDS = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
  // Adding
  function addWeeks(m, n) {
      let a = dateToUtcArray(m);
      a[2] += n * 7;
      return arrayToUtcDate(a);
  }
  function addDays(m, n) {
      let a = dateToUtcArray(m);
      a[2] += n;
      return arrayToUtcDate(a);
  }
  function addMs(m, n) {
      let a = dateToUtcArray(m);
      a[6] += n;
      return arrayToUtcDate(a);
  }
  // Diffing (all return floats)
  // TODO: why not use ranges?
  function diffWeeks(m0, m1) {
      return diffDays(m0, m1) / 7;
  }
  function diffDays(m0, m1) {
      return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60 * 24);
  }
  function diffHours(m0, m1) {
      return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60);
  }
  function diffMinutes(m0, m1) {
      return (m1.valueOf() - m0.valueOf()) / (1000 * 60);
  }
  function diffSeconds(m0, m1) {
      return (m1.valueOf() - m0.valueOf()) / 1000;
  }
  function diffDayAndTime(m0, m1) {
      let m0day = startOfDay(m0);
      let m1day = startOfDay(m1);
      return {
          years: 0,
          months: 0,
          days: Math.round(diffDays(m0day, m1day)),
          milliseconds: (m1.valueOf() - m1day.valueOf()) - (m0.valueOf() - m0day.valueOf()),
      };
  }
  // Diffing Whole Units
  function diffWholeWeeks(m0, m1) {
      let d = diffWholeDays(m0, m1);
      if (d !== null && d % 7 === 0) {
          return d / 7;
      }
      return null;
  }
  function diffWholeDays(m0, m1) {
      if (timeAsMs(m0) === timeAsMs(m1)) {
          return Math.round(diffDays(m0, m1));
      }
      return null;
  }
  // Start-Of
  function startOfDay(m) {
      return arrayToUtcDate([
          m.getUTCFullYear(),
          m.getUTCMonth(),
          m.getUTCDate(),
      ]);
  }
  function startOfHour(m) {
      return arrayToUtcDate([
          m.getUTCFullYear(),
          m.getUTCMonth(),
          m.getUTCDate(),
          m.getUTCHours(),
      ]);
  }
  function startOfMinute(m) {
      return arrayToUtcDate([
          m.getUTCFullYear(),
          m.getUTCMonth(),
          m.getUTCDate(),
          m.getUTCHours(),
          m.getUTCMinutes(),
      ]);
  }
  function startOfSecond(m) {
      return arrayToUtcDate([
          m.getUTCFullYear(),
          m.getUTCMonth(),
          m.getUTCDate(),
          m.getUTCHours(),
          m.getUTCMinutes(),
          m.getUTCSeconds(),
      ]);
  }
  // Week Computation
  function weekOfYear(marker, dow, doy) {
      let y = marker.getUTCFullYear();
      let w = weekOfGivenYear(marker, y, dow, doy);
      if (w < 1) {
          return weekOfGivenYear(marker, y - 1, dow, doy);
      }
      let nextW = weekOfGivenYear(marker, y + 1, dow, doy);
      if (nextW >= 1) {
          return Math.min(w, nextW);
      }
      return w;
  }
  function weekOfGivenYear(marker, year, dow, doy) {
      let firstWeekStart = arrayToUtcDate([year, 0, 1 + firstWeekOffset(year, dow, doy)]);
      let dayStart = startOfDay(marker);
      let days = Math.round(diffDays(firstWeekStart, dayStart));
      return Math.floor(days / 7) + 1; // zero-indexed
  }
  // start-of-first-week - start-of-year
  function firstWeekOffset(year, dow, doy) {
      // first-week day -- which january is always in the first week (4 for iso, 1 for other)
      let fwd = 7 + dow - doy;
      // first-week day local weekday -- which local weekday is fwd
      let fwdlw = (7 + arrayToUtcDate([year, 0, fwd]).getUTCDay() - dow) % 7;
      return -fwdlw + fwd - 1;
  }
  // Array Conversion
  function dateToLocalArray(date) {
      return [
          date.getFullYear(),
          date.getMonth(),
          date.getDate(),
          date.getHours(),
          date.getMinutes(),
          date.getSeconds(),
          date.getMilliseconds(),
      ];
  }
  function arrayToLocalDate(a) {
      return new Date(a[0], a[1] || 0, a[2] == null ? 1 : a[2], // day of month
      a[3] || 0, a[4] || 0, a[5] || 0);
  }
  function dateToUtcArray(date) {
      return [
          date.getUTCFullYear(),
          date.getUTCMonth(),
          date.getUTCDate(),
          date.getUTCHours(),
          date.getUTCMinutes(),
          date.getUTCSeconds(),
          date.getUTCMilliseconds(),
      ];
  }
  function arrayToUtcDate(a) {
      // according to web standards (and Safari), a month index is required.
      // massage if only given a year.
      if (a.length === 1) {
          a = a.concat([0]);
      }
      return new Date(Date.UTC(...a));
  }
  // Other Utils
  function isValidDate(m) {
      return !isNaN(m.valueOf());
  }
  function timeAsMs(m) {
      return m.getUTCHours() * 1000 * 60 * 60 +
          m.getUTCMinutes() * 1000 * 60 +
          m.getUTCSeconds() * 1000 +
          m.getUTCMilliseconds();
  }

  // timeZoneOffset is in minutes
  function buildIsoString(marker, timeZoneOffset, stripZeroTime = false) {
      let s = marker.toISOString();
      s = s.replace('.000', '');
      if (stripZeroTime) {
          s = s.replace('T00:00:00Z', '');
      }
      if (s.length > 10) { // time part wasn't stripped, can add timezone info
          if (timeZoneOffset == null) {
              s = s.replace('Z', '');
          }
          else if (timeZoneOffset !== 0) {
              s = s.replace('Z', formatTimeZoneOffset(timeZoneOffset, true));
          }
          // otherwise, its UTC-0 and we want to keep the Z
      }
      return s;
  }
  // formats the date, but with no time part
  // TODO: somehow merge with buildIsoString and stripZeroTime
  // TODO: rename. omit "string"
  function formatDayString(marker) {
      return marker.toISOString().replace(/T.*$/, '');
  }
  function formatIsoMonthStr(marker) {
      return marker.toISOString().match(/^\d{4}-\d{2}/)[0];
  }
  // TODO: use Date::toISOString and use everything after the T?
  function formatIsoTimeString(marker) {
      return padStart$2(marker.getUTCHours(), 2) + ':' +
          padStart$2(marker.getUTCMinutes(), 2) + ':' +
          padStart$2(marker.getUTCSeconds(), 2);
  }
  function formatTimeZoneOffset(minutes, doIso = false) {
      let sign = minutes < 0 ? '-' : '+';
      let abs = Math.abs(minutes);
      let hours = Math.floor(abs / 60);
      let mins = Math.round(abs % 60);
      if (doIso) {
          return `${sign + padStart$2(hours, 2)}:${padStart$2(mins, 2)}`;
      }
      return `GMT${sign}${hours}${mins ? `:${padStart$2(mins, 2)}` : ''}`;
  }

  function memoize(workerFunc, resEquality, teardownFunc) {
      let currentArgs;
      let currentRes;
      return function (...newArgs) {
          if (!currentArgs) {
              currentRes = workerFunc.apply(this, newArgs);
          }
          else if (!isArraysEqual(currentArgs, newArgs)) {
              if (teardownFunc) {
                  teardownFunc(currentRes);
              }
              let res = workerFunc.apply(this, newArgs);
              if (!resEquality || !resEquality(res, currentRes)) {
                  currentRes = res;
              }
          }
          currentArgs = newArgs;
          return currentRes;
      };
  }
  function memoizeObjArg(workerFunc, resEquality, teardownFunc) {
      let currentArg;
      let currentRes;
      return (newArg) => {
          if (!currentArg) {
              currentRes = workerFunc.call(this, newArg);
          }
          else if (!isPropsEqual(currentArg, newArg)) {
              if (teardownFunc) {
                  teardownFunc(currentRes);
              }
              let res = workerFunc.call(this, newArg);
              if (!resEquality || !resEquality(res, currentRes)) {
                  currentRes = res;
              }
          }
          currentArg = newArg;
          return currentRes;
      };
  }

  const EXTENDED_SETTINGS_AND_SEVERITIES = {
      week: 3,
      separator: 0,
      omitZeroMinute: 0,
      meridiem: 0,
      omitCommas: 0,
  };
  const STANDARD_DATE_PROP_SEVERITIES = {
      timeZoneName: 7,
      era: 6,
      year: 5,
      month: 4,
      day: 2,
      weekday: 2,
      hour: 1,
      minute: 1,
      second: 1,
  };
  const MERIDIEM_RE = /\s*([ap])\.?m\.?/i; // eats up leading spaces too
  const COMMA_RE = /,/g; // we need re for globalness
  const MULTI_SPACE_RE = /\s+/g;
  const LTR_RE = /\u200e/g; // control character
  const UTC_RE = /UTC|GMT/;
  class NativeFormatter {
      constructor(formatSettings) {
          let standardDateProps = {};
          let extendedSettings = {};
          let severity = 0;
          for (let name in formatSettings) {
              if (name in EXTENDED_SETTINGS_AND_SEVERITIES) {
                  extendedSettings[name] = formatSettings[name];
                  severity = Math.max(EXTENDED_SETTINGS_AND_SEVERITIES[name], severity);
              }
              else {
                  standardDateProps[name] = formatSettings[name];
                  if (name in STANDARD_DATE_PROP_SEVERITIES) { // TODO: what about hour12? no severity
                      severity = Math.max(STANDARD_DATE_PROP_SEVERITIES[name], severity);
                  }
              }
          }
          this.standardDateProps = standardDateProps;
          this.extendedSettings = extendedSettings;
          this.severity = severity;
          this.buildFormattingFunc = memoize(buildFormattingFunc);
      }
      format(date, context) {
          return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, context)(date);
      }
      formatRange(start, end, context, betterDefaultSeparator) {
          let { standardDateProps, extendedSettings } = this;
          let diffSeverity = computeMarkerDiffSeverity(start.marker, end.marker, context.calendarSystem);
          if (!diffSeverity) {
              return this.format(start, context);
          }
          let biggestUnitForPartial = diffSeverity;
          if (biggestUnitForPartial > 1 && // the two dates are different in a way that's larger scale than time
              (standardDateProps.year === 'numeric' || standardDateProps.year === '2-digit') &&
              (standardDateProps.month === 'numeric' || standardDateProps.month === '2-digit') &&
              (standardDateProps.day === 'numeric' || standardDateProps.day === '2-digit')) {
              biggestUnitForPartial = 1; // make it look like the dates are only different in terms of time
          }
          let full0 = this.format(start, context);
          let full1 = this.format(end, context);
          if (full0 === full1) {
              return full0;
          }
          let partialDateProps = computePartialFormattingOptions(standardDateProps, biggestUnitForPartial);
          let partialFormattingFunc = buildFormattingFunc(partialDateProps, extendedSettings, context);
          let partial0 = partialFormattingFunc(start);
          let partial1 = partialFormattingFunc(end);
          let insertion = findCommonInsertion(full0, partial0, full1, partial1);
          let separator = extendedSettings.separator || betterDefaultSeparator || context.defaultSeparator || '';
          if (insertion) {
              return insertion.before + partial0 + separator + partial1 + insertion.after;
          }
          return full0 + separator + full1;
      }
      getLargestUnit() {
          switch (this.severity) {
              case 7:
              case 6:
              case 5:
                  return 'year';
              case 4:
                  return 'month';
              case 3:
                  return 'week';
              case 2:
                  return 'day';
              default:
                  return 'time'; // really?
          }
      }
  }
  function buildFormattingFunc(standardDateProps, extendedSettings, context) {
      let standardDatePropCnt = Object.keys(standardDateProps).length;
      if (standardDatePropCnt === 1 && standardDateProps.timeZoneName === 'short') {
          return (date) => (formatTimeZoneOffset(date.timeZoneOffset));
      }
      if (standardDatePropCnt === 0 && extendedSettings.week) {
          return (date) => (formatWeekNumber(context.computeWeekNumber(date.marker), context.weekText, context.weekTextLong, context.locale, extendedSettings.week));
      }
      return buildNativeFormattingFunc(standardDateProps, extendedSettings, context);
  }
  function buildNativeFormattingFunc(standardDateProps, extendedSettings, context) {
      standardDateProps = Object.assign({}, standardDateProps); // copy
      extendedSettings = Object.assign({}, extendedSettings); // copy
      sanitizeSettings(standardDateProps, extendedSettings);
      standardDateProps.timeZone = 'UTC'; // we leverage the only guaranteed timeZone for our UTC markers
      let normalFormat = new Intl.DateTimeFormat(context.locale.codes, standardDateProps);
      let zeroFormat; // needed?
      if (extendedSettings.omitZeroMinute) {
          let zeroProps = Object.assign({}, standardDateProps);
          delete zeroProps.minute; // seconds and ms were already considered in sanitizeSettings
          zeroFormat = new Intl.DateTimeFormat(context.locale.codes, zeroProps);
      }
      return (date) => {
          let { marker } = date;
          let format;
          if (zeroFormat && !marker.getUTCMinutes()) {
              format = zeroFormat;
          }
          else {
              format = normalFormat;
          }
          let s = format.format(marker);
          return postProcess(s, date, standardDateProps, extendedSettings, context);
      };
  }
  function sanitizeSettings(standardDateProps, extendedSettings) {
      // deal with a browser inconsistency where formatting the timezone
      // requires that the hour/minute be present.
      if (standardDateProps.timeZoneName) {
          if (!standardDateProps.hour) {
              standardDateProps.hour = '2-digit';
          }
          if (!standardDateProps.minute) {
              standardDateProps.minute = '2-digit';
          }
      }
      // only support short timezone names
      if (standardDateProps.timeZoneName === 'long') {
          standardDateProps.timeZoneName = 'short';
      }
      // if requesting to display seconds, MUST display minutes
      if (extendedSettings.omitZeroMinute && (standardDateProps.second || standardDateProps.millisecond)) {
          delete extendedSettings.omitZeroMinute;
      }
  }
  function postProcess(s, date, standardDateProps, extendedSettings, context) {
      s = s.replace(LTR_RE, ''); // remove left-to-right control chars. do first. good for other regexes
      if (standardDateProps.timeZoneName === 'short') {
          s = injectTzoStr(s, (context.timeZone === 'UTC' || date.timeZoneOffset == null) ?
              'UTC' : // important to normalize for IE, which does "GMT"
              formatTimeZoneOffset(date.timeZoneOffset));
      }
      if (extendedSettings.omitCommas) {
          s = s.replace(COMMA_RE, '').trim();
      }
      if (extendedSettings.omitZeroMinute) {
          s = s.replace(':00', ''); // zeroFormat doesn't always achieve this
      }
      // ^ do anything that might create adjacent spaces before this point,
      // because MERIDIEM_RE likes to eat up loading spaces
      if (extendedSettings.meridiem === false) {
          s = s.replace(MERIDIEM_RE, '').trim();
      }
      else if (extendedSettings.meridiem === 'narrow') { // a/p
          s = s.replace(MERIDIEM_RE, (m0, m1) => m1.toLocaleLowerCase());
      }
      else if (extendedSettings.meridiem === 'short') { // am/pm
          s = s.replace(MERIDIEM_RE, (m0, m1) => `${m1.toLocaleLowerCase()}m`);
      }
      else if (extendedSettings.meridiem === 'lowercase') { // other meridiem transformers already converted to lowercase
          s = s.replace(MERIDIEM_RE, (m0) => m0.toLocaleLowerCase());
      }
      s = s.replace(MULTI_SPACE_RE, ' ');
      s = s.trim();
      return s;
  }
  function injectTzoStr(s, tzoStr) {
      let replaced = false;
      s = s.replace(UTC_RE, () => {
          replaced = true;
          return tzoStr;
      });
      // IE11 doesn't include UTC/GMT in the original string, so append to end
      if (!replaced) {
          s += ` ${tzoStr}`;
      }
      return s;
  }
  function formatWeekNumber(num, weekText, weekTextLong, locale, display) {
      let parts = [];
      if (display === 'long') {
          parts.push(weekTextLong);
      }
      else if (display === 'short' || display === 'narrow') {
          parts.push(weekText);
      }
      if (display === 'long' || display === 'short') {
          parts.push(' ');
      }
      parts.push(locale.simpleNumberFormat.format(num));
      if (locale.options.direction === 'rtl') { // TODO: use control characters instead?
          parts.reverse();
      }
      return parts.join('');
  }
  // Range Formatting Utils
  // 0 = exactly the same
  // 1 = different by time
  // and bigger
  function computeMarkerDiffSeverity(d0, d1, ca) {
      if (ca.getMarkerYear(d0) !== ca.getMarkerYear(d1)) {
          return 5;
      }
      if (ca.getMarkerMonth(d0) !== ca.getMarkerMonth(d1)) {
          return 4;
      }
      if (ca.getMarkerDay(d0) !== ca.getMarkerDay(d1)) {
          return 2;
      }
      if (timeAsMs(d0) !== timeAsMs(d1)) {
          return 1;
      }
      return 0;
  }
  function computePartialFormattingOptions(options, biggestUnit) {
      let partialOptions = {};
      for (let name in options) {
          if (!(name in STANDARD_DATE_PROP_SEVERITIES) || // not a date part prop (like timeZone)
              STANDARD_DATE_PROP_SEVERITIES[name] <= biggestUnit) {
              partialOptions[name] = options[name];
          }
      }
      return partialOptions;
  }
  function findCommonInsertion(full0, partial0, full1, partial1) {
      let i0 = 0;
      while (i0 < full0.length) {
          let found0 = full0.indexOf(partial0, i0);
          if (found0 === -1) {
              break;
          }
          let before0 = full0.substr(0, found0);
          i0 = found0 + partial0.length;
          let after0 = full0.substr(i0);
          let i1 = 0;
          while (i1 < full1.length) {
              let found1 = full1.indexOf(partial1, i1);
              if (found1 === -1) {
                  break;
              }
              let before1 = full1.substr(0, found1);
              i1 = found1 + partial1.length;
              let after1 = full1.substr(i1);
              if (before0 === before1 && after0 === after1) {
                  return {
                      before: before0,
                      after: after0,
                  };
              }
          }
      }
      return null;
  }

  function expandZonedMarker(dateInfo, calendarSystem) {
      let a = calendarSystem.markerToArray(dateInfo.marker);
      return {
          marker: dateInfo.marker,
          timeZoneOffset: dateInfo.timeZoneOffset,
          array: a,
          year: a[0],
          month: a[1],
          day: a[2],
          hour: a[3],
          minute: a[4],
          second: a[5],
          millisecond: a[6],
      };
  }

  function createVerboseFormattingArg(start, end, context, betterDefaultSeparator) {
      let startInfo = expandZonedMarker(start, context.calendarSystem);
      let endInfo = end ? expandZonedMarker(end, context.calendarSystem) : null;
      return {
          date: startInfo,
          start: startInfo,
          end: endInfo,
          timeZone: context.timeZone,
          localeCodes: context.locale.codes,
          defaultSeparator: betterDefaultSeparator || context.defaultSeparator,
      };
  }

  /*
  TODO: fix the terminology of "formatter" vs "formatting func"
  */
  /*
  At the time of instantiation, this object does not know which cmd-formatting system it will use.
  It receives this at the time of formatting, as a setting.
  */
  class CmdFormatter {
      constructor(cmdStr) {
          this.cmdStr = cmdStr;
      }
      format(date, context, betterDefaultSeparator) {
          return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(date, null, context, betterDefaultSeparator));
      }
      formatRange(start, end, context, betterDefaultSeparator) {
          return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(start, end, context, betterDefaultSeparator));
      }
  }

  class FuncFormatter {
      constructor(func) {
          this.func = func;
      }
      format(date, context, betterDefaultSeparator) {
          return this.func(createVerboseFormattingArg(date, null, context, betterDefaultSeparator));
      }
      formatRange(start, end, context, betterDefaultSeparator) {
          return this.func(createVerboseFormattingArg(start, end, context, betterDefaultSeparator));
      }
  }

  function createFormatter(input) {
      if (typeof input === 'object' && input) { // non-null object
          return new NativeFormatter(input);
      }
      if (typeof input === 'string') {
          return new CmdFormatter(input);
      }
      if (typeof input === 'function') {
          return new FuncFormatter(input);
      }
      return null;
  }

  // base options
  // ------------
  const BASE_OPTION_REFINERS = {
      navLinkDayClick: identity,
      navLinkWeekClick: identity,
      duration: createDuration,
      bootstrapFontAwesome: identity,
      buttonIcons: identity,
      customButtons: identity,
      defaultAllDayEventDuration: createDuration,
      defaultTimedEventDuration: createDuration,
      nextDayThreshold: createDuration,
      scrollTime: createDuration,
      scrollTimeReset: Boolean,
      slotMinTime: createDuration,
      slotMaxTime: createDuration,
      dayPopoverFormat: createFormatter,
      slotDuration: createDuration,
      snapDuration: createDuration,
      headerToolbar: identity,
      footerToolbar: identity,
      defaultRangeSeparator: String,
      titleRangeSeparator: String,
      forceEventDuration: Boolean,
      dayHeaders: Boolean,
      dayHeaderFormat: createFormatter,
      dayHeaderClassNames: identity,
      dayHeaderContent: identity,
      dayHeaderDidMount: identity,
      dayHeaderWillUnmount: identity,
      dayCellClassNames: identity,
      dayCellContent: identity,
      dayCellDidMount: identity,
      dayCellWillUnmount: identity,
      initialView: String,
      aspectRatio: Number,
      weekends: Boolean,
      weekNumberCalculation: identity,
      weekNumbers: Boolean,
      weekNumberClassNames: identity,
      weekNumberContent: identity,
      weekNumberDidMount: identity,
      weekNumberWillUnmount: identity,
      editable: Boolean,
      viewClassNames: identity,
      viewDidMount: identity,
      viewWillUnmount: identity,
      nowIndicator: Boolean,
      nowIndicatorClassNames: identity,
      nowIndicatorContent: identity,
      nowIndicatorDidMount: identity,
      nowIndicatorWillUnmount: identity,
      showNonCurrentDates: Boolean,
      lazyFetching: Boolean,
      startParam: String,
      endParam: String,
      timeZoneParam: String,
      timeZone: String,
      locales: identity,
      locale: identity,
      themeSystem: String,
      dragRevertDuration: Number,
      dragScroll: Boolean,
      allDayMaintainDuration: Boolean,
      unselectAuto: Boolean,
      dropAccept: identity,
      eventOrder: parseFieldSpecs,
      eventOrderStrict: Boolean,
      handleWindowResize: Boolean,
      windowResizeDelay: Number,
      longPressDelay: Number,
      eventDragMinDistance: Number,
      expandRows: Boolean,
      height: identity,
      contentHeight: identity,
      direction: String,
      weekNumberFormat: createFormatter,
      eventResizableFromStart: Boolean,
      displayEventTime: Boolean,
      displayEventEnd: Boolean,
      weekText: String,
      weekTextLong: String,
      progressiveEventRendering: Boolean,
      businessHours: identity,
      initialDate: identity,
      now: identity,
      eventDataTransform: identity,
      stickyHeaderDates: identity,
      stickyFooterScrollbar: identity,
      viewHeight: identity,
      defaultAllDay: Boolean,
      eventSourceFailure: identity,
      eventSourceSuccess: identity,
      eventDisplay: String,
      eventStartEditable: Boolean,
      eventDurationEditable: Boolean,
      eventOverlap: identity,
      eventConstraint: identity,
      eventAllow: identity,
      eventBackgroundColor: String,
      eventBorderColor: String,
      eventTextColor: String,
      eventColor: String,
      eventClassNames: identity,
      eventContent: identity,
      eventDidMount: identity,
      eventWillUnmount: identity,
      selectConstraint: identity,
      selectOverlap: identity,
      selectAllow: identity,
      droppable: Boolean,
      unselectCancel: String,
      slotLabelFormat: identity,
      slotLaneClassNames: identity,
      slotLaneContent: identity,
      slotLaneDidMount: identity,
      slotLaneWillUnmount: identity,
      slotLabelClassNames: identity,
      slotLabelContent: identity,
      slotLabelDidMount: identity,
      slotLabelWillUnmount: identity,
      dayMaxEvents: identity,
      dayMaxEventRows: identity,
      dayMinWidth: Number,
      slotLabelInterval: createDuration,
      allDayText: String,
      allDayClassNames: identity,
      allDayContent: identity,
      allDayDidMount: identity,
      allDayWillUnmount: identity,
      slotMinWidth: Number,
      navLinks: Boolean,
      eventTimeFormat: createFormatter,
      rerenderDelay: Number,
      moreLinkText: identity,
      moreLinkHint: identity,
      selectMinDistance: Number,
      selectable: Boolean,
      selectLongPressDelay: Number,
      eventLongPressDelay: Number,
      selectMirror: Boolean,
      eventMaxStack: Number,
      eventMinHeight: Number,
      eventMinWidth: Number,
      eventShortHeight: Number,
      slotEventOverlap: Boolean,
      plugins: identity,
      firstDay: Number,
      dayCount: Number,
      dateAlignment: String,
      dateIncrement: createDuration,
      hiddenDays: identity,
      fixedWeekCount: Boolean,
      validRange: identity,
      visibleRange: identity,
      titleFormat: identity,
      eventInteractive: Boolean,
      // only used by list-view, but languages define the value, so we need it in base options
      noEventsText: String,
      viewHint: identity,
      navLinkHint: identity,
      closeHint: String,
      timeHint: String,
      eventHint: String,
      moreLinkClick: identity,
      moreLinkClassNames: identity,
      moreLinkContent: identity,
      moreLinkDidMount: identity,
      moreLinkWillUnmount: identity,
      monthStartFormat: createFormatter,
      // for connectors
      // (can't be part of plugin system b/c must be provided at runtime)
      handleCustomRendering: identity,
      customRenderingMetaMap: identity,
      customRenderingReplaces: Boolean,
  };
  // do NOT give a type here. need `typeof BASE_OPTION_DEFAULTS` to give real results.
  // raw values.
  const BASE_OPTION_DEFAULTS = {
      eventDisplay: 'auto',
      defaultRangeSeparator: ' - ',
      titleRangeSeparator: ' \u2013 ',
      defaultTimedEventDuration: '01:00:00',
      defaultAllDayEventDuration: { day: 1 },
      forceEventDuration: false,
      nextDayThreshold: '00:00:00',
      dayHeaders: true,
      initialView: '',
      aspectRatio: 1.35,
      headerToolbar: {
          start: 'title',
          center: '',
          end: 'today prev,next',
      },
      weekends: true,
      weekNumbers: false,
      weekNumberCalculation: 'local',
      editable: false,
      nowIndicator: false,
      scrollTime: '06:00:00',
      scrollTimeReset: true,
      slotMinTime: '00:00:00',
      slotMaxTime: '24:00:00',
      showNonCurrentDates: true,
      lazyFetching: true,
      startParam: 'start',
      endParam: 'end',
      timeZoneParam: 'timeZone',
      timeZone: 'local',
      locales: [],
      locale: '',
      themeSystem: 'standard',
      dragRevertDuration: 500,
      dragScroll: true,
      allDayMaintainDuration: false,
      unselectAuto: true,
      dropAccept: '*',
      eventOrder: 'start,-duration,allDay,title',
      dayPopoverFormat: { month: 'long', day: 'numeric', year: 'numeric' },
      handleWindowResize: true,
      windowResizeDelay: 100,
      longPressDelay: 1000,
      eventDragMinDistance: 5,
      expandRows: false,
      navLinks: false,
      selectable: false,
      eventMinHeight: 15,
      eventMinWidth: 30,
      eventShortHeight: 30,
      monthStartFormat: { month: 'long', day: 'numeric' },
  };
  // calendar listeners
  // ------------------
  const CALENDAR_LISTENER_REFINERS = {
      datesSet: identity,
      eventsSet: identity,
      eventAdd: identity,
      eventChange: identity,
      eventRemove: identity,
      windowResize: identity,
      eventClick: identity,
      eventMouseEnter: identity,
      eventMouseLeave: identity,
      select: identity,
      unselect: identity,
      loading: identity,
      // internal
      _unmount: identity,
      _beforeprint: identity,
      _afterprint: identity,
      _noEventDrop: identity,
      _noEventResize: identity,
      _resize: identity,
      _scrollRequest: identity,
  };
  // calendar-specific options
  // -------------------------
  const CALENDAR_OPTION_REFINERS = {
      buttonText: identity,
      buttonHints: identity,
      views: identity,
      plugins: identity,
      initialEvents: identity,
      events: identity,
      eventSources: identity,
  };
  const COMPLEX_OPTION_COMPARATORS = {
      headerToolbar: isMaybeObjectsEqual,
      footerToolbar: isMaybeObjectsEqual,
      buttonText: isMaybeObjectsEqual,
      buttonHints: isMaybeObjectsEqual,
      buttonIcons: isMaybeObjectsEqual,
      dateIncrement: isMaybeObjectsEqual,
      plugins: isMaybeArraysEqual,
      events: isMaybeArraysEqual,
      eventSources: isMaybeArraysEqual,
      ['resources']: isMaybeArraysEqual,
  };
  function isMaybeObjectsEqual(a, b) {
      if (typeof a === 'object' && typeof b === 'object' && a && b) { // both non-null objects
          return isPropsEqual(a, b);
      }
      return a === b;
  }
  function isMaybeArraysEqual(a, b) {
      if (Array.isArray(a) && Array.isArray(b)) {
          return isArraysEqual(a, b);
      }
      return a === b;
  }
  // view-specific options
  // ---------------------
  const VIEW_OPTION_REFINERS = {
      type: String,
      component: identity,
      buttonText: String,
      buttonTextKey: String,
      dateProfileGeneratorClass: identity,
      usesMinMaxTime: Boolean,
      classNames: identity,
      content: identity,
      didMount: identity,
      willUnmount: identity,
  };
  // util funcs
  // ----------------------------------------------------------------------------------------------------
  function mergeRawOptions(optionSets) {
      return mergeProps(optionSets, COMPLEX_OPTION_COMPARATORS);
  }
  function refineProps(input, refiners) {
      let refined = {};
      let extra = {};
      for (let propName in refiners) {
          if (propName in input) {
              refined[propName] = refiners[propName](input[propName]);
          }
      }
      for (let propName in input) {
          if (!(propName in refiners)) {
              extra[propName] = input[propName];
          }
      }
      return { refined, extra };
  }
  function identity(raw) {
      return raw;
  }

  function createEventInstance(defId, range, forcedStartTzo, forcedEndTzo) {
      return {
          instanceId: guid(),
          defId,
          range,
          forcedStartTzo: forcedStartTzo == null ? null : forcedStartTzo,
          forcedEndTzo: forcedEndTzo == null ? null : forcedEndTzo,
      };
  }

  function parseRecurring(refined, defaultAllDay, dateEnv, recurringTypes) {
      for (let i = 0; i < recurringTypes.length; i += 1) {
          let parsed = recurringTypes[i].parse(refined, dateEnv);
          if (parsed) {
              let { allDay } = refined;
              if (allDay == null) {
                  allDay = defaultAllDay;
                  if (allDay == null) {
                      allDay = parsed.allDayGuess;
                      if (allDay == null) {
                          allDay = false;
                      }
                  }
              }
              return {
                  allDay,
                  duration: parsed.duration,
                  typeData: parsed.typeData,
                  typeId: i,
              };
          }
      }
      return null;
  }
  function expandRecurring(eventStore, framingRange, context) {
      let { dateEnv, pluginHooks, options } = context;
      let { defs, instances } = eventStore;
      // remove existing recurring instances
      // TODO: bad. always expand events as a second step
      instances = filterHash(instances, (instance) => !defs[instance.defId].recurringDef);
      for (let defId in defs) {
          let def = defs[defId];
          if (def.recurringDef) {
              let { duration } = def.recurringDef;
              if (!duration) {
                  duration = def.allDay ?
                      options.defaultAllDayEventDuration :
                      options.defaultTimedEventDuration;
              }
              let starts = expandRecurringRanges(def, duration, framingRange, dateEnv, pluginHooks.recurringTypes);
              for (let start of starts) {
                  let instance = createEventInstance(defId, {
                      start,
                      end: dateEnv.add(start, duration),
                  });
                  instances[instance.instanceId] = instance;
              }
          }
      }
      return { defs, instances };
  }
  /*
  Event MUST have a recurringDef
  */
  function expandRecurringRanges(eventDef, duration, framingRange, dateEnv, recurringTypes) {
      let typeDef = recurringTypes[eventDef.recurringDef.typeId];
      let markers = typeDef.expand(eventDef.recurringDef.typeData, {
          start: dateEnv.subtract(framingRange.start, duration),
          end: framingRange.end,
      }, dateEnv);
      // the recurrence plugins don't guarantee that all-day events are start-of-day, so we have to
      if (eventDef.allDay) {
          markers = markers.map(startOfDay);
      }
      return markers;
  }

  function parseEvents(rawEvents, eventSource, context, allowOpenRange, defIdMap, instanceIdMap) {
      let eventStore = createEmptyEventStore();
      let eventRefiners = buildEventRefiners(context);
      for (let rawEvent of rawEvents) {
          let tuple = parseEvent(rawEvent, eventSource, context, allowOpenRange, eventRefiners, defIdMap, instanceIdMap);
          if (tuple) {
              eventTupleToStore(tuple, eventStore);
          }
      }
      return eventStore;
  }
  function eventTupleToStore(tuple, eventStore = createEmptyEventStore()) {
      eventStore.defs[tuple.def.defId] = tuple.def;
      if (tuple.instance) {
          eventStore.instances[tuple.instance.instanceId] = tuple.instance;
      }
      return eventStore;
  }
  // retrieves events that have the same groupId as the instance specified by `instanceId`
  // or they are the same as the instance.
  // why might instanceId not be in the store? an event from another calendar?
  function getRelevantEvents(eventStore, instanceId) {
      let instance = eventStore.instances[instanceId];
      if (instance) {
          let def = eventStore.defs[instance.defId];
          // get events/instances with same group
          let newStore = filterEventStoreDefs(eventStore, (lookDef) => isEventDefsGrouped(def, lookDef));
          // add the original
          // TODO: wish we could use eventTupleToStore or something like it
          newStore.defs[def.defId] = def;
          newStore.instances[instance.instanceId] = instance;
          return newStore;
      }
      return createEmptyEventStore();
  }
  function isEventDefsGrouped(def0, def1) {
      return Boolean(def0.groupId && def0.groupId === def1.groupId);
  }
  function createEmptyEventStore() {
      return { defs: {}, instances: {} };
  }
  function mergeEventStores(store0, store1) {
      return {
          defs: Object.assign(Object.assign({}, store0.defs), store1.defs),
          instances: Object.assign(Object.assign({}, store0.instances), store1.instances),
      };
  }
  function filterEventStoreDefs(eventStore, filterFunc) {
      let defs = filterHash(eventStore.defs, filterFunc);
      let instances = filterHash(eventStore.instances, (instance) => (defs[instance.defId] // still exists?
      ));
      return { defs, instances };
  }
  function excludeSubEventStore(master, sub) {
      let { defs, instances } = master;
      let filteredDefs = {};
      let filteredInstances = {};
      for (let defId in defs) {
          if (!sub.defs[defId]) { // not explicitly excluded
              filteredDefs[defId] = defs[defId];
          }
      }
      for (let instanceId in instances) {
          if (!sub.instances[instanceId] && // not explicitly excluded
              filteredDefs[instances[instanceId].defId] // def wasn't filtered away
          ) {
              filteredInstances[instanceId] = instances[instanceId];
          }
      }
      return {
          defs: filteredDefs,
          instances: filteredInstances,
      };
  }

  function normalizeConstraint(input, context) {
      if (Array.isArray(input)) {
          return parseEvents(input, null, context, true); // allowOpenRange=true
      }
      if (typeof input === 'object' && input) { // non-null object
          return parseEvents([input], null, context, true); // allowOpenRange=true
      }
      if (input != null) {
          return String(input);
      }
      return null;
  }

  function parseClassNames(raw) {
      if (Array.isArray(raw)) {
          return raw;
      }
      if (typeof raw === 'string') {
          return raw.split(/\s+/);
      }
      return [];
  }

  // TODO: better called "EventSettings" or "EventConfig"
  // TODO: move this file into structs
  // TODO: separate constraint/overlap/allow, because selection uses only that, not other props
  const EVENT_UI_REFINERS = {
      display: String,
      editable: Boolean,
      startEditable: Boolean,
      durationEditable: Boolean,
      constraint: identity,
      overlap: identity,
      allow: identity,
      className: parseClassNames,
      classNames: parseClassNames,
      color: String,
      backgroundColor: String,
      borderColor: String,
      textColor: String,
  };
  const EMPTY_EVENT_UI = {
      display: null,
      startEditable: null,
      durationEditable: null,
      constraints: [],
      overlap: null,
      allows: [],
      backgroundColor: '',
      borderColor: '',
      textColor: '',
      classNames: [],
  };
  function createEventUi(refined, context) {
      let constraint = normalizeConstraint(refined.constraint, context);
      return {
          display: refined.display || null,
          startEditable: refined.startEditable != null ? refined.startEditable : refined.editable,
          durationEditable: refined.durationEditable != null ? refined.durationEditable : refined.editable,
          constraints: constraint != null ? [constraint] : [],
          overlap: refined.overlap != null ? refined.overlap : null,
          allows: refined.allow != null ? [refined.allow] : [],
          backgroundColor: refined.backgroundColor || refined.color || '',
          borderColor: refined.borderColor || refined.color || '',
          textColor: refined.textColor || '',
          classNames: (refined.className || []).concat(refined.classNames || []), // join singular and plural
      };
  }
  // TODO: prevent against problems with <2 args!
  function combineEventUis(uis) {
      return uis.reduce(combineTwoEventUis, EMPTY_EVENT_UI);
  }
  function combineTwoEventUis(item0, item1) {
      return {
          display: item1.display != null ? item1.display : item0.display,
          startEditable: item1.startEditable != null ? item1.startEditable : item0.startEditable,
          durationEditable: item1.durationEditable != null ? item1.durationEditable : item0.durationEditable,
          constraints: item0.constraints.concat(item1.constraints),
          overlap: typeof item1.overlap === 'boolean' ? item1.overlap : item0.overlap,
          allows: item0.allows.concat(item1.allows),
          backgroundColor: item1.backgroundColor || item0.backgroundColor,
          borderColor: item1.borderColor || item0.borderColor,
          textColor: item1.textColor || item0.textColor,
          classNames: item0.classNames.concat(item1.classNames),
      };
  }

  const EVENT_NON_DATE_REFINERS = {
      id: String,
      groupId: String,
      title: String,
      url: String,
      interactive: Boolean,
  };
  const EVENT_DATE_REFINERS = {
      start: identity,
      end: identity,
      date: identity,
      allDay: Boolean,
  };
  const EVENT_REFINERS = Object.assign(Object.assign(Object.assign({}, EVENT_NON_DATE_REFINERS), EVENT_DATE_REFINERS), { extendedProps: identity });
  function parseEvent(raw, eventSource, context, allowOpenRange, refiners = buildEventRefiners(context), defIdMap, instanceIdMap) {
      let { refined, extra } = refineEventDef(raw, context, refiners);
      let defaultAllDay = computeIsDefaultAllDay(eventSource, context);
      let recurringRes = parseRecurring(refined, defaultAllDay, context.dateEnv, context.pluginHooks.recurringTypes);
      if (recurringRes) {
          let def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : '', recurringRes.allDay, Boolean(recurringRes.duration), context, defIdMap);
          def.recurringDef = {
              typeId: recurringRes.typeId,
              typeData: recurringRes.typeData,
              duration: recurringRes.duration,
          };
          return { def, instance: null };
      }
      let singleRes = parseSingle(refined, defaultAllDay, context, allowOpenRange);
      if (singleRes) {
          let def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : '', singleRes.allDay, singleRes.hasEnd, context, defIdMap);
          let instance = createEventInstance(def.defId, singleRes.range, singleRes.forcedStartTzo, singleRes.forcedEndTzo);
          if (instanceIdMap && def.publicId && instanceIdMap[def.publicId]) {
              instance.instanceId = instanceIdMap[def.publicId];
          }
          return { def, instance };
      }
      return null;
  }
  function refineEventDef(raw, context, refiners = buildEventRefiners(context)) {
      return refineProps(raw, refiners);
  }
  function buildEventRefiners(context) {
      return Object.assign(Object.assign(Object.assign({}, EVENT_UI_REFINERS), EVENT_REFINERS), context.pluginHooks.eventRefiners);
  }
  /*
  Will NOT populate extendedProps with the leftover properties.
  Will NOT populate date-related props.
  */
  function parseEventDef(refined, extra, sourceId, allDay, hasEnd, context, defIdMap) {
      let def = {
          title: refined.title || '',
          groupId: refined.groupId || '',
          publicId: refined.id || '',
          url: refined.url || '',
          recurringDef: null,
          defId: ((defIdMap && refined.id) ? defIdMap[refined.id] : '') || guid(),
          sourceId,
          allDay,
          hasEnd,
          interactive: refined.interactive,
          ui: createEventUi(refined, context),
          extendedProps: Object.assign(Object.assign({}, (refined.extendedProps || {})), extra),
      };
      for (let memberAdder of context.pluginHooks.eventDefMemberAdders) {
          Object.assign(def, memberAdder(refined));
      }
      // help out EventImpl from having user modify props
      Object.freeze(def.ui.classNames);
      Object.freeze(def.extendedProps);
      return def;
  }
  function parseSingle(refined, defaultAllDay, context, allowOpenRange) {
      let { allDay } = refined;
      let startMeta;
      let startMarker = null;
      let hasEnd = false;
      let endMeta;
      let endMarker = null;
      let startInput = refined.start != null ? refined.start : refined.date;
      startMeta = context.dateEnv.createMarkerMeta(startInput);
      if (startMeta) {
          startMarker = startMeta.marker;
      }
      else if (!allowOpenRange) {
          return null;
      }
      if (refined.end != null) {
          endMeta = context.dateEnv.createMarkerMeta(refined.end);
      }
      if (allDay == null) {
          if (defaultAllDay != null) {
              allDay = defaultAllDay;
          }
          else {
              // fall back to the date props LAST
              allDay = (!startMeta || startMeta.isTimeUnspecified) &&
                  (!endMeta || endMeta.isTimeUnspecified);
          }
      }
      if (allDay && startMarker) {
          startMarker = startOfDay(startMarker);
      }
      if (endMeta) {
          endMarker = endMeta.marker;
          if (allDay) {
              endMarker = startOfDay(endMarker);
          }
          if (startMarker && endMarker <= startMarker) {
              endMarker = null;
          }
      }
      if (endMarker) {
          hasEnd = true;
      }
      else if (!allowOpenRange) {
          hasEnd = context.options.forceEventDuration || false;
          endMarker = context.dateEnv.add(startMarker, allDay ?
              context.options.defaultAllDayEventDuration :
              context.options.defaultTimedEventDuration);
      }
      return {
          allDay,
          hasEnd,
          range: { start: startMarker, end: endMarker },
          forcedStartTzo: startMeta ? startMeta.forcedTzo : null,
          forcedEndTzo: endMeta ? endMeta.forcedTzo : null,
      };
  }
  function computeIsDefaultAllDay(eventSource, context) {
      let res = null;
      if (eventSource) {
          res = eventSource.defaultAllDay;
      }
      if (res == null) {
          res = context.options.defaultAllDay;
      }
      return res;
  }

  const DEF_DEFAULTS = {
      startTime: '09:00',
      endTime: '17:00',
      daysOfWeek: [1, 2, 3, 4, 5],
      display: 'inverse-background',
      classNames: 'fc-non-business',
      groupId: '_businessHours', // so multiple defs get grouped
  };
  /*
  TODO: pass around as EventDefHash!!!
  */
  function parseBusinessHours(input, context) {
      return parseEvents(refineInputs(input), null, context);
  }
  function refineInputs(input) {
      let rawDefs;
      if (input === true) {
          rawDefs = [{}]; // will get DEF_DEFAULTS verbatim
      }
      else if (Array.isArray(input)) {
          // if specifying an array, every sub-definition NEEDS a day-of-week
          rawDefs = input.filter((rawDef) => rawDef.daysOfWeek);
      }
      else if (typeof input === 'object' && input) { // non-null object
          rawDefs = [input];
      }
      else { // is probably false
          rawDefs = [];
      }
      rawDefs = rawDefs.map((rawDef) => (Object.assign(Object.assign({}, DEF_DEFAULTS), rawDef)));
      return rawDefs;
  }

  /* Date stuff that doesn't belong in datelib core
  ----------------------------------------------------------------------------------------------------------------------*/
  // given a timed range, computes an all-day range that has the same exact duration,
  // but whose start time is aligned with the start of the day.
  function computeAlignedDayRange(timedRange) {
      let dayCnt = Math.floor(diffDays(timedRange.start, timedRange.end)) || 1;
      let start = startOfDay(timedRange.start);
      let end = addDays(start, dayCnt);
      return { start, end };
  }
  // given a timed range, computes an all-day range based on how for the end date bleeds into the next day
  // TODO: give nextDayThreshold a default arg
  function computeVisibleDayRange(timedRange, nextDayThreshold = createDuration(0)) {
      let startDay = null;
      let endDay = null;
      if (timedRange.end) {
          endDay = startOfDay(timedRange.end);
          let endTimeMS = timedRange.end.valueOf() - endDay.valueOf(); // # of milliseconds into `endDay`
          // If the end time is actually inclusively part of the next day and is equal to or
          // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.
          // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.
          if (endTimeMS && endTimeMS >= asRoughMs(nextDayThreshold)) {
              endDay = addDays(endDay, 1);
          }
      }
      if (timedRange.start) {
          startDay = startOfDay(timedRange.start); // the beginning of the day the range starts
          // If end is within `startDay` but not past nextDayThreshold, assign the default duration of one day.
          if (endDay && endDay <= startDay) {
              endDay = addDays(startDay, 1);
          }
      }
      return { start: startDay, end: endDay };
  }
  // spans from one day into another?
  function isMultiDayRange(range) {
      let visibleRange = computeVisibleDayRange(range);
      return diffDays(visibleRange.start, visibleRange.end) > 1;
  }
  function diffDates(date0, date1, dateEnv, largeUnit) {
      if (largeUnit === 'year') {
          return createDuration(dateEnv.diffWholeYears(date0, date1), 'year');
      }
      if (largeUnit === 'month') {
          return createDuration(dateEnv.diffWholeMonths(date0, date1), 'month');
      }
      return diffDayAndTime(date0, date1); // returns a duration
  }

  function pointInsideRect(point, rect) {
      return point.left >= rect.left &&
          point.left < rect.right &&
          point.top >= rect.top &&
          point.top < rect.bottom;
  }
  // Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false
  function intersectRects$1(rect1, rect2) {
      let res = {
          left: Math.max(rect1.left, rect2.left),
          right: Math.min(rect1.right, rect2.right),
          top: Math.max(rect1.top, rect2.top),
          bottom: Math.min(rect1.bottom, rect2.bottom),
      };
      if (res.left < res.right && res.top < res.bottom) {
          return res;
      }
      return false;
  }
  // Returns a new point that will have been moved to reside within the given rectangle
  function constrainPoint(point, rect) {
      return {
          left: Math.min(Math.max(point.left, rect.left), rect.right),
          top: Math.min(Math.max(point.top, rect.top), rect.bottom),
      };
  }
  // Returns a point that is the center of the given rectangle
  function getRectCenter$1(rect) {
      return {
          left: (rect.left + rect.right) / 2,
          top: (rect.top + rect.bottom) / 2,
      };
  }
  // Subtracts point2's coordinates from point1's coordinates, returning a delta
  function diffPoints(point1, point2) {
      return {
          left: point1.left - point2.left,
          top: point1.top - point2.top,
      };
  }

  let canVGrowWithinCell;
  function getCanVGrowWithinCell() {
      if (canVGrowWithinCell == null) {
          canVGrowWithinCell = computeCanVGrowWithinCell();
      }
      return canVGrowWithinCell;
  }
  function computeCanVGrowWithinCell() {
      // for SSR, because this function is call immediately at top-level
      // TODO: just make this logic execute top-level, immediately, instead of doing lazily
      if (typeof document === 'undefined') {
          return true;
      }
      let el = document.createElement('div');
      el.style.position = 'absolute';
      el.style.top = '0px';
      el.style.left = '0px';
      el.innerHTML = '<table><tr><td><div></div></td></tr></table>';
      el.querySelector('table').style.height = '100px';
      el.querySelector('div').style.height = '100%';
      document.body.appendChild(el);
      let div = el.querySelector('div');
      let possible = div.offsetHeight > 0;
      document.body.removeChild(el);
      return possible;
  }

  const EMPTY_EVENT_STORE = createEmptyEventStore(); // for purecomponents. TODO: keep elsewhere
  class Splitter {
      constructor() {
          this.getKeysForEventDefs = memoize(this._getKeysForEventDefs);
          this.splitDateSelection = memoize(this._splitDateSpan);
          this.splitEventStore = memoize(this._splitEventStore);
          this.splitIndividualUi = memoize(this._splitIndividualUi);
          this.splitEventDrag = memoize(this._splitInteraction);
          this.splitEventResize = memoize(this._splitInteraction);
          this.eventUiBuilders = {}; // TODO: typescript protection
      }
      splitProps(props) {
          let keyInfos = this.getKeyInfo(props);
          let defKeys = this.getKeysForEventDefs(props.eventStore);
          let dateSelections = this.splitDateSelection(props.dateSelection);
          let individualUi = this.splitIndividualUi(props.eventUiBases, defKeys); // the individual *bases*
          let eventStores = this.splitEventStore(props.eventStore, defKeys);
          let eventDrags = this.splitEventDrag(props.eventDrag);
          let eventResizes = this.splitEventResize(props.eventResize);
          let splitProps = {};
          this.eventUiBuilders = mapHash(keyInfos, (info, key) => this.eventUiBuilders[key] || memoize(buildEventUiForKey));
          for (let key in keyInfos) {
              let keyInfo = keyInfos[key];
              let eventStore = eventStores[key] || EMPTY_EVENT_STORE;
              let buildEventUi = this.eventUiBuilders[key];
              splitProps[key] = {
                  businessHours: keyInfo.businessHours || props.businessHours,
                  dateSelection: dateSelections[key] || null,
                  eventStore,
                  eventUiBases: buildEventUi(props.eventUiBases[''], keyInfo.ui, individualUi[key]),
                  eventSelection: eventStore.instances[props.eventSelection] ? props.eventSelection : '',
                  eventDrag: eventDrags[key] || null,
                  eventResize: eventResizes[key] || null,
              };
          }
          return splitProps;
      }
      _splitDateSpan(dateSpan) {
          let dateSpans = {};
          if (dateSpan) {
              let keys = this.getKeysForDateSpan(dateSpan);
              for (let key of keys) {
                  dateSpans[key] = dateSpan;
              }
          }
          return dateSpans;
      }
      _getKeysForEventDefs(eventStore) {
          return mapHash(eventStore.defs, (eventDef) => this.getKeysForEventDef(eventDef));
      }
      _splitEventStore(eventStore, defKeys) {
          let { defs, instances } = eventStore;
          let splitStores = {};
          for (let defId in defs) {
              for (let key of defKeys[defId]) {
                  if (!splitStores[key]) {
                      splitStores[key] = createEmptyEventStore();
                  }
                  splitStores[key].defs[defId] = defs[defId];
              }
          }
          for (let instanceId in instances) {
              let instance = instances[instanceId];
              for (let key of defKeys[instance.defId]) {
                  if (splitStores[key]) { // must have already been created
                      splitStores[key].instances[instanceId] = instance;
                  }
              }
          }
          return splitStores;
      }
      _splitIndividualUi(eventUiBases, defKeys) {
          let splitHashes = {};
          for (let defId in eventUiBases) {
              if (defId) { // not the '' key
                  for (let key of defKeys[defId]) {
                      if (!splitHashes[key]) {
                          splitHashes[key] = {};
                      }
                      splitHashes[key][defId] = eventUiBases[defId];
                  }
              }
          }
          return splitHashes;
      }
      _splitInteraction(interaction) {
          let splitStates = {};
          if (interaction) {
              let affectedStores = this._splitEventStore(interaction.affectedEvents, this._getKeysForEventDefs(interaction.affectedEvents));
              // can't rely on defKeys because event data is mutated
              let mutatedKeysByDefId = this._getKeysForEventDefs(interaction.mutatedEvents);
              let mutatedStores = this._splitEventStore(interaction.mutatedEvents, mutatedKeysByDefId);
              let populate = (key) => {
                  if (!splitStates[key]) {
                      splitStates[key] = {
                          affectedEvents: affectedStores[key] || EMPTY_EVENT_STORE,
                          mutatedEvents: mutatedStores[key] || EMPTY_EVENT_STORE,
                          isEvent: interaction.isEvent,
                      };
                  }
              };
              for (let key in affectedStores) {
                  populate(key);
              }
              for (let key in mutatedStores) {
                  populate(key);
              }
          }
          return splitStates;
      }
  }
  function buildEventUiForKey(allUi, eventUiForKey, individualUi) {
      let baseParts = [];
      if (allUi) {
          baseParts.push(allUi);
      }
      if (eventUiForKey) {
          baseParts.push(eventUiForKey);
      }
      let stuff = {
          '': combineEventUis(baseParts),
      };
      if (individualUi) {
          Object.assign(stuff, individualUi);
      }
      return stuff;
  }

  function parseRange(input, dateEnv) {
      let start = null;
      let end = null;
      if (input.start) {
          start = dateEnv.createMarker(input.start);
      }
      if (input.end) {
          end = dateEnv.createMarker(input.end);
      }
      if (!start && !end) {
          return null;
      }
      if (start && end && end < start) {
          return null;
      }
      return { start, end };
  }
  // SIDE-EFFECT: will mutate ranges.
  // Will return a new array result.
  function invertRanges(ranges, constraintRange) {
      let invertedRanges = [];
      let { start } = constraintRange; // the end of the previous range. the start of the new range
      let i;
      let dateRange;
      // ranges need to be in order. required for our date-walking algorithm
      ranges.sort(compareRanges);
      for (i = 0; i < ranges.length; i += 1) {
          dateRange = ranges[i];
          // add the span of time before the event (if there is any)
          if (dateRange.start > start) { // compare millisecond time (skip any ambig logic)
              invertedRanges.push({ start, end: dateRange.start });
          }
          if (dateRange.end > start) {
              start = dateRange.end;
          }
      }
      // add the span of time after the last event (if there is any)
      if (start < constraintRange.end) { // compare millisecond time (skip any ambig logic)
          invertedRanges.push({ start, end: constraintRange.end });
      }
      return invertedRanges;
  }
  function compareRanges(range0, range1) {
      return range0.start.valueOf() - range1.start.valueOf(); // earlier ranges go first
  }
  function intersectRanges(range0, range1) {
      let { start, end } = range0;
      let newRange = null;
      if (range1.start !== null) {
          if (start === null) {
              start = range1.start;
          }
          else {
              start = new Date(Math.max(start.valueOf(), range1.start.valueOf()));
          }
      }
      if (range1.end != null) {
          if (end === null) {
              end = range1.end;
          }
          else {
              end = new Date(Math.min(end.valueOf(), range1.end.valueOf()));
          }
      }
      if (start === null || end === null || start < end) {
          newRange = { start, end };
      }
      return newRange;
  }
  function rangesEqual(range0, range1) {
      return (range0.start === null ? null : range0.start.valueOf()) === (range1.start === null ? null : range1.start.valueOf()) &&
          (range0.end === null ? null : range0.end.valueOf()) === (range1.end === null ? null : range1.end.valueOf());
  }
  function rangesIntersect(range0, range1) {
      return (range0.end === null || range1.start === null || range0.end > range1.start) &&
          (range0.start === null || range1.end === null || range0.start < range1.end);
  }
  function rangeContainsRange(outerRange, innerRange) {
      return (outerRange.start === null || (innerRange.start !== null && innerRange.start >= outerRange.start)) &&
          (outerRange.end === null || (innerRange.end !== null && innerRange.end <= outerRange.end));
  }
  function rangeContainsMarker(range, date) {
      return (range.start === null || date >= range.start) &&
          (range.end === null || date < range.end);
  }
  // If the given date is not within the given range, move it inside.
  // (If it's past the end, make it one millisecond before the end).
  function constrainMarkerToRange(date, range) {
      if (range.start != null && date < range.start) {
          return range.start;
      }
      if (range.end != null && date >= range.end) {
          return new Date(range.end.valueOf() - 1);
      }
      return date;
  }

  function getDateMeta(date, todayRange, nowDate, dateProfile) {
      return {
          dow: date.getUTCDay(),
          isDisabled: Boolean(dateProfile && !rangeContainsMarker(dateProfile.activeRange, date)),
          isOther: Boolean(dateProfile && !rangeContainsMarker(dateProfile.currentRange, date)),
          isToday: Boolean(todayRange && rangeContainsMarker(todayRange, date)),
          isPast: Boolean(nowDate ? (date < nowDate) : todayRange ? (date < todayRange.start) : false),
          isFuture: Boolean(nowDate ? (date > nowDate) : todayRange ? (date >= todayRange.end) : false),
      };
  }
  function getDayClassNames(meta, theme) {
      let classNames = [
          'fc-day',
          `fc-day-${DAY_IDS[meta.dow]}`,
      ];
      if (meta.isDisabled) {
          classNames.push('fc-day-disabled');
      }
      else {
          if (meta.isToday) {
              classNames.push('fc-day-today');
              classNames.push(theme.getClass('today'));
          }
          if (meta.isPast) {
              classNames.push('fc-day-past');
          }
          if (meta.isFuture) {
              classNames.push('fc-day-future');
          }
          if (meta.isOther) {
              classNames.push('fc-day-other');
          }
      }
      return classNames;
  }

  const DAY_FORMAT = createFormatter({ year: 'numeric', month: 'long', day: 'numeric' });
  const WEEK_FORMAT = createFormatter({ week: 'long' });
  function buildNavLinkAttrs(context, dateMarker, viewType = 'day', isTabbable = true) {
      const { dateEnv, options, calendarApi } = context;
      let dateStr = dateEnv.format(dateMarker, viewType === 'week' ? WEEK_FORMAT : DAY_FORMAT);
      if (options.navLinks) {
          let zonedDate = dateEnv.toDate(dateMarker);
          const handleInteraction = (ev) => {
              let customAction = viewType === 'day' ? options.navLinkDayClick :
                  viewType === 'week' ? options.navLinkWeekClick : null;
              if (typeof customAction === 'function') {
                  customAction.call(calendarApi, dateEnv.toDate(dateMarker), ev);
              }
              else {
                  if (typeof customAction === 'string') {
                      viewType = customAction;
                  }
                  calendarApi.zoomTo(dateMarker, viewType);
              }
          };
          return Object.assign({ title: formatWithOrdinals(options.navLinkHint, [dateStr, zonedDate], dateStr), 'data-navlink': '' }, (isTabbable
              ? createAriaClickAttrs(handleInteraction)
              : { onClick: handleInteraction }));
      }
      return { 'aria-label': dateStr };
  }

  let _isRtlScrollbarOnLeft = null;
  function getIsRtlScrollbarOnLeft() {
      if (_isRtlScrollbarOnLeft === null) {
          _isRtlScrollbarOnLeft = computeIsRtlScrollbarOnLeft();
      }
      return _isRtlScrollbarOnLeft;
  }
  function computeIsRtlScrollbarOnLeft() {
      let outerEl = document.createElement('div');
      applyStyle(outerEl, {
          position: 'absolute',
          top: -1000,
          left: 0,
          border: 0,
          padding: 0,
          overflow: 'scroll',
          direction: 'rtl',
      });
      outerEl.innerHTML = '<div></div>';
      document.body.appendChild(outerEl);
      let innerEl = outerEl.firstChild;
      let res = innerEl.getBoundingClientRect().left > outerEl.getBoundingClientRect().left;
      removeElement(outerEl);
      return res;
  }

  let _scrollbarWidths;
  function getScrollbarWidths() {
      if (!_scrollbarWidths) {
          _scrollbarWidths = computeScrollbarWidths();
      }
      return _scrollbarWidths;
  }
  function computeScrollbarWidths() {
      let el = document.createElement('div');
      el.style.overflow = 'scroll';
      el.style.position = 'absolute';
      el.style.top = '-9999px';
      el.style.left = '-9999px';
      document.body.appendChild(el);
      let res = computeScrollbarWidthsForEl(el);
      document.body.removeChild(el);
      return res;
  }
  // WARNING: will include border
  function computeScrollbarWidthsForEl(el) {
      return {
          x: el.offsetHeight - el.clientHeight,
          y: el.offsetWidth - el.clientWidth,
      };
  }

  function computeEdges(el, getPadding = false) {
      let computedStyle = window.getComputedStyle(el);
      let borderLeft = parseInt(computedStyle.borderLeftWidth, 10) || 0;
      let borderRight = parseInt(computedStyle.borderRightWidth, 10) || 0;
      let borderTop = parseInt(computedStyle.borderTopWidth, 10) || 0;
      let borderBottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;
      let badScrollbarWidths = computeScrollbarWidthsForEl(el); // includes border!
      let scrollbarLeftRight = badScrollbarWidths.y - borderLeft - borderRight;
      let scrollbarBottom = badScrollbarWidths.x - borderTop - borderBottom;
      let res = {
          borderLeft,
          borderRight,
          borderTop,
          borderBottom,
          scrollbarBottom,
          scrollbarLeft: 0,
          scrollbarRight: 0,
      };
      if (getIsRtlScrollbarOnLeft() && computedStyle.direction === 'rtl') { // is the scrollbar on the left side?
          res.scrollbarLeft = scrollbarLeftRight;
      }
      else {
          res.scrollbarRight = scrollbarLeftRight;
      }
      if (getPadding) {
          res.paddingLeft = parseInt(computedStyle.paddingLeft, 10) || 0;
          res.paddingRight = parseInt(computedStyle.paddingRight, 10) || 0;
          res.paddingTop = parseInt(computedStyle.paddingTop, 10) || 0;
          res.paddingBottom = parseInt(computedStyle.paddingBottom, 10) || 0;
      }
      return res;
  }
  function computeInnerRect(el, goWithinPadding = false, doFromWindowViewport) {
      let outerRect = doFromWindowViewport ? el.getBoundingClientRect() : computeRect(el);
      let edges = computeEdges(el, goWithinPadding);
      let res = {
          left: outerRect.left + edges.borderLeft + edges.scrollbarLeft,
          right: outerRect.right - edges.borderRight - edges.scrollbarRight,
          top: outerRect.top + edges.borderTop,
          bottom: outerRect.bottom - edges.borderBottom - edges.scrollbarBottom,
      };
      if (goWithinPadding) {
          res.left += edges.paddingLeft;
          res.right -= edges.paddingRight;
          res.top += edges.paddingTop;
          res.bottom -= edges.paddingBottom;
      }
      return res;
  }
  function computeRect(el) {
      let rect = el.getBoundingClientRect();
      return {
          left: rect.left + window.pageXOffset,
          top: rect.top + window.pageYOffset,
          right: rect.right + window.pageXOffset,
          bottom: rect.bottom + window.pageYOffset,
      };
  }
  function computeClippedClientRect(el) {
      let clippingParents = getClippingParents(el);
      let rect = el.getBoundingClientRect();
      for (let clippingParent of clippingParents) {
          let intersection = intersectRects$1(rect, clippingParent.getBoundingClientRect());
          if (intersection) {
              rect = intersection;
          }
          else {
              return null;
          }
      }
      return rect;
  }
  // does not return window
  function getClippingParents(el) {
      let parents = [];
      while (el instanceof HTMLElement) { // will stop when gets to document or null
          let computedStyle = window.getComputedStyle(el);
          if (computedStyle.position === 'fixed') {
              break;
          }
          if ((/(auto|scroll)/).test(computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {
              parents.push(el);
          }
          el = el.parentNode;
      }
      return parents;
  }

  /*
  given a function that resolves a result asynchronously.
  the function can either call passed-in success and failure callbacks,
  or it can return a promise.
  if you need to pass additional params to func, bind them first.
  */
  function unpromisify(func, normalizedSuccessCallback, normalizedFailureCallback) {
      // guard against success/failure callbacks being called more than once
      // and guard against a promise AND callback being used together.
      let isResolved = false;
      let wrappedSuccess = function (res) {
          if (!isResolved) {
              isResolved = true;
              normalizedSuccessCallback(res);
          }
      };
      let wrappedFailure = function (error) {
          if (!isResolved) {
              isResolved = true;
              normalizedFailureCallback(error);
          }
      };
      let res = func(wrappedSuccess, wrappedFailure);
      if (res && typeof res.then === 'function') {
          res.then(wrappedSuccess, wrappedFailure);
      }
  }

  class Emitter {
      constructor() {
          this.handlers = {};
          this.thisContext = null;
      }
      setThisContext(thisContext) {
          this.thisContext = thisContext;
      }
      setOptions(options) {
          this.options = options;
      }
      on(type, handler) {
          addToHash(this.handlers, type, handler);
      }
      off(type, handler) {
          removeFromHash(this.handlers, type, handler);
      }
      trigger(type, ...args) {
          let attachedHandlers = this.handlers[type] || [];
          let optionHandler = this.options && this.options[type];
          let handlers = [].concat(optionHandler || [], attachedHandlers);
          for (let handler of handlers) {
              handler.apply(this.thisContext, args);
          }
      }
      hasHandlers(type) {
          return Boolean((this.handlers[type] && this.handlers[type].length) ||
              (this.options && this.options[type]));
      }
  }
  function addToHash(hash, type, handler) {
      (hash[type] || (hash[type] = []))
          .push(handler);
  }
  function removeFromHash(hash, type, handler) {
      if (handler) {
          if (hash[type]) {
              hash[type] = hash[type].filter((func) => func !== handler);
          }
      }
      else {
          delete hash[type]; // remove all handler funcs for this type
      }
  }

  /*
  Records offset information for a set of elements, relative to an origin element.
  Can record the left/right OR the top/bottom OR both.
  Provides methods for querying the cache by position.
  */
  class PositionCache {
      constructor(originEl, els, isHorizontal, isVertical) {
          this.els = els;
          let originClientRect = this.originClientRect = originEl.getBoundingClientRect(); // relative to viewport top-left
          if (isHorizontal) {
              this.buildElHorizontals(originClientRect.left);
          }
          if (isVertical) {
              this.buildElVerticals(originClientRect.top);
          }
      }
      // Populates the left/right internal coordinate arrays
      buildElHorizontals(originClientLeft) {
          let lefts = [];
          let rights = [];
          for (let el of this.els) {
              let rect = el.getBoundingClientRect();
              lefts.push(rect.left - originClientLeft);
              rights.push(rect.right - originClientLeft);
          }
          this.lefts = lefts;
          this.rights = rights;
      }
      // Populates the top/bottom internal coordinate arrays
      buildElVerticals(originClientTop) {
          let tops = [];
          let bottoms = [];
          for (let el of this.els) {
              let rect = el.getBoundingClientRect();
              tops.push(rect.top - originClientTop);
              bottoms.push(rect.bottom - originClientTop);
          }
          this.tops = tops;
          this.bottoms = bottoms;
      }
      // Given a left offset (from document left), returns the index of the el that it horizontally intersects.
      // If no intersection is made, returns undefined.
      leftToIndex(leftPosition) {
          let { lefts, rights } = this;
          let len = lefts.length;
          let i;
          for (i = 0; i < len; i += 1) {
              if (leftPosition >= lefts[i] && leftPosition < rights[i]) {
                  return i;
              }
          }
          return undefined; // TODO: better
      }
      // Given a top offset (from document top), returns the index of the el that it vertically intersects.
      // If no intersection is made, returns undefined.
      topToIndex(topPosition) {
          let { tops, bottoms } = this;
          let len = tops.length;
          let i;
          for (i = 0; i < len; i += 1) {
              if (topPosition >= tops[i] && topPosition < bottoms[i]) {
                  return i;
              }
          }
          return undefined; // TODO: better
      }
      // Gets the width of the element at the given index
      getWidth(leftIndex) {
          return this.rights[leftIndex] - this.lefts[leftIndex];
      }
      // Gets the height of the element at the given index
      getHeight(topIndex) {
          return this.bottoms[topIndex] - this.tops[topIndex];
      }
      similarTo(otherCache) {
          return similarNumArrays(this.tops || [], otherCache.tops || []) &&
              similarNumArrays(this.bottoms || [], otherCache.bottoms || []) &&
              similarNumArrays(this.lefts || [], otherCache.lefts || []) &&
              similarNumArrays(this.rights || [], otherCache.rights || []);
      }
  }
  function similarNumArrays(a, b) {
      const len = a.length;
      if (len !== b.length) {
          return false;
      }
      for (let i = 0; i < len; i++) {
          if (Math.round(a[i]) !== Math.round(b[i])) {
              return false;
          }
      }
      return true;
  }

  /* eslint max-classes-per-file: "off" */
  /*
  An object for getting/setting scroll-related information for an element.
  Internally, this is done very differently for window versus DOM element,
  so this object serves as a common interface.
  */
  class ScrollController {
      getMaxScrollTop() {
          return this.getScrollHeight() - this.getClientHeight();
      }
      getMaxScrollLeft() {
          return this.getScrollWidth() - this.getClientWidth();
      }
      canScrollVertically() {
          return this.getMaxScrollTop() > 0;
      }
      canScrollHorizontally() {
          return this.getMaxScrollLeft() > 0;
      }
      canScrollUp() {
          return this.getScrollTop() > 0;
      }
      canScrollDown() {
          return this.getScrollTop() < this.getMaxScrollTop();
      }
      canScrollLeft() {
          return this.getScrollLeft() > 0;
      }
      canScrollRight() {
          return this.getScrollLeft() < this.getMaxScrollLeft();
      }
  }
  class ElementScrollController extends ScrollController {
      constructor(el) {
          super();
          this.el = el;
      }
      getScrollTop() {
          return this.el.scrollTop;
      }
      getScrollLeft() {
          return this.el.scrollLeft;
      }
      setScrollTop(top) {
          this.el.scrollTop = top;
      }
      setScrollLeft(left) {
          this.el.scrollLeft = left;
      }
      getScrollWidth() {
          return this.el.scrollWidth;
      }
      getScrollHeight() {
          return this.el.scrollHeight;
      }
      getClientHeight() {
          return this.el.clientHeight;
      }
      getClientWidth() {
          return this.el.clientWidth;
      }
  }
  class WindowScrollController extends ScrollController {
      getScrollTop() {
          return window.pageYOffset;
      }
      getScrollLeft() {
          return window.pageXOffset;
      }
      setScrollTop(n) {
          window.scroll(window.pageXOffset, n);
      }
      setScrollLeft(n) {
          window.scroll(n, window.pageYOffset);
      }
      getScrollWidth() {
          return document.documentElement.scrollWidth;
      }
      getScrollHeight() {
          return document.documentElement.scrollHeight;
      }
      getClientHeight() {
          return document.documentElement.clientHeight;
      }
      getClientWidth() {
          return document.documentElement.clientWidth;
      }
  }

  class Theme {
      constructor(calendarOptions) {
          if (this.iconOverrideOption) {
              this.setIconOverride(calendarOptions[this.iconOverrideOption]);
          }
      }
      setIconOverride(iconOverrideHash) {
          let iconClassesCopy;
          let buttonName;
          if (typeof iconOverrideHash === 'object' && iconOverrideHash) { // non-null object
              iconClassesCopy = Object.assign({}, this.iconClasses);
              for (buttonName in iconOverrideHash) {
                  iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);
              }
              this.iconClasses = iconClassesCopy;
          }
          else if (iconOverrideHash === false) {
              this.iconClasses = {};
          }
      }
      applyIconOverridePrefix(className) {
          let prefix = this.iconOverridePrefix;
          if (prefix && className.indexOf(prefix) !== 0) { // if not already present
              className = prefix + className;
          }
          return className;
      }
      getClass(key) {
          return this.classes[key] || '';
      }
      getIconClass(buttonName, isRtl) {
          let className;
          if (isRtl && this.rtlIconClasses) {
              className = this.rtlIconClasses[buttonName] || this.iconClasses[buttonName];
          }
          else {
              className = this.iconClasses[buttonName];
          }
          if (className) {
              return `${this.baseIconClass} ${className}`;
          }
          return '';
      }
      getCustomButtonIconClass(customButtonProps) {
          let className;
          if (this.iconOverrideCustomButtonOption) {
              className = customButtonProps[this.iconOverrideCustomButtonOption];
              if (className) {
                  return `${this.baseIconClass} ${this.applyIconOverridePrefix(className)}`;
              }
          }
          return '';
      }
  }
  Theme.prototype.classes = {};
  Theme.prototype.iconClasses = {};
  Theme.prototype.baseIconClass = '';
  Theme.prototype.iconOverridePrefix = '';

  /*
  NOTE: this can be a public API, especially createElement for hooks.
  See examples/typescript-scheduler/src/index.ts
  */
  function flushSync(runBeforeFlush) {
      runBeforeFlush();
      let oldDebounceRendering = l$2.debounceRendering; // orig
      let callbackQ = [];
      function execCallbackSync(callback) {
          callbackQ.push(callback);
      }
      l$2.debounceRendering = execCallbackSync;
      D$1(y$1(FakeComponent, {}), document.createElement('div'));
      while (callbackQ.length) {
          callbackQ.shift()();
      }
      l$2.debounceRendering = oldDebounceRendering;
  }
  class FakeComponent extends x$1 {
      render() { return y$1('div', {}); }
      componentDidMount() { this.setState({}); }
  }
  // TODO: use preact/compat instead?
  function createContext(defaultValue) {
      let ContextType = G$1(defaultValue);
      let origProvider = ContextType.Provider;
      ContextType.Provider = function () {
          let isNew = !this.getChildContext;
          let children = origProvider.apply(this, arguments); // eslint-disable-line prefer-rest-params
          if (isNew) {
              let subs = [];
              this.shouldComponentUpdate = (_props) => {
                  if (this.props.value !== _props.value) {
                      subs.forEach((c) => {
                          c.context = _props.value;
                          c.forceUpdate();
                      });
                  }
              };
              this.sub = (c) => {
                  subs.push(c);
                  let old = c.componentWillUnmount;
                  c.componentWillUnmount = () => {
                      subs.splice(subs.indexOf(c), 1);
                      old && old.call(c);
                  };
              };
          }
          return children;
      };
      return ContextType;
  }

  class ScrollResponder {
      constructor(execFunc, emitter, scrollTime, scrollTimeReset) {
          this.execFunc = execFunc;
          this.emitter = emitter;
          this.scrollTime = scrollTime;
          this.scrollTimeReset = scrollTimeReset;
          this.handleScrollRequest = (request) => {
              this.queuedRequest = Object.assign({}, this.queuedRequest || {}, request);
              this.drain();
          };
          emitter.on('_scrollRequest', this.handleScrollRequest);
          this.fireInitialScroll();
      }
      detach() {
          this.emitter.off('_scrollRequest', this.handleScrollRequest);
      }
      update(isDatesNew) {
          if (isDatesNew && this.scrollTimeReset) {
              this.fireInitialScroll(); // will drain
          }
          else {
              this.drain();
          }
      }
      fireInitialScroll() {
          this.handleScrollRequest({
              time: this.scrollTime,
          });
      }
      drain() {
          if (this.queuedRequest && this.execFunc(this.queuedRequest)) {
              this.queuedRequest = null;
          }
      }
  }

  const ViewContextType = createContext({}); // for Components
  function buildViewContext(viewSpec, viewApi, viewOptions, dateProfileGenerator, dateEnv, theme, pluginHooks, dispatch, getCurrentData, emitter, calendarApi, registerInteractiveComponent, unregisterInteractiveComponent) {
      return {
          dateEnv,
          options: viewOptions,
          pluginHooks,
          emitter,
          dispatch,
          getCurrentData,
          calendarApi,
          viewSpec,
          viewApi,
          dateProfileGenerator,
          theme,
          isRtl: viewOptions.direction === 'rtl',
          addResizeHandler(handler) {
              emitter.on('_resize', handler);
          },
          removeResizeHandler(handler) {
              emitter.off('_resize', handler);
          },
          createScrollResponder(execFunc) {
              return new ScrollResponder(execFunc, emitter, createDuration(viewOptions.scrollTime), viewOptions.scrollTimeReset);
          },
          registerInteractiveComponent,
          unregisterInteractiveComponent,
      };
  }

  /* eslint max-classes-per-file: off */
  class PureComponent extends x$1 {
      shouldComponentUpdate(nextProps, nextState) {
          if (this.debug) {
              // eslint-disable-next-line no-console
              console.log(getUnequalProps(nextProps, this.props), getUnequalProps(nextState, this.state));
          }
          return !compareObjs(this.props, nextProps, this.propEquality) ||
              !compareObjs(this.state, nextState, this.stateEquality);
      }
      // HACK for freakin' React StrictMode
      safeSetState(newState) {
          if (!compareObjs(this.state, Object.assign(Object.assign({}, this.state), newState), this.stateEquality)) {
              this.setState(newState);
          }
      }
  }
  PureComponent.addPropsEquality = addPropsEquality;
  PureComponent.addStateEquality = addStateEquality;
  PureComponent.contextType = ViewContextType;
  PureComponent.prototype.propEquality = {};
  PureComponent.prototype.stateEquality = {};
  class BaseComponent extends PureComponent {
  }
  BaseComponent.contextType = ViewContextType;
  function addPropsEquality(propEquality) {
      let hash = Object.create(this.prototype.propEquality);
      Object.assign(hash, propEquality);
      this.prototype.propEquality = hash;
  }
  function addStateEquality(stateEquality) {
      let hash = Object.create(this.prototype.stateEquality);
      Object.assign(hash, stateEquality);
      this.prototype.stateEquality = hash;
  }
  // use other one
  function setRef(ref, current) {
      if (typeof ref === 'function') {
          ref(current);
      }
      else if (ref) {
          // see https://github.com/facebook/react/issues/13029
          ref.current = current;
      }
  }

  /*
  an INTERACTABLE date component

  PURPOSES:
  - hook up to fg, fill, and mirror renderers
  - interface for dragging and hits
  */
  class DateComponent extends BaseComponent {
      constructor() {
          super(...arguments);
          this.uid = guid();
      }
      // Hit System
      // -----------------------------------------------------------------------------------------------------------------
      prepareHits() {
      }
      queryHit(positionLeft, positionTop, elWidth, elHeight) {
          return null; // this should be abstract
      }
      // Pointer Interaction Utils
      // -----------------------------------------------------------------------------------------------------------------
      isValidSegDownEl(el) {
          return !this.props.eventDrag && // HACK
              !this.props.eventResize && // HACK
              !elementClosest(el, '.fc-event-mirror');
      }
      isValidDateDownEl(el) {
          return !elementClosest(el, '.fc-event:not(.fc-bg-event)') &&
              !elementClosest(el, '.fc-more-link') && // a "more.." link
              !elementClosest(el, 'a[data-navlink]') && // a clickable nav link
              !elementClosest(el, '.fc-popover'); // hack
      }
  }

  function reduceCurrentDate(currentDate, action) {
      switch (action.type) {
          case 'CHANGE_DATE':
              return action.dateMarker;
          default:
              return currentDate;
      }
  }
  function getInitialDate(options, dateEnv) {
      let initialDateInput = options.initialDate;
      // compute the initial ambig-timezone date
      if (initialDateInput != null) {
          return dateEnv.createMarker(initialDateInput);
      }
      return getNow(options.now, dateEnv); // getNow already returns unzoned
  }
  function getNow(nowInput, dateEnv) {
      if (typeof nowInput === 'function') {
          nowInput = nowInput();
      }
      if (nowInput == null) {
          return dateEnv.createNowMarker();
      }
      return dateEnv.createMarker(nowInput);
  }

  class DateProfileGenerator {
      constructor(props) {
          this.props = props;
          this.nowDate = getNow(props.nowInput, props.dateEnv);
          this.initHiddenDays();
      }
      /* Date Range Computation
      ------------------------------------------------------------------------------------------------------------------*/
      // Builds a structure with info about what the dates/ranges will be for the "prev" view.
      buildPrev(currentDateProfile, currentDate, forceToValid) {
          let { dateEnv } = this.props;
          let prevDate = dateEnv.subtract(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), // important for start-of-month
          currentDateProfile.dateIncrement);
          return this.build(prevDate, -1, forceToValid);
      }
      // Builds a structure with info about what the dates/ranges will be for the "next" view.
      buildNext(currentDateProfile, currentDate, forceToValid) {
          let { dateEnv } = this.props;
          let nextDate = dateEnv.add(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), // important for start-of-month
          currentDateProfile.dateIncrement);
          return this.build(nextDate, 1, forceToValid);
      }
      // Builds a structure holding dates/ranges for rendering around the given date.
      // Optional direction param indicates whether the date is being incremented/decremented
      // from its previous value. decremented = -1, incremented = 1 (default).
      build(currentDate, direction, forceToValid = true) {
          let { props } = this;
          let validRange;
          let currentInfo;
          let isRangeAllDay;
          let renderRange;
          let activeRange;
          let isValid;
          validRange = this.buildValidRange();
          validRange = this.trimHiddenDays(validRange);
          if (forceToValid) {
              currentDate = constrainMarkerToRange(currentDate, validRange);
          }
          currentInfo = this.buildCurrentRangeInfo(currentDate, direction);
          isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);
          renderRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.range), currentInfo.unit, isRangeAllDay);
          renderRange = this.trimHiddenDays(renderRange);
          activeRange = renderRange;
          if (!props.showNonCurrentDates) {
              activeRange = intersectRanges(activeRange, currentInfo.range);
          }
          activeRange = this.adjustActiveRange(activeRange);
          activeRange = intersectRanges(activeRange, validRange); // might return null
          // it's invalid if the originally requested date is not contained,
          // or if the range is completely outside of the valid range.
          isValid = rangesIntersect(currentInfo.range, validRange);
          // HACK: constrain to render-range so `currentDate` is more useful to view rendering
          if (!rangeContainsMarker(renderRange, currentDate)) {
              currentDate = renderRange.start;
          }
          return {
              currentDate,
              // constraint for where prev/next operations can go and where events can be dragged/resized to.
              // an object with optional start and end properties.
              validRange,
              // range the view is formally responsible for.
              // for example, a month view might have 1st-31st, excluding padded dates
              currentRange: currentInfo.range,
              // name of largest unit being displayed, like "month" or "week"
              currentRangeUnit: currentInfo.unit,
              isRangeAllDay,
              // dates that display events and accept drag-n-drop
              // will be `null` if no dates accept events
              activeRange,
              // date range with a rendered skeleton
              // includes not-active days that need some sort of DOM
              renderRange,
              // Duration object that denotes the first visible time of any given day
              slotMinTime: props.slotMinTime,
              // Duration object that denotes the exclusive visible end time of any given day
              slotMaxTime: props.slotMaxTime,
              isValid,
              // how far the current date will move for a prev/next operation
              dateIncrement: this.buildDateIncrement(currentInfo.duration),
              // pass a fallback (might be null) ^
          };
      }
      // Builds an object with optional start/end properties.
      // Indicates the minimum/maximum dates to display.
      // not responsible for trimming hidden days.
      buildValidRange() {
          let input = this.props.validRangeInput;
          let simpleInput = typeof input === 'function'
              ? input.call(this.props.calendarApi, this.nowDate)
              : input;
          return this.refineRange(simpleInput) ||
              { start: null, end: null }; // completely open-ended
      }
      // Builds a structure with info about the "current" range, the range that is
      // highlighted as being the current month for example.
      // See build() for a description of `direction`.
      // Guaranteed to have `range` and `unit` properties. `duration` is optional.
      buildCurrentRangeInfo(date, direction) {
          let { props } = this;
          let duration = null;
          let unit = null;
          let range = null;
          let dayCount;
          if (props.duration) {
              duration = props.duration;
              unit = props.durationUnit;
              range = this.buildRangeFromDuration(date, direction, duration, unit);
          }
          else if ((dayCount = this.props.dayCount)) {
              unit = 'day';
              range = this.buildRangeFromDayCount(date, direction, dayCount);
          }
          else if ((range = this.buildCustomVisibleRange(date))) {
              unit = props.dateEnv.greatestWholeUnit(range.start, range.end).unit;
          }
          else {
              duration = this.getFallbackDuration();
              unit = greatestDurationDenominator(duration).unit;
              range = this.buildRangeFromDuration(date, direction, duration, unit);
          }
          return { duration, unit, range };
      }
      getFallbackDuration() {
          return createDuration({ day: 1 });
      }
      // Returns a new activeRange to have time values (un-ambiguate)
      // slotMinTime or slotMaxTime causes the range to expand.
      adjustActiveRange(range) {
          let { dateEnv, usesMinMaxTime, slotMinTime, slotMaxTime } = this.props;
          let { start, end } = range;
          if (usesMinMaxTime) {
              // expand active range if slotMinTime is negative (why not when positive?)
              if (asRoughDays(slotMinTime) < 0) {
                  start = startOfDay(start); // necessary?
                  start = dateEnv.add(start, slotMinTime);
              }
              // expand active range if slotMaxTime is beyond one day (why not when negative?)
              if (asRoughDays(slotMaxTime) > 1) {
                  end = startOfDay(end); // necessary?
                  end = addDays(end, -1);
                  end = dateEnv.add(end, slotMaxTime);
              }
          }
          return { start, end };
      }
      // Builds the "current" range when it is specified as an explicit duration.
      // `unit` is the already-computed greatestDurationDenominator unit of duration.
      buildRangeFromDuration(date, direction, duration, unit) {
          let { dateEnv, dateAlignment } = this.props;
          let start;
          let end;
          let res;
          // compute what the alignment should be
          if (!dateAlignment) {
              let { dateIncrement } = this.props;
              if (dateIncrement) {
                  // use the smaller of the two units
                  if (asRoughMs(dateIncrement) < asRoughMs(duration)) {
                      dateAlignment = greatestDurationDenominator(dateIncrement).unit;
                  }
                  else {
                      dateAlignment = unit;
                  }
              }
              else {
                  dateAlignment = unit;
              }
          }
          // if the view displays a single day or smaller
          if (asRoughDays(duration) <= 1) {
              if (this.isHiddenDay(start)) {
                  start = this.skipHiddenDays(start, direction);
                  start = startOfDay(start);
              }
          }
          function computeRes() {
              start = dateEnv.startOf(date, dateAlignment);
              end = dateEnv.add(start, duration);
              res = { start, end };
          }
          computeRes();
          // if range is completely enveloped by hidden days, go past the hidden days
          if (!this.trimHiddenDays(res)) {
              date = this.skipHiddenDays(date, direction);
              computeRes();
          }
          return res;
      }
      // Builds the "current" range when a dayCount is specified.
      buildRangeFromDayCount(date, direction, dayCount) {
          let { dateEnv, dateAlignment } = this.props;
          let runningCount = 0;
          let start = date;
          let end;
          if (dateAlignment) {
              start = dateEnv.startOf(start, dateAlignment);
          }
          start = startOfDay(start);
          start = this.skipHiddenDays(start, direction);
          end = start;
          do {
              end = addDays(end, 1);
              if (!this.isHiddenDay(end)) {
                  runningCount += 1;
              }
          } while (runningCount < dayCount);
          return { start, end };
      }
      // Builds a normalized range object for the "visible" range,
      // which is a way to define the currentRange and activeRange at the same time.
      buildCustomVisibleRange(date) {
          let { props } = this;
          let input = props.visibleRangeInput;
          let simpleInput = typeof input === 'function'
              ? input.call(props.calendarApi, props.dateEnv.toDate(date))
              : input;
          let range = this.refineRange(simpleInput);
          if (range && (range.start == null || range.end == null)) {
              return null;
          }
          return range;
      }
      // Computes the range that will represent the element/cells for *rendering*,
      // but which may have voided days/times.
      // not responsible for trimming hidden days.
      buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay) {
          return currentRange;
      }
      // Compute the duration value that should be added/substracted to the current date
      // when a prev/next operation happens.
      buildDateIncrement(fallback) {
          let { dateIncrement } = this.props;
          let customAlignment;
          if (dateIncrement) {
              return dateIncrement;
          }
          if ((customAlignment = this.props.dateAlignment)) {
              return createDuration(1, customAlignment);
          }
          if (fallback) {
              return fallback;
          }
          return createDuration({ days: 1 });
      }
      refineRange(rangeInput) {
          if (rangeInput) {
              let range = parseRange(rangeInput, this.props.dateEnv);
              if (range) {
                  range = computeVisibleDayRange(range);
              }
              return range;
          }
          return null;
      }
      /* Hidden Days
      ------------------------------------------------------------------------------------------------------------------*/
      // Initializes internal variables related to calculating hidden days-of-week
      initHiddenDays() {
          let hiddenDays = this.props.hiddenDays || []; // array of day-of-week indices that are hidden
          let isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)
          let dayCnt = 0;
          let i;
          if (this.props.weekends === false) {
              hiddenDays.push(0, 6); // 0=sunday, 6=saturday
          }
          for (i = 0; i < 7; i += 1) {
              if (!(isHiddenDayHash[i] = hiddenDays.indexOf(i) !== -1)) {
                  dayCnt += 1;
              }
          }
          if (!dayCnt) {
              throw new Error('invalid hiddenDays'); // all days were hidden? bad.
          }
          this.isHiddenDayHash = isHiddenDayHash;
      }
      // Remove days from the beginning and end of the range that are computed as hidden.
      // If the whole range is trimmed off, returns null
      trimHiddenDays(range) {
          let { start, end } = range;
          if (start) {
              start = this.skipHiddenDays(start);
          }
          if (end) {
              end = this.skipHiddenDays(end, -1, true);
          }
          if (start == null || end == null || start < end) {
              return { start, end };
          }
          return null;
      }
      // Is the current day hidden?
      // `day` is a day-of-week index (0-6), or a Date (used for UTC)
      isHiddenDay(day) {
          if (day instanceof Date) {
              day = day.getUTCDay();
          }
          return this.isHiddenDayHash[day];
      }
      // Incrementing the current day until it is no longer a hidden day, returning a copy.
      // DOES NOT CONSIDER validRange!
      // If the initial value of `date` is not a hidden day, don't do anything.
      // Pass `isExclusive` as `true` if you are dealing with an end date.
      // `inc` defaults to `1` (increment one day forward each time)
      skipHiddenDays(date, inc = 1, isExclusive = false) {
          while (this.isHiddenDayHash[(date.getUTCDay() + (isExclusive ? inc : 0) + 7) % 7]) {
              date = addDays(date, inc);
          }
          return date;
      }
  }

  function triggerDateSelect(selection, pev, context) {
      context.emitter.trigger('select', Object.assign(Object.assign({}, buildDateSpanApiWithContext(selection, context)), { jsEvent: pev ? pev.origEvent : null, view: context.viewApi || context.calendarApi.view }));
  }
  function triggerDateUnselect(pev, context) {
      context.emitter.trigger('unselect', {
          jsEvent: pev ? pev.origEvent : null,
          view: context.viewApi || context.calendarApi.view,
      });
  }
  function buildDateSpanApiWithContext(dateSpan, context) {
      let props = {};
      for (let transform of context.pluginHooks.dateSpanTransforms) {
          Object.assign(props, transform(dateSpan, context));
      }
      Object.assign(props, buildDateSpanApi(dateSpan, context.dateEnv));
      return props;
  }
  // Given an event's allDay status and start date, return what its fallback end date should be.
  // TODO: rename to computeDefaultEventEnd
  function getDefaultEventEnd(allDay, marker, context) {
      let { dateEnv, options } = context;
      let end = marker;
      if (allDay) {
          end = startOfDay(end);
          end = dateEnv.add(end, options.defaultAllDayEventDuration);
      }
      else {
          end = dateEnv.add(end, options.defaultTimedEventDuration);
      }
      return end;
  }

  // applies the mutation to ALL defs/instances within the event store
  function applyMutationToEventStore(eventStore, eventConfigBase, mutation, context) {
      let eventConfigs = compileEventUis(eventStore.defs, eventConfigBase);
      let dest = createEmptyEventStore();
      for (let defId in eventStore.defs) {
          let def = eventStore.defs[defId];
          dest.defs[defId] = applyMutationToEventDef(def, eventConfigs[defId], mutation, context);
      }
      for (let instanceId in eventStore.instances) {
          let instance = eventStore.instances[instanceId];
          let def = dest.defs[instance.defId]; // important to grab the newly modified def
          dest.instances[instanceId] = applyMutationToEventInstance(instance, def, eventConfigs[instance.defId], mutation, context);
      }
      return dest;
  }
  function applyMutationToEventDef(eventDef, eventConfig, mutation, context) {
      let standardProps = mutation.standardProps || {};
      // if hasEnd has not been specified, guess a good value based on deltas.
      // if duration will change, there's no way the default duration will persist,
      // and thus, we need to mark the event as having a real end
      if (standardProps.hasEnd == null &&
          eventConfig.durationEditable &&
          (mutation.startDelta || mutation.endDelta)) {
          standardProps.hasEnd = true; // TODO: is this mutation okay?
      }
      let copy = Object.assign(Object.assign(Object.assign({}, eventDef), standardProps), { ui: Object.assign(Object.assign({}, eventDef.ui), standardProps.ui) });
      if (mutation.extendedProps) {
          copy.extendedProps = Object.assign(Object.assign({}, copy.extendedProps), mutation.extendedProps);
      }
      for (let applier of context.pluginHooks.eventDefMutationAppliers) {
          applier(copy, mutation, context);
      }
      if (!copy.hasEnd && context.options.forceEventDuration) {
          copy.hasEnd = true;
      }
      return copy;
  }
  function applyMutationToEventInstance(eventInstance, eventDef, // must first be modified by applyMutationToEventDef
  eventConfig, mutation, context) {
      let { dateEnv } = context;
      let forceAllDay = mutation.standardProps && mutation.standardProps.allDay === true;
      let clearEnd = mutation.standardProps && mutation.standardProps.hasEnd === false;
      let copy = Object.assign({}, eventInstance);
      if (forceAllDay) {
          copy.range = computeAlignedDayRange(copy.range);
      }
      if (mutation.datesDelta && eventConfig.startEditable) {
          copy.range = {
              start: dateEnv.add(copy.range.start, mutation.datesDelta),
              end: dateEnv.add(copy.range.end, mutation.datesDelta),
          };
      }
      if (mutation.startDelta && eventConfig.durationEditable) {
          copy.range = {
              start: dateEnv.add(copy.range.start, mutation.startDelta),
              end: copy.range.end,
          };
      }
      if (mutation.endDelta && eventConfig.durationEditable) {
          copy.range = {
              start: copy.range.start,
              end: dateEnv.add(copy.range.end, mutation.endDelta),
          };
      }
      if (clearEnd) {
          copy.range = {
              start: copy.range.start,
              end: getDefaultEventEnd(eventDef.allDay, copy.range.start, context),
          };
      }
      // in case event was all-day but the supplied deltas were not
      // better util for this?
      if (eventDef.allDay) {
          copy.range = {
              start: startOfDay(copy.range.start),
              end: startOfDay(copy.range.end),
          };
      }
      // handle invalid durations
      if (copy.range.end < copy.range.start) {
          copy.range.end = getDefaultEventEnd(eventDef.allDay, copy.range.start, context);
      }
      return copy;
  }

  class EventSourceImpl {
      constructor(context, internalEventSource) {
          this.context = context;
          this.internalEventSource = internalEventSource;
      }
      remove() {
          this.context.dispatch({
              type: 'REMOVE_EVENT_SOURCE',
              sourceId: this.internalEventSource.sourceId,
          });
      }
      refetch() {
          this.context.dispatch({
              type: 'FETCH_EVENT_SOURCES',
              sourceIds: [this.internalEventSource.sourceId],
              isRefetch: true,
          });
      }
      get id() {
          return this.internalEventSource.publicId;
      }
      get url() {
          return this.internalEventSource.meta.url;
      }
      get format() {
          return this.internalEventSource.meta.format; // TODO: bad. not guaranteed
      }
  }

  class EventImpl {
      // instance will be null if expressing a recurring event that has no current instances,
      // OR if trying to validate an incoming external event that has no dates assigned
      constructor(context, def, instance) {
          this._context = context;
          this._def = def;
          this._instance = instance || null;
      }
      /*
      TODO: make event struct more responsible for this
      */
      setProp(name, val) {
          if (name in EVENT_DATE_REFINERS) {
              console.warn('Could not set date-related prop \'name\'. Use one of the date-related methods instead.');
              // TODO: make proper aliasing system?
          }
          else if (name === 'id') {
              val = EVENT_NON_DATE_REFINERS[name](val);
              this.mutate({
                  standardProps: { publicId: val }, // hardcoded internal name
              });
          }
          else if (name in EVENT_NON_DATE_REFINERS) {
              val = EVENT_NON_DATE_REFINERS[name](val);
              this.mutate({
                  standardProps: { [name]: val },
              });
          }
          else if (name in EVENT_UI_REFINERS) {
              let ui = EVENT_UI_REFINERS[name](val);
              if (name === 'color') {
                  ui = { backgroundColor: val, borderColor: val };
              }
              else if (name === 'editable') {
                  ui = { startEditable: val, durationEditable: val };
              }
              else {
                  ui = { [name]: val };
              }
              this.mutate({
                  standardProps: { ui },
              });
          }
          else {
              console.warn(`Could not set prop '${name}'. Use setExtendedProp instead.`);
          }
      }
      setExtendedProp(name, val) {
          this.mutate({
              extendedProps: { [name]: val },
          });
      }
      setStart(startInput, options = {}) {
          let { dateEnv } = this._context;
          let start = dateEnv.createMarker(startInput);
          if (start && this._instance) { // TODO: warning if parsed bad
              let instanceRange = this._instance.range;
              let startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity); // what if parsed bad!?
              if (options.maintainDuration) {
                  this.mutate({ datesDelta: startDelta });
              }
              else {
                  this.mutate({ startDelta });
              }
          }
      }
      setEnd(endInput, options = {}) {
          let { dateEnv } = this._context;
          let end;
          if (endInput != null) {
              end = dateEnv.createMarker(endInput);
              if (!end) {
                  return; // TODO: warning if parsed bad
              }
          }
          if (this._instance) {
              if (end) {
                  let endDelta = diffDates(this._instance.range.end, end, dateEnv, options.granularity);
                  this.mutate({ endDelta });
              }
              else {
                  this.mutate({ standardProps: { hasEnd: false } });
              }
          }
      }
      setDates(startInput, endInput, options = {}) {
          let { dateEnv } = this._context;
          let standardProps = { allDay: options.allDay };
          let start = dateEnv.createMarker(startInput);
          let end;
          if (!start) {
              return; // TODO: warning if parsed bad
          }
          if (endInput != null) {
              end = dateEnv.createMarker(endInput);
              if (!end) { // TODO: warning if parsed bad
                  return;
              }
          }
          if (this._instance) {
              let instanceRange = this._instance.range;
              // when computing the diff for an event being converted to all-day,
              // compute diff off of the all-day values the way event-mutation does.
              if (options.allDay === true) {
                  instanceRange = computeAlignedDayRange(instanceRange);
              }
              let startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity);
              if (end) {
                  let endDelta = diffDates(instanceRange.end, end, dateEnv, options.granularity);
                  if (durationsEqual(startDelta, endDelta)) {
                      this.mutate({ datesDelta: startDelta, standardProps });
                  }
                  else {
                      this.mutate({ startDelta, endDelta, standardProps });
                  }
              }
              else { // means "clear the end"
                  standardProps.hasEnd = false;
                  this.mutate({ datesDelta: startDelta, standardProps });
              }
          }
      }
      moveStart(deltaInput) {
          let delta = createDuration(deltaInput);
          if (delta) { // TODO: warning if parsed bad
              this.mutate({ startDelta: delta });
          }
      }
      moveEnd(deltaInput) {
          let delta = createDuration(deltaInput);
          if (delta) { // TODO: warning if parsed bad
              this.mutate({ endDelta: delta });
          }
      }
      moveDates(deltaInput) {
          let delta = createDuration(deltaInput);
          if (delta) { // TODO: warning if parsed bad
              this.mutate({ datesDelta: delta });
          }
      }
      setAllDay(allDay, options = {}) {
          let standardProps = { allDay };
          let { maintainDuration } = options;
          if (maintainDuration == null) {
              maintainDuration = this._context.options.allDayMaintainDuration;
          }
          if (this._def.allDay !== allDay) {
              standardProps.hasEnd = maintainDuration;
          }
          this.mutate({ standardProps });
      }
      formatRange(formatInput) {
          let { dateEnv } = this._context;
          let instance = this._instance;
          let formatter = createFormatter(formatInput);
          if (this._def.hasEnd) {
              return dateEnv.formatRange(instance.range.start, instance.range.end, formatter, {
                  forcedStartTzo: instance.forcedStartTzo,
                  forcedEndTzo: instance.forcedEndTzo,
              });
          }
          return dateEnv.format(instance.range.start, formatter, {
              forcedTzo: instance.forcedStartTzo,
          });
      }
      mutate(mutation) {
          let instance = this._instance;
          if (instance) {
              let def = this._def;
              let context = this._context;
              let { eventStore } = context.getCurrentData();
              let relevantEvents = getRelevantEvents(eventStore, instance.instanceId);
              let eventConfigBase = {
                  '': {
                      display: '',
                      startEditable: true,
                      durationEditable: true,
                      constraints: [],
                      overlap: null,
                      allows: [],
                      backgroundColor: '',
                      borderColor: '',
                      textColor: '',
                      classNames: [],
                  },
              };
              relevantEvents = applyMutationToEventStore(relevantEvents, eventConfigBase, mutation, context);
              let oldEvent = new EventImpl(context, def, instance); // snapshot
              this._def = relevantEvents.defs[def.defId];
              this._instance = relevantEvents.instances[instance.instanceId];
              context.dispatch({
                  type: 'MERGE_EVENTS',
                  eventStore: relevantEvents,
              });
              context.emitter.trigger('eventChange', {
                  oldEvent,
                  event: this,
                  relatedEvents: buildEventApis(relevantEvents, context, instance),
                  revert() {
                      context.dispatch({
                          type: 'RESET_EVENTS',
                          eventStore, // the ORIGINAL store
                      });
                  },
              });
          }
      }
      remove() {
          let context = this._context;
          let asStore = eventApiToStore(this);
          context.dispatch({
              type: 'REMOVE_EVENTS',
              eventStore: asStore,
          });
          context.emitter.trigger('eventRemove', {
              event: this,
              relatedEvents: [],
              revert() {
                  context.dispatch({
                      type: 'MERGE_EVENTS',
                      eventStore: asStore,
                  });
              },
          });
      }
      get source() {
          let { sourceId } = this._def;
          if (sourceId) {
              return new EventSourceImpl(this._context, this._context.getCurrentData().eventSources[sourceId]);
          }
          return null;
      }
      get start() {
          return this._instance ?
              this._context.dateEnv.toDate(this._instance.range.start) :
              null;
      }
      get end() {
          return (this._instance && this._def.hasEnd) ?
              this._context.dateEnv.toDate(this._instance.range.end) :
              null;
      }
      get startStr() {
          let instance = this._instance;
          if (instance) {
              return this._context.dateEnv.formatIso(instance.range.start, {
                  omitTime: this._def.allDay,
                  forcedTzo: instance.forcedStartTzo,
              });
          }
          return '';
      }
      get endStr() {
          let instance = this._instance;
          if (instance && this._def.hasEnd) {
              return this._context.dateEnv.formatIso(instance.range.end, {
                  omitTime: this._def.allDay,
                  forcedTzo: instance.forcedEndTzo,
              });
          }
          return '';
      }
      // computable props that all access the def
      // TODO: find a TypeScript-compatible way to do this at scale
      get id() { return this._def.publicId; }
      get groupId() { return this._def.groupId; }
      get allDay() { return this._def.allDay; }
      get title() { return this._def.title; }
      get url() { return this._def.url; }
      get display() { return this._def.ui.display || 'auto'; } // bad. just normalize the type earlier
      get startEditable() { return this._def.ui.startEditable; }
      get durationEditable() { return this._def.ui.durationEditable; }
      get constraint() { return this._def.ui.constraints[0] || null; }
      get overlap() { return this._def.ui.overlap; }
      get allow() { return this._def.ui.allows[0] || null; }
      get backgroundColor() { return this._def.ui.backgroundColor; }
      get borderColor() { return this._def.ui.borderColor; }
      get textColor() { return this._def.ui.textColor; }
      // NOTE: user can't modify these because Object.freeze was called in event-def parsing
      get classNames() { return this._def.ui.classNames; }
      get extendedProps() { return this._def.extendedProps; }
      toPlainObject(settings = {}) {
          let def = this._def;
          let { ui } = def;
          let { startStr, endStr } = this;
          let res = {
              allDay: def.allDay,
          };
          if (def.title) {
              res.title = def.title;
          }
          if (startStr) {
              res.start = startStr;
          }
          if (endStr) {
              res.end = endStr;
          }
          if (def.publicId) {
              res.id = def.publicId;
          }
          if (def.groupId) {
              res.groupId = def.groupId;
          }
          if (def.url) {
              res.url = def.url;
          }
          if (ui.display && ui.display !== 'auto') {
              res.display = ui.display;
          }
          // TODO: what about recurring-event properties???
          // TODO: include startEditable/durationEditable/constraint/overlap/allow
          if (settings.collapseColor && ui.backgroundColor && ui.backgroundColor === ui.borderColor) {
              res.color = ui.backgroundColor;
          }
          else {
              if (ui.backgroundColor) {
                  res.backgroundColor = ui.backgroundColor;
              }
              if (ui.borderColor) {
                  res.borderColor = ui.borderColor;
              }
          }
          if (ui.textColor) {
              res.textColor = ui.textColor;
          }
          if (ui.classNames.length) {
              res.classNames = ui.classNames;
          }
          if (Object.keys(def.extendedProps).length) {
              if (settings.collapseExtendedProps) {
                  Object.assign(res, def.extendedProps);
              }
              else {
                  res.extendedProps = def.extendedProps;
              }
          }
          return res;
      }
      toJSON() {
          return this.toPlainObject();
      }
  }
  function eventApiToStore(eventApi) {
      let def = eventApi._def;
      let instance = eventApi._instance;
      return {
          defs: { [def.defId]: def },
          instances: instance
              ? { [instance.instanceId]: instance }
              : {},
      };
  }
  function buildEventApis(eventStore, context, excludeInstance) {
      let { defs, instances } = eventStore;
      let eventApis = [];
      let excludeInstanceId = excludeInstance ? excludeInstance.instanceId : '';
      for (let id in instances) {
          let instance = instances[id];
          let def = defs[instance.defId];
          if (instance.instanceId !== excludeInstanceId) {
              eventApis.push(new EventImpl(context, def, instance));
          }
      }
      return eventApis;
  }

  /*
  Specifying nextDayThreshold signals that all-day ranges should be sliced.
  */
  function sliceEventStore(eventStore, eventUiBases, framingRange, nextDayThreshold) {
      let inverseBgByGroupId = {};
      let inverseBgByDefId = {};
      let defByGroupId = {};
      let bgRanges = [];
      let fgRanges = [];
      let eventUis = compileEventUis(eventStore.defs, eventUiBases);
      for (let defId in eventStore.defs) {
          let def = eventStore.defs[defId];
          let ui = eventUis[def.defId];
          if (ui.display === 'inverse-background') {
              if (def.groupId) {
                  inverseBgByGroupId[def.groupId] = [];
                  if (!defByGroupId[def.groupId]) {
                      defByGroupId[def.groupId] = def;
                  }
              }
              else {
                  inverseBgByDefId[defId] = [];
              }
          }
      }
      for (let instanceId in eventStore.instances) {
          let instance = eventStore.instances[instanceId];
          let def = eventStore.defs[instance.defId];
          let ui = eventUis[def.defId];
          let origRange = instance.range;
          let normalRange = (!def.allDay && nextDayThreshold) ?
              computeVisibleDayRange(origRange, nextDayThreshold) :
              origRange;
          let slicedRange = intersectRanges(normalRange, framingRange);
          if (slicedRange) {
              if (ui.display === 'inverse-background') {
                  if (def.groupId) {
                      inverseBgByGroupId[def.groupId].push(slicedRange);
                  }
                  else {
                      inverseBgByDefId[instance.defId].push(slicedRange);
                  }
              }
              else if (ui.display !== 'none') {
                  (ui.display === 'background' ? bgRanges : fgRanges).push({
                      def,
                      ui,
                      instance,
                      range: slicedRange,
                      isStart: normalRange.start && normalRange.start.valueOf() === slicedRange.start.valueOf(),
                      isEnd: normalRange.end && normalRange.end.valueOf() === slicedRange.end.valueOf(),
                  });
              }
          }
      }
      for (let groupId in inverseBgByGroupId) { // BY GROUP
          let ranges = inverseBgByGroupId[groupId];
          let invertedRanges = invertRanges(ranges, framingRange);
          for (let invertedRange of invertedRanges) {
              let def = defByGroupId[groupId];
              let ui = eventUis[def.defId];
              bgRanges.push({
                  def,
                  ui,
                  instance: null,
                  range: invertedRange,
                  isStart: false,
                  isEnd: false,
              });
          }
      }
      for (let defId in inverseBgByDefId) {
          let ranges = inverseBgByDefId[defId];
          let invertedRanges = invertRanges(ranges, framingRange);
          for (let invertedRange of invertedRanges) {
              bgRanges.push({
                  def: eventStore.defs[defId],
                  ui: eventUis[defId],
                  instance: null,
                  range: invertedRange,
                  isStart: false,
                  isEnd: false,
              });
          }
      }
      return { bg: bgRanges, fg: fgRanges };
  }
  function hasBgRendering(def) {
      return def.ui.display === 'background' || def.ui.display === 'inverse-background';
  }
  function setElSeg(el, seg) {
      el.fcSeg = seg;
  }
  function getElSeg(el) {
      return el.fcSeg ||
          el.parentNode.fcSeg || // for the harness
          null;
  }
  // event ui computation
  function compileEventUis(eventDefs, eventUiBases) {
      return mapHash(eventDefs, (eventDef) => compileEventUi(eventDef, eventUiBases));
  }
  function compileEventUi(eventDef, eventUiBases) {
      let uis = [];
      if (eventUiBases['']) {
          uis.push(eventUiBases['']);
      }
      if (eventUiBases[eventDef.defId]) {
          uis.push(eventUiBases[eventDef.defId]);
      }
      uis.push(eventDef.ui);
      return combineEventUis(uis);
  }
  function sortEventSegs(segs, eventOrderSpecs) {
      let objs = segs.map(buildSegCompareObj);
      objs.sort((obj0, obj1) => compareByFieldSpecs(obj0, obj1, eventOrderSpecs));
      return objs.map((c) => c._seg);
  }
  // returns a object with all primitive props that can be compared
  function buildSegCompareObj(seg) {
      let { eventRange } = seg;
      let eventDef = eventRange.def;
      let range = eventRange.instance ? eventRange.instance.range : eventRange.range;
      let start = range.start ? range.start.valueOf() : 0; // TODO: better support for open-range events
      let end = range.end ? range.end.valueOf() : 0; // "
      return Object.assign(Object.assign(Object.assign({}, eventDef.extendedProps), eventDef), { id: eventDef.publicId, start,
          end, duration: end - start, allDay: Number(eventDef.allDay), _seg: seg });
  }
  function computeSegDraggable(seg, context) {
      let { pluginHooks } = context;
      let transformers = pluginHooks.isDraggableTransformers;
      let { def, ui } = seg.eventRange;
      let val = ui.startEditable;
      for (let transformer of transformers) {
          val = transformer(val, def, ui, context);
      }
      return val;
  }
  function computeSegStartResizable(seg, context) {
      return seg.isStart && seg.eventRange.ui.durationEditable && context.options.eventResizableFromStart;
  }
  function computeSegEndResizable(seg, context) {
      return seg.isEnd && seg.eventRange.ui.durationEditable;
  }
  function buildSegTimeText(seg, timeFormat, context, defaultDisplayEventTime, // defaults to true
  defaultDisplayEventEnd, // defaults to true
  startOverride, endOverride) {
      let { dateEnv, options } = context;
      let { displayEventTime, displayEventEnd } = options;
      let eventDef = seg.eventRange.def;
      let eventInstance = seg.eventRange.instance;
      if (displayEventTime == null) {
          displayEventTime = defaultDisplayEventTime !== false;
      }
      if (displayEventEnd == null) {
          displayEventEnd = defaultDisplayEventEnd !== false;
      }
      let wholeEventStart = eventInstance.range.start;
      let wholeEventEnd = eventInstance.range.end;
      let segStart = startOverride || seg.start || seg.eventRange.range.start;
      let segEnd = endOverride || seg.end || seg.eventRange.range.end;
      let isStartDay = startOfDay(wholeEventStart).valueOf() === startOfDay(segStart).valueOf();
      let isEndDay = startOfDay(addMs(wholeEventEnd, -1)).valueOf() === startOfDay(addMs(segEnd, -1)).valueOf();
      if (displayEventTime && !eventDef.allDay && (isStartDay || isEndDay)) {
          segStart = isStartDay ? wholeEventStart : segStart;
          segEnd = isEndDay ? wholeEventEnd : segEnd;
          if (displayEventEnd && eventDef.hasEnd) {
              return dateEnv.formatRange(segStart, segEnd, timeFormat, {
                  forcedStartTzo: startOverride ? null : eventInstance.forcedStartTzo,
                  forcedEndTzo: endOverride ? null : eventInstance.forcedEndTzo,
              });
          }
          return dateEnv.format(segStart, timeFormat, {
              forcedTzo: startOverride ? null : eventInstance.forcedStartTzo, // nooooo, same
          });
      }
      return '';
  }
  function getSegMeta(seg, todayRange, nowDate) {
      let segRange = seg.eventRange.range;
      return {
          isPast: segRange.end < (nowDate || todayRange.start),
          isFuture: segRange.start >= (nowDate || todayRange.end),
          isToday: todayRange && rangeContainsMarker(todayRange, segRange.start),
      };
  }
  function getEventClassNames(props) {
      let classNames = ['fc-event'];
      if (props.isMirror) {
          classNames.push('fc-event-mirror');
      }
      if (props.isDraggable) {
          classNames.push('fc-event-draggable');
      }
      if (props.isStartResizable || props.isEndResizable) {
          classNames.push('fc-event-resizable');
      }
      if (props.isDragging) {
          classNames.push('fc-event-dragging');
      }
      if (props.isResizing) {
          classNames.push('fc-event-resizing');
      }
      if (props.isSelected) {
          classNames.push('fc-event-selected');
      }
      if (props.isStart) {
          classNames.push('fc-event-start');
      }
      if (props.isEnd) {
          classNames.push('fc-event-end');
      }
      if (props.isPast) {
          classNames.push('fc-event-past');
      }
      if (props.isToday) {
          classNames.push('fc-event-today');
      }
      if (props.isFuture) {
          classNames.push('fc-event-future');
      }
      return classNames;
  }
  function buildEventRangeKey(eventRange) {
      return eventRange.instance
          ? eventRange.instance.instanceId
          : `${eventRange.def.defId}:${eventRange.range.start.toISOString()}`;
      // inverse-background events don't have specific instances. TODO: better solution
  }
  function getSegAnchorAttrs(seg, context) {
      let { def, instance } = seg.eventRange;
      let { url } = def;
      if (url) {
          return { href: url };
      }
      let { emitter, options } = context;
      let { eventInteractive } = options;
      if (eventInteractive == null) {
          eventInteractive = def.interactive;
          if (eventInteractive == null) {
              eventInteractive = Boolean(emitter.hasHandlers('eventClick'));
          }
      }
      // mock what happens in EventClicking
      if (eventInteractive) {
          // only attach keyboard-related handlers because click handler is already done in EventClicking
          return createAriaKeyboardAttrs((ev) => {
              emitter.trigger('eventClick', {
                  el: ev.target,
                  event: new EventImpl(context, def, instance),
                  jsEvent: ev,
                  view: context.viewApi,
              });
          });
      }
      return {};
  }

  const STANDARD_PROPS = {
      start: identity,
      end: identity,
      allDay: Boolean,
  };
  function parseDateSpan(raw, dateEnv, defaultDuration) {
      let span = parseOpenDateSpan(raw, dateEnv);
      let { range } = span;
      if (!range.start) {
          return null;
      }
      if (!range.end) {
          if (defaultDuration == null) {
              return null;
          }
          range.end = dateEnv.add(range.start, defaultDuration);
      }
      return span;
  }
  /*
  TODO: somehow combine with parseRange?
  Will return null if the start/end props were present but parsed invalidly.
  */
  function parseOpenDateSpan(raw, dateEnv) {
      let { refined: standardProps, extra } = refineProps(raw, STANDARD_PROPS);
      let startMeta = standardProps.start ? dateEnv.createMarkerMeta(standardProps.start) : null;
      let endMeta = standardProps.end ? dateEnv.createMarkerMeta(standardProps.end) : null;
      let { allDay } = standardProps;
      if (allDay == null) {
          allDay = (startMeta && startMeta.isTimeUnspecified) &&
              (!endMeta || endMeta.isTimeUnspecified);
      }
      return Object.assign({ range: {
              start: startMeta ? startMeta.marker : null,
              end: endMeta ? endMeta.marker : null,
          }, allDay }, extra);
  }
  function isDateSpansEqual(span0, span1) {
      return rangesEqual(span0.range, span1.range) &&
          span0.allDay === span1.allDay &&
          isSpanPropsEqual(span0, span1);
  }
  // the NON-DATE-RELATED props
  function isSpanPropsEqual(span0, span1) {
      for (let propName in span1) {
          if (propName !== 'range' && propName !== 'allDay') {
              if (span0[propName] !== span1[propName]) {
                  return false;
              }
          }
      }
      // are there any props that span0 has that span1 DOESN'T have?
      // both have range/allDay, so no need to special-case.
      for (let propName in span0) {
          if (!(propName in span1)) {
              return false;
          }
      }
      return true;
  }
  function buildDateSpanApi(span, dateEnv) {
      return Object.assign(Object.assign({}, buildRangeApi(span.range, dateEnv, span.allDay)), { allDay: span.allDay });
  }
  function buildRangeApiWithTimeZone(range, dateEnv, omitTime) {
      return Object.assign(Object.assign({}, buildRangeApi(range, dateEnv, omitTime)), { timeZone: dateEnv.timeZone });
  }
  function buildRangeApi(range, dateEnv, omitTime) {
      return {
          start: dateEnv.toDate(range.start),
          end: dateEnv.toDate(range.end),
          startStr: dateEnv.formatIso(range.start, { omitTime }),
          endStr: dateEnv.formatIso(range.end, { omitTime }),
      };
  }
  function fabricateEventRange(dateSpan, eventUiBases, context) {
      let res = refineEventDef({ editable: false }, context);
      let def = parseEventDef(res.refined, res.extra, '', // sourceId
      dateSpan.allDay, true, // hasEnd
      context);
      return {
          def,
          ui: compileEventUi(def, eventUiBases),
          instance: createEventInstance(def.defId, dateSpan.range),
          range: dateSpan.range,
          isStart: true,
          isEnd: true,
      };
  }

  let calendarSystemClassMap = {};
  function registerCalendarSystem(name, theClass) {
      calendarSystemClassMap[name] = theClass;
  }
  function createCalendarSystem(name) {
      return new calendarSystemClassMap[name]();
  }
  class GregorianCalendarSystem {
      getMarkerYear(d) {
          return d.getUTCFullYear();
      }
      getMarkerMonth(d) {
          return d.getUTCMonth();
      }
      getMarkerDay(d) {
          return d.getUTCDate();
      }
      arrayToMarker(arr) {
          return arrayToUtcDate(arr);
      }
      markerToArray(marker) {
          return dateToUtcArray(marker);
      }
  }
  registerCalendarSystem('gregory', GregorianCalendarSystem);

  const ISO_RE = /^\s*(\d{4})(-?(\d{2})(-?(\d{2})([T ](\d{2}):?(\d{2})(:?(\d{2})(\.(\d+))?)?(Z|(([-+])(\d{2})(:?(\d{2}))?))?)?)?)?$/;
  function parse$3(str) {
      let m = ISO_RE.exec(str);
      if (m) {
          let marker = new Date(Date.UTC(Number(m[1]), m[3] ? Number(m[3]) - 1 : 0, Number(m[5] || 1), Number(m[7] || 0), Number(m[8] || 0), Number(m[10] || 0), m[12] ? Number(`0.${m[12]}`) * 1000 : 0));
          if (isValidDate(marker)) {
              let timeZoneOffset = null;
              if (m[13]) {
                  timeZoneOffset = (m[15] === '-' ? -1 : 1) * (Number(m[16] || 0) * 60 +
                      Number(m[18] || 0));
              }
              return {
                  marker,
                  isTimeUnspecified: !m[6],
                  timeZoneOffset,
              };
          }
      }
      return null;
  }

  class DateEnv {
      constructor(settings) {
          let timeZone = this.timeZone = settings.timeZone;
          let isNamedTimeZone = timeZone !== 'local' && timeZone !== 'UTC';
          if (settings.namedTimeZoneImpl && isNamedTimeZone) {
              this.namedTimeZoneImpl = new settings.namedTimeZoneImpl(timeZone);
          }
          this.canComputeOffset = Boolean(!isNamedTimeZone || this.namedTimeZoneImpl);
          this.calendarSystem = createCalendarSystem(settings.calendarSystem);
          this.locale = settings.locale;
          this.weekDow = settings.locale.week.dow;
          this.weekDoy = settings.locale.week.doy;
          if (settings.weekNumberCalculation === 'ISO') {
              this.weekDow = 1;
              this.weekDoy = 4;
          }
          if (typeof settings.firstDay === 'number') {
              this.weekDow = settings.firstDay;
          }
          if (typeof settings.weekNumberCalculation === 'function') {
              this.weekNumberFunc = settings.weekNumberCalculation;
          }
          this.weekText = settings.weekText != null ? settings.weekText : settings.locale.options.weekText;
          this.weekTextLong = (settings.weekTextLong != null ? settings.weekTextLong : settings.locale.options.weekTextLong) || this.weekText;
          this.cmdFormatter = settings.cmdFormatter;
          this.defaultSeparator = settings.defaultSeparator;
      }
      // Creating / Parsing
      createMarker(input) {
          let meta = this.createMarkerMeta(input);
          if (meta === null) {
              return null;
          }
          return meta.marker;
      }
      createNowMarker() {
          if (this.canComputeOffset) {
              return this.timestampToMarker(new Date().valueOf());
          }
          // if we can't compute the current date val for a timezone,
          // better to give the current local date vals than UTC
          return arrayToUtcDate(dateToLocalArray(new Date()));
      }
      createMarkerMeta(input) {
          if (typeof input === 'string') {
              return this.parse(input);
          }
          let marker = null;
          if (typeof input === 'number') {
              marker = this.timestampToMarker(input);
          }
          else if (input instanceof Date) {
              input = input.valueOf();
              if (!isNaN(input)) {
                  marker = this.timestampToMarker(input);
              }
          }
          else if (Array.isArray(input)) {
              marker = arrayToUtcDate(input);
          }
          if (marker === null || !isValidDate(marker)) {
              return null;
          }
          return { marker, isTimeUnspecified: false, forcedTzo: null };
      }
      parse(s) {
          let parts = parse$3(s);
          if (parts === null) {
              return null;
          }
          let { marker } = parts;
          let forcedTzo = null;
          if (parts.timeZoneOffset !== null) {
              if (this.canComputeOffset) {
                  marker = this.timestampToMarker(marker.valueOf() - parts.timeZoneOffset * 60 * 1000);
              }
              else {
                  forcedTzo = parts.timeZoneOffset;
              }
          }
          return { marker, isTimeUnspecified: parts.isTimeUnspecified, forcedTzo };
      }
      // Accessors
      getYear(marker) {
          return this.calendarSystem.getMarkerYear(marker);
      }
      getMonth(marker) {
          return this.calendarSystem.getMarkerMonth(marker);
      }
      getDay(marker) {
          return this.calendarSystem.getMarkerDay(marker);
      }
      // Adding / Subtracting
      add(marker, dur) {
          let a = this.calendarSystem.markerToArray(marker);
          a[0] += dur.years;
          a[1] += dur.months;
          a[2] += dur.days;
          a[6] += dur.milliseconds;
          return this.calendarSystem.arrayToMarker(a);
      }
      subtract(marker, dur) {
          let a = this.calendarSystem.markerToArray(marker);
          a[0] -= dur.years;
          a[1] -= dur.months;
          a[2] -= dur.days;
          a[6] -= dur.milliseconds;
          return this.calendarSystem.arrayToMarker(a);
      }
      addYears(marker, n) {
          let a = this.calendarSystem.markerToArray(marker);
          a[0] += n;
          return this.calendarSystem.arrayToMarker(a);
      }
      addMonths(marker, n) {
          let a = this.calendarSystem.markerToArray(marker);
          a[1] += n;
          return this.calendarSystem.arrayToMarker(a);
      }
      // Diffing Whole Units
      diffWholeYears(m0, m1) {
          let { calendarSystem } = this;
          if (timeAsMs(m0) === timeAsMs(m1) &&
              calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1) &&
              calendarSystem.getMarkerMonth(m0) === calendarSystem.getMarkerMonth(m1)) {
              return calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0);
          }
          return null;
      }
      diffWholeMonths(m0, m1) {
          let { calendarSystem } = this;
          if (timeAsMs(m0) === timeAsMs(m1) &&
              calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1)) {
              return (calendarSystem.getMarkerMonth(m1) - calendarSystem.getMarkerMonth(m0)) +
                  (calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0)) * 12;
          }
          return null;
      }
      // Range / Duration
      greatestWholeUnit(m0, m1) {
          let n = this.diffWholeYears(m0, m1);
          if (n !== null) {
              return { unit: 'year', value: n };
          }
          n = this.diffWholeMonths(m0, m1);
          if (n !== null) {
              return { unit: 'month', value: n };
          }
          n = diffWholeWeeks(m0, m1);
          if (n !== null) {
              return { unit: 'week', value: n };
          }
          n = diffWholeDays(m0, m1);
          if (n !== null) {
              return { unit: 'day', value: n };
          }
          n = diffHours(m0, m1);
          if (isInt(n)) {
              return { unit: 'hour', value: n };
          }
          n = diffMinutes(m0, m1);
          if (isInt(n)) {
              return { unit: 'minute', value: n };
          }
          n = diffSeconds(m0, m1);
          if (isInt(n)) {
              return { unit: 'second', value: n };
          }
          return { unit: 'millisecond', value: m1.valueOf() - m0.valueOf() };
      }
      countDurationsBetween(m0, m1, d) {
          // TODO: can use greatestWholeUnit
          let diff;
          if (d.years) {
              diff = this.diffWholeYears(m0, m1);
              if (diff !== null) {
                  return diff / asRoughYears(d);
              }
          }
          if (d.months) {
              diff = this.diffWholeMonths(m0, m1);
              if (diff !== null) {
                  return diff / asRoughMonths(d);
              }
          }
          if (d.days) {
              diff = diffWholeDays(m0, m1);
              if (diff !== null) {
                  return diff / asRoughDays(d);
              }
          }
          return (m1.valueOf() - m0.valueOf()) / asRoughMs(d);
      }
      // Start-Of
      // these DON'T return zoned-dates. only UTC start-of dates
      startOf(m, unit) {
          if (unit === 'year') {
              return this.startOfYear(m);
          }
          if (unit === 'month') {
              return this.startOfMonth(m);
          }
          if (unit === 'week') {
              return this.startOfWeek(m);
          }
          if (unit === 'day') {
              return startOfDay(m);
          }
          if (unit === 'hour') {
              return startOfHour(m);
          }
          if (unit === 'minute') {
              return startOfMinute(m);
          }
          if (unit === 'second') {
              return startOfSecond(m);
          }
          return null;
      }
      startOfYear(m) {
          return this.calendarSystem.arrayToMarker([
              this.calendarSystem.getMarkerYear(m),
          ]);
      }
      startOfMonth(m) {
          return this.calendarSystem.arrayToMarker([
              this.calendarSystem.getMarkerYear(m),
              this.calendarSystem.getMarkerMonth(m),
          ]);
      }
      startOfWeek(m) {
          return this.calendarSystem.arrayToMarker([
              this.calendarSystem.getMarkerYear(m),
              this.calendarSystem.getMarkerMonth(m),
              m.getUTCDate() - ((m.getUTCDay() - this.weekDow + 7) % 7),
          ]);
      }
      // Week Number
      computeWeekNumber(marker) {
          if (this.weekNumberFunc) {
              return this.weekNumberFunc(this.toDate(marker));
          }
          return weekOfYear(marker, this.weekDow, this.weekDoy);
      }
      // TODO: choke on timeZoneName: long
      format(marker, formatter, dateOptions = {}) {
          return formatter.format({
              marker,
              timeZoneOffset: dateOptions.forcedTzo != null ?
                  dateOptions.forcedTzo :
                  this.offsetForMarker(marker),
          }, this);
      }
      formatRange(start, end, formatter, dateOptions = {}) {
          if (dateOptions.isEndExclusive) {
              end = addMs(end, -1);
          }
          return formatter.formatRange({
              marker: start,
              timeZoneOffset: dateOptions.forcedStartTzo != null ?
                  dateOptions.forcedStartTzo :
                  this.offsetForMarker(start),
          }, {
              marker: end,
              timeZoneOffset: dateOptions.forcedEndTzo != null ?
                  dateOptions.forcedEndTzo :
                  this.offsetForMarker(end),
          }, this, dateOptions.defaultSeparator);
      }
      /*
      DUMB: the omitTime arg is dumb. if we omit the time, we want to omit the timezone offset. and if we do that,
      might as well use buildIsoString or some other util directly
      */
      formatIso(marker, extraOptions = {}) {
          let timeZoneOffset = null;
          if (!extraOptions.omitTimeZoneOffset) {
              if (extraOptions.forcedTzo != null) {
                  timeZoneOffset = extraOptions.forcedTzo;
              }
              else {
                  timeZoneOffset = this.offsetForMarker(marker);
              }
          }
          return buildIsoString(marker, timeZoneOffset, extraOptions.omitTime);
      }
      // TimeZone
      timestampToMarker(ms) {
          if (this.timeZone === 'local') {
              return arrayToUtcDate(dateToLocalArray(new Date(ms)));
          }
          if (this.timeZone === 'UTC' || !this.namedTimeZoneImpl) {
              return new Date(ms);
          }
          return arrayToUtcDate(this.namedTimeZoneImpl.timestampToArray(ms));
      }
      offsetForMarker(m) {
          if (this.timeZone === 'local') {
              return -arrayToLocalDate(dateToUtcArray(m)).getTimezoneOffset(); // convert "inverse" offset to "normal" offset
          }
          if (this.timeZone === 'UTC') {
              return 0;
          }
          if (this.namedTimeZoneImpl) {
              return this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m));
          }
          return null;
      }
      // Conversion
      toDate(m, forcedTzo) {
          if (this.timeZone === 'local') {
              return arrayToLocalDate(dateToUtcArray(m));
          }
          if (this.timeZone === 'UTC') {
              return new Date(m.valueOf()); // make sure it's a copy
          }
          if (!this.namedTimeZoneImpl) {
              return new Date(m.valueOf() - (forcedTzo || 0));
          }
          return new Date(m.valueOf() -
              this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m)) * 1000 * 60);
      }
  }

  class NamedTimeZoneImpl {
      constructor(timeZoneName) {
          this.timeZoneName = timeZoneName;
      }
  }

  class SegHierarchy {
      constructor(getEntryThickness = (entry) => {
          // should return an integer
          return entry.thickness;
      }) {
          this.getEntryThickness = getEntryThickness;
          // settings
          this.strictOrder = false;
          this.allowReslicing = false;
          this.maxCoord = -1; // -1 means no max
          this.maxStackCnt = -1; // -1 means no max
          this.levelCoords = []; // ordered
          this.entriesByLevel = []; // parallel with levelCoords
          this.stackCnts = {}; // TODO: use better technique!?
      }
      addSegs(inputs) {
          let hiddenEntries = [];
          for (let input of inputs) {
              this.insertEntry(input, hiddenEntries);
          }
          return hiddenEntries;
      }
      insertEntry(entry, hiddenEntries) {
          let insertion = this.findInsertion(entry);
          if (this.isInsertionValid(insertion, entry)) {
              this.insertEntryAt(entry, insertion);
              return 1;
          }
          return this.handleInvalidInsertion(insertion, entry, hiddenEntries);
      }
      isInsertionValid(insertion, entry) {
          return (this.maxCoord === -1 || insertion.levelCoord + this.getEntryThickness(entry) <= this.maxCoord) &&
              (this.maxStackCnt === -1 || insertion.stackCnt < this.maxStackCnt);
      }
      // returns number of new entries inserted
      handleInvalidInsertion(insertion, entry, hiddenEntries) {
          if (this.allowReslicing && insertion.touchingEntry) {
              return this.splitEntry(entry, insertion.touchingEntry, hiddenEntries);
          }
          hiddenEntries.push(entry);
          return 0;
      }
      splitEntry(entry, barrier, hiddenEntries) {
          let partCnt = 0;
          let splitHiddenEntries = [];
          let entrySpan = entry.span;
          let barrierSpan = barrier.span;
          if (entrySpan.start < barrierSpan.start) {
              partCnt += this.insertEntry({
                  index: entry.index,
                  thickness: entry.thickness,
                  span: { start: entrySpan.start, end: barrierSpan.start },
              }, splitHiddenEntries);
          }
          if (entrySpan.end > barrierSpan.end) {
              partCnt += this.insertEntry({
                  index: entry.index,
                  thickness: entry.thickness,
                  span: { start: barrierSpan.end, end: entrySpan.end },
              }, splitHiddenEntries);
          }
          if (partCnt) {
              hiddenEntries.push({
                  index: entry.index,
                  thickness: entry.thickness,
                  span: intersectSpans(barrierSpan, entrySpan), // guaranteed to intersect
              }, ...splitHiddenEntries);
              return partCnt;
          }
          hiddenEntries.push(entry);
          return 0;
      }
      insertEntryAt(entry, insertion) {
          let { entriesByLevel, levelCoords } = this;
          if (insertion.lateral === -1) {
              // create a new level
              insertAt(levelCoords, insertion.level, insertion.levelCoord);
              insertAt(entriesByLevel, insertion.level, [entry]);
          }
          else {
              // insert into existing level
              insertAt(entriesByLevel[insertion.level], insertion.lateral, entry);
          }
          this.stackCnts[buildEntryKey(entry)] = insertion.stackCnt;
      }
      findInsertion(newEntry) {
          let { levelCoords, entriesByLevel, strictOrder, stackCnts } = this;
          let levelCnt = levelCoords.length;
          let candidateCoord = 0;
          let touchingLevel = -1;
          let touchingLateral = -1;
          let touchingEntry = null;
          let stackCnt = 0;
          for (let trackingLevel = 0; trackingLevel < levelCnt; trackingLevel += 1) {
              let trackingCoord = levelCoords[trackingLevel];
              // if the current level is past the placed entry, we have found a good empty space and can stop.
              // if strictOrder, keep finding more lateral intersections.
              if (!strictOrder && trackingCoord >= candidateCoord + this.getEntryThickness(newEntry)) {
                  break;
              }
              let trackingEntries = entriesByLevel[trackingLevel];
              let trackingEntry;
              let searchRes = binarySearch(trackingEntries, newEntry.span.start, getEntrySpanEnd); // find first entry after newEntry's end
              let lateralIndex = searchRes[0] + searchRes[1]; // if exact match (which doesn't collide), go to next one
              while ( // loop through entries that horizontally intersect
              (trackingEntry = trackingEntries[lateralIndex]) && // but not past the whole entry list
                  trackingEntry.span.start < newEntry.span.end // and not entirely past newEntry
              ) {
                  let trackingEntryBottom = trackingCoord + this.getEntryThickness(trackingEntry);
                  // intersects into the top of the candidate?
                  if (trackingEntryBottom > candidateCoord) {
                      candidateCoord = trackingEntryBottom;
                      touchingEntry = trackingEntry;
                      touchingLevel = trackingLevel;
                      touchingLateral = lateralIndex;
                  }
                  // butts up against top of candidate? (will happen if just intersected as well)
                  if (trackingEntryBottom === candidateCoord) {
                      // accumulate the highest possible stackCnt of the trackingEntries that butt up
                      stackCnt = Math.max(stackCnt, stackCnts[buildEntryKey(trackingEntry)] + 1);
                  }
                  lateralIndex += 1;
              }
          }
          // the destination level will be after touchingEntry's level. find it
          let destLevel = 0;
          if (touchingEntry) {
              destLevel = touchingLevel + 1;
              while (destLevel < levelCnt && levelCoords[destLevel] < candidateCoord) {
                  destLevel += 1;
              }
          }
          // if adding to an existing level, find where to insert
          let destLateral = -1;
          if (destLevel < levelCnt && levelCoords[destLevel] === candidateCoord) {
              destLateral = binarySearch(entriesByLevel[destLevel], newEntry.span.end, getEntrySpanEnd)[0];
          }
          return {
              touchingLevel,
              touchingLateral,
              touchingEntry,
              stackCnt,
              levelCoord: candidateCoord,
              level: destLevel,
              lateral: destLateral,
          };
      }
      // sorted by levelCoord (lowest to highest)
      toRects() {
          let { entriesByLevel, levelCoords } = this;
          let levelCnt = entriesByLevel.length;
          let rects = [];
          for (let level = 0; level < levelCnt; level += 1) {
              let entries = entriesByLevel[level];
              let levelCoord = levelCoords[level];
              for (let entry of entries) {
                  rects.push(Object.assign(Object.assign({}, entry), { thickness: this.getEntryThickness(entry), levelCoord }));
              }
          }
          return rects;
      }
  }
  function getEntrySpanEnd(entry) {
      return entry.span.end;
  }
  function buildEntryKey(entry) {
      return entry.index + ':' + entry.span.start;
  }
  // returns groups with entries sorted by input order
  function groupIntersectingEntries(entries) {
      let merges = [];
      for (let entry of entries) {
          let filteredMerges = [];
          let hungryMerge = {
              span: entry.span,
              entries: [entry],
          };
          for (let merge of merges) {
              if (intersectSpans(merge.span, hungryMerge.span)) {
                  hungryMerge = {
                      entries: merge.entries.concat(hungryMerge.entries),
                      span: joinSpans(merge.span, hungryMerge.span),
                  };
              }
              else {
                  filteredMerges.push(merge);
              }
          }
          filteredMerges.push(hungryMerge);
          merges = filteredMerges;
      }
      return merges;
  }
  function joinSpans(span0, span1) {
      return {
          start: Math.min(span0.start, span1.start),
          end: Math.max(span0.end, span1.end),
      };
  }
  function intersectSpans(span0, span1) {
      let start = Math.max(span0.start, span1.start);
      let end = Math.min(span0.end, span1.end);
      if (start < end) {
          return { start, end };
      }
      return null;
  }
  // general util
  // ---------------------------------------------------------------------------------------------------------------------
  function insertAt(arr, index, item) {
      arr.splice(index, 0, item);
  }
  function binarySearch(a, searchVal, getItemVal) {
      let startIndex = 0;
      let endIndex = a.length; // exclusive
      if (!endIndex || searchVal < getItemVal(a[startIndex])) { // no items OR before first item
          return [0, 0];
      }
      if (searchVal > getItemVal(a[endIndex - 1])) { // after last item
          return [endIndex, 0];
      }
      while (startIndex < endIndex) {
          let middleIndex = Math.floor(startIndex + (endIndex - startIndex) / 2);
          let middleVal = getItemVal(a[middleIndex]);
          if (searchVal < middleVal) {
              endIndex = middleIndex;
          }
          else if (searchVal > middleVal) {
              startIndex = middleIndex + 1;
          }
          else { // equal!
              return [middleIndex, 1];
          }
      }
      return [startIndex, 0];
  }

  class Interaction {
      constructor(settings) {
          this.component = settings.component;
          this.isHitComboAllowed = settings.isHitComboAllowed || null;
      }
      destroy() {
      }
  }
  function parseInteractionSettings(component, input) {
      return {
          component,
          el: input.el,
          useEventCenter: input.useEventCenter != null ? input.useEventCenter : true,
          isHitComboAllowed: input.isHitComboAllowed || null,
      };
  }
  function interactionSettingsToStore(settings) {
      return {
          [settings.component.uid]: settings,
      };
  }
  // global state
  const interactionSettingsStore = {};

  /*
  An abstraction for a dragging interaction originating on an event.
  Does higher-level things than PointerDragger, such as possibly:
  - a "mirror" that moves with the pointer
  - a minimum number of pixels or other criteria for a true drag to begin

  subclasses must emit:
  - pointerdown
  - dragstart
  - dragmove
  - pointerup
  - dragend
  */
  class ElementDragging {
      constructor(el, selector) {
          this.emitter = new Emitter();
      }
      destroy() {
      }
      setMirrorIsVisible(bool) {
          // optional if subclass doesn't want to support a mirror
      }
      setMirrorNeedsRevert(bool) {
          // optional if subclass doesn't want to support a mirror
      }
      setAutoScrollEnabled(bool) {
          // optional
      }
  }

  // TODO: get rid of this in favor of options system,
  // tho it's really easy to access this globally rather than pass thru options.
  const config = {};

  /*
  Information about what will happen when an external element is dragged-and-dropped
  onto a calendar. Contains information for creating an event.
  */
  const DRAG_META_REFINERS = {
      startTime: createDuration,
      duration: createDuration,
      create: Boolean,
      sourceId: String,
  };
  function parseDragMeta(raw) {
      let { refined, extra } = refineProps(raw, DRAG_META_REFINERS);
      return {
          startTime: refined.startTime || null,
          duration: refined.duration || null,
          create: refined.create != null ? refined.create : true,
          sourceId: refined.sourceId,
          leftoverProps: extra,
      };
  }

  class CalendarRoot extends BaseComponent {
      constructor() {
          super(...arguments);
          this.state = {
              forPrint: false,
          };
          this.handleBeforePrint = () => {
              this.setState({ forPrint: true });
          };
          this.handleAfterPrint = () => {
              this.setState({ forPrint: false });
          };
      }
      render() {
          let { props } = this;
          let { options } = props;
          let { forPrint } = this.state;
          let isHeightAuto = forPrint || options.height === 'auto' || options.contentHeight === 'auto';
          let height = (!isHeightAuto && options.height != null) ? options.height : '';
          let classNames = [
              'fc',
              forPrint ? 'fc-media-print' : 'fc-media-screen',
              `fc-direction-${options.direction}`,
              props.theme.getClass('root'),
          ];
          if (!getCanVGrowWithinCell()) {
              classNames.push('fc-liquid-hack');
          }
          return props.children(classNames, height, isHeightAuto, forPrint);
      }
      componentDidMount() {
          let { emitter } = this.props;
          emitter.on('_beforeprint', this.handleBeforePrint);
          emitter.on('_afterprint', this.handleAfterPrint);
      }
      componentWillUnmount() {
          let { emitter } = this.props;
          emitter.off('_beforeprint', this.handleBeforePrint);
          emitter.off('_afterprint', this.handleAfterPrint);
      }
  }

  // Computes a default column header formatting string if `colFormat` is not explicitly defined
  function computeFallbackHeaderFormat(datesRepDistinctDays, dayCnt) {
      // if more than one week row, or if there are a lot of columns with not much space,
      // put just the day numbers will be in each cell
      if (!datesRepDistinctDays || dayCnt > 10) {
          return createFormatter({ weekday: 'short' }); // "Sat"
      }
      if (dayCnt > 1) {
          return createFormatter({ weekday: 'short', month: 'numeric', day: 'numeric', omitCommas: true }); // "Sat 11/12"
      }
      return createFormatter({ weekday: 'long' }); // "Saturday"
  }

  const CLASS_NAME = 'fc-col-header-cell'; // do the cushion too? no
  function renderInner$1(renderProps) {
      return renderProps.text;
  }

  class ContentInjector extends BaseComponent {
      constructor() {
          super(...arguments);
          this.id = guid();
          this.queuedDomNodes = [];
          this.currentDomNodes = [];
          this.handleEl = (el) => {
              const { options } = this.context;
              const { generatorName } = this.props;
              if (!options.customRenderingReplaces || !hasCustomRenderingHandler(generatorName, options)) {
                  this.updateElRef(el);
              }
          };
          this.updateElRef = (el) => {
              if (this.props.elRef) {
                  setRef(this.props.elRef, el);
              }
          };
      }
      render() {
          const { props, context } = this;
          const { options } = context;
          const { customGenerator, defaultGenerator, renderProps } = props;
          const attrs = buildElAttrs(props, [], this.handleEl);
          let useDefault = false;
          let innerContent;
          let queuedDomNodes = [];
          let currentGeneratorMeta;
          if (customGenerator != null) {
              const customGeneratorRes = typeof customGenerator === 'function' ?
                  customGenerator(renderProps, y$1) :
                  customGenerator;
              if (customGeneratorRes === true) {
                  useDefault = true;
              }
              else {
                  const isObject = customGeneratorRes && typeof customGeneratorRes === 'object'; // non-null
                  if (isObject && ('html' in customGeneratorRes)) {
                      attrs.dangerouslySetInnerHTML = { __html: customGeneratorRes.html };
                  }
                  else if (isObject && ('domNodes' in customGeneratorRes)) {
                      queuedDomNodes = Array.prototype.slice.call(customGeneratorRes.domNodes);
                  }
                  else if (isObject
                      ? i$1(customGeneratorRes) // vdom node
                      : typeof customGeneratorRes !== 'function' // primitive value (like string or number)
                  ) {
                      // use in vdom
                      innerContent = customGeneratorRes;
                  }
                  else {
                      // an exotic object for handleCustomRendering
                      currentGeneratorMeta = customGeneratorRes;
                  }
              }
          }
          else {
              useDefault = !hasCustomRenderingHandler(props.generatorName, options);
          }
          if (useDefault && defaultGenerator) {
              innerContent = defaultGenerator(renderProps);
          }
          this.queuedDomNodes = queuedDomNodes;
          this.currentGeneratorMeta = currentGeneratorMeta;
          return y$1(props.elTag, attrs, innerContent);
      }
      componentDidMount() {
          this.applyQueueudDomNodes();
          this.triggerCustomRendering(true);
      }
      componentDidUpdate() {
          this.applyQueueudDomNodes();
          this.triggerCustomRendering(true);
      }
      componentWillUnmount() {
          this.triggerCustomRendering(false); // TODO: different API for removal?
      }
      triggerCustomRendering(isActive) {
          var _a;
          const { props, context } = this;
          const { handleCustomRendering, customRenderingMetaMap } = context.options;
          if (handleCustomRendering) {
              const generatorMeta = (_a = this.currentGeneratorMeta) !== null && _a !== void 0 ? _a : customRenderingMetaMap === null || customRenderingMetaMap === void 0 ? void 0 : customRenderingMetaMap[props.generatorName];
              if (generatorMeta) {
                  handleCustomRendering(Object.assign(Object.assign({ id: this.id, isActive, containerEl: this.base, reportNewContainerEl: this.updateElRef, // front-end framework tells us about new container els
                      generatorMeta }, props), { elClasses: (props.elClasses || []).filter(isTruthy) }));
              }
          }
      }
      applyQueueudDomNodes() {
          const { queuedDomNodes, currentDomNodes } = this;
          const el = this.base;
          if (!isArraysEqual(queuedDomNodes, currentDomNodes)) {
              currentDomNodes.forEach(removeElement);
              for (let newNode of queuedDomNodes) {
                  el.appendChild(newNode);
              }
              this.currentDomNodes = queuedDomNodes;
          }
      }
  }
  ContentInjector.addPropsEquality({
      elClasses: isArraysEqual,
      elStyle: isPropsEqual,
      elAttrs: isNonHandlerPropsEqual,
      renderProps: isPropsEqual,
  });
  // Util
  /*
  Does UI-framework provide custom way of rendering that does not use Preact VDOM
  AND does the calendar's options define custom rendering?
  AKA. Should we NOT render the default content?
  */
  function hasCustomRenderingHandler(generatorName, options) {
      var _a;
      return Boolean(options.handleCustomRendering &&
          generatorName &&
          ((_a = options.customRenderingMetaMap) === null || _a === void 0 ? void 0 : _a[generatorName]));
  }
  function buildElAttrs(props, extraClassNames, elRef) {
      const attrs = Object.assign(Object.assign({}, props.elAttrs), { ref: elRef });
      if (props.elClasses || extraClassNames) {
          attrs.className = (props.elClasses || [])
              .concat(extraClassNames || [])
              .concat(attrs.className || [])
              .filter(Boolean)
              .join(' ');
      }
      if (props.elStyle) {
          attrs.style = props.elStyle;
      }
      return attrs;
  }
  function isTruthy(val) {
      return Boolean(val);
  }

  const RenderId = createContext(0);

  class ContentContainer extends x$1 {
      constructor() {
          super(...arguments);
          this.InnerContent = InnerContentInjector.bind(undefined, this);
          this.handleEl = (el) => {
              this.el = el;
              if (this.props.elRef) {
                  setRef(this.props.elRef, el);
                  if (el && this.didMountMisfire) {
                      this.componentDidMount();
                  }
              }
          };
      }
      render() {
          const { props } = this;
          const generatedClassNames = generateClassNames(props.classNameGenerator, props.renderProps);
          if (props.children) {
              const elAttrs = buildElAttrs(props, generatedClassNames, this.handleEl);
              const children = props.children(this.InnerContent, props.renderProps, elAttrs);
              if (props.elTag) {
                  return y$1(props.elTag, elAttrs, children);
              }
              else {
                  return children;
              }
          }
          else {
              return y$1((ContentInjector), Object.assign(Object.assign({}, props), { elRef: this.handleEl, elTag: props.elTag || 'div', elClasses: (props.elClasses || []).concat(generatedClassNames), renderId: this.context }));
          }
      }
      componentDidMount() {
          var _a, _b;
          if (this.el) {
              (_b = (_a = this.props).didMount) === null || _b === void 0 ? void 0 : _b.call(_a, Object.assign(Object.assign({}, this.props.renderProps), { el: this.el }));
          }
          else {
              this.didMountMisfire = true;
          }
      }
      componentWillUnmount() {
          var _a, _b;
          (_b = (_a = this.props).willUnmount) === null || _b === void 0 ? void 0 : _b.call(_a, Object.assign(Object.assign({}, this.props.renderProps), { el: this.el }));
      }
  }
  ContentContainer.contextType = RenderId;
  function InnerContentInjector(containerComponent, props) {
      const parentProps = containerComponent.props;
      return y$1((ContentInjector), Object.assign({ renderProps: parentProps.renderProps, generatorName: parentProps.generatorName, customGenerator: parentProps.customGenerator, defaultGenerator: parentProps.defaultGenerator, renderId: containerComponent.context }, props));
  }
  // Utils
  function generateClassNames(classNameGenerator, renderProps) {
      const classNames = typeof classNameGenerator === 'function' ?
          classNameGenerator(renderProps) :
          classNameGenerator || [];
      return typeof classNames === 'string' ? [classNames] : classNames;
  }

  // BAD name for this class now. used in the Header
  class TableDateCell extends BaseComponent {
      render() {
          let { dateEnv, options, theme, viewApi } = this.context;
          let { props } = this;
          let { date, dateProfile } = props;
          let dayMeta = getDateMeta(date, props.todayRange, null, dateProfile);
          let classNames = [CLASS_NAME].concat(getDayClassNames(dayMeta, theme));
          let text = dateEnv.format(date, props.dayHeaderFormat);
          // if colCnt is 1, we are already in a day-view and don't need a navlink
          let navLinkAttrs = (!dayMeta.isDisabled && props.colCnt > 1)
              ? buildNavLinkAttrs(this.context, date)
              : {};
          let renderProps = Object.assign(Object.assign(Object.assign({ date: dateEnv.toDate(date), view: viewApi }, props.extraRenderProps), { text }), dayMeta);
          return (y$1(ContentContainer, { elTag: "th", elClasses: classNames, elAttrs: Object.assign({ role: 'columnheader', colSpan: props.colSpan, 'data-date': !dayMeta.isDisabled ? formatDayString(date) : undefined }, props.extraDataAttrs), renderProps: renderProps, generatorName: "dayHeaderContent", customGenerator: options.dayHeaderContent, defaultGenerator: renderInner$1, classNameGenerator: options.dayHeaderClassNames, didMount: options.dayHeaderDidMount, willUnmount: options.dayHeaderWillUnmount }, (InnerContainer) => (y$1("div", { className: "fc-scrollgrid-sync-inner" }, !dayMeta.isDisabled && (y$1(InnerContainer, { elTag: "a", elAttrs: navLinkAttrs, elClasses: [
                  'fc-col-header-cell-cushion',
                  props.isSticky && 'fc-sticky',
              ] }))))));
      }
  }

  const WEEKDAY_FORMAT = createFormatter({ weekday: 'long' });
  class TableDowCell extends BaseComponent {
      render() {
          let { props } = this;
          let { dateEnv, theme, viewApi, options } = this.context;
          let date = addDays(new Date(259200000), props.dow); // start with Sun, 04 Jan 1970 00:00:00 GMT
          let dateMeta = {
              dow: props.dow,
              isDisabled: false,
              isFuture: false,
              isPast: false,
              isToday: false,
              isOther: false,
          };
          let text = dateEnv.format(date, props.dayHeaderFormat);
          let renderProps = Object.assign(Object.assign(Object.assign(Object.assign({ // TODO: make this public?
              date }, dateMeta), { view: viewApi }), props.extraRenderProps), { text });
          return (y$1(ContentContainer, { elTag: "th", elClasses: [
                  CLASS_NAME,
                  ...getDayClassNames(dateMeta, theme),
                  ...(props.extraClassNames || []),
              ], elAttrs: Object.assign({ role: 'columnheader', colSpan: props.colSpan }, props.extraDataAttrs), renderProps: renderProps, generatorName: "dayHeaderContent", customGenerator: options.dayHeaderContent, defaultGenerator: renderInner$1, classNameGenerator: options.dayHeaderClassNames, didMount: options.dayHeaderDidMount, willUnmount: options.dayHeaderWillUnmount }, (InnerContent) => (y$1("div", { className: "fc-scrollgrid-sync-inner" },
              y$1(InnerContent, { elTag: "a", elClasses: [
                      'fc-col-header-cell-cushion',
                      props.isSticky && 'fc-sticky',
                  ], elAttrs: {
                      'aria-label': dateEnv.format(date, WEEKDAY_FORMAT),
                  } })))));
      }
  }

  class NowTimer extends x$1 {
      constructor(props, context) {
          super(props, context);
          this.initialNowDate = getNow(context.options.now, context.dateEnv);
          this.initialNowQueriedMs = new Date().valueOf();
          this.state = this.computeTiming().currentState;
      }
      render() {
          let { props, state } = this;
          return props.children(state.nowDate, state.todayRange);
      }
      componentDidMount() {
          this.setTimeout();
      }
      componentDidUpdate(prevProps) {
          if (prevProps.unit !== this.props.unit) {
              this.clearTimeout();
              this.setTimeout();
          }
      }
      componentWillUnmount() {
          this.clearTimeout();
      }
      computeTiming() {
          let { props, context } = this;
          let unroundedNow = addMs(this.initialNowDate, new Date().valueOf() - this.initialNowQueriedMs);
          let currentUnitStart = context.dateEnv.startOf(unroundedNow, props.unit);
          let nextUnitStart = context.dateEnv.add(currentUnitStart, createDuration(1, props.unit));
          let waitMs = nextUnitStart.valueOf() - unroundedNow.valueOf();
          // there is a max setTimeout ms value (https://stackoverflow.com/a/3468650/96342)
          // ensure no longer than a day
          waitMs = Math.min(1000 * 60 * 60 * 24, waitMs);
          return {
              currentState: { nowDate: currentUnitStart, todayRange: buildDayRange(currentUnitStart) },
              nextState: { nowDate: nextUnitStart, todayRange: buildDayRange(nextUnitStart) },
              waitMs,
          };
      }
      setTimeout() {
          let { nextState, waitMs } = this.computeTiming();
          this.timeoutId = setTimeout(() => {
              this.setState(nextState, () => {
                  this.setTimeout();
              });
          }, waitMs);
      }
      clearTimeout() {
          if (this.timeoutId) {
              clearTimeout(this.timeoutId);
          }
      }
  }
  NowTimer.contextType = ViewContextType;
  function buildDayRange(date) {
      let start = startOfDay(date);
      let end = addDays(start, 1);
      return { start, end };
  }

  class DayHeader extends BaseComponent {
      constructor() {
          super(...arguments);
          this.createDayHeaderFormatter = memoize(createDayHeaderFormatter);
      }
      render() {
          let { context } = this;
          let { dates, dateProfile, datesRepDistinctDays, renderIntro } = this.props;
          let dayHeaderFormat = this.createDayHeaderFormatter(context.options.dayHeaderFormat, datesRepDistinctDays, dates.length);
          return (y$1(NowTimer, { unit: "day" }, (nowDate, todayRange) => (y$1("tr", { role: "row" },
              renderIntro && renderIntro('day'),
              dates.map((date) => (datesRepDistinctDays ? (y$1(TableDateCell, { key: date.toISOString(), date: date, dateProfile: dateProfile, todayRange: todayRange, colCnt: dates.length, dayHeaderFormat: dayHeaderFormat })) : (y$1(TableDowCell, { key: date.getUTCDay(), dow: date.getUTCDay(), dayHeaderFormat: dayHeaderFormat }))))))));
      }
  }
  function createDayHeaderFormatter(explicitFormat, datesRepDistinctDays, dateCnt) {
      return explicitFormat || computeFallbackHeaderFormat(datesRepDistinctDays, dateCnt);
  }

  class DaySeriesModel {
      constructor(range, dateProfileGenerator) {
          let date = range.start;
          let { end } = range;
          let indices = [];
          let dates = [];
          let dayIndex = -1;
          while (date < end) { // loop each day from start to end
              if (dateProfileGenerator.isHiddenDay(date)) {
                  indices.push(dayIndex + 0.5); // mark that it's between indices
              }
              else {
                  dayIndex += 1;
                  indices.push(dayIndex);
                  dates.push(date);
              }
              date = addDays(date, 1);
          }
          this.dates = dates;
          this.indices = indices;
          this.cnt = dates.length;
      }
      sliceRange(range) {
          let firstIndex = this.getDateDayIndex(range.start); // inclusive first index
          let lastIndex = this.getDateDayIndex(addDays(range.end, -1)); // inclusive last index
          let clippedFirstIndex = Math.max(0, firstIndex);
          let clippedLastIndex = Math.min(this.cnt - 1, lastIndex);
          // deal with in-between indices
          clippedFirstIndex = Math.ceil(clippedFirstIndex); // in-between starts round to next cell
          clippedLastIndex = Math.floor(clippedLastIndex); // in-between ends round to prev cell
          if (clippedFirstIndex <= clippedLastIndex) {
              return {
                  firstIndex: clippedFirstIndex,
                  lastIndex: clippedLastIndex,
                  isStart: firstIndex === clippedFirstIndex,
                  isEnd: lastIndex === clippedLastIndex,
              };
          }
          return null;
      }
      // Given a date, returns its chronolocial cell-index from the first cell of the grid.
      // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.
      // If before the first offset, returns a negative number.
      // If after the last offset, returns an offset past the last cell offset.
      // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.
      getDateDayIndex(date) {
          let { indices } = this;
          let dayOffset = Math.floor(diffDays(this.dates[0], date));
          if (dayOffset < 0) {
              return indices[0] - 1;
          }
          if (dayOffset >= indices.length) {
              return indices[indices.length - 1] + 1;
          }
          return indices[dayOffset];
      }
  }

  class DayTableModel {
      constructor(daySeries, breakOnWeeks) {
          let { dates } = daySeries;
          let daysPerRow;
          let firstDay;
          let rowCnt;
          if (breakOnWeeks) {
              // count columns until the day-of-week repeats
              firstDay = dates[0].getUTCDay();
              for (daysPerRow = 1; daysPerRow < dates.length; daysPerRow += 1) {
                  if (dates[daysPerRow].getUTCDay() === firstDay) {
                      break;
                  }
              }
              rowCnt = Math.ceil(dates.length / daysPerRow);
          }
          else {
              rowCnt = 1;
              daysPerRow = dates.length;
          }
          this.rowCnt = rowCnt;
          this.colCnt = daysPerRow;
          this.daySeries = daySeries;
          this.cells = this.buildCells();
          this.headerDates = this.buildHeaderDates();
      }
      buildCells() {
          let rows = [];
          for (let row = 0; row < this.rowCnt; row += 1) {
              let cells = [];
              for (let col = 0; col < this.colCnt; col += 1) {
                  cells.push(this.buildCell(row, col));
              }
              rows.push(cells);
          }
          return rows;
      }
      buildCell(row, col) {
          let date = this.daySeries.dates[row * this.colCnt + col];
          return {
              key: date.toISOString(),
              date,
          };
      }
      buildHeaderDates() {
          let dates = [];
          for (let col = 0; col < this.colCnt; col += 1) {
              dates.push(this.cells[0][col].date);
          }
          return dates;
      }
      sliceRange(range) {
          let { colCnt } = this;
          let seriesSeg = this.daySeries.sliceRange(range);
          let segs = [];
          if (seriesSeg) {
              let { firstIndex, lastIndex } = seriesSeg;
              let index = firstIndex;
              while (index <= lastIndex) {
                  let row = Math.floor(index / colCnt);
                  let nextIndex = Math.min((row + 1) * colCnt, lastIndex + 1);
                  segs.push({
                      row,
                      firstCol: index % colCnt,
                      lastCol: (nextIndex - 1) % colCnt,
                      isStart: seriesSeg.isStart && index === firstIndex,
                      isEnd: seriesSeg.isEnd && (nextIndex - 1) === lastIndex,
                  });
                  index = nextIndex;
              }
          }
          return segs;
      }
  }

  class Slicer {
      constructor() {
          this.sliceBusinessHours = memoize(this._sliceBusinessHours);
          this.sliceDateSelection = memoize(this._sliceDateSpan);
          this.sliceEventStore = memoize(this._sliceEventStore);
          this.sliceEventDrag = memoize(this._sliceInteraction);
          this.sliceEventResize = memoize(this._sliceInteraction);
          this.forceDayIfListItem = false; // hack
      }
      sliceProps(props, dateProfile, nextDayThreshold, context, ...extraArgs) {
          let { eventUiBases } = props;
          let eventSegs = this.sliceEventStore(props.eventStore, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs);
          return {
              dateSelectionSegs: this.sliceDateSelection(props.dateSelection, dateProfile, nextDayThreshold, eventUiBases, context, ...extraArgs),
              businessHourSegs: this.sliceBusinessHours(props.businessHours, dateProfile, nextDayThreshold, context, ...extraArgs),
              fgEventSegs: eventSegs.fg,
              bgEventSegs: eventSegs.bg,
              eventDrag: this.sliceEventDrag(props.eventDrag, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs),
              eventResize: this.sliceEventResize(props.eventResize, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs),
              eventSelection: props.eventSelection,
          }; // TODO: give interactionSegs?
      }
      sliceNowDate(// does not memoize
      date, dateProfile, nextDayThreshold, context, ...extraArgs) {
          return this._sliceDateSpan({ range: { start: date, end: addMs(date, 1) }, allDay: false }, // add 1 ms, protect against null range
          dateProfile, nextDayThreshold, {}, context, ...extraArgs);
      }
      _sliceBusinessHours(businessHours, dateProfile, nextDayThreshold, context, ...extraArgs) {
          if (!businessHours) {
              return [];
          }
          return this._sliceEventStore(expandRecurring(businessHours, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), context), {}, dateProfile, nextDayThreshold, ...extraArgs).bg;
      }
      _sliceEventStore(eventStore, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs) {
          if (eventStore) {
              let rangeRes = sliceEventStore(eventStore, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);
              return {
                  bg: this.sliceEventRanges(rangeRes.bg, extraArgs),
                  fg: this.sliceEventRanges(rangeRes.fg, extraArgs),
              };
          }
          return { bg: [], fg: [] };
      }
      _sliceInteraction(interaction, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs) {
          if (!interaction) {
              return null;
          }
          let rangeRes = sliceEventStore(interaction.mutatedEvents, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);
          return {
              segs: this.sliceEventRanges(rangeRes.fg, extraArgs),
              affectedInstances: interaction.affectedEvents.instances,
              isEvent: interaction.isEvent,
          };
      }
      _sliceDateSpan(dateSpan, dateProfile, nextDayThreshold, eventUiBases, context, ...extraArgs) {
          if (!dateSpan) {
              return [];
          }
          let activeRange = computeActiveRange(dateProfile, Boolean(nextDayThreshold));
          let activeDateSpanRange = intersectRanges(dateSpan.range, activeRange);
          if (activeDateSpanRange) {
              dateSpan = Object.assign(Object.assign({}, dateSpan), { range: activeDateSpanRange });
              let eventRange = fabricateEventRange(dateSpan, eventUiBases, context);
              let segs = this.sliceRange(dateSpan.range, ...extraArgs);
              for (let seg of segs) {
                  seg.eventRange = eventRange;
              }
              return segs;
          }
          return [];
      }
      /*
      "complete" seg means it has component and eventRange
      */
      sliceEventRanges(eventRanges, extraArgs) {
          let segs = [];
          for (let eventRange of eventRanges) {
              segs.push(...this.sliceEventRange(eventRange, extraArgs));
          }
          return segs;
      }
      /*
      "complete" seg means it has component and eventRange
      */
      sliceEventRange(eventRange, extraArgs) {
          let dateRange = eventRange.range;
          // hack to make multi-day events that are being force-displayed as list-items to take up only one day
          if (this.forceDayIfListItem && eventRange.ui.display === 'list-item') {
              dateRange = {
                  start: dateRange.start,
                  end: addDays(dateRange.start, 1),
              };
          }
          let segs = this.sliceRange(dateRange, ...extraArgs);
          for (let seg of segs) {
              seg.eventRange = eventRange;
              seg.isStart = eventRange.isStart && seg.isStart;
              seg.isEnd = eventRange.isEnd && seg.isEnd;
          }
          return segs;
      }
  }
  /*
  for incorporating slotMinTime/slotMaxTime if appropriate
  TODO: should be part of DateProfile!
  TimelineDateProfile already does this btw
  */
  function computeActiveRange(dateProfile, isComponentAllDay) {
      let range = dateProfile.activeRange;
      if (isComponentAllDay) {
          return range;
      }
      return {
          start: addMs(range.start, dateProfile.slotMinTime.milliseconds),
          end: addMs(range.end, dateProfile.slotMaxTime.milliseconds - 864e5), // 864e5 = ms in a day
      };
  }

  function reduceEventStore(eventStore, action, eventSources, dateProfile, context) {
      switch (action.type) {
          case 'RECEIVE_EVENTS': // raw
              return receiveRawEvents(eventStore, eventSources[action.sourceId], action.fetchId, action.fetchRange, action.rawEvents, context);
          case 'RESET_RAW_EVENTS':
              return resetRawEvents(eventStore, eventSources[action.sourceId], action.rawEvents, dateProfile.activeRange, context);
          case 'ADD_EVENTS': // already parsed, but not expanded
              return addEvent(eventStore, action.eventStore, // new ones
              dateProfile ? dateProfile.activeRange : null, context);
          case 'RESET_EVENTS':
              return action.eventStore;
          case 'MERGE_EVENTS': // already parsed and expanded
              return mergeEventStores(eventStore, action.eventStore);
          case 'PREV': // TODO: how do we track all actions that affect dateProfile :(
          case 'NEXT':
          case 'CHANGE_DATE':
          case 'CHANGE_VIEW_TYPE':
              if (dateProfile) {
                  return expandRecurring(eventStore, dateProfile.activeRange, context);
              }
              return eventStore;
          case 'REMOVE_EVENTS':
              return excludeSubEventStore(eventStore, action.eventStore);
          case 'REMOVE_EVENT_SOURCE':
              return excludeEventsBySourceId(eventStore, action.sourceId);
          case 'REMOVE_ALL_EVENT_SOURCES':
              return filterEventStoreDefs(eventStore, (eventDef) => (!eventDef.sourceId // only keep events with no source id
              ));
          case 'REMOVE_ALL_EVENTS':
              return createEmptyEventStore();
          default:
              return eventStore;
      }
  }
  function receiveRawEvents(eventStore, eventSource, fetchId, fetchRange, rawEvents, context) {
      if (eventSource && // not already removed
          fetchId === eventSource.latestFetchId // TODO: wish this logic was always in event-sources
      ) {
          let subset = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context);
          if (fetchRange) {
              subset = expandRecurring(subset, fetchRange, context);
          }
          return mergeEventStores(excludeEventsBySourceId(eventStore, eventSource.sourceId), subset);
      }
      return eventStore;
  }
  function resetRawEvents(existingEventStore, eventSource, rawEvents, activeRange, context) {
      const { defIdMap, instanceIdMap } = buildPublicIdMaps(existingEventStore);
      let newEventStore = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context, false, defIdMap, instanceIdMap);
      return expandRecurring(newEventStore, activeRange, context);
  }
  function transformRawEvents(rawEvents, eventSource, context) {
      let calEachTransform = context.options.eventDataTransform;
      let sourceEachTransform = eventSource ? eventSource.eventDataTransform : null;
      if (sourceEachTransform) {
          rawEvents = transformEachRawEvent(rawEvents, sourceEachTransform);
      }
      if (calEachTransform) {
          rawEvents = transformEachRawEvent(rawEvents, calEachTransform);
      }
      return rawEvents;
  }
  function transformEachRawEvent(rawEvents, func) {
      let refinedEvents;
      if (!func) {
          refinedEvents = rawEvents;
      }
      else {
          refinedEvents = [];
          for (let rawEvent of rawEvents) {
              let refinedEvent = func(rawEvent);
              if (refinedEvent) {
                  refinedEvents.push(refinedEvent);
              }
              else if (refinedEvent == null) {
                  refinedEvents.push(rawEvent);
              } // if a different falsy value, do nothing
          }
      }
      return refinedEvents;
  }
  function addEvent(eventStore, subset, expandRange, context) {
      if (expandRange) {
          subset = expandRecurring(subset, expandRange, context);
      }
      return mergeEventStores(eventStore, subset);
  }
  function rezoneEventStoreDates(eventStore, oldDateEnv, newDateEnv) {
      let { defs } = eventStore;
      let instances = mapHash(eventStore.instances, (instance) => {
          let def = defs[instance.defId];
          if (def.allDay) {
              return instance; // isn't dependent on timezone
          }
          return Object.assign(Object.assign({}, instance), { range: {
                  start: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.start, instance.forcedStartTzo)),
                  end: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.end, instance.forcedEndTzo)),
              }, forcedStartTzo: newDateEnv.canComputeOffset ? null : instance.forcedStartTzo, forcedEndTzo: newDateEnv.canComputeOffset ? null : instance.forcedEndTzo });
      });
      return { defs, instances };
  }
  function excludeEventsBySourceId(eventStore, sourceId) {
      return filterEventStoreDefs(eventStore, (eventDef) => eventDef.sourceId !== sourceId);
  }
  // QUESTION: why not just return instances? do a general object-property-exclusion util
  function excludeInstances(eventStore, removals) {
      return {
          defs: eventStore.defs,
          instances: filterHash(eventStore.instances, (instance) => !removals[instance.instanceId]),
      };
  }
  function buildPublicIdMaps(eventStore) {
      const { defs, instances } = eventStore;
      const defIdMap = {};
      const instanceIdMap = {};
      for (let defId in defs) {
          const def = defs[defId];
          const { publicId } = def;
          if (publicId) {
              defIdMap[publicId] = defId;
          }
      }
      for (let instanceId in instances) {
          const instance = instances[instanceId];
          const def = defs[instance.defId];
          const { publicId } = def;
          if (publicId) {
              instanceIdMap[publicId] = instanceId;
          }
      }
      return { defIdMap, instanceIdMap };
  }

  // high-level segmenting-aware tester functions
  // ------------------------------------------------------------------------------------------------------------------------
  function isInteractionValid(interaction, dateProfile, context) {
      let { instances } = interaction.mutatedEvents;
      for (let instanceId in instances) {
          if (!rangeContainsRange(dateProfile.validRange, instances[instanceId].range)) {
              return false;
          }
      }
      return isNewPropsValid({ eventDrag: interaction }, context); // HACK: the eventDrag props is used for ALL interactions
  }
  function isDateSelectionValid(dateSelection, dateProfile, context) {
      if (!rangeContainsRange(dateProfile.validRange, dateSelection.range)) {
          return false;
      }
      return isNewPropsValid({ dateSelection }, context);
  }
  function isNewPropsValid(newProps, context) {
      let calendarState = context.getCurrentData();
      let props = Object.assign({ businessHours: calendarState.businessHours, dateSelection: '', eventStore: calendarState.eventStore, eventUiBases: calendarState.eventUiBases, eventSelection: '', eventDrag: null, eventResize: null }, newProps);
      return (context.pluginHooks.isPropsValid || isPropsValid)(props, context);
  }
  function isPropsValid(state, context, dateSpanMeta = {}, filterConfig) {
      if (state.eventDrag && !isInteractionPropsValid(state, context, dateSpanMeta, filterConfig)) {
          return false;
      }
      if (state.dateSelection && !isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig)) {
          return false;
      }
      return true;
  }
  // Moving Event Validation
  // ------------------------------------------------------------------------------------------------------------------------
  function isInteractionPropsValid(state, context, dateSpanMeta, filterConfig) {
      let currentState = context.getCurrentData();
      let interaction = state.eventDrag; // HACK: the eventDrag props is used for ALL interactions
      let subjectEventStore = interaction.mutatedEvents;
      let subjectDefs = subjectEventStore.defs;
      let subjectInstances = subjectEventStore.instances;
      let subjectConfigs = compileEventUis(subjectDefs, interaction.isEvent ?
          state.eventUiBases :
          { '': currentState.selectionConfig });
      if (filterConfig) {
          subjectConfigs = mapHash(subjectConfigs, filterConfig);
      }
      // exclude the subject events. TODO: exclude defs too?
      let otherEventStore = excludeInstances(state.eventStore, interaction.affectedEvents.instances);
      let otherDefs = otherEventStore.defs;
      let otherInstances = otherEventStore.instances;
      let otherConfigs = compileEventUis(otherDefs, state.eventUiBases);
      for (let subjectInstanceId in subjectInstances) {
          let subjectInstance = subjectInstances[subjectInstanceId];
          let subjectRange = subjectInstance.range;
          let subjectConfig = subjectConfigs[subjectInstance.defId];
          let subjectDef = subjectDefs[subjectInstance.defId];
          // constraint
          if (!allConstraintsPass(subjectConfig.constraints, subjectRange, otherEventStore, state.businessHours, context)) {
              return false;
          }
          // overlap
          let { eventOverlap } = context.options;
          let eventOverlapFunc = typeof eventOverlap === 'function' ? eventOverlap : null;
          for (let otherInstanceId in otherInstances) {
              let otherInstance = otherInstances[otherInstanceId];
              // intersect! evaluate
              if (rangesIntersect(subjectRange, otherInstance.range)) {
                  let otherOverlap = otherConfigs[otherInstance.defId].overlap;
                  // consider the other event's overlap. only do this if the subject event is a "real" event
                  if (otherOverlap === false && interaction.isEvent) {
                      return false;
                  }
                  if (subjectConfig.overlap === false) {
                      return false;
                  }
                  if (eventOverlapFunc && !eventOverlapFunc(new EventImpl(context, otherDefs[otherInstance.defId], otherInstance), // still event
                  new EventImpl(context, subjectDef, subjectInstance))) {
                      return false;
                  }
              }
          }
          // allow (a function)
          let calendarEventStore = currentState.eventStore; // need global-to-calendar, not local to component (splittable)state
          for (let subjectAllow of subjectConfig.allows) {
              let subjectDateSpan = Object.assign(Object.assign({}, dateSpanMeta), { range: subjectInstance.range, allDay: subjectDef.allDay });
              let origDef = calendarEventStore.defs[subjectDef.defId];
              let origInstance = calendarEventStore.instances[subjectInstanceId];
              let eventApi;
              if (origDef) { // was previously in the calendar
                  eventApi = new EventImpl(context, origDef, origInstance);
              }
              else { // was an external event
                  eventApi = new EventImpl(context, subjectDef); // no instance, because had no dates
              }
              if (!subjectAllow(buildDateSpanApiWithContext(subjectDateSpan, context), eventApi)) {
                  return false;
              }
          }
      }
      return true;
  }
  // Date Selection Validation
  // ------------------------------------------------------------------------------------------------------------------------
  function isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig) {
      let relevantEventStore = state.eventStore;
      let relevantDefs = relevantEventStore.defs;
      let relevantInstances = relevantEventStore.instances;
      let selection = state.dateSelection;
      let selectionRange = selection.range;
      let { selectionConfig } = context.getCurrentData();
      if (filterConfig) {
          selectionConfig = filterConfig(selectionConfig);
      }
      // constraint
      if (!allConstraintsPass(selectionConfig.constraints, selectionRange, relevantEventStore, state.businessHours, context)) {
          return false;
      }
      // overlap
      let { selectOverlap } = context.options;
      let selectOverlapFunc = typeof selectOverlap === 'function' ? selectOverlap : null;
      for (let relevantInstanceId in relevantInstances) {
          let relevantInstance = relevantInstances[relevantInstanceId];
          // intersect! evaluate
          if (rangesIntersect(selectionRange, relevantInstance.range)) {
              if (selectionConfig.overlap === false) {
                  return false;
              }
              if (selectOverlapFunc && !selectOverlapFunc(new EventImpl(context, relevantDefs[relevantInstance.defId], relevantInstance), null)) {
                  return false;
              }
          }
      }
      // allow (a function)
      for (let selectionAllow of selectionConfig.allows) {
          let fullDateSpan = Object.assign(Object.assign({}, dateSpanMeta), selection);
          if (!selectionAllow(buildDateSpanApiWithContext(fullDateSpan, context), null)) {
              return false;
          }
      }
      return true;
  }
  // Constraint Utils
  // ------------------------------------------------------------------------------------------------------------------------
  function allConstraintsPass(constraints, subjectRange, otherEventStore, businessHoursUnexpanded, context) {
      for (let constraint of constraints) {
          if (!anyRangesContainRange(constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context), subjectRange)) {
              return false;
          }
      }
      return true;
  }
  function constraintToRanges(constraint, subjectRange, // for expanding a recurring constraint, or expanding business hours
  otherEventStore, // for if constraint is an even group ID
  businessHoursUnexpanded, // for if constraint is 'businessHours'
  context) {
      if (constraint === 'businessHours') {
          return eventStoreToRanges(expandRecurring(businessHoursUnexpanded, subjectRange, context));
      }
      if (typeof constraint === 'string') { // an group ID
          return eventStoreToRanges(filterEventStoreDefs(otherEventStore, (eventDef) => eventDef.groupId === constraint));
      }
      if (typeof constraint === 'object' && constraint) { // non-null object
          return eventStoreToRanges(expandRecurring(constraint, subjectRange, context));
      }
      return []; // if it's false
  }
  // TODO: move to event-store file?
  function eventStoreToRanges(eventStore) {
      let { instances } = eventStore;
      let ranges = [];
      for (let instanceId in instances) {
          ranges.push(instances[instanceId].range);
      }
      return ranges;
  }
  // TODO: move to geom file?
  function anyRangesContainRange(outerRanges, innerRange) {
      for (let outerRange of outerRanges) {
          if (rangeContainsRange(outerRange, innerRange)) {
              return true;
          }
      }
      return false;
  }

  class JsonRequestError extends Error {
      constructor(message, response) {
          super(message);
          this.response = response;
      }
  }
  function requestJson(method, url, params) {
      method = method.toUpperCase();
      const fetchOptions = {
          method,
      };
      if (method === 'GET') {
          url += (url.indexOf('?') === -1 ? '?' : '&') +
              new URLSearchParams(params);
      }
      else {
          fetchOptions.body = new URLSearchParams(params);
          fetchOptions.headers = {
              'Content-Type': 'application/x-www-form-urlencoded',
          };
      }
      return fetch(url, fetchOptions).then((fetchRes) => {
          if (fetchRes.ok) {
              return fetchRes.json().then((parsedResponse) => {
                  return [parsedResponse, fetchRes];
              }, () => {
                  throw new JsonRequestError('Failure parsing JSON', fetchRes);
              });
          }
          else {
              throw new JsonRequestError('Request failed', fetchRes);
          }
      });
  }

  class DelayedRunner {
      constructor(drainedOption) {
          this.drainedOption = drainedOption;
          this.isRunning = false;
          this.isDirty = false;
          this.pauseDepths = {};
          this.timeoutId = 0;
      }
      request(delay) {
          this.isDirty = true;
          if (!this.isPaused()) {
              this.clearTimeout();
              if (delay == null) {
                  this.tryDrain();
              }
              else {
                  this.timeoutId = setTimeout(// NOT OPTIMAL! TODO: look at debounce
                  this.tryDrain.bind(this), delay);
              }
          }
      }
      pause(scope = '') {
          let { pauseDepths } = this;
          pauseDepths[scope] = (pauseDepths[scope] || 0) + 1;
          this.clearTimeout();
      }
      resume(scope = '', force) {
          let { pauseDepths } = this;
          if (scope in pauseDepths) {
              if (force) {
                  delete pauseDepths[scope];
              }
              else {
                  pauseDepths[scope] -= 1;
                  let depth = pauseDepths[scope];
                  if (depth <= 0) {
                      delete pauseDepths[scope];
                  }
              }
              this.tryDrain();
          }
      }
      isPaused() {
          return Object.keys(this.pauseDepths).length;
      }
      tryDrain() {
          if (!this.isRunning && !this.isPaused()) {
              this.isRunning = true;
              while (this.isDirty) {
                  this.isDirty = false;
                  this.drained(); // might set isDirty to true again
              }
              this.isRunning = false;
          }
      }
      clear() {
          this.clearTimeout();
          this.isDirty = false;
          this.pauseDepths = {};
      }
      clearTimeout() {
          if (this.timeoutId) {
              clearTimeout(this.timeoutId);
              this.timeoutId = 0;
          }
      }
      drained() {
          if (this.drainedOption) {
              this.drainedOption();
          }
      }
  }

  const VISIBLE_HIDDEN_RE = /^(visible|hidden)$/;
  class Scroller extends BaseComponent {
      constructor() {
          super(...arguments);
          this.handleEl = (el) => {
              this.el = el;
              setRef(this.props.elRef, el);
          };
      }
      render() {
          let { props } = this;
          let { liquid, liquidIsAbsolute } = props;
          let isAbsolute = liquid && liquidIsAbsolute;
          let className = ['fc-scroller'];
          if (liquid) {
              if (liquidIsAbsolute) {
                  className.push('fc-scroller-liquid-absolute');
              }
              else {
                  className.push('fc-scroller-liquid');
              }
          }
          return (y$1("div", { ref: this.handleEl, className: className.join(' '), style: {
                  overflowX: props.overflowX,
                  overflowY: props.overflowY,
                  left: (isAbsolute && -(props.overcomeLeft || 0)) || '',
                  right: (isAbsolute && -(props.overcomeRight || 0)) || '',
                  bottom: (isAbsolute && -(props.overcomeBottom || 0)) || '',
                  marginLeft: (!isAbsolute && -(props.overcomeLeft || 0)) || '',
                  marginRight: (!isAbsolute && -(props.overcomeRight || 0)) || '',
                  marginBottom: (!isAbsolute && -(props.overcomeBottom || 0)) || '',
                  maxHeight: props.maxHeight || '',
              } }, props.children));
      }
      needsXScrolling() {
          if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {
              return false;
          }
          // testing scrollWidth>clientWidth is unreliable cross-browser when pixel heights aren't integers.
          // much more reliable to see if children are taller than the scroller, even tho doesn't account for
          // inner-child margins and absolute positioning
          let { el } = this;
          let realClientWidth = this.el.getBoundingClientRect().width - this.getYScrollbarWidth();
          let { children } = el;
          for (let i = 0; i < children.length; i += 1) {
              let childEl = children[i];
              if (childEl.getBoundingClientRect().width > realClientWidth) {
                  return true;
              }
          }
          return false;
      }
      needsYScrolling() {
          if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {
              return false;
          }
          // testing scrollHeight>clientHeight is unreliable cross-browser when pixel heights aren't integers.
          // much more reliable to see if children are taller than the scroller, even tho doesn't account for
          // inner-child margins and absolute positioning
          let { el } = this;
          let realClientHeight = this.el.getBoundingClientRect().height - this.getXScrollbarWidth();
          let { children } = el;
          for (let i = 0; i < children.length; i += 1) {
              let childEl = children[i];
              if (childEl.getBoundingClientRect().height > realClientHeight) {
                  return true;
              }
          }
          return false;
      }
      getXScrollbarWidth() {
          if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {
              return 0;
          }
          return this.el.offsetHeight - this.el.clientHeight; // only works because we guarantee no borders. TODO: add to CSS with important?
      }
      getYScrollbarWidth() {
          if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {
              return 0;
          }
          return this.el.offsetWidth - this.el.clientWidth; // only works because we guarantee no borders. TODO: add to CSS with important?
      }
  }

  /*
  TODO: somehow infer OtherArgs from masterCallback?
  TODO: infer RefType from masterCallback if provided
  */
  class RefMap {
      constructor(masterCallback) {
          this.masterCallback = masterCallback;
          this.currentMap = {};
          this.depths = {};
          this.callbackMap = {};
          this.handleValue = (val, key) => {
              let { depths, currentMap } = this;
              let removed = false;
              let added = false;
              if (val !== null) {
                  // for bug... ACTUALLY: can probably do away with this now that callers don't share numeric indices anymore
                  removed = (key in currentMap);
                  currentMap[key] = val;
                  depths[key] = (depths[key] || 0) + 1;
                  added = true;
              }
              else {
                  depths[key] -= 1;
                  if (!depths[key]) {
                      delete currentMap[key];
                      delete this.callbackMap[key];
                      removed = true;
                  }
              }
              if (this.masterCallback) {
                  if (removed) {
                      this.masterCallback(null, String(key));
                  }
                  if (added) {
                      this.masterCallback(val, String(key));
                  }
              }
          };
      }
      createRef(key) {
          let refCallback = this.callbackMap[key];
          if (!refCallback) {
              refCallback = this.callbackMap[key] = (val) => {
                  this.handleValue(val, String(key));
              };
          }
          return refCallback;
      }
      // TODO: check callers that don't care about order. should use getAll instead
      // NOTE: this method has become less valuable now that we are encouraged to map order by some other index
      // TODO: provide ONE array-export function, buildArray, which fails on non-numeric indexes. caller can manipulate and "collect"
      collect(startIndex, endIndex, step) {
          return collectFromHash(this.currentMap, startIndex, endIndex, step);
      }
      getAll() {
          return hashValuesToArray(this.currentMap);
      }
  }

  function computeShrinkWidth(chunkEls) {
      let shrinkCells = findElements(chunkEls, '.fc-scrollgrid-shrink');
      let largestWidth = 0;
      for (let shrinkCell of shrinkCells) {
          largestWidth = Math.max(largestWidth, computeSmallestCellWidth(shrinkCell));
      }
      return Math.ceil(largestWidth); // <table> elements work best with integers. round up to ensure contents fits
  }
  function getSectionHasLiquidHeight(props, sectionConfig) {
      return props.liquid && sectionConfig.liquid; // does the section do liquid-height? (need to have whole scrollgrid liquid-height as well)
  }
  function getAllowYScrolling(props, sectionConfig) {
      return sectionConfig.maxHeight != null || // if its possible for the height to max out, we might need scrollbars
          getSectionHasLiquidHeight(props, sectionConfig); // if the section is liquid height, it might condense enough to require scrollbars
  }
  // TODO: ONLY use `arg`. force out internal function to use same API
  function renderChunkContent(sectionConfig, chunkConfig, arg, isHeader) {
      let { expandRows } = arg;
      let content = typeof chunkConfig.content === 'function' ?
          chunkConfig.content(arg) :
          y$1('table', {
              role: 'presentation',
              className: [
                  chunkConfig.tableClassName,
                  sectionConfig.syncRowHeights ? 'fc-scrollgrid-sync-table' : '',
              ].join(' '),
              style: {
                  minWidth: arg.tableMinWidth,
                  width: arg.clientWidth,
                  height: expandRows ? arg.clientHeight : '', // css `height` on a <table> serves as a min-height
              },
          }, arg.tableColGroupNode, y$1(isHeader ? 'thead' : 'tbody', {
              role: 'presentation',
          }, typeof chunkConfig.rowContent === 'function'
              ? chunkConfig.rowContent(arg)
              : chunkConfig.rowContent));
      return content;
  }
  function isColPropsEqual(cols0, cols1) {
      return isArraysEqual(cols0, cols1, isPropsEqual);
  }
  function renderMicroColGroup(cols, shrinkWidth) {
      let colNodes = [];
      /*
      for ColProps with spans, it would have been great to make a single <col span="">
      HOWEVER, Chrome was getting messing up distributing the width to <td>/<th> elements with colspans.
      SOLUTION: making individual <col> elements makes Chrome behave.
      */
      for (let colProps of cols) {
          let span = colProps.span || 1;
          for (let i = 0; i < span; i += 1) {
              colNodes.push(y$1("col", { style: {
                      width: colProps.width === 'shrink' ? sanitizeShrinkWidth(shrinkWidth) : (colProps.width || ''),
                      minWidth: colProps.minWidth || '',
                  } }));
          }
      }
      return y$1('colgroup', {}, ...colNodes);
  }
  function sanitizeShrinkWidth(shrinkWidth) {
      /* why 4? if we do 0, it will kill any border, which are needed for computeSmallestCellWidth
      4 accounts for 2 2-pixel borders. TODO: better solution? */
      return shrinkWidth == null ? 4 : shrinkWidth;
  }
  function hasShrinkWidth(cols) {
      for (let col of cols) {
          if (col.width === 'shrink') {
              return true;
          }
      }
      return false;
  }
  function getScrollGridClassNames(liquid, context) {
      let classNames = [
          'fc-scrollgrid',
          context.theme.getClass('table'),
      ];
      if (liquid) {
          classNames.push('fc-scrollgrid-liquid');
      }
      return classNames;
  }
  function getSectionClassNames(sectionConfig, wholeTableVGrow) {
      let classNames = [
          'fc-scrollgrid-section',
          `fc-scrollgrid-section-${sectionConfig.type}`,
          sectionConfig.className, // used?
      ];
      if (wholeTableVGrow && sectionConfig.liquid && sectionConfig.maxHeight == null) {
          classNames.push('fc-scrollgrid-section-liquid');
      }
      if (sectionConfig.isSticky) {
          classNames.push('fc-scrollgrid-section-sticky');
      }
      return classNames;
  }
  function renderScrollShim(arg) {
      return (y$1("div", { className: "fc-scrollgrid-sticky-shim", style: {
              width: arg.clientWidth,
              minWidth: arg.tableMinWidth,
          } }));
  }
  function getStickyHeaderDates(options) {
      let { stickyHeaderDates } = options;
      if (stickyHeaderDates == null || stickyHeaderDates === 'auto') {
          stickyHeaderDates = options.height === 'auto' || options.viewHeight === 'auto';
      }
      return stickyHeaderDates;
  }
  function getStickyFooterScrollbar(options) {
      let { stickyFooterScrollbar } = options;
      if (stickyFooterScrollbar == null || stickyFooterScrollbar === 'auto') {
          stickyFooterScrollbar = options.height === 'auto' || options.viewHeight === 'auto';
      }
      return stickyFooterScrollbar;
  }

  class SimpleScrollGrid extends BaseComponent {
      constructor() {
          super(...arguments);
          this.processCols = memoize((a) => a, isColPropsEqual); // so we get same `cols` props every time
          // yucky to memoize VNodes, but much more efficient for consumers
          this.renderMicroColGroup = memoize(renderMicroColGroup);
          this.scrollerRefs = new RefMap();
          this.scrollerElRefs = new RefMap(this._handleScrollerEl.bind(this));
          this.state = {
              shrinkWidth: null,
              forceYScrollbars: false,
              scrollerClientWidths: {},
              scrollerClientHeights: {},
          };
          // TODO: can do a really simple print-view. dont need to join rows
          this.handleSizing = () => {
              this.safeSetState(Object.assign({ shrinkWidth: this.computeShrinkWidth() }, this.computeScrollerDims()));
          };
      }
      render() {
          let { props, state, context } = this;
          let sectionConfigs = props.sections || [];
          let cols = this.processCols(props.cols);
          let microColGroupNode = this.renderMicroColGroup(cols, state.shrinkWidth);
          let classNames = getScrollGridClassNames(props.liquid, context);
          if (props.collapsibleWidth) {
              classNames.push('fc-scrollgrid-collapsible');
          }
          // TODO: make DRY
          let configCnt = sectionConfigs.length;
          let configI = 0;
          let currentConfig;
          let headSectionNodes = [];
          let bodySectionNodes = [];
          let footSectionNodes = [];
          while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'header') {
              headSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));
              configI += 1;
          }
          while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'body') {
              bodySectionNodes.push(this.renderSection(currentConfig, microColGroupNode, false));
              configI += 1;
          }
          while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'footer') {
              footSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));
              configI += 1;
          }
          // firefox bug: when setting height on table and there is a thead or tfoot,
          // the necessary height:100% on the liquid-height body section forces the *whole* table to be taller. (bug #5524)
          // use getCanVGrowWithinCell as a way to detect table-stupid firefox.
          // if so, use a simpler dom structure, jam everything into a lone tbody.
          let isBuggy = !getCanVGrowWithinCell();
          const roleAttrs = { role: 'rowgroup' };
          return y$1('table', {
              role: 'grid',
              className: classNames.join(' '),
              style: { height: props.height },
          }, Boolean(!isBuggy && headSectionNodes.length) && y$1('thead', roleAttrs, ...headSectionNodes), Boolean(!isBuggy && bodySectionNodes.length) && y$1('tbody', roleAttrs, ...bodySectionNodes), Boolean(!isBuggy && footSectionNodes.length) && y$1('tfoot', roleAttrs, ...footSectionNodes), isBuggy && y$1('tbody', roleAttrs, ...headSectionNodes, ...bodySectionNodes, ...footSectionNodes));
      }
      renderSection(sectionConfig, microColGroupNode, isHeader) {
          if ('outerContent' in sectionConfig) {
              return (y$1(_, { key: sectionConfig.key }, sectionConfig.outerContent));
          }
          return (y$1("tr", { key: sectionConfig.key, role: "presentation", className: getSectionClassNames(sectionConfig, this.props.liquid).join(' ') }, this.renderChunkTd(sectionConfig, microColGroupNode, sectionConfig.chunk, isHeader)));
      }
      renderChunkTd(sectionConfig, microColGroupNode, chunkConfig, isHeader) {
          if ('outerContent' in chunkConfig) {
              return chunkConfig.outerContent;
          }
          let { props } = this;
          let { forceYScrollbars, scrollerClientWidths, scrollerClientHeights } = this.state;
          let needsYScrolling = getAllowYScrolling(props, sectionConfig); // TODO: do lazily. do in section config?
          let isLiquid = getSectionHasLiquidHeight(props, sectionConfig);
          // for `!props.liquid` - is WHOLE scrollgrid natural height?
          // TODO: do same thing in advanced scrollgrid? prolly not b/c always has horizontal scrollbars
          let overflowY = !props.liquid ? 'visible' :
              forceYScrollbars ? 'scroll' :
                  !needsYScrolling ? 'hidden' :
                      'auto';
          let sectionKey = sectionConfig.key;
          let content = renderChunkContent(sectionConfig, chunkConfig, {
              tableColGroupNode: microColGroupNode,
              tableMinWidth: '',
              clientWidth: (!props.collapsibleWidth && scrollerClientWidths[sectionKey] !== undefined) ? scrollerClientWidths[sectionKey] : null,
              clientHeight: scrollerClientHeights[sectionKey] !== undefined ? scrollerClientHeights[sectionKey] : null,
              expandRows: sectionConfig.expandRows,
              syncRowHeights: false,
              rowSyncHeights: [],
              reportRowHeightChange: () => { },
          }, isHeader);
          return y$1(isHeader ? 'th' : 'td', {
              ref: chunkConfig.elRef,
              role: 'presentation',
          }, y$1("div", { className: `fc-scroller-harness${isLiquid ? ' fc-scroller-harness-liquid' : ''}` },
              y$1(Scroller, { ref: this.scrollerRefs.createRef(sectionKey), elRef: this.scrollerElRefs.createRef(sectionKey), overflowY: overflowY, overflowX: !props.liquid ? 'visible' : 'hidden' /* natural height? */, maxHeight: sectionConfig.maxHeight, liquid: isLiquid, liquidIsAbsolute // because its within a harness
                  : true }, content)));
      }
      _handleScrollerEl(scrollerEl, key) {
          let section = getSectionByKey(this.props.sections, key);
          if (section) {
              setRef(section.chunk.scrollerElRef, scrollerEl);
          }
      }
      componentDidMount() {
          this.handleSizing();
          this.context.addResizeHandler(this.handleSizing);
      }
      componentDidUpdate() {
          // TODO: need better solution when state contains non-sizing things
          this.handleSizing();
      }
      componentWillUnmount() {
          this.context.removeResizeHandler(this.handleSizing);
      }
      computeShrinkWidth() {
          return hasShrinkWidth(this.props.cols)
              ? computeShrinkWidth(this.scrollerElRefs.getAll())
              : 0;
      }
      computeScrollerDims() {
          let scrollbarWidth = getScrollbarWidths();
          let { scrollerRefs, scrollerElRefs } = this;
          let forceYScrollbars = false;
          let scrollerClientWidths = {};
          let scrollerClientHeights = {};
          for (let sectionKey in scrollerRefs.currentMap) {
              let scroller = scrollerRefs.currentMap[sectionKey];
              if (scroller && scroller.needsYScrolling()) {
                  forceYScrollbars = true;
                  break;
              }
          }
          for (let section of this.props.sections) {
              let sectionKey = section.key;
              let scrollerEl = scrollerElRefs.currentMap[sectionKey];
              if (scrollerEl) {
                  let harnessEl = scrollerEl.parentNode; // TODO: weird way to get this. need harness b/c doesn't include table borders
                  scrollerClientWidths[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().width - (forceYScrollbars
                      ? scrollbarWidth.y // use global because scroller might not have scrollbars yet but will need them in future
                      : 0));
                  scrollerClientHeights[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().height);
              }
          }
          return { forceYScrollbars, scrollerClientWidths, scrollerClientHeights };
      }
  }
  SimpleScrollGrid.addStateEquality({
      scrollerClientWidths: isPropsEqual,
      scrollerClientHeights: isPropsEqual,
  });
  function getSectionByKey(sections, key) {
      for (let section of sections) {
          if (section.key === key) {
              return section;
          }
      }
      return null;
  }

  class EventContainer extends BaseComponent {
      constructor() {
          super(...arguments);
          this.handleEl = (el) => {
              this.el = el;
              if (el) {
                  setElSeg(el, this.props.seg);
              }
          };
      }
      render() {
          const { props, context } = this;
          const { options } = context;
          const { seg } = props;
          const { eventRange } = seg;
          const { ui } = eventRange;
          const renderProps = {
              event: new EventImpl(context, eventRange.def, eventRange.instance),
              view: context.viewApi,
              timeText: props.timeText,
              textColor: ui.textColor,
              backgroundColor: ui.backgroundColor,
              borderColor: ui.borderColor,
              isDraggable: !props.disableDragging && computeSegDraggable(seg, context),
              isStartResizable: !props.disableResizing && computeSegStartResizable(seg, context),
              isEndResizable: !props.disableResizing && computeSegEndResizable(seg),
              isMirror: Boolean(props.isDragging || props.isResizing || props.isDateSelecting),
              isStart: Boolean(seg.isStart),
              isEnd: Boolean(seg.isEnd),
              isPast: Boolean(props.isPast),
              isFuture: Boolean(props.isFuture),
              isToday: Boolean(props.isToday),
              isSelected: Boolean(props.isSelected),
              isDragging: Boolean(props.isDragging),
              isResizing: Boolean(props.isResizing),
          };
          return (y$1(ContentContainer, Object.assign({}, props /* contains children */, { elRef: this.handleEl, elClasses: [
                  ...getEventClassNames(renderProps),
                  ...seg.eventRange.ui.classNames,
                  ...(props.elClasses || []),
              ], renderProps: renderProps, generatorName: "eventContent", customGenerator: options.eventContent, defaultGenerator: props.defaultGenerator, classNameGenerator: options.eventClassNames, didMount: options.eventDidMount, willUnmount: options.eventWillUnmount })));
      }
      componentDidUpdate(prevProps) {
          if (this.el && this.props.seg !== prevProps.seg) {
              setElSeg(this.el, this.props.seg);
          }
      }
  }

  // should not be a purecomponent
  class StandardEvent extends BaseComponent {
      render() {
          let { props, context } = this;
          let { options } = context;
          let { seg } = props;
          let { ui } = seg.eventRange;
          let timeFormat = options.eventTimeFormat || props.defaultTimeFormat;
          let timeText = buildSegTimeText(seg, timeFormat, context, props.defaultDisplayEventTime, props.defaultDisplayEventEnd);
          return (y$1(EventContainer, Object.assign({}, props /* includes elRef */, { elTag: "a", elStyle: {
                  borderColor: ui.borderColor,
                  backgroundColor: ui.backgroundColor,
              }, elAttrs: getSegAnchorAttrs(seg, context), defaultGenerator: renderInnerContent$1$1, timeText: timeText }), (InnerContent, eventContentArg) => (y$1(_, null,
              y$1(InnerContent, { elTag: "div", elClasses: ['fc-event-main'], elStyle: { color: eventContentArg.textColor } }),
              Boolean(eventContentArg.isStartResizable) && (y$1("div", { className: "fc-event-resizer fc-event-resizer-start" })),
              Boolean(eventContentArg.isEndResizable) && (y$1("div", { className: "fc-event-resizer fc-event-resizer-end" }))))));
      }
  }
  function renderInnerContent$1$1(innerProps) {
      return (y$1("div", { className: "fc-event-main-frame" },
          innerProps.timeText && (y$1("div", { className: "fc-event-time" }, innerProps.timeText)),
          y$1("div", { className: "fc-event-title-container" },
              y$1("div", { className: "fc-event-title fc-sticky" }, innerProps.event.title || y$1(_, null, "\u00A0")))));
  }

  const NowIndicatorContainer = (props) => (y$1(ViewContextType.Consumer, null, (context) => {
      let { options } = context;
      let renderProps = {
          isAxis: props.isAxis,
          date: context.dateEnv.toDate(props.date),
          view: context.viewApi,
      };
      return (y$1(ContentContainer, Object.assign({}, props /* includes children */, { elTag: props.elTag || 'div', renderProps: renderProps, generatorName: "nowIndicatorContent", customGenerator: options.nowIndicatorContent, classNameGenerator: options.nowIndicatorClassNames, didMount: options.nowIndicatorDidMount, willUnmount: options.nowIndicatorWillUnmount })));
  }));

  const DAY_NUM_FORMAT = createFormatter({ day: 'numeric' });
  class DayCellContainer extends BaseComponent {
      constructor() {
          super(...arguments);
          this.refineRenderProps = memoizeObjArg(refineRenderProps);
      }
      render() {
          let { props, context } = this;
          let { options } = context;
          let renderProps = this.refineRenderProps({
              date: props.date,
              dateProfile: props.dateProfile,
              todayRange: props.todayRange,
              isMonthStart: props.isMonthStart || false,
              showDayNumber: props.showDayNumber,
              extraRenderProps: props.extraRenderProps,
              viewApi: context.viewApi,
              dateEnv: context.dateEnv,
              monthStartFormat: options.monthStartFormat,
          });
          return (y$1(ContentContainer, Object.assign({}, props /* includes children */, { elClasses: [
                  ...getDayClassNames(renderProps, context.theme),
                  ...(props.elClasses || []),
              ], elAttrs: Object.assign(Object.assign({}, props.elAttrs), (renderProps.isDisabled ? {} : { 'data-date': formatDayString(props.date) })), renderProps: renderProps, generatorName: "dayCellContent", customGenerator: options.dayCellContent, defaultGenerator: props.defaultGenerator, classNameGenerator: 
              // don't use custom classNames if disabled
              renderProps.isDisabled ? undefined : options.dayCellClassNames, didMount: options.dayCellDidMount, willUnmount: options.dayCellWillUnmount })));
      }
  }
  function hasCustomDayCellContent(options) {
      return Boolean(options.dayCellContent || hasCustomRenderingHandler('dayCellContent', options));
  }
  function refineRenderProps(raw) {
      let { date, dateEnv, dateProfile, isMonthStart } = raw;
      let dayMeta = getDateMeta(date, raw.todayRange, null, dateProfile);
      let dayNumberText = raw.showDayNumber ? (dateEnv.format(date, isMonthStart ? raw.monthStartFormat : DAY_NUM_FORMAT)) : '';
      return Object.assign(Object.assign(Object.assign({ date: dateEnv.toDate(date), view: raw.viewApi }, dayMeta), { isMonthStart,
          dayNumberText }), raw.extraRenderProps);
  }

  class BgEvent extends BaseComponent {
      render() {
          let { props } = this;
          let { seg } = props;
          return (y$1(EventContainer, { elTag: "div", elClasses: ['fc-bg-event'], elStyle: { backgroundColor: seg.eventRange.ui.backgroundColor }, defaultGenerator: renderInnerContent$3, seg: seg, timeText: "", isDragging: false, isResizing: false, isDateSelecting: false, isSelected: false, isPast: props.isPast, isFuture: props.isFuture, isToday: props.isToday, disableDragging: true, disableResizing: true }));
      }
  }
  function renderInnerContent$3(props) {
      let { title } = props.event;
      return title && (y$1("div", { className: "fc-event-title" }, props.event.title));
  }
  function renderFill(fillType) {
      return (y$1("div", { className: `fc-${fillType}` }));
  }

  const WeekNumberContainer = (props) => (y$1(ViewContextType.Consumer, null, (context) => {
      let { dateEnv, options } = context;
      let { date } = props;
      let format = options.weekNumberFormat || props.defaultFormat;
      let num = dateEnv.computeWeekNumber(date); // TODO: somehow use for formatting as well?
      let text = dateEnv.format(date, format);
      let renderProps = { num, text, date };
      return (y$1(ContentContainer // why isn't WeekNumberContentArg being auto-detected?
      , Object.assign({}, props /* includes children */, { renderProps: renderProps, generatorName: "weekNumberContent", customGenerator: options.weekNumberContent, defaultGenerator: renderInner, classNameGenerator: options.weekNumberClassNames, didMount: options.weekNumberDidMount, willUnmount: options.weekNumberWillUnmount })));
  }));
  function renderInner(innerProps) {
      return innerProps.text;
  }

  const PADDING_FROM_VIEWPORT = 10;
  class Popover extends BaseComponent {
      constructor() {
          super(...arguments);
          this.state = {
              titleId: getUniqueDomId(),
          };
          this.handleRootEl = (el) => {
              this.rootEl = el;
              if (this.props.elRef) {
                  setRef(this.props.elRef, el);
              }
          };
          // Triggered when the user clicks *anywhere* in the document, for the autoHide feature
          this.handleDocumentMouseDown = (ev) => {
              // only hide the popover if the click happened outside the popover
              const target = getEventTargetViaRoot(ev);
              if (!this.rootEl.contains(target)) {
                  this.handleCloseClick();
              }
          };
          this.handleDocumentKeyDown = (ev) => {
              if (ev.key === 'Escape') {
                  this.handleCloseClick();
              }
          };
          this.handleCloseClick = () => {
              let { onClose } = this.props;
              if (onClose) {
                  onClose();
              }
          };
      }
      render() {
          let { theme, options } = this.context;
          let { props, state } = this;
          let classNames = [
              'fc-popover',
              theme.getClass('popover'),
          ].concat(props.extraClassNames || []);
          return j(y$1("div", Object.assign({}, props.extraAttrs, { id: props.id, className: classNames.join(' '), "aria-labelledby": state.titleId, ref: this.handleRootEl }),
              y$1("div", { className: 'fc-popover-header ' + theme.getClass('popoverHeader') },
                  y$1("span", { className: "fc-popover-title", id: state.titleId }, props.title),
                  y$1("span", { className: 'fc-popover-close ' + theme.getIconClass('close'), title: options.closeHint, onClick: this.handleCloseClick })),
              y$1("div", { className: 'fc-popover-body ' + theme.getClass('popoverContent') }, props.children)), props.parentEl);
      }
      componentDidMount() {
          document.addEventListener('mousedown', this.handleDocumentMouseDown);
          document.addEventListener('keydown', this.handleDocumentKeyDown);
          this.updateSize();
      }
      componentWillUnmount() {
          document.removeEventListener('mousedown', this.handleDocumentMouseDown);
          document.removeEventListener('keydown', this.handleDocumentKeyDown);
      }
      updateSize() {
          let { isRtl } = this.context;
          let { alignmentEl, alignGridTop } = this.props;
          let { rootEl } = this;
          let alignmentRect = computeClippedClientRect(alignmentEl);
          if (alignmentRect) {
              let popoverDims = rootEl.getBoundingClientRect();
              // position relative to viewport
              let popoverTop = alignGridTop
                  ? elementClosest(alignmentEl, '.fc-scrollgrid').getBoundingClientRect().top
                  : alignmentRect.top;
              let popoverLeft = isRtl ? alignmentRect.right - popoverDims.width : alignmentRect.left;
              // constrain
              popoverTop = Math.max(popoverTop, PADDING_FROM_VIEWPORT);
              popoverLeft = Math.min(popoverLeft, document.documentElement.clientWidth - PADDING_FROM_VIEWPORT - popoverDims.width);
              popoverLeft = Math.max(popoverLeft, PADDING_FROM_VIEWPORT);
              let origin = rootEl.offsetParent.getBoundingClientRect();
              applyStyle(rootEl, {
                  top: popoverTop - origin.top,
                  left: popoverLeft - origin.left,
              });
          }
      }
  }

  class MorePopover extends DateComponent {
      constructor() {
          super(...arguments);
          this.handleRootEl = (rootEl) => {
              this.rootEl = rootEl;
              if (rootEl) {
                  this.context.registerInteractiveComponent(this, {
                      el: rootEl,
                      useEventCenter: false,
                  });
              }
              else {
                  this.context.unregisterInteractiveComponent(this);
              }
          };
      }
      render() {
          let { options, dateEnv } = this.context;
          let { props } = this;
          let { startDate, todayRange, dateProfile } = props;
          let title = dateEnv.format(startDate, options.dayPopoverFormat);
          return (y$1(DayCellContainer, { elRef: this.handleRootEl, date: startDate, dateProfile: dateProfile, todayRange: todayRange }, (InnerContent, renderProps, elAttrs) => (y$1(Popover, { elRef: elAttrs.ref, id: props.id, title: title, extraClassNames: ['fc-more-popover'].concat(elAttrs.className || []), extraAttrs: elAttrs /* TODO: make these time-based when not whole-day? */, parentEl: props.parentEl, alignmentEl: props.alignmentEl, alignGridTop: props.alignGridTop, onClose: props.onClose },
              hasCustomDayCellContent(options) && (y$1(InnerContent, { elTag: "div", elClasses: ['fc-more-popover-misc'] })),
              props.children))));
      }
      queryHit(positionLeft, positionTop, elWidth, elHeight) {
          let { rootEl, props } = this;
          if (positionLeft >= 0 && positionLeft < elWidth &&
              positionTop >= 0 && positionTop < elHeight) {
              return {
                  dateProfile: props.dateProfile,
                  dateSpan: Object.assign({ allDay: !props.forceTimed, range: {
                          start: props.startDate,
                          end: props.endDate,
                      } }, props.extraDateSpan),
                  dayEl: rootEl,
                  rect: {
                      left: 0,
                      top: 0,
                      right: elWidth,
                      bottom: elHeight,
                  },
                  layer: 1, // important when comparing with hits from other components
              };
          }
          return null;
      }
  }

  class MoreLinkContainer extends BaseComponent {
      constructor() {
          super(...arguments);
          this.state = {
              isPopoverOpen: false,
              popoverId: getUniqueDomId(),
          };
          this.handleLinkEl = (linkEl) => {
              this.linkEl = linkEl;
              if (this.props.elRef) {
                  setRef(this.props.elRef, linkEl);
              }
          };
          this.handleClick = (ev) => {
              let { props, context } = this;
              let { moreLinkClick } = context.options;
              let date = computeRange(props).start;
              function buildPublicSeg(seg) {
                  let { def, instance, range } = seg.eventRange;
                  return {
                      event: new EventImpl(context, def, instance),
                      start: context.dateEnv.toDate(range.start),
                      end: context.dateEnv.toDate(range.end),
                      isStart: seg.isStart,
                      isEnd: seg.isEnd,
                  };
              }
              if (typeof moreLinkClick === 'function') {
                  moreLinkClick = moreLinkClick({
                      date,
                      allDay: Boolean(props.allDayDate),
                      allSegs: props.allSegs.map(buildPublicSeg),
                      hiddenSegs: props.hiddenSegs.map(buildPublicSeg),
                      jsEvent: ev,
                      view: context.viewApi,
                  });
              }
              if (!moreLinkClick || moreLinkClick === 'popover') {
                  this.setState({ isPopoverOpen: true });
              }
              else if (typeof moreLinkClick === 'string') { // a view name
                  context.calendarApi.zoomTo(date, moreLinkClick);
              }
          };
          this.handlePopoverClose = () => {
              this.setState({ isPopoverOpen: false });
          };
      }
      render() {
          let { props, state } = this;
          return (y$1(ViewContextType.Consumer, null, (context) => {
              let { viewApi, options, calendarApi } = context;
              let { moreLinkText } = options;
              let { moreCnt } = props;
              let range = computeRange(props);
              let text = typeof moreLinkText === 'function' // TODO: eventually use formatWithOrdinals
                  ? moreLinkText.call(calendarApi, moreCnt)
                  : `+${moreCnt} ${moreLinkText}`;
              let hint = formatWithOrdinals(options.moreLinkHint, [moreCnt], text);
              let renderProps = {
                  num: moreCnt,
                  shortText: `+${moreCnt}`,
                  text,
                  view: viewApi,
              };
              return (y$1(_, null,
                  Boolean(props.moreCnt) && (y$1(ContentContainer, { elTag: props.elTag || 'a', elRef: this.handleLinkEl, elClasses: [
                          ...(props.elClasses || []),
                          'fc-more-link',
                      ], elStyle: props.elStyle, elAttrs: Object.assign(Object.assign(Object.assign({}, props.elAttrs), createAriaClickAttrs(this.handleClick)), { title: hint, 'aria-expanded': state.isPopoverOpen, 'aria-controls': state.isPopoverOpen ? state.popoverId : '' }), renderProps: renderProps, generatorName: "moreLinkContent", customGenerator: options.moreLinkContent, defaultGenerator: props.defaultGenerator || renderMoreLinkInner$1, classNameGenerator: options.moreLinkClassNames, didMount: options.moreLinkDidMount, willUnmount: options.moreLinkWillUnmount }, props.children)),
                  state.isPopoverOpen && (y$1(MorePopover, { id: state.popoverId, startDate: range.start, endDate: range.end, dateProfile: props.dateProfile, todayRange: props.todayRange, extraDateSpan: props.extraDateSpan, parentEl: this.parentEl, alignmentEl: props.alignmentElRef ?
                          props.alignmentElRef.current :
                          this.linkEl, alignGridTop: props.alignGridTop, forceTimed: props.forceTimed, onClose: this.handlePopoverClose }, props.popoverContent()))));
          }));
      }
      componentDidMount() {
          this.updateParentEl();
      }
      componentDidUpdate() {
          this.updateParentEl();
      }
      updateParentEl() {
          if (this.linkEl) {
              this.parentEl = elementClosest(this.linkEl, '.fc-view-harness');
          }
      }
  }
  function renderMoreLinkInner$1(props) {
      return props.text;
  }
  function computeRange(props) {
      if (props.allDayDate) {
          return {
              start: props.allDayDate,
              end: addDays(props.allDayDate, 1),
          };
      }
      let { hiddenSegs } = props;
      return {
          start: computeEarliestSegStart(hiddenSegs),
          end: computeLatestSegEnd(hiddenSegs),
      };
  }
  function computeEarliestSegStart(segs) {
      return segs.reduce(pickEarliestStart).eventRange.range.start;
  }
  function pickEarliestStart(seg0, seg1) {
      return seg0.eventRange.range.start < seg1.eventRange.range.start ? seg0 : seg1;
  }
  function computeLatestSegEnd(segs) {
      return segs.reduce(pickLatestEnd).eventRange.range.end;
  }
  function pickLatestEnd(seg0, seg1) {
      return seg0.eventRange.range.end > seg1.eventRange.range.end ? seg0 : seg1;
  }

  class ViewContainer extends BaseComponent {
      render() {
          let { props, context } = this;
          let { options } = context;
          let renderProps = { view: context.viewApi };
          return (y$1(ContentContainer, Object.assign({}, props, { elTag: props.elTag || 'div', elClasses: [
                  ...buildViewClassNames(props.viewSpec),
                  ...(props.elClasses || []),
              ], renderProps: renderProps, classNameGenerator: options.viewClassNames, generatorName: undefined, didMount: options.viewDidMount, willUnmount: options.viewWillUnmount }), () => props.children));
      }
  }
  function buildViewClassNames(viewSpec) {
      return [
          `fc-${viewSpec.type}-view`,
          'fc-view',
      ];
  }

  const EVENT_SOURCE_REFINERS$1 = {
      id: String,
      defaultAllDay: Boolean,
      url: String,
      format: String,
      events: identity,
      eventDataTransform: identity,
      // for any network-related sources
      success: identity,
      failure: identity,
  };
  function parseEventSource(raw, context, refiners = buildEventSourceRefiners(context)) {
      let rawObj;
      if (typeof raw === 'string') {
          rawObj = { url: raw };
      }
      else if (typeof raw === 'function' || Array.isArray(raw)) {
          rawObj = { events: raw };
      }
      else if (typeof raw === 'object' && raw) { // not null
          rawObj = raw;
      }
      if (rawObj) {
          let { refined, extra } = refineProps(rawObj, refiners);
          let metaRes = buildEventSourceMeta(refined, context);
          if (metaRes) {
              return {
                  _raw: raw,
                  isFetching: false,
                  latestFetchId: '',
                  fetchRange: null,
                  defaultAllDay: refined.defaultAllDay,
                  eventDataTransform: refined.eventDataTransform,
                  success: refined.success,
                  failure: refined.failure,
                  publicId: refined.id || '',
                  sourceId: guid(),
                  sourceDefId: metaRes.sourceDefId,
                  meta: metaRes.meta,
                  ui: createEventUi(refined, context),
                  extendedProps: extra,
              };
          }
      }
      return null;
  }
  function buildEventSourceRefiners(context) {
      return Object.assign(Object.assign(Object.assign({}, EVENT_UI_REFINERS), EVENT_SOURCE_REFINERS$1), context.pluginHooks.eventSourceRefiners);
  }
  function buildEventSourceMeta(raw, context) {
      let defs = context.pluginHooks.eventSourceDefs;
      for (let i = defs.length - 1; i >= 0; i -= 1) { // later-added plugins take precedence
          let def = defs[i];
          let meta = def.parseMeta(raw);
          if (meta) {
              return { sourceDefId: i, meta };
          }
      }
      return null;
  }

  class CalendarImpl {
      getCurrentData() {
          return this.currentDataManager.getCurrentData();
      }
      dispatch(action) {
          this.currentDataManager.dispatch(action);
      }
      get view() { return this.getCurrentData().viewApi; }
      batchRendering(callback) {
          callback();
      }
      updateSize() {
          this.trigger('_resize', true);
      }
      // Options
      // -----------------------------------------------------------------------------------------------------------------
      setOption(name, val) {
          this.dispatch({
              type: 'SET_OPTION',
              optionName: name,
              rawOptionValue: val,
          });
      }
      getOption(name) {
          return this.currentDataManager.currentCalendarOptionsInput[name];
      }
      getAvailableLocaleCodes() {
          return Object.keys(this.getCurrentData().availableRawLocales);
      }
      // Trigger
      // -----------------------------------------------------------------------------------------------------------------
      on(handlerName, handler) {
          let { currentDataManager } = this;
          if (currentDataManager.currentCalendarOptionsRefiners[handlerName]) {
              currentDataManager.emitter.on(handlerName, handler);
          }
          else {
              console.warn(`Unknown listener name '${handlerName}'`);
          }
      }
      off(handlerName, handler) {
          this.currentDataManager.emitter.off(handlerName, handler);
      }
      // not meant for public use
      trigger(handlerName, ...args) {
          this.currentDataManager.emitter.trigger(handlerName, ...args);
      }
      // View
      // -----------------------------------------------------------------------------------------------------------------
      changeView(viewType, dateOrRange) {
          this.batchRendering(() => {
              this.unselect();
              if (dateOrRange) {
                  if (dateOrRange.start && dateOrRange.end) { // a range
                      this.dispatch({
                          type: 'CHANGE_VIEW_TYPE',
                          viewType,
                      });
                      this.dispatch({
                          type: 'SET_OPTION',
                          optionName: 'visibleRange',
                          rawOptionValue: dateOrRange,
                      });
                  }
                  else {
                      let { dateEnv } = this.getCurrentData();
                      this.dispatch({
                          type: 'CHANGE_VIEW_TYPE',
                          viewType,
                          dateMarker: dateEnv.createMarker(dateOrRange),
                      });
                  }
              }
              else {
                  this.dispatch({
                      type: 'CHANGE_VIEW_TYPE',
                      viewType,
                  });
              }
          });
      }
      // Forces navigation to a view for the given date.
      // `viewType` can be a specific view name or a generic one like "week" or "day".
      // needs to change
      zoomTo(dateMarker, viewType) {
          let state = this.getCurrentData();
          let spec;
          viewType = viewType || 'day'; // day is default zoom
          spec = state.viewSpecs[viewType] || this.getUnitViewSpec(viewType);
          this.unselect();
          if (spec) {
              this.dispatch({
                  type: 'CHANGE_VIEW_TYPE',
                  viewType: spec.type,
                  dateMarker,
              });
          }
          else {
              this.dispatch({
                  type: 'CHANGE_DATE',
                  dateMarker,
              });
          }
      }
      // Given a duration singular unit, like "week" or "day", finds a matching view spec.
      // Preference is given to views that have corresponding buttons.
      getUnitViewSpec(unit) {
          let { viewSpecs, toolbarConfig } = this.getCurrentData();
          let viewTypes = [].concat(toolbarConfig.header ? toolbarConfig.header.viewsWithButtons : [], toolbarConfig.footer ? toolbarConfig.footer.viewsWithButtons : []);
          let i;
          let spec;
          for (let viewType in viewSpecs) {
              viewTypes.push(viewType);
          }
          for (i = 0; i < viewTypes.length; i += 1) {
              spec = viewSpecs[viewTypes[i]];
              if (spec) {
                  if (spec.singleUnit === unit) {
                      return spec;
                  }
              }
          }
          return null;
      }
      // Current Date
      // -----------------------------------------------------------------------------------------------------------------
      prev() {
          this.unselect();
          this.dispatch({ type: 'PREV' });
      }
      next() {
          this.unselect();
          this.dispatch({ type: 'NEXT' });
      }
      prevYear() {
          let state = this.getCurrentData();
          this.unselect();
          this.dispatch({
              type: 'CHANGE_DATE',
              dateMarker: state.dateEnv.addYears(state.currentDate, -1),
          });
      }
      nextYear() {
          let state = this.getCurrentData();
          this.unselect();
          this.dispatch({
              type: 'CHANGE_DATE',
              dateMarker: state.dateEnv.addYears(state.currentDate, 1),
          });
      }
      today() {
          let state = this.getCurrentData();
          this.unselect();
          this.dispatch({
              type: 'CHANGE_DATE',
              dateMarker: getNow(state.calendarOptions.now, state.dateEnv),
          });
      }
      gotoDate(zonedDateInput) {
          let state = this.getCurrentData();
          this.unselect();
          this.dispatch({
              type: 'CHANGE_DATE',
              dateMarker: state.dateEnv.createMarker(zonedDateInput),
          });
      }
      incrementDate(deltaInput) {
          let state = this.getCurrentData();
          let delta = createDuration(deltaInput);
          if (delta) { // else, warn about invalid input?
              this.unselect();
              this.dispatch({
                  type: 'CHANGE_DATE',
                  dateMarker: state.dateEnv.add(state.currentDate, delta),
              });
          }
      }
      getDate() {
          let state = this.getCurrentData();
          return state.dateEnv.toDate(state.currentDate);
      }
      // Date Formatting Utils
      // -----------------------------------------------------------------------------------------------------------------
      formatDate(d, formatter) {
          let { dateEnv } = this.getCurrentData();
          return dateEnv.format(dateEnv.createMarker(d), createFormatter(formatter));
      }
      // `settings` is for formatter AND isEndExclusive
      formatRange(d0, d1, settings) {
          let { dateEnv } = this.getCurrentData();
          return dateEnv.formatRange(dateEnv.createMarker(d0), dateEnv.createMarker(d1), createFormatter(settings), settings);
      }
      formatIso(d, omitTime) {
          let { dateEnv } = this.getCurrentData();
          return dateEnv.formatIso(dateEnv.createMarker(d), { omitTime });
      }
      // Date Selection / Event Selection / DayClick
      // -----------------------------------------------------------------------------------------------------------------
      select(dateOrObj, endDate) {
          let selectionInput;
          if (endDate == null) {
              if (dateOrObj.start != null) {
                  selectionInput = dateOrObj;
              }
              else {
                  selectionInput = {
                      start: dateOrObj,
                      end: null,
                  };
              }
          }
          else {
              selectionInput = {
                  start: dateOrObj,
                  end: endDate,
              };
          }
          let state = this.getCurrentData();
          let selection = parseDateSpan(selectionInput, state.dateEnv, createDuration({ days: 1 }));
          if (selection) { // throw parse error otherwise?
              this.dispatch({ type: 'SELECT_DATES', selection });
              triggerDateSelect(selection, null, state);
          }
      }
      unselect(pev) {
          let state = this.getCurrentData();
          if (state.dateSelection) {
              this.dispatch({ type: 'UNSELECT_DATES' });
              triggerDateUnselect(pev, state);
          }
      }
      // Public Events API
      // -----------------------------------------------------------------------------------------------------------------
      addEvent(eventInput, sourceInput) {
          if (eventInput instanceof EventImpl) {
              let def = eventInput._def;
              let instance = eventInput._instance;
              let currentData = this.getCurrentData();
              // not already present? don't want to add an old snapshot
              if (!currentData.eventStore.defs[def.defId]) {
                  this.dispatch({
                      type: 'ADD_EVENTS',
                      eventStore: eventTupleToStore({ def, instance }), // TODO: better util for two args?
                  });
                  this.triggerEventAdd(eventInput);
              }
              return eventInput;
          }
          let state = this.getCurrentData();
          let eventSource;
          if (sourceInput instanceof EventSourceImpl) {
              eventSource = sourceInput.internalEventSource;
          }
          else if (typeof sourceInput === 'boolean') {
              if (sourceInput) { // true. part of the first event source
                  [eventSource] = hashValuesToArray(state.eventSources);
              }
          }
          else if (sourceInput != null) { // an ID. accepts a number too
              let sourceApi = this.getEventSourceById(sourceInput); // TODO: use an internal function
              if (!sourceApi) {
                  console.warn(`Could not find an event source with ID "${sourceInput}"`); // TODO: test
                  return null;
              }
              eventSource = sourceApi.internalEventSource;
          }
          let tuple = parseEvent(eventInput, eventSource, state, false);
          if (tuple) {
              let newEventApi = new EventImpl(state, tuple.def, tuple.def.recurringDef ? null : tuple.instance);
              this.dispatch({
                  type: 'ADD_EVENTS',
                  eventStore: eventTupleToStore(tuple),
              });
              this.triggerEventAdd(newEventApi);
              return newEventApi;
          }
          return null;
      }
      triggerEventAdd(eventApi) {
          let { emitter } = this.getCurrentData();
          emitter.trigger('eventAdd', {
              event: eventApi,
              relatedEvents: [],
              revert: () => {
                  this.dispatch({
                      type: 'REMOVE_EVENTS',
                      eventStore: eventApiToStore(eventApi),
                  });
              },
          });
      }
      // TODO: optimize
      getEventById(id) {
          let state = this.getCurrentData();
          let { defs, instances } = state.eventStore;
          id = String(id);
          for (let defId in defs) {
              let def = defs[defId];
              if (def.publicId === id) {
                  if (def.recurringDef) {
                      return new EventImpl(state, def, null);
                  }
                  for (let instanceId in instances) {
                      let instance = instances[instanceId];
                      if (instance.defId === def.defId) {
                          return new EventImpl(state, def, instance);
                      }
                  }
              }
          }
          return null;
      }
      getEvents() {
          let currentData = this.getCurrentData();
          return buildEventApis(currentData.eventStore, currentData);
      }
      removeAllEvents() {
          this.dispatch({ type: 'REMOVE_ALL_EVENTS' });
      }
      // Public Event Sources API
      // -----------------------------------------------------------------------------------------------------------------
      getEventSources() {
          let state = this.getCurrentData();
          let sourceHash = state.eventSources;
          let sourceApis = [];
          for (let internalId in sourceHash) {
              sourceApis.push(new EventSourceImpl(state, sourceHash[internalId]));
          }
          return sourceApis;
      }
      getEventSourceById(id) {
          let state = this.getCurrentData();
          let sourceHash = state.eventSources;
          id = String(id);
          for (let sourceId in sourceHash) {
              if (sourceHash[sourceId].publicId === id) {
                  return new EventSourceImpl(state, sourceHash[sourceId]);
              }
          }
          return null;
      }
      addEventSource(sourceInput) {
          let state = this.getCurrentData();
          if (sourceInput instanceof EventSourceImpl) {
              // not already present? don't want to add an old snapshot
              if (!state.eventSources[sourceInput.internalEventSource.sourceId]) {
                  this.dispatch({
                      type: 'ADD_EVENT_SOURCES',
                      sources: [sourceInput.internalEventSource],
                  });
              }
              return sourceInput;
          }
          let eventSource = parseEventSource(sourceInput, state);
          if (eventSource) { // TODO: error otherwise?
              this.dispatch({ type: 'ADD_EVENT_SOURCES', sources: [eventSource] });
              return new EventSourceImpl(state, eventSource);
          }
          return null;
      }
      removeAllEventSources() {
          this.dispatch({ type: 'REMOVE_ALL_EVENT_SOURCES' });
      }
      refetchEvents() {
          this.dispatch({ type: 'FETCH_EVENT_SOURCES', isRefetch: true });
      }
      // Scroll
      // -----------------------------------------------------------------------------------------------------------------
      scrollToTime(timeInput) {
          let time = createDuration(timeInput);
          if (time) {
              this.trigger('_scrollRequest', { time });
          }
      }
  }

  const globalLocales = [];

  const MINIMAL_RAW_EN_LOCALE = {
      code: 'en',
      week: {
          dow: 0,
          doy: 4, // 4 days need to be within the year to be considered the first week
      },
      direction: 'ltr',
      buttonText: {
          prev: 'prev',
          next: 'next',
          prevYear: 'prev year',
          nextYear: 'next year',
          year: 'year',
          today: 'today',
          month: 'month',
          week: 'week',
          day: 'day',
          list: 'list',
      },
      weekText: 'W',
      weekTextLong: 'Week',
      closeHint: 'Close',
      timeHint: 'Time',
      eventHint: 'Event',
      allDayText: 'all-day',
      moreLinkText: 'more',
      noEventsText: 'No events to display',
  };
  const RAW_EN_LOCALE = Object.assign(Object.assign({}, MINIMAL_RAW_EN_LOCALE), { 
      // Includes things we don't want other locales to inherit,
      // things that derive from other translatable strings.
      buttonHints: {
          prev: 'Previous $0',
          next: 'Next $0',
          today(buttonText, unit) {
              return (unit === 'day')
                  ? 'Today'
                  : `This ${buttonText}`;
          },
      }, viewHint: '$0 view', navLinkHint: 'Go to $0', moreLinkHint(eventCnt) {
          return `Show ${eventCnt} more event${eventCnt === 1 ? '' : 's'}`;
      } });
  function organizeRawLocales(explicitRawLocales) {
      let defaultCode = explicitRawLocales.length > 0 ? explicitRawLocales[0].code : 'en';
      let allRawLocales = globalLocales.concat(explicitRawLocales);
      let rawLocaleMap = {
          en: RAW_EN_LOCALE,
      };
      for (let rawLocale of allRawLocales) {
          rawLocaleMap[rawLocale.code] = rawLocale;
      }
      return {
          map: rawLocaleMap,
          defaultCode,
      };
  }
  function buildLocale(inputSingular, available) {
      if (typeof inputSingular === 'object' && !Array.isArray(inputSingular)) {
          return parseLocale(inputSingular.code, [inputSingular.code], inputSingular);
      }
      return queryLocale(inputSingular, available);
  }
  function queryLocale(codeArg, available) {
      let codes = [].concat(codeArg || []); // will convert to array
      let raw = queryRawLocale(codes, available) || RAW_EN_LOCALE;
      return parseLocale(codeArg, codes, raw);
  }
  function queryRawLocale(codes, available) {
      for (let i = 0; i < codes.length; i += 1) {
          let parts = codes[i].toLocaleLowerCase().split('-');
          for (let j = parts.length; j > 0; j -= 1) {
              let simpleId = parts.slice(0, j).join('-');
              if (available[simpleId]) {
                  return available[simpleId];
              }
          }
      }
      return null;
  }
  function parseLocale(codeArg, codes, raw) {
      let merged = mergeProps([MINIMAL_RAW_EN_LOCALE, raw], ['buttonText']);
      delete merged.code; // don't want this part of the options
      let { week } = merged;
      delete merged.week;
      return {
          codeArg,
          codes,
          week,
          simpleNumberFormat: new Intl.NumberFormat(codeArg),
          options: merged,
      };
  }

  // TODO: easier way to add new hooks? need to update a million things
  function createPlugin(input) {
      return {
          id: guid(),
          name: input.name,
          premiumReleaseDate: input.premiumReleaseDate ? new Date(input.premiumReleaseDate) : undefined,
          deps: input.deps || [],
          reducers: input.reducers || [],
          isLoadingFuncs: input.isLoadingFuncs || [],
          contextInit: [].concat(input.contextInit || []),
          eventRefiners: input.eventRefiners || {},
          eventDefMemberAdders: input.eventDefMemberAdders || [],
          eventSourceRefiners: input.eventSourceRefiners || {},
          isDraggableTransformers: input.isDraggableTransformers || [],
          eventDragMutationMassagers: input.eventDragMutationMassagers || [],
          eventDefMutationAppliers: input.eventDefMutationAppliers || [],
          dateSelectionTransformers: input.dateSelectionTransformers || [],
          datePointTransforms: input.datePointTransforms || [],
          dateSpanTransforms: input.dateSpanTransforms || [],
          views: input.views || {},
          viewPropsTransformers: input.viewPropsTransformers || [],
          isPropsValid: input.isPropsValid || null,
          externalDefTransforms: input.externalDefTransforms || [],
          viewContainerAppends: input.viewContainerAppends || [],
          eventDropTransformers: input.eventDropTransformers || [],
          componentInteractions: input.componentInteractions || [],
          calendarInteractions: input.calendarInteractions || [],
          themeClasses: input.themeClasses || {},
          eventSourceDefs: input.eventSourceDefs || [],
          cmdFormatter: input.cmdFormatter,
          recurringTypes: input.recurringTypes || [],
          namedTimeZonedImpl: input.namedTimeZonedImpl,
          initialView: input.initialView || '',
          elementDraggingImpl: input.elementDraggingImpl,
          optionChangeHandlers: input.optionChangeHandlers || {},
          scrollGridImpl: input.scrollGridImpl || null,
          listenerRefiners: input.listenerRefiners || {},
          optionRefiners: input.optionRefiners || {},
          propSetHandlers: input.propSetHandlers || {},
      };
  }
  function buildPluginHooks(pluginDefs, globalDefs) {
      let currentPluginIds = {};
      let hooks = {
          premiumReleaseDate: undefined,
          reducers: [],
          isLoadingFuncs: [],
          contextInit: [],
          eventRefiners: {},
          eventDefMemberAdders: [],
          eventSourceRefiners: {},
          isDraggableTransformers: [],
          eventDragMutationMassagers: [],
          eventDefMutationAppliers: [],
          dateSelectionTransformers: [],
          datePointTransforms: [],
          dateSpanTransforms: [],
          views: {},
          viewPropsTransformers: [],
          isPropsValid: null,
          externalDefTransforms: [],
          viewContainerAppends: [],
          eventDropTransformers: [],
          componentInteractions: [],
          calendarInteractions: [],
          themeClasses: {},
          eventSourceDefs: [],
          cmdFormatter: null,
          recurringTypes: [],
          namedTimeZonedImpl: null,
          initialView: '',
          elementDraggingImpl: null,
          optionChangeHandlers: {},
          scrollGridImpl: null,
          listenerRefiners: {},
          optionRefiners: {},
          propSetHandlers: {},
      };
      function addDefs(defs) {
          for (let def of defs) {
              const pluginName = def.name;
              const currentId = currentPluginIds[pluginName];
              if (currentId === undefined) {
                  currentPluginIds[pluginName] = def.id;
                  addDefs(def.deps);
                  hooks = combineHooks(hooks, def);
              }
              else if (currentId !== def.id) {
                  // different ID than the one already added
                  console.warn(`Duplicate plugin '${pluginName}'`);
              }
          }
      }
      if (pluginDefs) {
          addDefs(pluginDefs);
      }
      addDefs(globalDefs);
      return hooks;
  }
  function buildBuildPluginHooks() {
      let currentOverrideDefs = [];
      let currentGlobalDefs = [];
      let currentHooks;
      return (overrideDefs, globalDefs) => {
          if (!currentHooks || !isArraysEqual(overrideDefs, currentOverrideDefs) || !isArraysEqual(globalDefs, currentGlobalDefs)) {
              currentHooks = buildPluginHooks(overrideDefs, globalDefs);
          }
          currentOverrideDefs = overrideDefs;
          currentGlobalDefs = globalDefs;
          return currentHooks;
      };
  }
  function combineHooks(hooks0, hooks1) {
      return {
          premiumReleaseDate: compareOptionalDates(hooks0.premiumReleaseDate, hooks1.premiumReleaseDate),
          reducers: hooks0.reducers.concat(hooks1.reducers),
          isLoadingFuncs: hooks0.isLoadingFuncs.concat(hooks1.isLoadingFuncs),
          contextInit: hooks0.contextInit.concat(hooks1.contextInit),
          eventRefiners: Object.assign(Object.assign({}, hooks0.eventRefiners), hooks1.eventRefiners),
          eventDefMemberAdders: hooks0.eventDefMemberAdders.concat(hooks1.eventDefMemberAdders),
          eventSourceRefiners: Object.assign(Object.assign({}, hooks0.eventSourceRefiners), hooks1.eventSourceRefiners),
          isDraggableTransformers: hooks0.isDraggableTransformers.concat(hooks1.isDraggableTransformers),
          eventDragMutationMassagers: hooks0.eventDragMutationMassagers.concat(hooks1.eventDragMutationMassagers),
          eventDefMutationAppliers: hooks0.eventDefMutationAppliers.concat(hooks1.eventDefMutationAppliers),
          dateSelectionTransformers: hooks0.dateSelectionTransformers.concat(hooks1.dateSelectionTransformers),
          datePointTransforms: hooks0.datePointTransforms.concat(hooks1.datePointTransforms),
          dateSpanTransforms: hooks0.dateSpanTransforms.concat(hooks1.dateSpanTransforms),
          views: Object.assign(Object.assign({}, hooks0.views), hooks1.views),
          viewPropsTransformers: hooks0.viewPropsTransformers.concat(hooks1.viewPropsTransformers),
          isPropsValid: hooks1.isPropsValid || hooks0.isPropsValid,
          externalDefTransforms: hooks0.externalDefTransforms.concat(hooks1.externalDefTransforms),
          viewContainerAppends: hooks0.viewContainerAppends.concat(hooks1.viewContainerAppends),
          eventDropTransformers: hooks0.eventDropTransformers.concat(hooks1.eventDropTransformers),
          calendarInteractions: hooks0.calendarInteractions.concat(hooks1.calendarInteractions),
          componentInteractions: hooks0.componentInteractions.concat(hooks1.componentInteractions),
          themeClasses: Object.assign(Object.assign({}, hooks0.themeClasses), hooks1.themeClasses),
          eventSourceDefs: hooks0.eventSourceDefs.concat(hooks1.eventSourceDefs),
          cmdFormatter: hooks1.cmdFormatter || hooks0.cmdFormatter,
          recurringTypes: hooks0.recurringTypes.concat(hooks1.recurringTypes),
          namedTimeZonedImpl: hooks1.namedTimeZonedImpl || hooks0.namedTimeZonedImpl,
          initialView: hooks0.initialView || hooks1.initialView,
          elementDraggingImpl: hooks0.elementDraggingImpl || hooks1.elementDraggingImpl,
          optionChangeHandlers: Object.assign(Object.assign({}, hooks0.optionChangeHandlers), hooks1.optionChangeHandlers),
          scrollGridImpl: hooks1.scrollGridImpl || hooks0.scrollGridImpl,
          listenerRefiners: Object.assign(Object.assign({}, hooks0.listenerRefiners), hooks1.listenerRefiners),
          optionRefiners: Object.assign(Object.assign({}, hooks0.optionRefiners), hooks1.optionRefiners),
          propSetHandlers: Object.assign(Object.assign({}, hooks0.propSetHandlers), hooks1.propSetHandlers),
      };
  }
  function compareOptionalDates(date0, date1) {
      if (date0 === undefined) {
          return date1;
      }
      if (date1 === undefined) {
          return date0;
      }
      return new Date(Math.max(date0.valueOf(), date1.valueOf()));
  }

  class StandardTheme extends Theme {
  }
  StandardTheme.prototype.classes = {
      root: 'fc-theme-standard',
      tableCellShaded: 'fc-cell-shaded',
      buttonGroup: 'fc-button-group',
      button: 'fc-button fc-button-primary',
      buttonActive: 'fc-button-active',
  };
  StandardTheme.prototype.baseIconClass = 'fc-icon';
  StandardTheme.prototype.iconClasses = {
      close: 'fc-icon-x',
      prev: 'fc-icon-chevron-left',
      next: 'fc-icon-chevron-right',
      prevYear: 'fc-icon-chevrons-left',
      nextYear: 'fc-icon-chevrons-right',
  };
  StandardTheme.prototype.rtlIconClasses = {
      prev: 'fc-icon-chevron-right',
      next: 'fc-icon-chevron-left',
      prevYear: 'fc-icon-chevrons-right',
      nextYear: 'fc-icon-chevrons-left',
  };
  StandardTheme.prototype.iconOverrideOption = 'buttonIcons'; // TODO: make TS-friendly
  StandardTheme.prototype.iconOverrideCustomButtonOption = 'icon';
  StandardTheme.prototype.iconOverridePrefix = 'fc-icon-';

  function compileViewDefs(defaultConfigs, overrideConfigs) {
      let hash = {};
      let viewType;
      for (viewType in defaultConfigs) {
          ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);
      }
      for (viewType in overrideConfigs) {
          ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);
      }
      return hash;
  }
  function ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs) {
      if (hash[viewType]) {
          return hash[viewType];
      }
      let viewDef = buildViewDef(viewType, hash, defaultConfigs, overrideConfigs);
      if (viewDef) {
          hash[viewType] = viewDef;
      }
      return viewDef;
  }
  function buildViewDef(viewType, hash, defaultConfigs, overrideConfigs) {
      let defaultConfig = defaultConfigs[viewType];
      let overrideConfig = overrideConfigs[viewType];
      let queryProp = (name) => ((defaultConfig && defaultConfig[name] !== null) ? defaultConfig[name] :
          ((overrideConfig && overrideConfig[name] !== null) ? overrideConfig[name] : null));
      let theComponent = queryProp('component');
      let superType = queryProp('superType');
      let superDef = null;
      if (superType) {
          if (superType === viewType) {
              throw new Error('Can\'t have a custom view type that references itself');
          }
          superDef = ensureViewDef(superType, hash, defaultConfigs, overrideConfigs);
      }
      if (!theComponent && superDef) {
          theComponent = superDef.component;
      }
      if (!theComponent) {
          return null; // don't throw a warning, might be settings for a single-unit view
      }
      return {
          type: viewType,
          component: theComponent,
          defaults: Object.assign(Object.assign({}, (superDef ? superDef.defaults : {})), (defaultConfig ? defaultConfig.rawOptions : {})),
          overrides: Object.assign(Object.assign({}, (superDef ? superDef.overrides : {})), (overrideConfig ? overrideConfig.rawOptions : {})),
      };
  }

  function parseViewConfigs(inputs) {
      return mapHash(inputs, parseViewConfig);
  }
  function parseViewConfig(input) {
      let rawOptions = typeof input === 'function' ?
          { component: input } :
          input;
      let { component } = rawOptions;
      if (rawOptions.content) {
          // TODO: remove content/classNames/didMount/etc from options?
          component = createViewHookComponent(rawOptions);
      }
      else if (component && !(component.prototype instanceof BaseComponent)) {
          // WHY?: people were using `component` property for `content`
          // TODO: converge on one setting name
          component = createViewHookComponent(Object.assign(Object.assign({}, rawOptions), { content: component }));
      }
      return {
          superType: rawOptions.type,
          component: component,
          rawOptions, // includes type and component too :(
      };
  }
  function createViewHookComponent(options) {
      return (viewProps) => (y$1(ViewContextType.Consumer, null, (context) => (y$1(ContentContainer, { elTag: "div", elClasses: buildViewClassNames(context.viewSpec), renderProps: Object.assign(Object.assign({}, viewProps), { nextDayThreshold: context.options.nextDayThreshold }), generatorName: undefined, customGenerator: options.content, classNameGenerator: options.classNames, didMount: options.didMount, willUnmount: options.willUnmount }))));
  }

  function buildViewSpecs(defaultInputs, optionOverrides, dynamicOptionOverrides, localeDefaults) {
      let defaultConfigs = parseViewConfigs(defaultInputs);
      let overrideConfigs = parseViewConfigs(optionOverrides.views);
      let viewDefs = compileViewDefs(defaultConfigs, overrideConfigs);
      return mapHash(viewDefs, (viewDef) => buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults));
  }
  function buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults) {
      let durationInput = viewDef.overrides.duration ||
          viewDef.defaults.duration ||
          dynamicOptionOverrides.duration ||
          optionOverrides.duration;
      let duration = null;
      let durationUnit = '';
      let singleUnit = '';
      let singleUnitOverrides = {};
      if (durationInput) {
          duration = createDurationCached(durationInput);
          if (duration) { // valid?
              let denom = greatestDurationDenominator(duration);
              durationUnit = denom.unit;
              if (denom.value === 1) {
                  singleUnit = durationUnit;
                  singleUnitOverrides = overrideConfigs[durationUnit] ? overrideConfigs[durationUnit].rawOptions : {};
              }
          }
      }
      let queryButtonText = (optionsSubset) => {
          let buttonTextMap = optionsSubset.buttonText || {};
          let buttonTextKey = viewDef.defaults.buttonTextKey;
          if (buttonTextKey != null && buttonTextMap[buttonTextKey] != null) {
              return buttonTextMap[buttonTextKey];
          }
          if (buttonTextMap[viewDef.type] != null) {
              return buttonTextMap[viewDef.type];
          }
          if (buttonTextMap[singleUnit] != null) {
              return buttonTextMap[singleUnit];
          }
          return null;
      };
      let queryButtonTitle = (optionsSubset) => {
          let buttonHints = optionsSubset.buttonHints || {};
          let buttonKey = viewDef.defaults.buttonTextKey; // use same key as text
          if (buttonKey != null && buttonHints[buttonKey] != null) {
              return buttonHints[buttonKey];
          }
          if (buttonHints[viewDef.type] != null) {
              return buttonHints[viewDef.type];
          }
          if (buttonHints[singleUnit] != null) {
              return buttonHints[singleUnit];
          }
          return null;
      };
      return {
          type: viewDef.type,
          component: viewDef.component,
          duration,
          durationUnit,
          singleUnit,
          optionDefaults: viewDef.defaults,
          optionOverrides: Object.assign(Object.assign({}, singleUnitOverrides), viewDef.overrides),
          buttonTextOverride: queryButtonText(dynamicOptionOverrides) ||
              queryButtonText(optionOverrides) || // constructor-specified buttonText lookup hash takes precedence
              viewDef.overrides.buttonText,
          buttonTextDefault: queryButtonText(localeDefaults) ||
              viewDef.defaults.buttonText ||
              queryButtonText(BASE_OPTION_DEFAULTS) ||
              viewDef.type,
          // not DRY
          buttonTitleOverride: queryButtonTitle(dynamicOptionOverrides) ||
              queryButtonTitle(optionOverrides) ||
              viewDef.overrides.buttonHint,
          buttonTitleDefault: queryButtonTitle(localeDefaults) ||
              viewDef.defaults.buttonHint ||
              queryButtonTitle(BASE_OPTION_DEFAULTS),
          // will eventually fall back to buttonText
      };
  }
  // hack to get memoization working
  let durationInputMap = {};
  function createDurationCached(durationInput) {
      let json = JSON.stringify(durationInput);
      let res = durationInputMap[json];
      if (res === undefined) {
          res = createDuration(durationInput);
          durationInputMap[json] = res;
      }
      return res;
  }

  function reduceViewType(viewType, action) {
      switch (action.type) {
          case 'CHANGE_VIEW_TYPE':
              viewType = action.viewType;
      }
      return viewType;
  }

  function reduceDynamicOptionOverrides(dynamicOptionOverrides, action) {
      switch (action.type) {
          case 'SET_OPTION':
              return Object.assign(Object.assign({}, dynamicOptionOverrides), { [action.optionName]: action.rawOptionValue });
          default:
              return dynamicOptionOverrides;
      }
  }

  function reduceDateProfile(currentDateProfile, action, currentDate, dateProfileGenerator) {
      let dp;
      switch (action.type) {
          case 'CHANGE_VIEW_TYPE':
              return dateProfileGenerator.build(action.dateMarker || currentDate);
          case 'CHANGE_DATE':
              return dateProfileGenerator.build(action.dateMarker);
          case 'PREV':
              dp = dateProfileGenerator.buildPrev(currentDateProfile, currentDate);
              if (dp.isValid) {
                  return dp;
              }
              break;
          case 'NEXT':
              dp = dateProfileGenerator.buildNext(currentDateProfile, currentDate);
              if (dp.isValid) {
                  return dp;
              }
              break;
      }
      return currentDateProfile;
  }

  function initEventSources(calendarOptions, dateProfile, context) {
      let activeRange = dateProfile ? dateProfile.activeRange : null;
      return addSources({}, parseInitialSources(calendarOptions, context), activeRange, context);
  }
  function reduceEventSources(eventSources, action, dateProfile, context) {
      let activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?
      switch (action.type) {
          case 'ADD_EVENT_SOURCES': // already parsed
              return addSources(eventSources, action.sources, activeRange, context);
          case 'REMOVE_EVENT_SOURCE':
              return removeSource(eventSources, action.sourceId);
          case 'PREV': // TODO: how do we track all actions that affect dateProfile :(
          case 'NEXT':
          case 'CHANGE_DATE':
          case 'CHANGE_VIEW_TYPE':
              if (dateProfile) {
                  return fetchDirtySources(eventSources, activeRange, context);
              }
              return eventSources;
          case 'FETCH_EVENT_SOURCES':
              return fetchSourcesByIds(eventSources, action.sourceIds ? // why no type?
                  arrayToHash(action.sourceIds) :
                  excludeStaticSources(eventSources, context), activeRange, action.isRefetch || false, context);
          case 'RECEIVE_EVENTS':
          case 'RECEIVE_EVENT_ERROR':
              return receiveResponse(eventSources, action.sourceId, action.fetchId, action.fetchRange);
          case 'REMOVE_ALL_EVENT_SOURCES':
              return {};
          default:
              return eventSources;
      }
  }
  function reduceEventSourcesNewTimeZone(eventSources, dateProfile, context) {
      let activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?
      return fetchSourcesByIds(eventSources, excludeStaticSources(eventSources, context), activeRange, true, context);
  }
  function computeEventSourcesLoading(eventSources) {
      for (let sourceId in eventSources) {
          if (eventSources[sourceId].isFetching) {
              return true;
          }
      }
      return false;
  }
  function addSources(eventSourceHash, sources, fetchRange, context) {
      let hash = {};
      for (let source of sources) {
          hash[source.sourceId] = source;
      }
      if (fetchRange) {
          hash = fetchDirtySources(hash, fetchRange, context);
      }
      return Object.assign(Object.assign({}, eventSourceHash), hash);
  }
  function removeSource(eventSourceHash, sourceId) {
      return filterHash(eventSourceHash, (eventSource) => eventSource.sourceId !== sourceId);
  }
  function fetchDirtySources(sourceHash, fetchRange, context) {
      return fetchSourcesByIds(sourceHash, filterHash(sourceHash, (eventSource) => isSourceDirty(eventSource, fetchRange, context)), fetchRange, false, context);
  }
  function isSourceDirty(eventSource, fetchRange, context) {
      if (!doesSourceNeedRange(eventSource, context)) {
          return !eventSource.latestFetchId;
      }
      return !context.options.lazyFetching ||
          !eventSource.fetchRange ||
          eventSource.isFetching || // always cancel outdated in-progress fetches
          fetchRange.start < eventSource.fetchRange.start ||
          fetchRange.end > eventSource.fetchRange.end;
  }
  function fetchSourcesByIds(prevSources, sourceIdHash, fetchRange, isRefetch, context) {
      let nextSources = {};
      for (let sourceId in prevSources) {
          let source = prevSources[sourceId];
          if (sourceIdHash[sourceId]) {
              nextSources[sourceId] = fetchSource(source, fetchRange, isRefetch, context);
          }
          else {
              nextSources[sourceId] = source;
          }
      }
      return nextSources;
  }
  function fetchSource(eventSource, fetchRange, isRefetch, context) {
      let { options, calendarApi } = context;
      let sourceDef = context.pluginHooks.eventSourceDefs[eventSource.sourceDefId];
      let fetchId = guid();
      sourceDef.fetch({
          eventSource,
          range: fetchRange,
          isRefetch,
          context,
      }, (res) => {
          let { rawEvents } = res;
          if (options.eventSourceSuccess) {
              rawEvents = options.eventSourceSuccess.call(calendarApi, rawEvents, res.response) || rawEvents;
          }
          if (eventSource.success) {
              rawEvents = eventSource.success.call(calendarApi, rawEvents, res.response) || rawEvents;
          }
          context.dispatch({
              type: 'RECEIVE_EVENTS',
              sourceId: eventSource.sourceId,
              fetchId,
              fetchRange,
              rawEvents,
          });
      }, (error) => {
          let errorHandled = false;
          if (options.eventSourceFailure) {
              options.eventSourceFailure.call(calendarApi, error);
              errorHandled = true;
          }
          if (eventSource.failure) {
              eventSource.failure(error);
              errorHandled = true;
          }
          if (!errorHandled) {
              console.warn(error.message, error);
          }
          context.dispatch({
              type: 'RECEIVE_EVENT_ERROR',
              sourceId: eventSource.sourceId,
              fetchId,
              fetchRange,
              error,
          });
      });
      return Object.assign(Object.assign({}, eventSource), { isFetching: true, latestFetchId: fetchId });
  }
  function receiveResponse(sourceHash, sourceId, fetchId, fetchRange) {
      let eventSource = sourceHash[sourceId];
      if (eventSource && // not already removed
          fetchId === eventSource.latestFetchId) {
          return Object.assign(Object.assign({}, sourceHash), { [sourceId]: Object.assign(Object.assign({}, eventSource), { isFetching: false, fetchRange }) });
      }
      return sourceHash;
  }
  function excludeStaticSources(eventSources, context) {
      return filterHash(eventSources, (eventSource) => doesSourceNeedRange(eventSource, context));
  }
  function parseInitialSources(rawOptions, context) {
      let refiners = buildEventSourceRefiners(context);
      let rawSources = [].concat(rawOptions.eventSources || []);
      let sources = []; // parsed
      if (rawOptions.initialEvents) {
          rawSources.unshift(rawOptions.initialEvents);
      }
      if (rawOptions.events) {
          rawSources.unshift(rawOptions.events);
      }
      for (let rawSource of rawSources) {
          let source = parseEventSource(rawSource, context, refiners);
          if (source) {
              sources.push(source);
          }
      }
      return sources;
  }
  function doesSourceNeedRange(eventSource, context) {
      let defs = context.pluginHooks.eventSourceDefs;
      return !defs[eventSource.sourceDefId].ignoreRange;
  }

  function reduceDateSelection(currentSelection, action) {
      switch (action.type) {
          case 'UNSELECT_DATES':
              return null;
          case 'SELECT_DATES':
              return action.selection;
          default:
              return currentSelection;
      }
  }

  function reduceSelectedEvent(currentInstanceId, action) {
      switch (action.type) {
          case 'UNSELECT_EVENT':
              return '';
          case 'SELECT_EVENT':
              return action.eventInstanceId;
          default:
              return currentInstanceId;
      }
  }

  function reduceEventDrag(currentDrag, action) {
      let newDrag;
      switch (action.type) {
          case 'UNSET_EVENT_DRAG':
              return null;
          case 'SET_EVENT_DRAG':
              newDrag = action.state;
              return {
                  affectedEvents: newDrag.affectedEvents,
                  mutatedEvents: newDrag.mutatedEvents,
                  isEvent: newDrag.isEvent,
              };
          default:
              return currentDrag;
      }
  }

  function reduceEventResize(currentResize, action) {
      let newResize;
      switch (action.type) {
          case 'UNSET_EVENT_RESIZE':
              return null;
          case 'SET_EVENT_RESIZE':
              newResize = action.state;
              return {
                  affectedEvents: newResize.affectedEvents,
                  mutatedEvents: newResize.mutatedEvents,
                  isEvent: newResize.isEvent,
              };
          default:
              return currentResize;
      }
  }

  function parseToolbars(calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {
      let header = calendarOptions.headerToolbar ? parseToolbar(calendarOptions.headerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;
      let footer = calendarOptions.footerToolbar ? parseToolbar(calendarOptions.footerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;
      return { header, footer };
  }
  function parseToolbar(sectionStrHash, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {
      let sectionWidgets = {};
      let viewsWithButtons = [];
      let hasTitle = false;
      for (let sectionName in sectionStrHash) {
          let sectionStr = sectionStrHash[sectionName];
          let sectionRes = parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi);
          sectionWidgets[sectionName] = sectionRes.widgets;
          viewsWithButtons.push(...sectionRes.viewsWithButtons);
          hasTitle = hasTitle || sectionRes.hasTitle;
      }
      return { sectionWidgets, viewsWithButtons, hasTitle };
  }
  /*
  BAD: querying icons and text here. should be done at render time
  */
  function parseSection(sectionStr, calendarOptions, // defaults+overrides, then refined
  calendarOptionOverrides, // overrides only!, unrefined :(
  theme, viewSpecs, calendarApi) {
      let isRtl = calendarOptions.direction === 'rtl';
      let calendarCustomButtons = calendarOptions.customButtons || {};
      let calendarButtonTextOverrides = calendarOptionOverrides.buttonText || {};
      let calendarButtonText = calendarOptions.buttonText || {};
      let calendarButtonHintOverrides = calendarOptionOverrides.buttonHints || {};
      let calendarButtonHints = calendarOptions.buttonHints || {};
      let sectionSubstrs = sectionStr ? sectionStr.split(' ') : [];
      let viewsWithButtons = [];
      let hasTitle = false;
      let widgets = sectionSubstrs.map((buttonGroupStr) => (buttonGroupStr.split(',').map((buttonName) => {
          if (buttonName === 'title') {
              hasTitle = true;
              return { buttonName };
          }
          let customButtonProps;
          let viewSpec;
          let buttonClick;
          let buttonIcon; // only one of these will be set
          let buttonText; // "
          let buttonHint;
          // ^ for the title="" attribute, for accessibility
          if ((customButtonProps = calendarCustomButtons[buttonName])) {
              buttonClick = (ev) => {
                  if (customButtonProps.click) {
                      customButtonProps.click.call(ev.target, ev, ev.target); // TODO: use Calendar this context?
                  }
              };
              (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) ||
                  (buttonIcon = theme.getIconClass(buttonName, isRtl)) ||
                  (buttonText = customButtonProps.text);
              buttonHint = customButtonProps.hint || customButtonProps.text;
          }
          else if ((viewSpec = viewSpecs[buttonName])) {
              viewsWithButtons.push(buttonName);
              buttonClick = () => {
                  calendarApi.changeView(buttonName);
              };
              (buttonText = viewSpec.buttonTextOverride) ||
                  (buttonIcon = theme.getIconClass(buttonName, isRtl)) ||
                  (buttonText = viewSpec.buttonTextDefault);
              let textFallback = viewSpec.buttonTextOverride ||
                  viewSpec.buttonTextDefault;
              buttonHint = formatWithOrdinals(viewSpec.buttonTitleOverride ||
                  viewSpec.buttonTitleDefault ||
                  calendarOptions.viewHint, [textFallback, buttonName], // view-name = buttonName
              textFallback);
          }
          else if (calendarApi[buttonName]) { // a calendarApi method
              buttonClick = () => {
                  calendarApi[buttonName]();
              };
              (buttonText = calendarButtonTextOverrides[buttonName]) ||
                  (buttonIcon = theme.getIconClass(buttonName, isRtl)) ||
                  (buttonText = calendarButtonText[buttonName]); // everything else is considered default
              if (buttonName === 'prevYear' || buttonName === 'nextYear') {
                  let prevOrNext = buttonName === 'prevYear' ? 'prev' : 'next';
                  buttonHint = formatWithOrdinals(calendarButtonHintOverrides[prevOrNext] ||
                      calendarButtonHints[prevOrNext], [
                      calendarButtonText.year || 'year',
                      'year',
                  ], calendarButtonText[buttonName]);
              }
              else {
                  buttonHint = (navUnit) => formatWithOrdinals(calendarButtonHintOverrides[buttonName] ||
                      calendarButtonHints[buttonName], [
                      calendarButtonText[navUnit] || navUnit,
                      navUnit,
                  ], calendarButtonText[buttonName]);
              }
          }
          return { buttonName, buttonClick, buttonIcon, buttonText, buttonHint };
      })));
      return { widgets, viewsWithButtons, hasTitle };
  }

  // always represents the current view. otherwise, it'd need to change value every time date changes
  class ViewImpl {
      constructor(type, getCurrentData, dateEnv) {
          this.type = type;
          this.getCurrentData = getCurrentData;
          this.dateEnv = dateEnv;
      }
      get calendar() {
          return this.getCurrentData().calendarApi;
      }
      get title() {
          return this.getCurrentData().viewTitle;
      }
      get activeStart() {
          return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.start);
      }
      get activeEnd() {
          return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.end);
      }
      get currentStart() {
          return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.start);
      }
      get currentEnd() {
          return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.end);
      }
      getOption(name) {
          return this.getCurrentData().options[name]; // are the view-specific options
      }
  }

  let eventSourceDef$2 = {
      ignoreRange: true,
      parseMeta(refined) {
          if (Array.isArray(refined.events)) {
              return refined.events;
          }
          return null;
      },
      fetch(arg, successCallback) {
          successCallback({
              rawEvents: arg.eventSource.meta,
          });
      },
  };
  const arrayEventSourcePlugin = createPlugin({
      name: 'array-event-source',
      eventSourceDefs: [eventSourceDef$2],
  });

  let eventSourceDef$1$1 = {
      parseMeta(refined) {
          if (typeof refined.events === 'function') {
              return refined.events;
          }
          return null;
      },
      fetch(arg, successCallback, errorCallback) {
          const { dateEnv } = arg.context;
          const func = arg.eventSource.meta;
          unpromisify(func.bind(null, buildRangeApiWithTimeZone(arg.range, dateEnv)), (rawEvents) => successCallback({ rawEvents }), errorCallback);
      },
  };
  const funcEventSourcePlugin = createPlugin({
      name: 'func-event-source',
      eventSourceDefs: [eventSourceDef$1$1],
  });

  const JSON_FEED_EVENT_SOURCE_REFINERS = {
      method: String,
      extraParams: identity,
      startParam: String,
      endParam: String,
      timeZoneParam: String,
  };

  let eventSourceDef$3 = {
      parseMeta(refined) {
          if (refined.url && (refined.format === 'json' || !refined.format)) {
              return {
                  url: refined.url,
                  format: 'json',
                  method: (refined.method || 'GET').toUpperCase(),
                  extraParams: refined.extraParams,
                  startParam: refined.startParam,
                  endParam: refined.endParam,
                  timeZoneParam: refined.timeZoneParam,
              };
          }
          return null;
      },
      fetch(arg, successCallback, errorCallback) {
          const { meta } = arg.eventSource;
          const requestParams = buildRequestParams$1(meta, arg.range, arg.context);
          requestJson(meta.method, meta.url, requestParams).then(([rawEvents, response]) => {
              successCallback({ rawEvents, response });
          }, errorCallback);
      },
  };
  const jsonFeedEventSourcePlugin = createPlugin({
      name: 'json-event-source',
      eventSourceRefiners: JSON_FEED_EVENT_SOURCE_REFINERS,
      eventSourceDefs: [eventSourceDef$3],
  });
  function buildRequestParams$1(meta, range, context) {
      let { dateEnv, options } = context;
      let startParam;
      let endParam;
      let timeZoneParam;
      let customRequestParams;
      let params = {};
      startParam = meta.startParam;
      if (startParam == null) {
          startParam = options.startParam;
      }
      endParam = meta.endParam;
      if (endParam == null) {
          endParam = options.endParam;
      }
      timeZoneParam = meta.timeZoneParam;
      if (timeZoneParam == null) {
          timeZoneParam = options.timeZoneParam;
      }
      // retrieve any outbound GET/POST data from the options
      if (typeof meta.extraParams === 'function') {
          // supplied as a function that returns a key/value object
          customRequestParams = meta.extraParams();
      }
      else {
          // probably supplied as a straight key/value object
          customRequestParams = meta.extraParams || {};
      }
      Object.assign(params, customRequestParams);
      params[startParam] = dateEnv.formatIso(range.start);
      params[endParam] = dateEnv.formatIso(range.end);
      if (dateEnv.timeZone !== 'local') {
          params[timeZoneParam] = dateEnv.timeZone;
      }
      return params;
  }

  const SIMPLE_RECURRING_REFINERS = {
      daysOfWeek: identity,
      startTime: createDuration,
      endTime: createDuration,
      duration: createDuration,
      startRecur: identity,
      endRecur: identity,
  };

  let recurring = {
      parse(refined, dateEnv) {
          if (refined.daysOfWeek || refined.startTime || refined.endTime || refined.startRecur || refined.endRecur) {
              let recurringData = {
                  daysOfWeek: refined.daysOfWeek || null,
                  startTime: refined.startTime || null,
                  endTime: refined.endTime || null,
                  startRecur: refined.startRecur ? dateEnv.createMarker(refined.startRecur) : null,
                  endRecur: refined.endRecur ? dateEnv.createMarker(refined.endRecur) : null,
              };
              let duration;
              if (refined.duration) {
                  duration = refined.duration;
              }
              if (!duration && refined.startTime && refined.endTime) {
                  duration = subtractDurations(refined.endTime, refined.startTime);
              }
              return {
                  allDayGuess: Boolean(!refined.startTime && !refined.endTime),
                  duration,
                  typeData: recurringData, // doesn't need endTime anymore but oh well
              };
          }
          return null;
      },
      expand(typeData, framingRange, dateEnv) {
          let clippedFramingRange = intersectRanges(framingRange, { start: typeData.startRecur, end: typeData.endRecur });
          if (clippedFramingRange) {
              return expandRanges(typeData.daysOfWeek, typeData.startTime, clippedFramingRange, dateEnv);
          }
          return [];
      },
  };
  const simpleRecurringEventsPlugin = createPlugin({
      name: 'simple-recurring-event',
      recurringTypes: [recurring],
      eventRefiners: SIMPLE_RECURRING_REFINERS,
  });
  function expandRanges(daysOfWeek, startTime, framingRange, dateEnv) {
      let dowHash = daysOfWeek ? arrayToHash(daysOfWeek) : null;
      let dayMarker = startOfDay(framingRange.start);
      let endMarker = framingRange.end;
      let instanceStarts = [];
      while (dayMarker < endMarker) {
          let instanceStart;
          // if everyday, or this particular day-of-week
          if (!dowHash || dowHash[dayMarker.getUTCDay()]) {
              if (startTime) {
                  instanceStart = dateEnv.add(dayMarker, startTime);
              }
              else {
                  instanceStart = dayMarker;
              }
              instanceStarts.push(instanceStart);
          }
          dayMarker = addDays(dayMarker, 1);
      }
      return instanceStarts;
  }

  const changeHandlerPlugin = createPlugin({
      name: 'change-handler',
      optionChangeHandlers: {
          events(events, context) {
              handleEventSources([events], context);
          },
          eventSources: handleEventSources,
      },
  });
  /*
  BUG: if `event` was supplied, all previously-given `eventSources` will be wiped out
  */
  function handleEventSources(inputs, context) {
      let unfoundSources = hashValuesToArray(context.getCurrentData().eventSources);
      if (unfoundSources.length === 1 &&
          inputs.length === 1 &&
          Array.isArray(unfoundSources[0]._raw) &&
          Array.isArray(inputs[0])) {
          context.dispatch({
              type: 'RESET_RAW_EVENTS',
              sourceId: unfoundSources[0].sourceId,
              rawEvents: inputs[0],
          });
          return;
      }
      let newInputs = [];
      for (let input of inputs) {
          let inputFound = false;
          for (let i = 0; i < unfoundSources.length; i += 1) {
              if (unfoundSources[i]._raw === input) {
                  unfoundSources.splice(i, 1); // delete
                  inputFound = true;
                  break;
              }
          }
          if (!inputFound) {
              newInputs.push(input);
          }
      }
      for (let unfoundSource of unfoundSources) {
          context.dispatch({
              type: 'REMOVE_EVENT_SOURCE',
              sourceId: unfoundSource.sourceId,
          });
      }
      for (let newInput of newInputs) {
          context.calendarApi.addEventSource(newInput);
      }
  }

  function handleDateProfile(dateProfile, context) {
      context.emitter.trigger('datesSet', Object.assign(Object.assign({}, buildRangeApiWithTimeZone(dateProfile.activeRange, context.dateEnv)), { view: context.viewApi }));
  }

  function handleEventStore(eventStore, context) {
      let { emitter } = context;
      if (emitter.hasHandlers('eventsSet')) {
          emitter.trigger('eventsSet', buildEventApis(eventStore, context));
      }
  }

  /*
  this array is exposed on the root namespace so that UMD plugins can add to it.
  see the rollup-bundles script.
  */
  const globalPlugins = [
      arrayEventSourcePlugin,
      funcEventSourcePlugin,
      jsonFeedEventSourcePlugin,
      simpleRecurringEventsPlugin,
      changeHandlerPlugin,
      createPlugin({
          name: 'misc',
          isLoadingFuncs: [
              (state) => computeEventSourcesLoading(state.eventSources),
          ],
          propSetHandlers: {
              dateProfile: handleDateProfile,
              eventStore: handleEventStore,
          },
      }),
  ];

  class TaskRunner {
      constructor(runTaskOption, drainedOption) {
          this.runTaskOption = runTaskOption;
          this.drainedOption = drainedOption;
          this.queue = [];
          this.delayedRunner = new DelayedRunner(this.drain.bind(this));
      }
      request(task, delay) {
          this.queue.push(task);
          this.delayedRunner.request(delay);
      }
      pause(scope) {
          this.delayedRunner.pause(scope);
      }
      resume(scope, force) {
          this.delayedRunner.resume(scope, force);
      }
      drain() {
          let { queue } = this;
          while (queue.length) {
              let completedTasks = [];
              let task;
              while ((task = queue.shift())) {
                  this.runTask(task);
                  completedTasks.push(task);
              }
              this.drained(completedTasks);
          } // keep going, in case new tasks were added in the drained handler
      }
      runTask(task) {
          if (this.runTaskOption) {
              this.runTaskOption(task);
          }
      }
      drained(completedTasks) {
          if (this.drainedOption) {
              this.drainedOption(completedTasks);
          }
      }
  }

  // Computes what the title at the top of the calendarApi should be for this view
  function buildTitle(dateProfile, viewOptions, dateEnv) {
      let range;
      // for views that span a large unit of time, show the proper interval, ignoring stray days before and after
      if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {
          range = dateProfile.currentRange;
      }
      else { // for day units or smaller, use the actual day range
          range = dateProfile.activeRange;
      }
      return dateEnv.formatRange(range.start, range.end, createFormatter(viewOptions.titleFormat || buildTitleFormat(dateProfile)), {
          isEndExclusive: dateProfile.isRangeAllDay,
          defaultSeparator: viewOptions.titleRangeSeparator,
      });
  }
  // Generates the format string that should be used to generate the title for the current date range.
  // Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.
  function buildTitleFormat(dateProfile) {
      let { currentRangeUnit } = dateProfile;
      if (currentRangeUnit === 'year') {
          return { year: 'numeric' };
      }
      if (currentRangeUnit === 'month') {
          return { year: 'numeric', month: 'long' }; // like "September 2014"
      }
      let days = diffWholeDays(dateProfile.currentRange.start, dateProfile.currentRange.end);
      if (days !== null && days > 1) {
          // multi-day range. shorter, like "Sep 9 - 10 2014"
          return { year: 'numeric', month: 'short', day: 'numeric' };
      }
      // one day. longer, like "September 9 2014"
      return { year: 'numeric', month: 'long', day: 'numeric' };
  }

  // in future refactor, do the redux-style function(state=initial) for initial-state
  // also, whatever is happening in constructor, have it happen in action queue too
  class CalendarDataManager {
      constructor(props) {
          this.computeCurrentViewData = memoize(this._computeCurrentViewData);
          this.organizeRawLocales = memoize(organizeRawLocales);
          this.buildLocale = memoize(buildLocale);
          this.buildPluginHooks = buildBuildPluginHooks();
          this.buildDateEnv = memoize(buildDateEnv$1);
          this.buildTheme = memoize(buildTheme);
          this.parseToolbars = memoize(parseToolbars);
          this.buildViewSpecs = memoize(buildViewSpecs);
          this.buildDateProfileGenerator = memoizeObjArg(buildDateProfileGenerator);
          this.buildViewApi = memoize(buildViewApi);
          this.buildViewUiProps = memoizeObjArg(buildViewUiProps);
          this.buildEventUiBySource = memoize(buildEventUiBySource, isPropsEqual);
          this.buildEventUiBases = memoize(buildEventUiBases);
          this.parseContextBusinessHours = memoizeObjArg(parseContextBusinessHours);
          this.buildTitle = memoize(buildTitle);
          this.emitter = new Emitter();
          this.actionRunner = new TaskRunner(this._handleAction.bind(this), this.updateData.bind(this));
          this.currentCalendarOptionsInput = {};
          this.currentCalendarOptionsRefined = {};
          this.currentViewOptionsInput = {};
          this.currentViewOptionsRefined = {};
          this.currentCalendarOptionsRefiners = {};
          this.optionsForRefining = [];
          this.optionsForHandling = [];
          this.getCurrentData = () => this.data;
          this.dispatch = (action) => {
              this.actionRunner.request(action); // protects against recursive calls to _handleAction
          };
          this.props = props;
          this.actionRunner.pause();
          let dynamicOptionOverrides = {};
          let optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);
          let currentViewType = optionsData.calendarOptions.initialView || optionsData.pluginHooks.initialView;
          let currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);
          // wire things up
          // TODO: not DRY
          props.calendarApi.currentDataManager = this;
          this.emitter.setThisContext(props.calendarApi);
          this.emitter.setOptions(currentViewData.options);
          let currentDate = getInitialDate(optionsData.calendarOptions, optionsData.dateEnv);
          let dateProfile = currentViewData.dateProfileGenerator.build(currentDate);
          if (!rangeContainsMarker(dateProfile.activeRange, currentDate)) {
              currentDate = dateProfile.currentRange.start;
          }
          let calendarContext = {
              dateEnv: optionsData.dateEnv,
              options: optionsData.calendarOptions,
              pluginHooks: optionsData.pluginHooks,
              calendarApi: props.calendarApi,
              dispatch: this.dispatch,
              emitter: this.emitter,
              getCurrentData: this.getCurrentData,
          };
          // needs to be after setThisContext
          for (let callback of optionsData.pluginHooks.contextInit) {
              callback(calendarContext);
          }
          // NOT DRY
          let eventSources = initEventSources(optionsData.calendarOptions, dateProfile, calendarContext);
          let initialState = {
              dynamicOptionOverrides,
              currentViewType,
              currentDate,
              dateProfile,
              businessHours: this.parseContextBusinessHours(calendarContext),
              eventSources,
              eventUiBases: {},
              eventStore: createEmptyEventStore(),
              renderableEventStore: createEmptyEventStore(),
              dateSelection: null,
              eventSelection: '',
              eventDrag: null,
              eventResize: null,
              selectionConfig: this.buildViewUiProps(calendarContext).selectionConfig,
          };
          let contextAndState = Object.assign(Object.assign({}, calendarContext), initialState);
          for (let reducer of optionsData.pluginHooks.reducers) {
              Object.assign(initialState, reducer(null, null, contextAndState));
          }
          if (computeIsLoading(initialState, calendarContext)) {
              this.emitter.trigger('loading', true); // NOT DRY
          }
          this.state = initialState;
          this.updateData();
          this.actionRunner.resume();
      }
      resetOptions(optionOverrides, changedOptionNames) {
          let { props } = this;
          if (changedOptionNames === undefined) {
              props.optionOverrides = optionOverrides;
          }
          else {
              props.optionOverrides = Object.assign(Object.assign({}, (props.optionOverrides || {})), optionOverrides);
              this.optionsForRefining.push(...changedOptionNames);
          }
          if (changedOptionNames === undefined || changedOptionNames.length) {
              this.actionRunner.request({
                  type: 'NOTHING',
              });
          }
      }
      _handleAction(action) {
          let { props, state, emitter } = this;
          let dynamicOptionOverrides = reduceDynamicOptionOverrides(state.dynamicOptionOverrides, action);
          let optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);
          let currentViewType = reduceViewType(state.currentViewType, action);
          let currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);
          // wire things up
          // TODO: not DRY
          props.calendarApi.currentDataManager = this;
          emitter.setThisContext(props.calendarApi);
          emitter.setOptions(currentViewData.options);
          let calendarContext = {
              dateEnv: optionsData.dateEnv,
              options: optionsData.calendarOptions,
              pluginHooks: optionsData.pluginHooks,
              calendarApi: props.calendarApi,
              dispatch: this.dispatch,
              emitter,
              getCurrentData: this.getCurrentData,
          };
          let { currentDate, dateProfile } = state;
          if (this.data && this.data.dateProfileGenerator !== currentViewData.dateProfileGenerator) { // hack
              dateProfile = currentViewData.dateProfileGenerator.build(currentDate);
          }
          currentDate = reduceCurrentDate(currentDate, action);
          dateProfile = reduceDateProfile(dateProfile, action, currentDate, currentViewData.dateProfileGenerator);
          if (action.type === 'PREV' || // TODO: move this logic into DateProfileGenerator
              action.type === 'NEXT' || // "
              !rangeContainsMarker(dateProfile.currentRange, currentDate)) {
              currentDate = dateProfile.currentRange.start;
          }
          let eventSources = reduceEventSources(state.eventSources, action, dateProfile, calendarContext);
          let eventStore = reduceEventStore(state.eventStore, action, eventSources, dateProfile, calendarContext);
          let isEventsLoading = computeEventSourcesLoading(eventSources); // BAD. also called in this func in computeIsLoading
          let renderableEventStore = (isEventsLoading && !currentViewData.options.progressiveEventRendering) ?
              (state.renderableEventStore || eventStore) : // try from previous state
              eventStore;
          let { eventUiSingleBase, selectionConfig } = this.buildViewUiProps(calendarContext); // will memoize obj
          let eventUiBySource = this.buildEventUiBySource(eventSources);
          let eventUiBases = this.buildEventUiBases(renderableEventStore.defs, eventUiSingleBase, eventUiBySource);
          let newState = {
              dynamicOptionOverrides,
              currentViewType,
              currentDate,
              dateProfile,
              eventSources,
              eventStore,
              renderableEventStore,
              selectionConfig,
              eventUiBases,
              businessHours: this.parseContextBusinessHours(calendarContext),
              dateSelection: reduceDateSelection(state.dateSelection, action),
              eventSelection: reduceSelectedEvent(state.eventSelection, action),
              eventDrag: reduceEventDrag(state.eventDrag, action),
              eventResize: reduceEventResize(state.eventResize, action),
          };
          let contextAndState = Object.assign(Object.assign({}, calendarContext), newState);
          for (let reducer of optionsData.pluginHooks.reducers) {
              Object.assign(newState, reducer(state, action, contextAndState)); // give the OLD state, for old value
          }
          let wasLoading = computeIsLoading(state, calendarContext);
          let isLoading = computeIsLoading(newState, calendarContext);
          // TODO: use propSetHandlers in plugin system
          if (!wasLoading && isLoading) {
              emitter.trigger('loading', true);
          }
          else if (wasLoading && !isLoading) {
              emitter.trigger('loading', false);
          }
          this.state = newState;
          if (props.onAction) {
              props.onAction(action);
          }
      }
      updateData() {
          let { props, state } = this;
          let oldData = this.data;
          let optionsData = this.computeOptionsData(props.optionOverrides, state.dynamicOptionOverrides, props.calendarApi);
          let currentViewData = this.computeCurrentViewData(state.currentViewType, optionsData, props.optionOverrides, state.dynamicOptionOverrides);
          let data = this.data = Object.assign(Object.assign(Object.assign({ viewTitle: this.buildTitle(state.dateProfile, currentViewData.options, optionsData.dateEnv), calendarApi: props.calendarApi, dispatch: this.dispatch, emitter: this.emitter, getCurrentData: this.getCurrentData }, optionsData), currentViewData), state);
          let changeHandlers = optionsData.pluginHooks.optionChangeHandlers;
          let oldCalendarOptions = oldData && oldData.calendarOptions;
          let newCalendarOptions = optionsData.calendarOptions;
          if (oldCalendarOptions && oldCalendarOptions !== newCalendarOptions) {
              if (oldCalendarOptions.timeZone !== newCalendarOptions.timeZone) {
                  // hack
                  state.eventSources = data.eventSources = reduceEventSourcesNewTimeZone(data.eventSources, state.dateProfile, data);
                  state.eventStore = data.eventStore = rezoneEventStoreDates(data.eventStore, oldData.dateEnv, data.dateEnv);
                  state.renderableEventStore = data.renderableEventStore = rezoneEventStoreDates(data.renderableEventStore, oldData.dateEnv, data.dateEnv);
              }
              for (let optionName in changeHandlers) {
                  if (this.optionsForHandling.indexOf(optionName) !== -1 ||
                      oldCalendarOptions[optionName] !== newCalendarOptions[optionName]) {
                      changeHandlers[optionName](newCalendarOptions[optionName], data);
                  }
              }
          }
          this.optionsForHandling = [];
          if (props.onData) {
              props.onData(data);
          }
      }
      computeOptionsData(optionOverrides, dynamicOptionOverrides, calendarApi) {
          // TODO: blacklist options that are handled by optionChangeHandlers
          if (!this.optionsForRefining.length &&
              optionOverrides === this.stableOptionOverrides &&
              dynamicOptionOverrides === this.stableDynamicOptionOverrides) {
              return this.stableCalendarOptionsData;
          }
          let { refinedOptions, pluginHooks, localeDefaults, availableLocaleData, extra, } = this.processRawCalendarOptions(optionOverrides, dynamicOptionOverrides);
          warnUnknownOptions(extra);
          let dateEnv = this.buildDateEnv(refinedOptions.timeZone, refinedOptions.locale, refinedOptions.weekNumberCalculation, refinedOptions.firstDay, refinedOptions.weekText, pluginHooks, availableLocaleData, refinedOptions.defaultRangeSeparator);
          let viewSpecs = this.buildViewSpecs(pluginHooks.views, this.stableOptionOverrides, this.stableDynamicOptionOverrides, localeDefaults);
          let theme = this.buildTheme(refinedOptions, pluginHooks);
          let toolbarConfig = this.parseToolbars(refinedOptions, this.stableOptionOverrides, theme, viewSpecs, calendarApi);
          return this.stableCalendarOptionsData = {
              calendarOptions: refinedOptions,
              pluginHooks,
              dateEnv,
              viewSpecs,
              theme,
              toolbarConfig,
              localeDefaults,
              availableRawLocales: availableLocaleData.map,
          };
      }
      // always called from behind a memoizer
      processRawCalendarOptions(optionOverrides, dynamicOptionOverrides) {
          let { locales, locale } = mergeRawOptions([
              BASE_OPTION_DEFAULTS,
              optionOverrides,
              dynamicOptionOverrides,
          ]);
          let availableLocaleData = this.organizeRawLocales(locales);
          let availableRawLocales = availableLocaleData.map;
          let localeDefaults = this.buildLocale(locale || availableLocaleData.defaultCode, availableRawLocales).options;
          let pluginHooks = this.buildPluginHooks(optionOverrides.plugins || [], globalPlugins);
          let refiners = this.currentCalendarOptionsRefiners = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);
          let extra = {};
          let raw = mergeRawOptions([
              BASE_OPTION_DEFAULTS,
              localeDefaults,
              optionOverrides,
              dynamicOptionOverrides,
          ]);
          let refined = {};
          let currentRaw = this.currentCalendarOptionsInput;
          let currentRefined = this.currentCalendarOptionsRefined;
          let anyChanges = false;
          for (let optionName in raw) {
              if (this.optionsForRefining.indexOf(optionName) === -1 && (raw[optionName] === currentRaw[optionName] || (COMPLEX_OPTION_COMPARATORS[optionName] &&
                  (optionName in currentRaw) &&
                  COMPLEX_OPTION_COMPARATORS[optionName](currentRaw[optionName], raw[optionName])))) {
                  refined[optionName] = currentRefined[optionName];
              }
              else if (refiners[optionName]) {
                  refined[optionName] = refiners[optionName](raw[optionName]);
                  anyChanges = true;
              }
              else {
                  extra[optionName] = currentRaw[optionName];
              }
          }
          if (anyChanges) {
              this.currentCalendarOptionsInput = raw;
              this.currentCalendarOptionsRefined = refined;
              this.stableOptionOverrides = optionOverrides;
              this.stableDynamicOptionOverrides = dynamicOptionOverrides;
          }
          this.optionsForHandling.push(...this.optionsForRefining);
          this.optionsForRefining = [];
          return {
              rawOptions: this.currentCalendarOptionsInput,
              refinedOptions: this.currentCalendarOptionsRefined,
              pluginHooks,
              availableLocaleData,
              localeDefaults,
              extra,
          };
      }
      _computeCurrentViewData(viewType, optionsData, optionOverrides, dynamicOptionOverrides) {
          let viewSpec = optionsData.viewSpecs[viewType];
          if (!viewSpec) {
              throw new Error(`viewType "${viewType}" is not available. Please make sure you've loaded all neccessary plugins`);
          }
          let { refinedOptions, extra } = this.processRawViewOptions(viewSpec, optionsData.pluginHooks, optionsData.localeDefaults, optionOverrides, dynamicOptionOverrides);
          warnUnknownOptions(extra);
          let dateProfileGenerator = this.buildDateProfileGenerator({
              dateProfileGeneratorClass: viewSpec.optionDefaults.dateProfileGeneratorClass,
              duration: viewSpec.duration,
              durationUnit: viewSpec.durationUnit,
              usesMinMaxTime: viewSpec.optionDefaults.usesMinMaxTime,
              dateEnv: optionsData.dateEnv,
              calendarApi: this.props.calendarApi,
              slotMinTime: refinedOptions.slotMinTime,
              slotMaxTime: refinedOptions.slotMaxTime,
              showNonCurrentDates: refinedOptions.showNonCurrentDates,
              dayCount: refinedOptions.dayCount,
              dateAlignment: refinedOptions.dateAlignment,
              dateIncrement: refinedOptions.dateIncrement,
              hiddenDays: refinedOptions.hiddenDays,
              weekends: refinedOptions.weekends,
              nowInput: refinedOptions.now,
              validRangeInput: refinedOptions.validRange,
              visibleRangeInput: refinedOptions.visibleRange,
              fixedWeekCount: refinedOptions.fixedWeekCount,
          });
          let viewApi = this.buildViewApi(viewType, this.getCurrentData, optionsData.dateEnv);
          return { viewSpec, options: refinedOptions, dateProfileGenerator, viewApi };
      }
      processRawViewOptions(viewSpec, pluginHooks, localeDefaults, optionOverrides, dynamicOptionOverrides) {
          let raw = mergeRawOptions([
              BASE_OPTION_DEFAULTS,
              viewSpec.optionDefaults,
              localeDefaults,
              optionOverrides,
              viewSpec.optionOverrides,
              dynamicOptionOverrides,
          ]);
          let refiners = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), VIEW_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);
          let refined = {};
          let currentRaw = this.currentViewOptionsInput;
          let currentRefined = this.currentViewOptionsRefined;
          let anyChanges = false;
          let extra = {};
          for (let optionName in raw) {
              if (raw[optionName] === currentRaw[optionName] ||
                  (COMPLEX_OPTION_COMPARATORS[optionName] &&
                      COMPLEX_OPTION_COMPARATORS[optionName](raw[optionName], currentRaw[optionName]))) {
                  refined[optionName] = currentRefined[optionName];
              }
              else {
                  if (raw[optionName] === this.currentCalendarOptionsInput[optionName] ||
                      (COMPLEX_OPTION_COMPARATORS[optionName] &&
                          COMPLEX_OPTION_COMPARATORS[optionName](raw[optionName], this.currentCalendarOptionsInput[optionName]))) {
                      if (optionName in this.currentCalendarOptionsRefined) { // might be an "extra" prop
                          refined[optionName] = this.currentCalendarOptionsRefined[optionName];
                      }
                  }
                  else if (refiners[optionName]) {
                      refined[optionName] = refiners[optionName](raw[optionName]);
                  }
                  else {
                      extra[optionName] = raw[optionName];
                  }
                  anyChanges = true;
              }
          }
          if (anyChanges) {
              this.currentViewOptionsInput = raw;
              this.currentViewOptionsRefined = refined;
          }
          return {
              rawOptions: this.currentViewOptionsInput,
              refinedOptions: this.currentViewOptionsRefined,
              extra,
          };
      }
  }
  function buildDateEnv$1(timeZone, explicitLocale, weekNumberCalculation, firstDay, weekText, pluginHooks, availableLocaleData, defaultSeparator) {
      let locale = buildLocale(explicitLocale || availableLocaleData.defaultCode, availableLocaleData.map);
      return new DateEnv({
          calendarSystem: 'gregory',
          timeZone,
          namedTimeZoneImpl: pluginHooks.namedTimeZonedImpl,
          locale,
          weekNumberCalculation,
          firstDay,
          weekText,
          cmdFormatter: pluginHooks.cmdFormatter,
          defaultSeparator,
      });
  }
  function buildTheme(options, pluginHooks) {
      let ThemeClass = pluginHooks.themeClasses[options.themeSystem] || StandardTheme;
      return new ThemeClass(options);
  }
  function buildDateProfileGenerator(props) {
      let DateProfileGeneratorClass = props.dateProfileGeneratorClass || DateProfileGenerator;
      return new DateProfileGeneratorClass(props);
  }
  function buildViewApi(type, getCurrentData, dateEnv) {
      return new ViewImpl(type, getCurrentData, dateEnv);
  }
  function buildEventUiBySource(eventSources) {
      return mapHash(eventSources, (eventSource) => eventSource.ui);
  }
  function buildEventUiBases(eventDefs, eventUiSingleBase, eventUiBySource) {
      let eventUiBases = { '': eventUiSingleBase };
      for (let defId in eventDefs) {
          let def = eventDefs[defId];
          if (def.sourceId && eventUiBySource[def.sourceId]) {
              eventUiBases[defId] = eventUiBySource[def.sourceId];
          }
      }
      return eventUiBases;
  }
  function buildViewUiProps(calendarContext) {
      let { options } = calendarContext;
      return {
          eventUiSingleBase: createEventUi({
              display: options.eventDisplay,
              editable: options.editable,
              startEditable: options.eventStartEditable,
              durationEditable: options.eventDurationEditable,
              constraint: options.eventConstraint,
              overlap: typeof options.eventOverlap === 'boolean' ? options.eventOverlap : undefined,
              allow: options.eventAllow,
              backgroundColor: options.eventBackgroundColor,
              borderColor: options.eventBorderColor,
              textColor: options.eventTextColor,
              color: options.eventColor,
              // classNames: options.eventClassNames // render hook will handle this
          }, calendarContext),
          selectionConfig: createEventUi({
              constraint: options.selectConstraint,
              overlap: typeof options.selectOverlap === 'boolean' ? options.selectOverlap : undefined,
              allow: options.selectAllow,
          }, calendarContext),
      };
  }
  function computeIsLoading(state, context) {
      for (let isLoadingFunc of context.pluginHooks.isLoadingFuncs) {
          if (isLoadingFunc(state)) {
              return true;
          }
      }
      return false;
  }
  function parseContextBusinessHours(calendarContext) {
      return parseBusinessHours(calendarContext.options.businessHours, calendarContext);
  }
  function warnUnknownOptions(options, viewName) {
      for (let optionName in options) {
          console.warn(`Unknown option '${optionName}'` +
              (viewName ? ` for view '${viewName}'` : ''));
      }
  }

  class ToolbarSection extends BaseComponent {
      render() {
          let children = this.props.widgetGroups.map((widgetGroup) => this.renderWidgetGroup(widgetGroup));
          return y$1('div', { className: 'fc-toolbar-chunk' }, ...children);
      }
      renderWidgetGroup(widgetGroup) {
          let { props } = this;
          let { theme } = this.context;
          let children = [];
          let isOnlyButtons = true;
          for (let widget of widgetGroup) {
              let { buttonName, buttonClick, buttonText, buttonIcon, buttonHint } = widget;
              if (buttonName === 'title') {
                  isOnlyButtons = false;
                  children.push(y$1("h2", { className: "fc-toolbar-title", id: props.titleId }, props.title));
              }
              else {
                  let isPressed = buttonName === props.activeButton;
                  let isDisabled = (!props.isTodayEnabled && buttonName === 'today') ||
                      (!props.isPrevEnabled && buttonName === 'prev') ||
                      (!props.isNextEnabled && buttonName === 'next');
                  let buttonClasses = [`fc-${buttonName}-button`, theme.getClass('button')];
                  if (isPressed) {
                      buttonClasses.push(theme.getClass('buttonActive'));
                  }
                  children.push(y$1("button", { type: "button", title: typeof buttonHint === 'function' ? buttonHint(props.navUnit) : buttonHint, disabled: isDisabled, "aria-pressed": isPressed, className: buttonClasses.join(' '), onClick: buttonClick }, buttonText || (buttonIcon ? y$1("span", { className: buttonIcon, role: "img" }) : '')));
              }
          }
          if (children.length > 1) {
              let groupClassName = (isOnlyButtons && theme.getClass('buttonGroup')) || '';
              return y$1('div', { className: groupClassName }, ...children);
          }
          return children[0];
      }
  }

  class Toolbar extends BaseComponent {
      render() {
          let { model, extraClassName } = this.props;
          let forceLtr = false;
          let startContent;
          let endContent;
          let sectionWidgets = model.sectionWidgets;
          let centerContent = sectionWidgets.center;
          if (sectionWidgets.left) {
              forceLtr = true;
              startContent = sectionWidgets.left;
          }
          else {
              startContent = sectionWidgets.start;
          }
          if (sectionWidgets.right) {
              forceLtr = true;
              endContent = sectionWidgets.right;
          }
          else {
              endContent = sectionWidgets.end;
          }
          let classNames = [
              extraClassName || '',
              'fc-toolbar',
              forceLtr ? 'fc-toolbar-ltr' : '',
          ];
          return (y$1("div", { className: classNames.join(' ') },
              this.renderSection('start', startContent || []),
              this.renderSection('center', centerContent || []),
              this.renderSection('end', endContent || [])));
      }
      renderSection(key, widgetGroups) {
          let { props } = this;
          return (y$1(ToolbarSection, { key: key, widgetGroups: widgetGroups, title: props.title, navUnit: props.navUnit, activeButton: props.activeButton, isTodayEnabled: props.isTodayEnabled, isPrevEnabled: props.isPrevEnabled, isNextEnabled: props.isNextEnabled, titleId: props.titleId }));
      }
  }

  class ViewHarness extends BaseComponent {
      constructor() {
          super(...arguments);
          this.state = {
              availableWidth: null,
          };
          this.handleEl = (el) => {
              this.el = el;
              setRef(this.props.elRef, el);
              this.updateAvailableWidth();
          };
          this.handleResize = () => {
              this.updateAvailableWidth();
          };
      }
      render() {
          let { props, state } = this;
          let { aspectRatio } = props;
          let classNames = [
              'fc-view-harness',
              (aspectRatio || props.liquid || props.height)
                  ? 'fc-view-harness-active' // harness controls the height
                  : 'fc-view-harness-passive', // let the view do the height
          ];
          let height = '';
          let paddingBottom = '';
          if (aspectRatio) {
              if (state.availableWidth !== null) {
                  height = state.availableWidth / aspectRatio;
              }
              else {
                  // while waiting to know availableWidth, we can't set height to *zero*
                  // because will cause lots of unnecessary scrollbars within scrollgrid.
                  // BETTER: don't start rendering ANYTHING yet until we know container width
                  // NOTE: why not always use paddingBottom? Causes height oscillation (issue 5606)
                  paddingBottom = `${(1 / aspectRatio) * 100}%`;
              }
          }
          else {
              height = props.height || '';
          }
          return (y$1("div", { "aria-labelledby": props.labeledById, ref: this.handleEl, className: classNames.join(' '), style: { height, paddingBottom } }, props.children));
      }
      componentDidMount() {
          this.context.addResizeHandler(this.handleResize);
      }
      componentWillUnmount() {
          this.context.removeResizeHandler(this.handleResize);
      }
      updateAvailableWidth() {
          if (this.el && // needed. but why?
              this.props.aspectRatio // aspectRatio is the only height setting that needs availableWidth
          ) {
              this.setState({ availableWidth: this.el.offsetWidth });
          }
      }
  }

  /*
  Detects when the user clicks on an event within a DateComponent
  */
  class EventClicking extends Interaction {
      constructor(settings) {
          super(settings);
          this.handleSegClick = (ev, segEl) => {
              let { component } = this;
              let { context } = component;
              let seg = getElSeg(segEl);
              if (seg && // might be the <div> surrounding the more link
                  component.isValidSegDownEl(ev.target)) {
                  // our way to simulate a link click for elements that can't be <a> tags
                  // grab before trigger fired in case trigger trashes DOM thru rerendering
                  let hasUrlContainer = elementClosest(ev.target, '.fc-event-forced-url');
                  let url = hasUrlContainer ? hasUrlContainer.querySelector('a[href]').href : '';
                  context.emitter.trigger('eventClick', {
                      el: segEl,
                      event: new EventImpl(component.context, seg.eventRange.def, seg.eventRange.instance),
                      jsEvent: ev,
                      view: context.viewApi,
                  });
                  if (url && !ev.defaultPrevented) {
                      window.location.href = url;
                  }
              }
          };
          this.destroy = listenBySelector(settings.el, 'click', '.fc-event', // on both fg and bg events
          this.handleSegClick);
      }
  }

  /*
  Triggers events and adds/removes core classNames when the user's pointer
  enters/leaves event-elements of a component.
  */
  class EventHovering extends Interaction {
      constructor(settings) {
          super(settings);
          // for simulating an eventMouseLeave when the event el is destroyed while mouse is over it
          this.handleEventElRemove = (el) => {
              if (el === this.currentSegEl) {
                  this.handleSegLeave(null, this.currentSegEl);
              }
          };
          this.handleSegEnter = (ev, segEl) => {
              if (getElSeg(segEl)) { // TODO: better way to make sure not hovering over more+ link or its wrapper
                  this.currentSegEl = segEl;
                  this.triggerEvent('eventMouseEnter', ev, segEl);
              }
          };
          this.handleSegLeave = (ev, segEl) => {
              if (this.currentSegEl) {
                  this.currentSegEl = null;
                  this.triggerEvent('eventMouseLeave', ev, segEl);
              }
          };
          this.removeHoverListeners = listenToHoverBySelector(settings.el, '.fc-event', // on both fg and bg events
          this.handleSegEnter, this.handleSegLeave);
      }
      destroy() {
          this.removeHoverListeners();
      }
      triggerEvent(publicEvName, ev, segEl) {
          let { component } = this;
          let { context } = component;
          let seg = getElSeg(segEl);
          if (!ev || component.isValidSegDownEl(ev.target)) {
              context.emitter.trigger(publicEvName, {
                  el: segEl,
                  event: new EventImpl(context, seg.eventRange.def, seg.eventRange.instance),
                  jsEvent: ev,
                  view: context.viewApi,
              });
          }
      }
  }

  class CalendarContent extends PureComponent {
      constructor() {
          super(...arguments);
          this.buildViewContext = memoize(buildViewContext);
          this.buildViewPropTransformers = memoize(buildViewPropTransformers);
          this.buildToolbarProps = memoize(buildToolbarProps);
          this.headerRef = d$1();
          this.footerRef = d$1();
          this.interactionsStore = {};
          // eslint-disable-next-line
          this.state = {
              viewLabelId: getUniqueDomId(),
          };
          // Component Registration
          // -----------------------------------------------------------------------------------------------------------------
          this.registerInteractiveComponent = (component, settingsInput) => {
              let settings = parseInteractionSettings(component, settingsInput);
              let DEFAULT_INTERACTIONS = [
                  EventClicking,
                  EventHovering,
              ];
              let interactionClasses = DEFAULT_INTERACTIONS.concat(this.props.pluginHooks.componentInteractions);
              let interactions = interactionClasses.map((TheInteractionClass) => new TheInteractionClass(settings));
              this.interactionsStore[component.uid] = interactions;
              interactionSettingsStore[component.uid] = settings;
          };
          this.unregisterInteractiveComponent = (component) => {
              let listeners = this.interactionsStore[component.uid];
              if (listeners) {
                  for (let listener of listeners) {
                      listener.destroy();
                  }
                  delete this.interactionsStore[component.uid];
              }
              delete interactionSettingsStore[component.uid];
          };
          // Resizing
          // -----------------------------------------------------------------------------------------------------------------
          this.resizeRunner = new DelayedRunner(() => {
              this.props.emitter.trigger('_resize', true); // should window resizes be considered "forced" ?
              this.props.emitter.trigger('windowResize', { view: this.props.viewApi });
          });
          this.handleWindowResize = (ev) => {
              let { options } = this.props;
              if (options.handleWindowResize &&
                  ev.target === window // avoid jqui events
              ) {
                  this.resizeRunner.request(options.windowResizeDelay);
              }
          };
      }
      /*
      renders INSIDE of an outer div
      */
      render() {
          let { props } = this;
          let { toolbarConfig, options } = props;
          let toolbarProps = this.buildToolbarProps(props.viewSpec, props.dateProfile, props.dateProfileGenerator, props.currentDate, getNow(props.options.now, props.dateEnv), // TODO: use NowTimer????
          props.viewTitle);
          let viewVGrow = false;
          let viewHeight = '';
          let viewAspectRatio;
          if (props.isHeightAuto || props.forPrint) {
              viewHeight = '';
          }
          else if (options.height != null) {
              viewVGrow = true;
          }
          else if (options.contentHeight != null) {
              viewHeight = options.contentHeight;
          }
          else {
              viewAspectRatio = Math.max(options.aspectRatio, 0.5); // prevent from getting too tall
          }
          let viewContext = this.buildViewContext(props.viewSpec, props.viewApi, props.options, props.dateProfileGenerator, props.dateEnv, props.theme, props.pluginHooks, props.dispatch, props.getCurrentData, props.emitter, props.calendarApi, this.registerInteractiveComponent, this.unregisterInteractiveComponent);
          let viewLabelId = (toolbarConfig.header && toolbarConfig.header.hasTitle)
              ? this.state.viewLabelId
              : '';
          return (y$1(ViewContextType.Provider, { value: viewContext },
              toolbarConfig.header && (y$1(Toolbar, Object.assign({ ref: this.headerRef, extraClassName: "fc-header-toolbar", model: toolbarConfig.header, titleId: viewLabelId }, toolbarProps))),
              y$1(ViewHarness, { liquid: viewVGrow, height: viewHeight, aspectRatio: viewAspectRatio, labeledById: viewLabelId },
                  this.renderView(props),
                  this.buildAppendContent()),
              toolbarConfig.footer && (y$1(Toolbar, Object.assign({ ref: this.footerRef, extraClassName: "fc-footer-toolbar", model: toolbarConfig.footer, titleId: "" }, toolbarProps)))));
      }
      componentDidMount() {
          let { props } = this;
          this.calendarInteractions = props.pluginHooks.calendarInteractions
              .map((CalendarInteractionClass) => new CalendarInteractionClass(props));
          window.addEventListener('resize', this.handleWindowResize);
          let { propSetHandlers } = props.pluginHooks;
          for (let propName in propSetHandlers) {
              propSetHandlers[propName](props[propName], props);
          }
      }
      componentDidUpdate(prevProps) {
          let { props } = this;
          let { propSetHandlers } = props.pluginHooks;
          for (let propName in propSetHandlers) {
              if (props[propName] !== prevProps[propName]) {
                  propSetHandlers[propName](props[propName], props);
              }
          }
      }
      componentWillUnmount() {
          window.removeEventListener('resize', this.handleWindowResize);
          this.resizeRunner.clear();
          for (let interaction of this.calendarInteractions) {
              interaction.destroy();
          }
          this.props.emitter.trigger('_unmount');
      }
      buildAppendContent() {
          let { props } = this;
          let children = props.pluginHooks.viewContainerAppends.map((buildAppendContent) => buildAppendContent(props));
          return y$1(_, {}, ...children);
      }
      renderView(props) {
          let { pluginHooks } = props;
          let { viewSpec } = props;
          let viewProps = {
              dateProfile: props.dateProfile,
              businessHours: props.businessHours,
              eventStore: props.renderableEventStore,
              eventUiBases: props.eventUiBases,
              dateSelection: props.dateSelection,
              eventSelection: props.eventSelection,
              eventDrag: props.eventDrag,
              eventResize: props.eventResize,
              isHeightAuto: props.isHeightAuto,
              forPrint: props.forPrint,
          };
          let transformers = this.buildViewPropTransformers(pluginHooks.viewPropsTransformers);
          for (let transformer of transformers) {
              Object.assign(viewProps, transformer.transform(viewProps, props));
          }
          let ViewComponent = viewSpec.component;
          return (y$1(ViewComponent, Object.assign({}, viewProps)));
      }
  }
  function buildToolbarProps(viewSpec, dateProfile, dateProfileGenerator, currentDate, now, title) {
      // don't force any date-profiles to valid date profiles (the `false`) so that we can tell if it's invalid
      let todayInfo = dateProfileGenerator.build(now, undefined, false); // TODO: need `undefined` or else INFINITE LOOP for some reason
      let prevInfo = dateProfileGenerator.buildPrev(dateProfile, currentDate, false);
      let nextInfo = dateProfileGenerator.buildNext(dateProfile, currentDate, false);
      return {
          title,
          activeButton: viewSpec.type,
          navUnit: viewSpec.singleUnit,
          isTodayEnabled: todayInfo.isValid && !rangeContainsMarker(dateProfile.currentRange, now),
          isPrevEnabled: prevInfo.isValid,
          isNextEnabled: nextInfo.isValid,
      };
  }
  // Plugin
  // -----------------------------------------------------------------------------------------------------------------
  function buildViewPropTransformers(theClasses) {
      return theClasses.map((TheClass) => new TheClass());
  }

  class Calendar extends CalendarImpl {
      constructor(el, optionOverrides = {}) {
          super();
          this.isRendering = false;
          this.isRendered = false;
          this.currentClassNames = [];
          this.customContentRenderId = 0;
          this.handleAction = (action) => {
              // actions we know we want to render immediately
              switch (action.type) {
                  case 'SET_EVENT_DRAG':
                  case 'SET_EVENT_RESIZE':
                      this.renderRunner.tryDrain();
              }
          };
          this.handleData = (data) => {
              this.currentData = data;
              this.renderRunner.request(data.calendarOptions.rerenderDelay);
          };
          this.handleRenderRequest = () => {
              if (this.isRendering) {
                  this.isRendered = true;
                  let { currentData } = this;
                  flushSync(() => {
                      D$1(y$1(CalendarRoot, { options: currentData.calendarOptions, theme: currentData.theme, emitter: currentData.emitter }, (classNames, height, isHeightAuto, forPrint) => {
                          this.setClassNames(classNames);
                          this.setHeight(height);
                          return (y$1(RenderId.Provider, { value: this.customContentRenderId },
                              y$1(CalendarContent, Object.assign({ isHeightAuto: isHeightAuto, forPrint: forPrint }, currentData))));
                      }), this.el);
                  });
              }
              else if (this.isRendered) {
                  this.isRendered = false;
                  D$1(null, this.el);
                  this.setClassNames([]);
                  this.setHeight('');
              }
          };
          ensureElHasStyles(el);
          this.el = el;
          this.renderRunner = new DelayedRunner(this.handleRenderRequest);
          new CalendarDataManager({
              optionOverrides,
              calendarApi: this,
              onAction: this.handleAction,
              onData: this.handleData,
          });
      }
      render() {
          let wasRendering = this.isRendering;
          if (!wasRendering) {
              this.isRendering = true;
          }
          else {
              this.customContentRenderId += 1;
          }
          this.renderRunner.request();
          if (wasRendering) {
              this.updateSize();
          }
      }
      destroy() {
          if (this.isRendering) {
              this.isRendering = false;
              this.renderRunner.request();
          }
      }
      updateSize() {
          flushSync(() => {
              super.updateSize();
          });
      }
      batchRendering(func) {
          this.renderRunner.pause('batchRendering');
          func();
          this.renderRunner.resume('batchRendering');
      }
      pauseRendering() {
          this.renderRunner.pause('pauseRendering');
      }
      resumeRendering() {
          this.renderRunner.resume('pauseRendering', true);
      }
      resetOptions(optionOverrides, changedOptionNames) {
          this.currentDataManager.resetOptions(optionOverrides, changedOptionNames);
      }
      setClassNames(classNames) {
          if (!isArraysEqual(classNames, this.currentClassNames)) {
              let { classList } = this.el;
              for (let className of this.currentClassNames) {
                  classList.remove(className);
              }
              for (let className of classNames) {
                  classList.add(className);
              }
              this.currentClassNames = classNames;
          }
      }
      setHeight(height) {
          applyStyleProp(this.el, 'height', height);
      }
  }

  function formatDate(dateInput, options = {}) {
      let dateEnv = buildDateEnv(options);
      let formatter = createFormatter(options);
      let dateMeta = dateEnv.createMarkerMeta(dateInput);
      if (!dateMeta) { // TODO: warning?
          return '';
      }
      return dateEnv.format(dateMeta.marker, formatter, {
          forcedTzo: dateMeta.forcedTzo,
      });
  }
  function formatRange$2(startInput, endInput, options) {
      let dateEnv = buildDateEnv(typeof options === 'object' && options ? options : {}); // pass in if non-null object
      let formatter = createFormatter(options);
      let startMeta = dateEnv.createMarkerMeta(startInput);
      let endMeta = dateEnv.createMarkerMeta(endInput);
      if (!startMeta || !endMeta) { // TODO: warning?
          return '';
      }
      return dateEnv.formatRange(startMeta.marker, endMeta.marker, formatter, {
          forcedStartTzo: startMeta.forcedTzo,
          forcedEndTzo: endMeta.forcedTzo,
          isEndExclusive: options.isEndExclusive,
          defaultSeparator: BASE_OPTION_DEFAULTS.defaultRangeSeparator,
      });
  }
  // TODO: more DRY and optimized
  function buildDateEnv(settings) {
      let locale = buildLocale(settings.locale || 'en', organizeRawLocales([]).map); // TODO: don't hardcode 'en' everywhere
      return new DateEnv(Object.assign(Object.assign({ timeZone: BASE_OPTION_DEFAULTS.timeZone, calendarSystem: 'gregory' }, settings), { locale }));
  }

  // HELPERS
  /*
  if nextDayThreshold is specified, slicing is done in an all-day fashion.
  you can get nextDayThreshold from context.nextDayThreshold
  */
  function sliceEvents(props, allDay) {
      return sliceEventStore(props.eventStore, props.eventUiBases, props.dateProfile.activeRange, allDay ? props.nextDayThreshold : null).fg;
  }

  /*
  NOTE: can't use Date.parse or new Date(str) to parse strings without timezones:
  https://stackoverflow.com/a/33909265/96342
  */
  /*
  Given an ISO8601 string with no timezone part, parses as UTC
  */
  function parseUtcDate(str) {
      let parts = str.split(/\D/);
      if (parts.length > 6) { // has timezone info. will correctly parse
          return new Date(str);
      }
      return new Date(Date.UTC(parseInt(parts[0], 10), parseInt(parts[1], 10) - 1, parts[2] ? parseInt(parts[2], 10) : 0, parts[3] ? parseInt(parts[3], 10) : 0, parts[4] ? parseInt(parts[4], 10) : 0, parts[5] ? parseInt(parts[5], 10) : 0));
  }
  /*
  Given an ISO8601 string with no timezone part, parses as local
  */
  function parseLocalDate(str) {
      let parts = str.split(/\D/);
      if (parts.length > 6) { // has timezone info
          throw new Error('Don\'t pass timezone info to parseLocalDate. Use parseUtcDate instead.');
      }
      else {
          return new Date(parseInt(parts[0], 10), parseInt(parts[1], 10) - 1, parts[2] ? parseInt(parts[2], 10) : 0, parts[3] ? parseInt(parts[3], 10) : 0, parts[4] ? parseInt(parts[4], 10) : 0, parts[5] ? parseInt(parts[5], 10) : 0);
      }
  }

  beforeEach(() => {
      // On real devices, when a click-like touch interaction happens, there is a preiod of time where mouse events
      // are ignores. Since ignore peroid is global, and might span across tests, disable it.
      // The simulates touch events do not fire these mouse events anyway.
      config.touchMouseIgnoreWait = 0;
      // increase the default timeout
      jasmine.DEFAULT_TIMEOUT_INTERVAL = 30000;
  });

  /* General Utils
  ---------------------------------------------------------------------------------------------------------------------- */
  $.simulateByPoint = (type, options) => {
      let docEl = $(document);
      let point = options.point;
      let clientX;
      let clientY;
      let node;
      if (point) {
          clientX = point.left - docEl.scrollLeft();
          clientY = point.top - docEl.scrollTop();
          node = document.elementFromPoint(clientX, clientY);
          $(node).simulate(type, options);
      }
  };
  /* Touch
  ---------------------------------------------------------------------------------------------------------------------- */
  let origSimulateEvent = $.simulate.prototype.simulateEvent;
  let touchUID = Date.now();
  $.simulate.prototype.simulateEvent = function (elem, type, options) {
      if (elem === window && type === 'resize') {
          return this.simulateWindowResize();
      }
      if (/^touch/.test(type)) {
          return this.simulateTouchEvent(elem, type, options);
      }
      return origSimulateEvent.apply(this, arguments); // eslint-disable-line prefer-rest-params
  };
  $.simulate.prototype.simulateWindowResize = function () {
      // from https://stackoverflow.com/a/1818513/96342
      let event;
      if (typeof Event !== 'undefined') {
          try {
              event = new Event('resize');
          }
          catch (ex) {
              // why would fail?
          }
      }
      if (!event) {
          event = document.createEvent('UIEvents');
          event.initUIEvent('resize', true, false, window, 0);
      }
      this.dispatchEvent(window, 'resize', event);
  };
  $.simulate.prototype.simulateTouchEvent = function (elem, type, options) {
      // http://stackoverflow.com/a/29019278/96342
      let event = document.createEvent('Event');
      event.initEvent(type, true, true); // cancelable, bubbleable
      event.touches = [{
              target: elem,
              identifier: touchUID,
              pageX: options.clientX,
              pageY: options.clientY,
              screenX: options.clientX,
              screenY: options.clientY,
              clientX: options.clientX,
              clientY: options.clientY,
          }];
      touchUID += 1;
      this.dispatchEvent(elem, type, event, options);
  };
  $.simulateMouseClick = function (elem) {
      let $elem = $(elem);
      let clientCoords = {
          clientX: $elem.offset().left + $elem.outerWidth() / 2,
          clientY: $elem.offset().top + $elem.outerHeight() / 2,
      };
      $elem.simulate('mousemove', clientCoords);
      $elem.simulate('mousedown', clientCoords);
      $elem.simulate('mouseup', clientCoords);
      $elem.simulate('click', clientCoords);
  };
  $.simulateTouchClick = function (elem) {
      let $elem = $(elem);
      let clientCoords = {
          clientX: $elem.offset().left + $elem.outerWidth() / 2,
          clientY: $elem.offset().top + $elem.outerHeight() / 2,
      };
      $elem.simulate('touchstart', clientCoords);
      $elem.simulate('touchend', clientCoords);
      $elem.simulate('mousemove', clientCoords);
      $elem.simulate('mousedown', clientCoords);
      $elem.simulate('mouseup', clientCoords);
      $elem.simulate('click', clientCoords);
  };
  /* Drag-n-drop
  ---------------------------------------------------------------------------------------------------------------------- */
  let DEBUG_DELAY = 500;
  let DEBUG_MIN_DURATION = 2000;
  let DEBUG_MIN_MOVES = 100;
  let DRAG_DEFAULTS = {
      point: null,
      localPoint: { left: '50%', top: '50%' },
      end: null,
      localEndPoint: { left: '50%', top: '50%' },
      dx: 0,
      dy: 0,
      moves: 5,
      duration: 100, // ms
  };
  let dragStackCnt = 0;
  $.simulate.prototype.simulateDrag = function () {
      let options = $.extend({}, DRAG_DEFAULTS, this.options);
      let targetNode = this.target; // raw DOM node
      let targetEl = $(targetNode); // jq object
      let dx = options.dx;
      let dy = options.dy;
      let duration = options.duration;
      let moves = options.moves;
      let startPoint;
      let endEl;
      let endPoint;
      let localPoint;
      let offset;
      // compute start point
      if (options.point) {
          startPoint = options.point;
      }
      else {
          localPoint = normalizeElPoint(options.localPoint, targetEl);
          offset = targetEl.offset();
          startPoint = {
              left: offset.left + localPoint.left,
              top: offset.top + localPoint.top,
          };
      }
      // compute end point
      if (options.end) {
          if (isPoint(options.end)) {
              endPoint = options.end;
          }
          else { // assume options.end is an element
              endEl = $(options.end);
              localPoint = normalizeElPoint(options.localEndPoint, endEl);
              offset = endEl.offset();
              endPoint = {
                  left: offset.left + localPoint.left,
                  top: offset.top + localPoint.top,
              };
          }
      }
      if (endPoint) {
          dx = endPoint.left - startPoint.left;
          dy = endPoint.top - startPoint.top;
      }
      moves = Math.max(moves, options.debug ? DEBUG_MIN_MOVES : 1);
      duration = Math.max(duration, options.debug ? DEBUG_MIN_DURATION : 10);
      simulateDrag(this, targetNode, startPoint, dx, dy, moves, duration, options);
  };
  function simulateDrag(self, targetNode, startPoint, dx, dy, moveCnt, duration, options) {
      let debug = options.debug;
      let isTouch = options.isTouch;
      let docNode = targetNode.ownerDocument;
      let docEl = $(docNode);
      let waitTime = duration / moveCnt;
      let moveIndex = 0;
      let clientCoords;
      let intervalId;
      let dotEl;
      let dragId;
      if (debug) {
          dotEl = $('<div>')
              .css({
              position: 'absolute',
              zIndex: 99999,
              border: '5px solid red',
              borderRadius: '5px',
              margin: '-5px 0 0 -5px',
          })
              .appendTo('body');
      }
      function updateCoords() {
          let progress = moveIndex / moveCnt;
          let left = startPoint.left + dx * progress;
          let top = startPoint.top + dy * progress;
          clientCoords = {
              clientX: left - docEl.scrollLeft(),
              clientY: top - docEl.scrollTop(),
          };
          if (debug) {
              dotEl.css({ left, top });
          }
      }
      function startDrag() {
          updateCoords();
          dragStackCnt += 1;
          dragId = dragStackCnt;
          // simulate a drag-start only if another drag isn't already happening
          if (dragStackCnt === 1) {
              self.simulateEvent(targetNode, // can have an inner drag-start el. targetNode will still be source of emitted events
              isTouch ? 'touchstart' : 'mousedown', clientCoords);
          }
          let delay = options.delay || 0;
          if (debug) {
              delay = Math.max(delay, DEBUG_DELAY);
          }
          if (delay) {
              setTimeout(() => {
                  startMoving();
              }, delay);
          }
          else {
              startMoving();
          }
      }
      function startMoving() {
          intervalId = setInterval(tick, waitTime);
      }
      function tick() {
          moveIndex += 1;
          updateCoords(); // update clientCoords before mousemove
          if (isTouch) {
              // touchmove happens on the originating element
              self.simulateEvent(targetNode, 'touchmove', clientCoords);
          }
          else {
              self.simulateEvent(docNode, 'mousemove', clientCoords);
          }
          if (moveIndex >= moveCnt) {
              stopMoving();
          }
      }
      function stopMoving() {
          clearInterval(intervalId);
          if (debug) {
              setTimeout(() => {
                  dotEl.remove(); // do this before calling stopDrag/callback. don't want dot picked up by elementFromPoint
                  stopDrag();
              }, DEBUG_DELAY);
          }
          else {
              stopDrag();
          }
      }
      function stopDrag() {
          (options.onBeforeRelease || (() => { }))();
          // only simulate a drop if the current drag is still the active one.
          // otherwise, this means another drag has begun via onBeforeRelease.
          if (dragId === dragStackCnt) {
              if ($.contains(docNode, targetNode) ||
                  isTouch // touch will always first touchend on original node, even if removed from DOM
              // https://stackoverflow.com/a/45760014
              ) {
                  self.simulateEvent(targetNode, isTouch ? 'touchend' : 'mouseup', clientCoords);
                  self.simulateEvent(targetNode, 'click', clientCoords);
              }
              else {
                  self.simulateEvent(docNode, isTouch ? 'touchend' : 'mouseup', clientCoords);
              }
          }
          dragStackCnt -= 1;
          let callback = options.onRelease || options.callback || (() => { });
          // we wait because the there might be a FullCalendar drag interaction that finishes asynchronously
          // after the mouseend/touchend happens, and it's really convenient if our callback fires after that.
          setTimeout(callback, 0);
      }
      startDrag();
  }
  function normalizeElPoint(point, el) {
      let left = point.left;
      let top = point.top;
      if (/%$/.test(left)) {
          left = (parseInt(left, 10) / 100) * el.outerWidth();
      }
      if (/%$/.test(top)) {
          top = (parseInt(top, 10) / 100) * el.outerHeight();
      }
      return { left, top };
  }
  function isPoint(input) {
      return typeof input === 'object' && // `in` operator only works on objects
          'left' in input && 'top' in input;
  }

  beforeEach(() => {
      jasmine.addMatchers({
          toEqualDate() {
              return {
                  compare(actual, expected) {
                      let result;
                      if (typeof expected === 'string') {
                          expected = parseUtcDate(expected);
                      }
                      if (!(actual instanceof Date)) {
                          result = {
                              pass: false,
                              message: 'Actual value ' + actual + ' needs to be an instance of a Date',
                          };
                      }
                      else if (!(expected instanceof Date)) {
                          result = {
                              pass: false,
                              message: 'Expected value ' + expected + ' needs to be an instance of a Date',
                          };
                      }
                      else if (actual.valueOf() !== expected.valueOf()) {
                          result = {
                              pass: false,
                              message: 'Date ' + actual.toUTCString() + ' does not equal ' + expected.toUTCString(),
                          };
                      }
                      else {
                          result = { pass: true };
                      }
                      return result;
                  },
              };
          },
          toEqualLocalDate() {
              return {
                  compare(actual, expected) {
                      let result;
                      if (typeof expected === 'string') {
                          expected = parseLocalDate(expected);
                      }
                      if (!(actual instanceof Date)) {
                          result = {
                              pass: false,
                              message: 'Actual value ' + actual + ' needs to be an instance of a Date',
                          };
                      }
                      else if (!(expected instanceof Date)) {
                          result = {
                              pass: false,
                              message: 'Expected value ' + expected + ' needs to be an instance of a Date',
                          };
                      }
                      else if (actual.valueOf() !== expected.valueOf()) {
                          result = {
                              pass: false,
                              message: 'Date ' + actual.toString() + ' does not equal ' + expected.toString(),
                          };
                      }
                      else {
                          result = { pass: true };
                      }
                      return result;
                  },
              };
          },
          toEqualNow() {
              return {
                  compare(actual) {
                      let result;
                      if (!(actual instanceof Date)) {
                          result = {
                              pass: false,
                              message: 'Actual value ' + actual + ' needs to be an instance of a Date',
                          };
                      }
                      else if (Math.abs(actual.valueOf() - new Date().valueOf()) > 1000) {
                          result = {
                              pass: false,
                              message: 'Date ' + actual.toUTCString() + ' is not close enough to now',
                          };
                      }
                      else {
                          result = { pass: true };
                      }
                      return result;
                  },
              };
          },
      });
  });

  // Setup / Teardown
  // ---------------------------------------------------------------------------------------------------------------------
  let optionsStack = null;
  beforeEach(() => {
      optionsStack = [];
  });
  afterEach(() => {
      optionsStack = null;
      if (window.currentCalendar) {
          window.currentCalendar.destroy();
          window.currentCalendar = null;
      }
      $('#calendar').remove();
  });
  // Calendar Options and Initialization
  // ---------------------------------------------------------------------------------------------------------------------
  function pushOptions$1(options) {
      beforeEach(() => {
          optionsStack.push(options);
      });
  }
  // called within an `it`
  // needs to be called *before* initCalendar
  function spyOnCalendarCallback$1(name, func) {
      let options = {};
      options[name] = func || (() => { });
      spyOn(options, name).and.callThrough();
      optionsStack.push(options);
      return options[name];
  }
  function initCalendar$1(moreOptions, el) {
      let $el;
      if (moreOptions) {
          optionsStack.push(moreOptions);
      }
      if (el) {
          $el = $(el);
      }
      else {
          $el = $('<div id="calendar">').appendTo('body');
      }
      if (window.currentCalendar) {
          window.currentCalendar.destroy();
      }
      let options = getCurrentOptions$1();
      let newCalendar = null;
      options.plugins = options.plugins.concat([
          createPlugin({
              name: 'current-calendar-' + Date.now(),
              contextInit(context) {
                  newCalendar = window.currentCalendar = context.calendarApi;
              },
          }),
      ]);
      let cool = new Calendar($el[0], options);
      if (newCalendar === window.currentCalendar) {
          newCalendar.render();
      }
      else {
          newCalendar.destroy();
      }
      return cool;
  }
  function getCurrentOptions$1() {
      let args = [{}].concat(optionsStack);
      return $.extend.apply($, args); // eslint-disable-line prefer-spread
  }
  // Categorizing Tests
  // ---------------------------------------------------------------------------------------------------------------------
  /*
  describeOptions(optionName, descriptionAndValueHash, callback)
  describeOptions(descriptionAndOptionsHash, callback)
   */
  function describeOptions$1(optName, hash, callback) {
      if ($.type(optName) === 'object') {
          callback = hash;
          hash = optName;
          optName = null;
      }
      $.each(hash, (desc, val) => {
          let opts;
          if (optName) {
              opts = {};
              opts[optName] = val;
          }
          else {
              opts = val;
          }
          opts = $.extend(true, {}, opts);
          describe(desc, () => {
              pushOptions$1(opts);
              callback(val);
          });
      });
  }
  function describeValues$1(hash, callback) {
      $.each(hash, 
      /**
       * @param desc {string}
       */
      (desc, val) => {
          describe(desc, () => {
              callback(val);
          });
      });
  }
  // Timezone Tests (needed?)
  // ---------------------------------------------------------------------------------------------------------------------
  const timeZoneScenarios = {
      local: {
          description: 'when local timezone',
          value: 'local',
          parseDate: parseLocalDate,
      },
      UTC: {
          description: 'when UTC timezone',
          value: 'UTC',
          parseDate: parseUtcDate,
      },
  };
  function describeTimeZones$1(callback) {
      $.each(timeZoneScenarios, (name, scenario) => {
          describe(scenario.description, () => {
              pushOptions$1({
                  timeZone: name,
              });
              callback(scenario);
          });
      });
  }
  function describeTimeZone(name, callback) {
      let scenario = timeZoneScenarios[name];
      describe(scenario.description, () => {
          pushOptions$1({
              timeZone: name,
          });
          callback(scenario);
      });
  }
  // Misc
  // ---------------------------------------------------------------------------------------------------------------------
  function oneCall(func) {
      let called;
      called = false;
      return function () {
          if (!called) {
              called = true;
              return func.apply(this, arguments); // eslint-disable-line prefer-rest-params
          }
          return null;
      };
  }
  function spyOnMethod(Class, methodName, dontCallThrough) {
      let origMethod = Class.prototype.hasOwnProperty(methodName) // eslint-disable-line no-prototype-builtins
          ? Class.prototype[methodName]
          : null;
      let spy = spyOn(Class.prototype, methodName);
      if (!dontCallThrough) {
          spy = spy.and.callThrough();
      }
      spy.restore = () => {
          if (origMethod) {
              Class.prototype[methodName] = origMethod;
          }
          else {
              delete Class.prototype[methodName];
          }
      };
      return spy;
  }
  // wraps an existing function in a spy, calling through to the function
  function spyCall(func) {
      func = func || (() => { });
      const obj = { func };
      spyOn(obj, 'func').and.callThrough();
      return obj.func;
  }
  Object.assign(window, {
      spyOnCalendarCallback: spyOnCalendarCallback$1,
      pushOptions: pushOptions$1,
      initCalendar: initCalendar$1,
      getCurrentOptions: getCurrentOptions$1,
      describeOptions: describeOptions$1,
      describeValues: describeValues$1,
      describeTimeZones: describeTimeZones$1,
      describeTimeZone,
      oneCall,
      spyOnMethod,
      spyCall,
  });
  pushOptions$1({
      timeZone: 'UTC',
      eventDisplay: 'auto',
  });

  config.touchMouseIgnoreWait = 500;
  let ignoreMouseDepth = 0;
  let listenerCnt = 0;
  let isWindowTouchMoveCancelled = false;
  /*
  Uses a "pointer" abstraction, which monitors UI events for both mouse and touch.
  Tracks when the pointer "drags" on a certain element, meaning down+move+up.

  Also, tracks if there was touch-scrolling.
  Also, can prevent touch-scrolling from happening.
  Also, can fire pointermove events when scrolling happens underneath, even when no real pointer movement.

  emits:
  - pointerdown
  - pointermove
  - pointerup
  */
  class PointerDragging {
      constructor(containerEl) {
          this.subjectEl = null;
          // options that can be directly assigned by caller
          this.selector = ''; // will cause subjectEl in all emitted events to be this element
          this.handleSelector = '';
          this.shouldIgnoreMove = false;
          this.shouldWatchScroll = true; // for simulating pointermove on scroll
          // internal states
          this.isDragging = false;
          this.isTouchDragging = false;
          this.wasTouchScroll = false;
          // Mouse
          // ----------------------------------------------------------------------------------------------------
          this.handleMouseDown = (ev) => {
              if (!this.shouldIgnoreMouse() &&
                  isPrimaryMouseButton(ev) &&
                  this.tryStart(ev)) {
                  let pev = this.createEventFromMouse(ev, true);
                  this.emitter.trigger('pointerdown', pev);
                  this.initScrollWatch(pev);
                  if (!this.shouldIgnoreMove) {
                      document.addEventListener('mousemove', this.handleMouseMove);
                  }
                  document.addEventListener('mouseup', this.handleMouseUp);
              }
          };
          this.handleMouseMove = (ev) => {
              let pev = this.createEventFromMouse(ev);
              this.recordCoords(pev);
              this.emitter.trigger('pointermove', pev);
          };
          this.handleMouseUp = (ev) => {
              document.removeEventListener('mousemove', this.handleMouseMove);
              document.removeEventListener('mouseup', this.handleMouseUp);
              this.emitter.trigger('pointerup', this.createEventFromMouse(ev));
              this.cleanup(); // call last so that pointerup has access to props
          };
          // Touch
          // ----------------------------------------------------------------------------------------------------
          this.handleTouchStart = (ev) => {
              if (this.tryStart(ev)) {
                  this.isTouchDragging = true;
                  let pev = this.createEventFromTouch(ev, true);
                  this.emitter.trigger('pointerdown', pev);
                  this.initScrollWatch(pev);
                  // unlike mouse, need to attach to target, not document
                  // https://stackoverflow.com/a/45760014
                  let targetEl = ev.target;
                  if (!this.shouldIgnoreMove) {
                      targetEl.addEventListener('touchmove', this.handleTouchMove);
                  }
                  targetEl.addEventListener('touchend', this.handleTouchEnd);
                  targetEl.addEventListener('touchcancel', this.handleTouchEnd); // treat it as a touch end
                  // attach a handler to get called when ANY scroll action happens on the page.
                  // this was impossible to do with normal on/off because 'scroll' doesn't bubble.
                  // http://stackoverflow.com/a/32954565/96342
                  window.addEventListener('scroll', this.handleTouchScroll, true);
              }
          };
          this.handleTouchMove = (ev) => {
              let pev = this.createEventFromTouch(ev);
              this.recordCoords(pev);
              this.emitter.trigger('pointermove', pev);
          };
          this.handleTouchEnd = (ev) => {
              if (this.isDragging) { // done to guard against touchend followed by touchcancel
                  let targetEl = ev.target;
                  targetEl.removeEventListener('touchmove', this.handleTouchMove);
                  targetEl.removeEventListener('touchend', this.handleTouchEnd);
                  targetEl.removeEventListener('touchcancel', this.handleTouchEnd);
                  window.removeEventListener('scroll', this.handleTouchScroll, true); // useCaptured=true
                  this.emitter.trigger('pointerup', this.createEventFromTouch(ev));
                  this.cleanup(); // call last so that pointerup has access to props
                  this.isTouchDragging = false;
                  startIgnoringMouse();
              }
          };
          this.handleTouchScroll = () => {
              this.wasTouchScroll = true;
          };
          this.handleScroll = (ev) => {
              if (!this.shouldIgnoreMove) {
                  let pageX = (window.pageXOffset - this.prevScrollX) + this.prevPageX;
                  let pageY = (window.pageYOffset - this.prevScrollY) + this.prevPageY;
                  this.emitter.trigger('pointermove', {
                      origEvent: ev,
                      isTouch: this.isTouchDragging,
                      subjectEl: this.subjectEl,
                      pageX,
                      pageY,
                      deltaX: pageX - this.origPageX,
                      deltaY: pageY - this.origPageY,
                  });
              }
          };
          this.containerEl = containerEl;
          this.emitter = new Emitter();
          containerEl.addEventListener('mousedown', this.handleMouseDown);
          containerEl.addEventListener('touchstart', this.handleTouchStart, { passive: true });
          listenerCreated();
      }
      destroy() {
          this.containerEl.removeEventListener('mousedown', this.handleMouseDown);
          this.containerEl.removeEventListener('touchstart', this.handleTouchStart, { passive: true });
          listenerDestroyed();
      }
      tryStart(ev) {
          let subjectEl = this.querySubjectEl(ev);
          let downEl = ev.target;
          if (subjectEl &&
              (!this.handleSelector || elementClosest(downEl, this.handleSelector))) {
              this.subjectEl = subjectEl;
              this.isDragging = true; // do this first so cancelTouchScroll will work
              this.wasTouchScroll = false;
              return true;
          }
          return false;
      }
      cleanup() {
          isWindowTouchMoveCancelled = false;
          this.isDragging = false;
          this.subjectEl = null;
          // keep wasTouchScroll around for later access
          this.destroyScrollWatch();
      }
      querySubjectEl(ev) {
          if (this.selector) {
              return elementClosest(ev.target, this.selector);
          }
          return this.containerEl;
      }
      shouldIgnoreMouse() {
          return ignoreMouseDepth || this.isTouchDragging;
      }
      // can be called by user of this class, to cancel touch-based scrolling for the current drag
      cancelTouchScroll() {
          if (this.isDragging) {
              isWindowTouchMoveCancelled = true;
          }
      }
      // Scrolling that simulates pointermoves
      // ----------------------------------------------------------------------------------------------------
      initScrollWatch(ev) {
          if (this.shouldWatchScroll) {
              this.recordCoords(ev);
              window.addEventListener('scroll', this.handleScroll, true); // useCapture=true
          }
      }
      recordCoords(ev) {
          if (this.shouldWatchScroll) {
              this.prevPageX = ev.pageX;
              this.prevPageY = ev.pageY;
              this.prevScrollX = window.pageXOffset;
              this.prevScrollY = window.pageYOffset;
          }
      }
      destroyScrollWatch() {
          if (this.shouldWatchScroll) {
              window.removeEventListener('scroll', this.handleScroll, true); // useCaptured=true
          }
      }
      // Event Normalization
      // ----------------------------------------------------------------------------------------------------
      createEventFromMouse(ev, isFirst) {
          let deltaX = 0;
          let deltaY = 0;
          // TODO: repeat code
          if (isFirst) {
              this.origPageX = ev.pageX;
              this.origPageY = ev.pageY;
          }
          else {
              deltaX = ev.pageX - this.origPageX;
              deltaY = ev.pageY - this.origPageY;
          }
          return {
              origEvent: ev,
              isTouch: false,
              subjectEl: this.subjectEl,
              pageX: ev.pageX,
              pageY: ev.pageY,
              deltaX,
              deltaY,
          };
      }
      createEventFromTouch(ev, isFirst) {
          let touches = ev.touches;
          let pageX;
          let pageY;
          let deltaX = 0;
          let deltaY = 0;
          // if touch coords available, prefer,
          // because FF would give bad ev.pageX ev.pageY
          if (touches && touches.length) {
              pageX = touches[0].pageX;
              pageY = touches[0].pageY;
          }
          else {
              pageX = ev.pageX;
              pageY = ev.pageY;
          }
          // TODO: repeat code
          if (isFirst) {
              this.origPageX = pageX;
              this.origPageY = pageY;
          }
          else {
              deltaX = pageX - this.origPageX;
              deltaY = pageY - this.origPageY;
          }
          return {
              origEvent: ev,
              isTouch: true,
              subjectEl: this.subjectEl,
              pageX,
              pageY,
              deltaX,
              deltaY,
          };
      }
  }
  // Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)
  function isPrimaryMouseButton(ev) {
      return ev.button === 0 && !ev.ctrlKey;
  }
  // Ignoring fake mouse events generated by touch
  // ----------------------------------------------------------------------------------------------------
  function startIgnoringMouse() {
      ignoreMouseDepth += 1;
      setTimeout(() => {
          ignoreMouseDepth -= 1;
      }, config.touchMouseIgnoreWait);
  }
  // We want to attach touchmove as early as possible for Safari
  // ----------------------------------------------------------------------------------------------------
  function listenerCreated() {
      listenerCnt += 1;
      if (listenerCnt === 1) {
          window.addEventListener('touchmove', onWindowTouchMove, { passive: false });
      }
  }
  function listenerDestroyed() {
      listenerCnt -= 1;
      if (!listenerCnt) {
          window.removeEventListener('touchmove', onWindowTouchMove, { passive: false });
      }
  }
  function onWindowTouchMove(ev) {
      if (isWindowTouchMoveCancelled) {
          ev.preventDefault();
      }
  }

  /*
  An effect in which an element follows the movement of a pointer across the screen.
  The moving element is a clone of some other element.
  Must call start + handleMove + stop.
  */
  class ElementMirror {
      constructor() {
          this.isVisible = false; // must be explicitly enabled
          this.sourceEl = null;
          this.mirrorEl = null;
          this.sourceElRect = null; // screen coords relative to viewport
          // options that can be set directly by caller
          this.parentNode = document.body; // HIGHLY SUGGESTED to set this to sidestep ShadowDOM issues
          this.zIndex = 9999;
          this.revertDuration = 0;
      }
      start(sourceEl, pageX, pageY) {
          this.sourceEl = sourceEl;
          this.sourceElRect = this.sourceEl.getBoundingClientRect();
          this.origScreenX = pageX - window.pageXOffset;
          this.origScreenY = pageY - window.pageYOffset;
          this.deltaX = 0;
          this.deltaY = 0;
          this.updateElPosition();
      }
      handleMove(pageX, pageY) {
          this.deltaX = (pageX - window.pageXOffset) - this.origScreenX;
          this.deltaY = (pageY - window.pageYOffset) - this.origScreenY;
          this.updateElPosition();
      }
      // can be called before start
      setIsVisible(bool) {
          if (bool) {
              if (!this.isVisible) {
                  if (this.mirrorEl) {
                      this.mirrorEl.style.display = '';
                  }
                  this.isVisible = bool; // needs to happen before updateElPosition
                  this.updateElPosition(); // because was not updating the position while invisible
              }
          }
          else if (this.isVisible) {
              if (this.mirrorEl) {
                  this.mirrorEl.style.display = 'none';
              }
              this.isVisible = bool;
          }
      }
      // always async
      stop(needsRevertAnimation, callback) {
          let done = () => {
              this.cleanup();
              callback();
          };
          if (needsRevertAnimation &&
              this.mirrorEl &&
              this.isVisible &&
              this.revertDuration && // if 0, transition won't work
              (this.deltaX || this.deltaY) // if same coords, transition won't work
          ) {
              this.doRevertAnimation(done, this.revertDuration);
          }
          else {
              setTimeout(done, 0);
          }
      }
      doRevertAnimation(callback, revertDuration) {
          let mirrorEl = this.mirrorEl;
          let finalSourceElRect = this.sourceEl.getBoundingClientRect(); // because autoscrolling might have happened
          mirrorEl.style.transition =
              'top ' + revertDuration + 'ms,' +
                  'left ' + revertDuration + 'ms';
          applyStyle(mirrorEl, {
              left: finalSourceElRect.left,
              top: finalSourceElRect.top,
          });
          whenTransitionDone(mirrorEl, () => {
              mirrorEl.style.transition = '';
              callback();
          });
      }
      cleanup() {
          if (this.mirrorEl) {
              removeElement(this.mirrorEl);
              this.mirrorEl = null;
          }
          this.sourceEl = null;
      }
      updateElPosition() {
          if (this.sourceEl && this.isVisible) {
              applyStyle(this.getMirrorEl(), {
                  left: this.sourceElRect.left + this.deltaX,
                  top: this.sourceElRect.top + this.deltaY,
              });
          }
      }
      getMirrorEl() {
          let sourceElRect = this.sourceElRect;
          let mirrorEl = this.mirrorEl;
          if (!mirrorEl) {
              mirrorEl = this.mirrorEl = this.sourceEl.cloneNode(true); // cloneChildren=true
              // we don't want long taps or any mouse interaction causing selection/menus.
              // would use preventSelection(), but that prevents selectstart, causing problems.
              mirrorEl.style.userSelect = 'none';
              mirrorEl.style.webkitUserSelect = 'none';
              mirrorEl.classList.add('fc-event-dragging');
              applyStyle(mirrorEl, {
                  position: 'fixed',
                  zIndex: this.zIndex,
                  visibility: '',
                  boxSizing: 'border-box',
                  width: sourceElRect.right - sourceElRect.left,
                  height: sourceElRect.bottom - sourceElRect.top,
                  right: 'auto',
                  bottom: 'auto',
                  margin: 0,
              });
              this.parentNode.appendChild(mirrorEl);
          }
          return mirrorEl;
      }
  }

  /*
  Is a cache for a given element's scroll information (all the info that ScrollController stores)
  in addition the "client rectangle" of the element.. the area within the scrollbars.

  The cache can be in one of two modes:
  - doesListening:false - ignores when the container is scrolled by someone else
  - doesListening:true - watch for scrolling and update the cache
  */
  class ScrollGeomCache extends ScrollController {
      constructor(scrollController, doesListening) {
          super();
          this.handleScroll = () => {
              this.scrollTop = this.scrollController.getScrollTop();
              this.scrollLeft = this.scrollController.getScrollLeft();
              this.handleScrollChange();
          };
          this.scrollController = scrollController;
          this.doesListening = doesListening;
          this.scrollTop = this.origScrollTop = scrollController.getScrollTop();
          this.scrollLeft = this.origScrollLeft = scrollController.getScrollLeft();
          this.scrollWidth = scrollController.getScrollWidth();
          this.scrollHeight = scrollController.getScrollHeight();
          this.clientWidth = scrollController.getClientWidth();
          this.clientHeight = scrollController.getClientHeight();
          this.clientRect = this.computeClientRect(); // do last in case it needs cached values
          if (this.doesListening) {
              this.getEventTarget().addEventListener('scroll', this.handleScroll);
          }
      }
      destroy() {
          if (this.doesListening) {
              this.getEventTarget().removeEventListener('scroll', this.handleScroll);
          }
      }
      getScrollTop() {
          return this.scrollTop;
      }
      getScrollLeft() {
          return this.scrollLeft;
      }
      setScrollTop(top) {
          this.scrollController.setScrollTop(top);
          if (!this.doesListening) {
              // we are not relying on the element to normalize out-of-bounds scroll values
              // so we need to sanitize ourselves
              this.scrollTop = Math.max(Math.min(top, this.getMaxScrollTop()), 0);
              this.handleScrollChange();
          }
      }
      setScrollLeft(top) {
          this.scrollController.setScrollLeft(top);
          if (!this.doesListening) {
              // we are not relying on the element to normalize out-of-bounds scroll values
              // so we need to sanitize ourselves
              this.scrollLeft = Math.max(Math.min(top, this.getMaxScrollLeft()), 0);
              this.handleScrollChange();
          }
      }
      getClientWidth() {
          return this.clientWidth;
      }
      getClientHeight() {
          return this.clientHeight;
      }
      getScrollWidth() {
          return this.scrollWidth;
      }
      getScrollHeight() {
          return this.scrollHeight;
      }
      handleScrollChange() {
      }
  }

  class ElementScrollGeomCache extends ScrollGeomCache {
      constructor(el, doesListening) {
          super(new ElementScrollController(el), doesListening);
      }
      getEventTarget() {
          return this.scrollController.el;
      }
      computeClientRect() {
          return computeInnerRect(this.scrollController.el);
      }
  }

  class WindowScrollGeomCache extends ScrollGeomCache {
      constructor(doesListening) {
          super(new WindowScrollController(), doesListening);
      }
      getEventTarget() {
          return window;
      }
      computeClientRect() {
          return {
              left: this.scrollLeft,
              right: this.scrollLeft + this.clientWidth,
              top: this.scrollTop,
              bottom: this.scrollTop + this.clientHeight,
          };
      }
      // the window is the only scroll object that changes it's rectangle relative
      // to the document's topleft as it scrolls
      handleScrollChange() {
          this.clientRect = this.computeClientRect();
      }
  }

  // If available we are using native "performance" API instead of "Date"
  // Read more about it on MDN:
  // https://developer.mozilla.org/en-US/docs/Web/API/Performance
  const getTime = typeof performance === 'function' ? performance.now : Date.now;
  /*
  For a pointer interaction, automatically scrolls certain scroll containers when the pointer
  approaches the edge.

  The caller must call start + handleMove + stop.
  */
  class AutoScroller {
      constructor() {
          // options that can be set by caller
          this.isEnabled = true;
          this.scrollQuery = [window, '.fc-scroller'];
          this.edgeThreshold = 50; // pixels
          this.maxVelocity = 300; // pixels per second
          // internal state
          this.pointerScreenX = null;
          this.pointerScreenY = null;
          this.isAnimating = false;
          this.scrollCaches = null;
          // protect against the initial pointerdown being too close to an edge and starting the scroll
          this.everMovedUp = false;
          this.everMovedDown = false;
          this.everMovedLeft = false;
          this.everMovedRight = false;
          this.animate = () => {
              if (this.isAnimating) { // wasn't cancelled between animation calls
                  let edge = this.computeBestEdge(this.pointerScreenX + window.pageXOffset, this.pointerScreenY + window.pageYOffset);
                  if (edge) {
                      let now = getTime();
                      this.handleSide(edge, (now - this.msSinceRequest) / 1000);
                      this.requestAnimation(now);
                  }
                  else {
                      this.isAnimating = false; // will stop animation
                  }
              }
          };
      }
      start(pageX, pageY, scrollStartEl) {
          if (this.isEnabled) {
              this.scrollCaches = this.buildCaches(scrollStartEl);
              this.pointerScreenX = null;
              this.pointerScreenY = null;
              this.everMovedUp = false;
              this.everMovedDown = false;
              this.everMovedLeft = false;
              this.everMovedRight = false;
              this.handleMove(pageX, pageY);
          }
      }
      handleMove(pageX, pageY) {
          if (this.isEnabled) {
              let pointerScreenX = pageX - window.pageXOffset;
              let pointerScreenY = pageY - window.pageYOffset;
              let yDelta = this.pointerScreenY === null ? 0 : pointerScreenY - this.pointerScreenY;
              let xDelta = this.pointerScreenX === null ? 0 : pointerScreenX - this.pointerScreenX;
              if (yDelta < 0) {
                  this.everMovedUp = true;
              }
              else if (yDelta > 0) {
                  this.everMovedDown = true;
              }
              if (xDelta < 0) {
                  this.everMovedLeft = true;
              }
              else if (xDelta > 0) {
                  this.everMovedRight = true;
              }
              this.pointerScreenX = pointerScreenX;
              this.pointerScreenY = pointerScreenY;
              if (!this.isAnimating) {
                  this.isAnimating = true;
                  this.requestAnimation(getTime());
              }
          }
      }
      stop() {
          if (this.isEnabled) {
              this.isAnimating = false; // will stop animation
              for (let scrollCache of this.scrollCaches) {
                  scrollCache.destroy();
              }
              this.scrollCaches = null;
          }
      }
      requestAnimation(now) {
          this.msSinceRequest = now;
          requestAnimationFrame(this.animate);
      }
      handleSide(edge, seconds) {
          let { scrollCache } = edge;
          let { edgeThreshold } = this;
          let invDistance = edgeThreshold - edge.distance;
          let velocity = // the closer to the edge, the faster we scroll
           ((invDistance * invDistance) / (edgeThreshold * edgeThreshold)) * // quadratic
              this.maxVelocity * seconds;
          let sign = 1;
          switch (edge.name) {
              case 'left':
                  sign = -1;
              // falls through
              case 'right':
                  scrollCache.setScrollLeft(scrollCache.getScrollLeft() + velocity * sign);
                  break;
              case 'top':
                  sign = -1;
              // falls through
              case 'bottom':
                  scrollCache.setScrollTop(scrollCache.getScrollTop() + velocity * sign);
                  break;
          }
      }
      // left/top are relative to document topleft
      computeBestEdge(left, top) {
          let { edgeThreshold } = this;
          let bestSide = null;
          let scrollCaches = this.scrollCaches || [];
          for (let scrollCache of scrollCaches) {
              let rect = scrollCache.clientRect;
              let leftDist = left - rect.left;
              let rightDist = rect.right - left;
              let topDist = top - rect.top;
              let bottomDist = rect.bottom - top;
              // completely within the rect?
              if (leftDist >= 0 && rightDist >= 0 && topDist >= 0 && bottomDist >= 0) {
                  if (topDist <= edgeThreshold && this.everMovedUp && scrollCache.canScrollUp() &&
                      (!bestSide || bestSide.distance > topDist)) {
                      bestSide = { scrollCache, name: 'top', distance: topDist };
                  }
                  if (bottomDist <= edgeThreshold && this.everMovedDown && scrollCache.canScrollDown() &&
                      (!bestSide || bestSide.distance > bottomDist)) {
                      bestSide = { scrollCache, name: 'bottom', distance: bottomDist };
                  }
                  if (leftDist <= edgeThreshold && this.everMovedLeft && scrollCache.canScrollLeft() &&
                      (!bestSide || bestSide.distance > leftDist)) {
                      bestSide = { scrollCache, name: 'left', distance: leftDist };
                  }
                  if (rightDist <= edgeThreshold && this.everMovedRight && scrollCache.canScrollRight() &&
                      (!bestSide || bestSide.distance > rightDist)) {
                      bestSide = { scrollCache, name: 'right', distance: rightDist };
                  }
              }
          }
          return bestSide;
      }
      buildCaches(scrollStartEl) {
          return this.queryScrollEls(scrollStartEl).map((el) => {
              if (el === window) {
                  return new WindowScrollGeomCache(false); // false = don't listen to user-generated scrolls
              }
              return new ElementScrollGeomCache(el, false); // false = don't listen to user-generated scrolls
          });
      }
      queryScrollEls(scrollStartEl) {
          let els = [];
          for (let query of this.scrollQuery) {
              if (typeof query === 'object') {
                  els.push(query);
              }
              else {
                  els.push(...Array.prototype.slice.call(scrollStartEl.getRootNode().querySelectorAll(query)));
              }
          }
          return els;
      }
  }

  /*
  Monitors dragging on an element. Has a number of high-level features:
  - minimum distance required before dragging
  - minimum wait time ("delay") before dragging
  - a mirror element that follows the pointer
  */
  class FeaturefulElementDragging extends ElementDragging {
      constructor(containerEl, selector) {
          super(containerEl);
          this.containerEl = containerEl;
          // options that can be directly set by caller
          // the caller can also set the PointerDragging's options as well
          this.delay = null;
          this.minDistance = 0;
          this.touchScrollAllowed = true; // prevents drag from starting and blocks scrolling during drag
          this.mirrorNeedsRevert = false;
          this.isInteracting = false; // is the user validly moving the pointer? lasts until pointerup
          this.isDragging = false; // is it INTENTFULLY dragging? lasts until after revert animation
          this.isDelayEnded = false;
          this.isDistanceSurpassed = false;
          this.delayTimeoutId = null;
          this.onPointerDown = (ev) => {
              if (!this.isDragging) { // so new drag doesn't happen while revert animation is going
                  this.isInteracting = true;
                  this.isDelayEnded = false;
                  this.isDistanceSurpassed = false;
                  preventSelection(document.body);
                  preventContextMenu(document.body);
                  // prevent links from being visited if there's an eventual drag.
                  // also prevents selection in older browsers (maybe?).
                  // not necessary for touch, besides, browser would complain about passiveness.
                  if (!ev.isTouch) {
                      ev.origEvent.preventDefault();
                  }
                  this.emitter.trigger('pointerdown', ev);
                  if (this.isInteracting && // not destroyed via pointerdown handler
                      !this.pointer.shouldIgnoreMove) {
                      // actions related to initiating dragstart+dragmove+dragend...
                      this.mirror.setIsVisible(false); // reset. caller must set-visible
                      this.mirror.start(ev.subjectEl, ev.pageX, ev.pageY); // must happen on first pointer down
                      this.startDelay(ev);
                      if (!this.minDistance) {
                          this.handleDistanceSurpassed(ev);
                      }
                  }
              }
          };
          this.onPointerMove = (ev) => {
              if (this.isInteracting) {
                  this.emitter.trigger('pointermove', ev);
                  if (!this.isDistanceSurpassed) {
                      let minDistance = this.minDistance;
                      let distanceSq; // current distance from the origin, squared
                      let { deltaX, deltaY } = ev;
                      distanceSq = deltaX * deltaX + deltaY * deltaY;
                      if (distanceSq >= minDistance * minDistance) { // use pythagorean theorem
                          this.handleDistanceSurpassed(ev);
                      }
                  }
                  if (this.isDragging) {
                      // a real pointer move? (not one simulated by scrolling)
                      if (ev.origEvent.type !== 'scroll') {
                          this.mirror.handleMove(ev.pageX, ev.pageY);
                          this.autoScroller.handleMove(ev.pageX, ev.pageY);
                      }
                      this.emitter.trigger('dragmove', ev);
                  }
              }
          };
          this.onPointerUp = (ev) => {
              if (this.isInteracting) {
                  this.isInteracting = false;
                  allowSelection(document.body);
                  allowContextMenu(document.body);
                  this.emitter.trigger('pointerup', ev); // can potentially set mirrorNeedsRevert
                  if (this.isDragging) {
                      this.autoScroller.stop();
                      this.tryStopDrag(ev); // which will stop the mirror
                  }
                  if (this.delayTimeoutId) {
                      clearTimeout(this.delayTimeoutId);
                      this.delayTimeoutId = null;
                  }
              }
          };
          let pointer = this.pointer = new PointerDragging(containerEl);
          pointer.emitter.on('pointerdown', this.onPointerDown);
          pointer.emitter.on('pointermove', this.onPointerMove);
          pointer.emitter.on('pointerup', this.onPointerUp);
          if (selector) {
              pointer.selector = selector;
          }
          this.mirror = new ElementMirror();
          this.autoScroller = new AutoScroller();
      }
      destroy() {
          this.pointer.destroy();
          // HACK: simulate a pointer-up to end the current drag
          // TODO: fire 'dragend' directly and stop interaction. discourage use of pointerup event (b/c might not fire)
          this.onPointerUp({});
      }
      startDelay(ev) {
          if (typeof this.delay === 'number') {
              this.delayTimeoutId = setTimeout(() => {
                  this.delayTimeoutId = null;
                  this.handleDelayEnd(ev);
              }, this.delay); // not assignable to number!
          }
          else {
              this.handleDelayEnd(ev);
          }
      }
      handleDelayEnd(ev) {
          this.isDelayEnded = true;
          this.tryStartDrag(ev);
      }
      handleDistanceSurpassed(ev) {
          this.isDistanceSurpassed = true;
          this.tryStartDrag(ev);
      }
      tryStartDrag(ev) {
          if (this.isDelayEnded && this.isDistanceSurpassed) {
              if (!this.pointer.wasTouchScroll || this.touchScrollAllowed) {
                  this.isDragging = true;
                  this.mirrorNeedsRevert = false;
                  this.autoScroller.start(ev.pageX, ev.pageY, this.containerEl);
                  this.emitter.trigger('dragstart', ev);
                  if (this.touchScrollAllowed === false) {
                      this.pointer.cancelTouchScroll();
                  }
              }
          }
      }
      tryStopDrag(ev) {
          // .stop() is ALWAYS asynchronous, which we NEED because we want all pointerup events
          // that come from the document to fire beforehand. much more convenient this way.
          this.mirror.stop(this.mirrorNeedsRevert, this.stopDrag.bind(this, ev));
      }
      stopDrag(ev) {
          this.isDragging = false;
          this.emitter.trigger('dragend', ev);
      }
      // fill in the implementations...
      setIgnoreMove(bool) {
          this.pointer.shouldIgnoreMove = bool;
      }
      setMirrorIsVisible(bool) {
          this.mirror.setIsVisible(bool);
      }
      setMirrorNeedsRevert(bool) {
          this.mirrorNeedsRevert = bool;
      }
      setAutoScrollEnabled(bool) {
          this.autoScroller.isEnabled = bool;
      }
  }

  /*
  When this class is instantiated, it records the offset of an element (relative to the document topleft),
  and continues to monitor scrolling, updating the cached coordinates if it needs to.
  Does not access the DOM after instantiation, so highly performant.

  Also keeps track of all scrolling/overflow:hidden containers that are parents of the given element
  and an determine if a given point is inside the combined clipping rectangle.
  */
  class OffsetTracker {
      constructor(el) {
          this.origRect = computeRect(el);
          // will work fine for divs that have overflow:hidden
          this.scrollCaches = getClippingParents(el).map((scrollEl) => new ElementScrollGeomCache(scrollEl, true));
      }
      destroy() {
          for (let scrollCache of this.scrollCaches) {
              scrollCache.destroy();
          }
      }
      computeLeft() {
          let left = this.origRect.left;
          for (let scrollCache of this.scrollCaches) {
              left += scrollCache.origScrollLeft - scrollCache.getScrollLeft();
          }
          return left;
      }
      computeTop() {
          let top = this.origRect.top;
          for (let scrollCache of this.scrollCaches) {
              top += scrollCache.origScrollTop - scrollCache.getScrollTop();
          }
          return top;
      }
      isWithinClipping(pageX, pageY) {
          let point = { left: pageX, top: pageY };
          for (let scrollCache of this.scrollCaches) {
              if (!isIgnoredClipping(scrollCache.getEventTarget()) &&
                  !pointInsideRect(point, scrollCache.clientRect)) {
                  return false;
              }
          }
          return true;
      }
  }
  // certain clipping containers should never constrain interactions, like <html> and <body>
  // https://github.com/fullcalendar/fullcalendar/issues/3615
  function isIgnoredClipping(node) {
      let tagName = node.tagName;
      return tagName === 'HTML' || tagName === 'BODY';
  }

  /*
  Tracks movement over multiple droppable areas (aka "hits")
  that exist in one or more DateComponents.
  Relies on an existing draggable.

  emits:
  - pointerdown
  - dragstart
  - hitchange - fires initially, even if not over a hit
  - pointerup
  - (hitchange - again, to null, if ended over a hit)
  - dragend
  */
  class HitDragging {
      constructor(dragging, droppableStore) {
          // options that can be set by caller
          this.useSubjectCenter = false;
          this.requireInitial = true; // if doesn't start out on a hit, won't emit any events
          this.initialHit = null;
          this.movingHit = null;
          this.finalHit = null; // won't ever be populated if shouldIgnoreMove
          this.handlePointerDown = (ev) => {
              let { dragging } = this;
              this.initialHit = null;
              this.movingHit = null;
              this.finalHit = null;
              this.prepareHits();
              this.processFirstCoord(ev);
              if (this.initialHit || !this.requireInitial) {
                  dragging.setIgnoreMove(false);
                  // TODO: fire this before computing processFirstCoord, so listeners can cancel. this gets fired by almost every handler :(
                  this.emitter.trigger('pointerdown', ev);
              }
              else {
                  dragging.setIgnoreMove(true);
              }
          };
          this.handleDragStart = (ev) => {
              this.emitter.trigger('dragstart', ev);
              this.handleMove(ev, true); // force = fire even if initially null
          };
          this.handleDragMove = (ev) => {
              this.emitter.trigger('dragmove', ev);
              this.handleMove(ev);
          };
          this.handlePointerUp = (ev) => {
              this.releaseHits();
              this.emitter.trigger('pointerup', ev);
          };
          this.handleDragEnd = (ev) => {
              if (this.movingHit) {
                  this.emitter.trigger('hitupdate', null, true, ev);
              }
              this.finalHit = this.movingHit;
              this.movingHit = null;
              this.emitter.trigger('dragend', ev);
          };
          this.droppableStore = droppableStore;
          dragging.emitter.on('pointerdown', this.handlePointerDown);
          dragging.emitter.on('dragstart', this.handleDragStart);
          dragging.emitter.on('dragmove', this.handleDragMove);
          dragging.emitter.on('pointerup', this.handlePointerUp);
          dragging.emitter.on('dragend', this.handleDragEnd);
          this.dragging = dragging;
          this.emitter = new Emitter();
      }
      // sets initialHit
      // sets coordAdjust
      processFirstCoord(ev) {
          let origPoint = { left: ev.pageX, top: ev.pageY };
          let adjustedPoint = origPoint;
          let subjectEl = ev.subjectEl;
          let subjectRect;
          if (subjectEl instanceof HTMLElement) { // i.e. not a Document/ShadowRoot
              subjectRect = computeRect(subjectEl);
              adjustedPoint = constrainPoint(adjustedPoint, subjectRect);
          }
          let initialHit = this.initialHit = this.queryHitForOffset(adjustedPoint.left, adjustedPoint.top);
          if (initialHit) {
              if (this.useSubjectCenter && subjectRect) {
                  let slicedSubjectRect = intersectRects$1(subjectRect, initialHit.rect);
                  if (slicedSubjectRect) {
                      adjustedPoint = getRectCenter$1(slicedSubjectRect);
                  }
              }
              this.coordAdjust = diffPoints(adjustedPoint, origPoint);
          }
          else {
              this.coordAdjust = { left: 0, top: 0 };
          }
      }
      handleMove(ev, forceHandle) {
          let hit = this.queryHitForOffset(ev.pageX + this.coordAdjust.left, ev.pageY + this.coordAdjust.top);
          if (forceHandle || !isHitsEqual(this.movingHit, hit)) {
              this.movingHit = hit;
              this.emitter.trigger('hitupdate', hit, false, ev);
          }
      }
      prepareHits() {
          this.offsetTrackers = mapHash(this.droppableStore, (interactionSettings) => {
              interactionSettings.component.prepareHits();
              return new OffsetTracker(interactionSettings.el);
          });
      }
      releaseHits() {
          let { offsetTrackers } = this;
          for (let id in offsetTrackers) {
              offsetTrackers[id].destroy();
          }
          this.offsetTrackers = {};
      }
      queryHitForOffset(offsetLeft, offsetTop) {
          let { droppableStore, offsetTrackers } = this;
          let bestHit = null;
          for (let id in droppableStore) {
              let component = droppableStore[id].component;
              let offsetTracker = offsetTrackers[id];
              if (offsetTracker && // wasn't destroyed mid-drag
                  offsetTracker.isWithinClipping(offsetLeft, offsetTop)) {
                  let originLeft = offsetTracker.computeLeft();
                  let originTop = offsetTracker.computeTop();
                  let positionLeft = offsetLeft - originLeft;
                  let positionTop = offsetTop - originTop;
                  let { origRect } = offsetTracker;
                  let width = origRect.right - origRect.left;
                  let height = origRect.bottom - origRect.top;
                  if (
                  // must be within the element's bounds
                  positionLeft >= 0 && positionLeft < width &&
                      positionTop >= 0 && positionTop < height) {
                      let hit = component.queryHit(positionLeft, positionTop, width, height);
                      if (hit && (
                      // make sure the hit is within activeRange, meaning it's not a dead cell
                      rangeContainsRange(hit.dateProfile.activeRange, hit.dateSpan.range)) &&
                          (!bestHit || hit.layer > bestHit.layer)) {
                          hit.componentId = id;
                          hit.context = component.context;
                          // TODO: better way to re-orient rectangle
                          hit.rect.left += originLeft;
                          hit.rect.right += originLeft;
                          hit.rect.top += originTop;
                          hit.rect.bottom += originTop;
                          bestHit = hit;
                      }
                  }
              }
          }
          return bestHit;
      }
  }
  function isHitsEqual(hit0, hit1) {
      if (!hit0 && !hit1) {
          return true;
      }
      if (Boolean(hit0) !== Boolean(hit1)) {
          return false;
      }
      return isDateSpansEqual(hit0.dateSpan, hit1.dateSpan);
  }

  function buildDatePointApiWithContext(dateSpan, context) {
      let props = {};
      for (let transform of context.pluginHooks.datePointTransforms) {
          Object.assign(props, transform(dateSpan, context));
      }
      Object.assign(props, buildDatePointApi(dateSpan, context.dateEnv));
      return props;
  }
  function buildDatePointApi(span, dateEnv) {
      return {
          date: dateEnv.toDate(span.range.start),
          dateStr: dateEnv.formatIso(span.range.start, { omitTime: span.allDay }),
          allDay: span.allDay,
      };
  }

  /*
  Monitors when the user clicks on a specific date/time of a component.
  A pointerdown+pointerup on the same "hit" constitutes a click.
  */
  class DateClicking extends Interaction {
      constructor(settings) {
          super(settings);
          this.handlePointerDown = (pev) => {
              let { dragging } = this;
              let downEl = pev.origEvent.target;
              // do this in pointerdown (not dragend) because DOM might be mutated by the time dragend is fired
              dragging.setIgnoreMove(!this.component.isValidDateDownEl(downEl));
          };
          // won't even fire if moving was ignored
          this.handleDragEnd = (ev) => {
              let { component } = this;
              let { pointer } = this.dragging;
              if (!pointer.wasTouchScroll) {
                  let { initialHit, finalHit } = this.hitDragging;
                  if (initialHit && finalHit && isHitsEqual(initialHit, finalHit)) {
                      let { context } = component;
                      let arg = Object.assign(Object.assign({}, buildDatePointApiWithContext(initialHit.dateSpan, context)), { dayEl: initialHit.dayEl, jsEvent: ev.origEvent, view: context.viewApi || context.calendarApi.view });
                      context.emitter.trigger('dateClick', arg);
                  }
              }
          };
          // we DO want to watch pointer moves because otherwise finalHit won't get populated
          this.dragging = new FeaturefulElementDragging(settings.el);
          this.dragging.autoScroller.isEnabled = false;
          let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings));
          hitDragging.emitter.on('pointerdown', this.handlePointerDown);
          hitDragging.emitter.on('dragend', this.handleDragEnd);
      }
      destroy() {
          this.dragging.destroy();
      }
  }

  /*
  Tracks when the user selects a portion of time of a component,
  constituted by a drag over date cells, with a possible delay at the beginning of the drag.
  */
  class DateSelecting extends Interaction {
      constructor(settings) {
          super(settings);
          this.dragSelection = null;
          this.handlePointerDown = (ev) => {
              let { component, dragging } = this;
              let { options } = component.context;
              let canSelect = options.selectable &&
                  component.isValidDateDownEl(ev.origEvent.target);
              // don't bother to watch expensive moves if component won't do selection
              dragging.setIgnoreMove(!canSelect);
              // if touch, require user to hold down
              dragging.delay = ev.isTouch ? getComponentTouchDelay$1(component) : null;
          };
          this.handleDragStart = (ev) => {
              this.component.context.calendarApi.unselect(ev); // unselect previous selections
          };
          this.handleHitUpdate = (hit, isFinal) => {
              let { context } = this.component;
              let dragSelection = null;
              let isInvalid = false;
              if (hit) {
                  let initialHit = this.hitDragging.initialHit;
                  let disallowed = hit.componentId === initialHit.componentId
                      && this.isHitComboAllowed
                      && !this.isHitComboAllowed(initialHit, hit);
                  if (!disallowed) {
                      dragSelection = joinHitsIntoSelection(initialHit, hit, context.pluginHooks.dateSelectionTransformers);
                  }
                  if (!dragSelection || !isDateSelectionValid(dragSelection, hit.dateProfile, context)) {
                      isInvalid = true;
                      dragSelection = null;
                  }
              }
              if (dragSelection) {
                  context.dispatch({ type: 'SELECT_DATES', selection: dragSelection });
              }
              else if (!isFinal) { // only unselect if moved away while dragging
                  context.dispatch({ type: 'UNSELECT_DATES' });
              }
              if (!isInvalid) {
                  enableCursor();
              }
              else {
                  disableCursor();
              }
              if (!isFinal) {
                  this.dragSelection = dragSelection; // only clear if moved away from all hits while dragging
              }
          };
          this.handlePointerUp = (pev) => {
              if (this.dragSelection) {
                  // selection is already rendered, so just need to report selection
                  triggerDateSelect(this.dragSelection, pev, this.component.context);
                  this.dragSelection = null;
              }
          };
          let { component } = settings;
          let { options } = component.context;
          let dragging = this.dragging = new FeaturefulElementDragging(settings.el);
          dragging.touchScrollAllowed = false;
          dragging.minDistance = options.selectMinDistance || 0;
          dragging.autoScroller.isEnabled = options.dragScroll;
          let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings));
          hitDragging.emitter.on('pointerdown', this.handlePointerDown);
          hitDragging.emitter.on('dragstart', this.handleDragStart);
          hitDragging.emitter.on('hitupdate', this.handleHitUpdate);
          hitDragging.emitter.on('pointerup', this.handlePointerUp);
      }
      destroy() {
          this.dragging.destroy();
      }
  }
  function getComponentTouchDelay$1(component) {
      let { options } = component.context;
      let delay = options.selectLongPressDelay;
      if (delay == null) {
          delay = options.longPressDelay;
      }
      return delay;
  }
  function joinHitsIntoSelection(hit0, hit1, dateSelectionTransformers) {
      let dateSpan0 = hit0.dateSpan;
      let dateSpan1 = hit1.dateSpan;
      let ms = [
          dateSpan0.range.start,
          dateSpan0.range.end,
          dateSpan1.range.start,
          dateSpan1.range.end,
      ];
      ms.sort(compareNumbers);
      let props = {};
      for (let transformer of dateSelectionTransformers) {
          let res = transformer(hit0, hit1);
          if (res === false) {
              return null;
          }
          if (res) {
              Object.assign(props, res);
          }
      }
      props.range = { start: ms[0], end: ms[3] };
      props.allDay = dateSpan0.allDay;
      return props;
  }

  class EventDragging extends Interaction {
      constructor(settings) {
          super(settings);
          // internal state
          this.subjectEl = null;
          this.subjectSeg = null; // the seg being selected/dragged
          this.isDragging = false;
          this.eventRange = null;
          this.relevantEvents = null; // the events being dragged
          this.receivingContext = null;
          this.validMutation = null;
          this.mutatedRelevantEvents = null;
          this.handlePointerDown = (ev) => {
              let origTarget = ev.origEvent.target;
              let { component, dragging } = this;
              let { mirror } = dragging;
              let { options } = component.context;
              let initialContext = component.context;
              this.subjectEl = ev.subjectEl;
              let subjectSeg = this.subjectSeg = getElSeg(ev.subjectEl);
              let eventRange = this.eventRange = subjectSeg.eventRange;
              let eventInstanceId = eventRange.instance.instanceId;
              this.relevantEvents = getRelevantEvents(initialContext.getCurrentData().eventStore, eventInstanceId);
              dragging.minDistance = ev.isTouch ? 0 : options.eventDragMinDistance;
              dragging.delay =
                  // only do a touch delay if touch and this event hasn't been selected yet
                  (ev.isTouch && eventInstanceId !== component.props.eventSelection) ?
                      getComponentTouchDelay(component) :
                      null;
              if (options.fixedMirrorParent) {
                  mirror.parentNode = options.fixedMirrorParent;
              }
              else {
                  mirror.parentNode = elementClosest(origTarget, '.fc');
              }
              mirror.revertDuration = options.dragRevertDuration;
              let isValid = component.isValidSegDownEl(origTarget) &&
                  !elementClosest(origTarget, '.fc-event-resizer'); // NOT on a resizer
              dragging.setIgnoreMove(!isValid);
              // disable dragging for elements that are resizable (ie, selectable)
              // but are not draggable
              this.isDragging = isValid &&
                  ev.subjectEl.classList.contains('fc-event-draggable');
          };
          this.handleDragStart = (ev) => {
              let initialContext = this.component.context;
              let eventRange = this.eventRange;
              let eventInstanceId = eventRange.instance.instanceId;
              if (ev.isTouch) {
                  // need to select a different event?
                  if (eventInstanceId !== this.component.props.eventSelection) {
                      initialContext.dispatch({ type: 'SELECT_EVENT', eventInstanceId });
                  }
              }
              else {
                  // if now using mouse, but was previous touch interaction, clear selected event
                  initialContext.dispatch({ type: 'UNSELECT_EVENT' });
              }
              if (this.isDragging) {
                  initialContext.calendarApi.unselect(ev); // unselect *date* selection
                  initialContext.emitter.trigger('eventDragStart', {
                      el: this.subjectEl,
                      event: new EventImpl(initialContext, eventRange.def, eventRange.instance),
                      jsEvent: ev.origEvent,
                      view: initialContext.viewApi,
                  });
              }
          };
          this.handleHitUpdate = (hit, isFinal) => {
              if (!this.isDragging) {
                  return;
              }
              let relevantEvents = this.relevantEvents;
              let initialHit = this.hitDragging.initialHit;
              let initialContext = this.component.context;
              // states based on new hit
              let receivingContext = null;
              let mutation = null;
              let mutatedRelevantEvents = null;
              let isInvalid = false;
              let interaction = {
                  affectedEvents: relevantEvents,
                  mutatedEvents: createEmptyEventStore(),
                  isEvent: true,
              };
              if (hit) {
                  receivingContext = hit.context;
                  let receivingOptions = receivingContext.options;
                  if (initialContext === receivingContext ||
                      (receivingOptions.editable && receivingOptions.droppable)) {
                      mutation = computeEventMutation(initialHit, hit, receivingContext.getCurrentData().pluginHooks.eventDragMutationMassagers);
                      if (mutation) {
                          mutatedRelevantEvents = applyMutationToEventStore(relevantEvents, receivingContext.getCurrentData().eventUiBases, mutation, receivingContext);
                          interaction.mutatedEvents = mutatedRelevantEvents;
                          if (!isInteractionValid(interaction, hit.dateProfile, receivingContext)) {
                              isInvalid = true;
                              mutation = null;
                              mutatedRelevantEvents = null;
                              interaction.mutatedEvents = createEmptyEventStore();
                          }
                      }
                  }
                  else {
                      receivingContext = null;
                  }
              }
              this.displayDrag(receivingContext, interaction);
              if (!isInvalid) {
                  enableCursor();
              }
              else {
                  disableCursor();
              }
              if (!isFinal) {
                  if (initialContext === receivingContext && // TODO: write test for this
                      isHitsEqual(initialHit, hit)) {
                      mutation = null;
                  }
                  this.dragging.setMirrorNeedsRevert(!mutation);
                  // render the mirror if no already-rendered mirror
                  // TODO: wish we could somehow wait for dispatch to guarantee render
                  this.dragging.setMirrorIsVisible(!hit || !this.subjectEl.getRootNode().querySelector('.fc-event-mirror'));
                  // assign states based on new hit
                  this.receivingContext = receivingContext;
                  this.validMutation = mutation;
                  this.mutatedRelevantEvents = mutatedRelevantEvents;
              }
          };
          this.handlePointerUp = () => {
              if (!this.isDragging) {
                  this.cleanup(); // because handleDragEnd won't fire
              }
          };
          this.handleDragEnd = (ev) => {
              if (this.isDragging) {
                  let initialContext = this.component.context;
                  let initialView = initialContext.viewApi;
                  let { receivingContext, validMutation } = this;
                  let eventDef = this.eventRange.def;
                  let eventInstance = this.eventRange.instance;
                  let eventApi = new EventImpl(initialContext, eventDef, eventInstance);
                  let relevantEvents = this.relevantEvents;
                  let mutatedRelevantEvents = this.mutatedRelevantEvents;
                  let { finalHit } = this.hitDragging;
                  this.clearDrag(); // must happen after revert animation
                  initialContext.emitter.trigger('eventDragStop', {
                      el: this.subjectEl,
                      event: eventApi,
                      jsEvent: ev.origEvent,
                      view: initialView,
                  });
                  if (validMutation) {
                      // dropped within same calendar
                      if (receivingContext === initialContext) {
                          let updatedEventApi = new EventImpl(initialContext, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null);
                          initialContext.dispatch({
                              type: 'MERGE_EVENTS',
                              eventStore: mutatedRelevantEvents,
                          });
                          let eventChangeArg = {
                              oldEvent: eventApi,
                              event: updatedEventApi,
                              relatedEvents: buildEventApis(mutatedRelevantEvents, initialContext, eventInstance),
                              revert() {
                                  initialContext.dispatch({
                                      type: 'MERGE_EVENTS',
                                      eventStore: relevantEvents, // the pre-change data
                                  });
                              },
                          };
                          let transformed = {};
                          for (let transformer of initialContext.getCurrentData().pluginHooks.eventDropTransformers) {
                              Object.assign(transformed, transformer(validMutation, initialContext));
                          }
                          initialContext.emitter.trigger('eventDrop', Object.assign(Object.assign(Object.assign({}, eventChangeArg), transformed), { el: ev.subjectEl, delta: validMutation.datesDelta, jsEvent: ev.origEvent, view: initialView }));
                          initialContext.emitter.trigger('eventChange', eventChangeArg);
                          // dropped in different calendar
                      }
                      else if (receivingContext) {
                          let eventRemoveArg = {
                              event: eventApi,
                              relatedEvents: buildEventApis(relevantEvents, initialContext, eventInstance),
                              revert() {
                                  initialContext.dispatch({
                                      type: 'MERGE_EVENTS',
                                      eventStore: relevantEvents,
                                  });
                              },
                          };
                          initialContext.emitter.trigger('eventLeave', Object.assign(Object.assign({}, eventRemoveArg), { draggedEl: ev.subjectEl, view: initialView }));
                          initialContext.dispatch({
                              type: 'REMOVE_EVENTS',
                              eventStore: relevantEvents,
                          });
                          initialContext.emitter.trigger('eventRemove', eventRemoveArg);
                          let addedEventDef = mutatedRelevantEvents.defs[eventDef.defId];
                          let addedEventInstance = mutatedRelevantEvents.instances[eventInstance.instanceId];
                          let addedEventApi = new EventImpl(receivingContext, addedEventDef, addedEventInstance);
                          receivingContext.dispatch({
                              type: 'MERGE_EVENTS',
                              eventStore: mutatedRelevantEvents,
                          });
                          let eventAddArg = {
                              event: addedEventApi,
                              relatedEvents: buildEventApis(mutatedRelevantEvents, receivingContext, addedEventInstance),
                              revert() {
                                  receivingContext.dispatch({
                                      type: 'REMOVE_EVENTS',
                                      eventStore: mutatedRelevantEvents,
                                  });
                              },
                          };
                          receivingContext.emitter.trigger('eventAdd', eventAddArg);
                          if (ev.isTouch) {
                              receivingContext.dispatch({
                                  type: 'SELECT_EVENT',
                                  eventInstanceId: eventInstance.instanceId,
                              });
                          }
                          receivingContext.emitter.trigger('drop', Object.assign(Object.assign({}, buildDatePointApiWithContext(finalHit.dateSpan, receivingContext)), { draggedEl: ev.subjectEl, jsEvent: ev.origEvent, view: finalHit.context.viewApi }));
                          receivingContext.emitter.trigger('eventReceive', Object.assign(Object.assign({}, eventAddArg), { draggedEl: ev.subjectEl, view: finalHit.context.viewApi }));
                      }
                  }
                  else {
                      initialContext.emitter.trigger('_noEventDrop');
                  }
              }
              this.cleanup();
          };
          let { component } = this;
          let { options } = component.context;
          let dragging = this.dragging = new FeaturefulElementDragging(settings.el);
          dragging.pointer.selector = EventDragging.SELECTOR;
          dragging.touchScrollAllowed = false;
          dragging.autoScroller.isEnabled = options.dragScroll;
          let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsStore);
          hitDragging.useSubjectCenter = settings.useEventCenter;
          hitDragging.emitter.on('pointerdown', this.handlePointerDown);
          hitDragging.emitter.on('dragstart', this.handleDragStart);
          hitDragging.emitter.on('hitupdate', this.handleHitUpdate);
          hitDragging.emitter.on('pointerup', this.handlePointerUp);
          hitDragging.emitter.on('dragend', this.handleDragEnd);
      }
      destroy() {
          this.dragging.destroy();
      }
      // render a drag state on the next receivingCalendar
      displayDrag(nextContext, state) {
          let initialContext = this.component.context;
          let prevContext = this.receivingContext;
          // does the previous calendar need to be cleared?
          if (prevContext && prevContext !== nextContext) {
              // does the initial calendar need to be cleared?
              // if so, don't clear all the way. we still need to to hide the affectedEvents
              if (prevContext === initialContext) {
                  prevContext.dispatch({
                      type: 'SET_EVENT_DRAG',
                      state: {
                          affectedEvents: state.affectedEvents,
                          mutatedEvents: createEmptyEventStore(),
                          isEvent: true,
                      },
                  });
                  // completely clear the old calendar if it wasn't the initial
              }
              else {
                  prevContext.dispatch({ type: 'UNSET_EVENT_DRAG' });
              }
          }
          if (nextContext) {
              nextContext.dispatch({ type: 'SET_EVENT_DRAG', state });
          }
      }
      clearDrag() {
          let initialCalendar = this.component.context;
          let { receivingContext } = this;
          if (receivingContext) {
              receivingContext.dispatch({ type: 'UNSET_EVENT_DRAG' });
          }
          // the initial calendar might have an dummy drag state from displayDrag
          if (initialCalendar !== receivingContext) {
              initialCalendar.dispatch({ type: 'UNSET_EVENT_DRAG' });
          }
      }
      cleanup() {
          this.subjectSeg = null;
          this.isDragging = false;
          this.eventRange = null;
          this.relevantEvents = null;
          this.receivingContext = null;
          this.validMutation = null;
          this.mutatedRelevantEvents = null;
      }
  }
  // TODO: test this in IE11
  // QUESTION: why do we need it on the resizable???
  EventDragging.SELECTOR = '.fc-event-draggable, .fc-event-resizable';
  function computeEventMutation(hit0, hit1, massagers) {
      let dateSpan0 = hit0.dateSpan;
      let dateSpan1 = hit1.dateSpan;
      let date0 = dateSpan0.range.start;
      let date1 = dateSpan1.range.start;
      let standardProps = {};
      if (dateSpan0.allDay !== dateSpan1.allDay) {
          standardProps.allDay = dateSpan1.allDay;
          standardProps.hasEnd = hit1.context.options.allDayMaintainDuration;
          if (dateSpan1.allDay) {
              // means date1 is already start-of-day,
              // but date0 needs to be converted
              date0 = startOfDay(date0);
          }
      }
      let delta = diffDates(date0, date1, hit0.context.dateEnv, hit0.componentId === hit1.componentId ?
          hit0.largeUnit :
          null);
      if (delta.milliseconds) { // has hours/minutes/seconds
          standardProps.allDay = false;
      }
      let mutation = {
          datesDelta: delta,
          standardProps,
      };
      for (let massager of massagers) {
          massager(mutation, hit0, hit1);
      }
      return mutation;
  }
  function getComponentTouchDelay(component) {
      let { options } = component.context;
      let delay = options.eventLongPressDelay;
      if (delay == null) {
          delay = options.longPressDelay;
      }
      return delay;
  }

  class EventResizing extends Interaction {
      constructor(settings) {
          super(settings);
          // internal state
          this.draggingSegEl = null;
          this.draggingSeg = null; // TODO: rename to resizingSeg? subjectSeg?
          this.eventRange = null;
          this.relevantEvents = null;
          this.validMutation = null;
          this.mutatedRelevantEvents = null;
          this.handlePointerDown = (ev) => {
              let { component } = this;
              let segEl = this.querySegEl(ev);
              let seg = getElSeg(segEl);
              let eventRange = this.eventRange = seg.eventRange;
              this.dragging.minDistance = component.context.options.eventDragMinDistance;
              // if touch, need to be working with a selected event
              this.dragging.setIgnoreMove(!this.component.isValidSegDownEl(ev.origEvent.target) ||
                  (ev.isTouch && this.component.props.eventSelection !== eventRange.instance.instanceId));
          };
          this.handleDragStart = (ev) => {
              let { context } = this.component;
              let eventRange = this.eventRange;
              this.relevantEvents = getRelevantEvents(context.getCurrentData().eventStore, this.eventRange.instance.instanceId);
              let segEl = this.querySegEl(ev);
              this.draggingSegEl = segEl;
              this.draggingSeg = getElSeg(segEl);
              context.calendarApi.unselect();
              context.emitter.trigger('eventResizeStart', {
                  el: segEl,
                  event: new EventImpl(context, eventRange.def, eventRange.instance),
                  jsEvent: ev.origEvent,
                  view: context.viewApi,
              });
          };
          this.handleHitUpdate = (hit, isFinal, ev) => {
              let { context } = this.component;
              let relevantEvents = this.relevantEvents;
              let initialHit = this.hitDragging.initialHit;
              let eventInstance = this.eventRange.instance;
              let mutation = null;
              let mutatedRelevantEvents = null;
              let isInvalid = false;
              let interaction = {
                  affectedEvents: relevantEvents,
                  mutatedEvents: createEmptyEventStore(),
                  isEvent: true,
              };
              if (hit) {
                  let disallowed = hit.componentId === initialHit.componentId
                      && this.isHitComboAllowed
                      && !this.isHitComboAllowed(initialHit, hit);
                  if (!disallowed) {
                      mutation = computeMutation(initialHit, hit, ev.subjectEl.classList.contains('fc-event-resizer-start'), eventInstance.range);
                  }
              }
              if (mutation) {
                  mutatedRelevantEvents = applyMutationToEventStore(relevantEvents, context.getCurrentData().eventUiBases, mutation, context);
                  interaction.mutatedEvents = mutatedRelevantEvents;
                  if (!isInteractionValid(interaction, hit.dateProfile, context)) {
                      isInvalid = true;
                      mutation = null;
                      mutatedRelevantEvents = null;
                      interaction.mutatedEvents = null;
                  }
              }
              if (mutatedRelevantEvents) {
                  context.dispatch({
                      type: 'SET_EVENT_RESIZE',
                      state: interaction,
                  });
              }
              else {
                  context.dispatch({ type: 'UNSET_EVENT_RESIZE' });
              }
              if (!isInvalid) {
                  enableCursor();
              }
              else {
                  disableCursor();
              }
              if (!isFinal) {
                  if (mutation && isHitsEqual(initialHit, hit)) {
                      mutation = null;
                  }
                  this.validMutation = mutation;
                  this.mutatedRelevantEvents = mutatedRelevantEvents;
              }
          };
          this.handleDragEnd = (ev) => {
              let { context } = this.component;
              let eventDef = this.eventRange.def;
              let eventInstance = this.eventRange.instance;
              let eventApi = new EventImpl(context, eventDef, eventInstance);
              let relevantEvents = this.relevantEvents;
              let mutatedRelevantEvents = this.mutatedRelevantEvents;
              context.emitter.trigger('eventResizeStop', {
                  el: this.draggingSegEl,
                  event: eventApi,
                  jsEvent: ev.origEvent,
                  view: context.viewApi,
              });
              if (this.validMutation) {
                  let updatedEventApi = new EventImpl(context, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null);
                  context.dispatch({
                      type: 'MERGE_EVENTS',
                      eventStore: mutatedRelevantEvents,
                  });
                  let eventChangeArg = {
                      oldEvent: eventApi,
                      event: updatedEventApi,
                      relatedEvents: buildEventApis(mutatedRelevantEvents, context, eventInstance),
                      revert() {
                          context.dispatch({
                              type: 'MERGE_EVENTS',
                              eventStore: relevantEvents, // the pre-change events
                          });
                      },
                  };
                  context.emitter.trigger('eventResize', Object.assign(Object.assign({}, eventChangeArg), { el: this.draggingSegEl, startDelta: this.validMutation.startDelta || createDuration(0), endDelta: this.validMutation.endDelta || createDuration(0), jsEvent: ev.origEvent, view: context.viewApi }));
                  context.emitter.trigger('eventChange', eventChangeArg);
              }
              else {
                  context.emitter.trigger('_noEventResize');
              }
              // reset all internal state
              this.draggingSeg = null;
              this.relevantEvents = null;
              this.validMutation = null;
              // okay to keep eventInstance around. useful to set it in handlePointerDown
          };
          let { component } = settings;
          let dragging = this.dragging = new FeaturefulElementDragging(settings.el);
          dragging.pointer.selector = '.fc-event-resizer';
          dragging.touchScrollAllowed = false;
          dragging.autoScroller.isEnabled = component.context.options.dragScroll;
          let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings));
          hitDragging.emitter.on('pointerdown', this.handlePointerDown);
          hitDragging.emitter.on('dragstart', this.handleDragStart);
          hitDragging.emitter.on('hitupdate', this.handleHitUpdate);
          hitDragging.emitter.on('dragend', this.handleDragEnd);
      }
      destroy() {
          this.dragging.destroy();
      }
      querySegEl(ev) {
          return elementClosest(ev.subjectEl, '.fc-event');
      }
  }
  function computeMutation(hit0, hit1, isFromStart, instanceRange) {
      let dateEnv = hit0.context.dateEnv;
      let date0 = hit0.dateSpan.range.start;
      let date1 = hit1.dateSpan.range.start;
      let delta = diffDates(date0, date1, dateEnv, hit0.largeUnit);
      if (isFromStart) {
          if (dateEnv.add(instanceRange.start, delta) < instanceRange.end) {
              return { startDelta: delta };
          }
      }
      else if (dateEnv.add(instanceRange.end, delta) > instanceRange.start) {
          return { endDelta: delta };
      }
      return null;
  }

  class UnselectAuto {
      constructor(context) {
          this.context = context;
          this.isRecentPointerDateSelect = false; // wish we could use a selector to detect date selection, but uses hit system
          this.matchesCancel = false;
          this.matchesEvent = false;
          this.onSelect = (selectInfo) => {
              if (selectInfo.jsEvent) {
                  this.isRecentPointerDateSelect = true;
              }
          };
          this.onDocumentPointerDown = (pev) => {
              let unselectCancel = this.context.options.unselectCancel;
              let downEl = getEventTargetViaRoot(pev.origEvent);
              this.matchesCancel = !!elementClosest(downEl, unselectCancel);
              this.matchesEvent = !!elementClosest(downEl, EventDragging.SELECTOR); // interaction started on an event?
          };
          this.onDocumentPointerUp = (pev) => {
              let { context } = this;
              let { documentPointer } = this;
              let calendarState = context.getCurrentData();
              // touch-scrolling should never unfocus any type of selection
              if (!documentPointer.wasTouchScroll) {
                  if (calendarState.dateSelection && // an existing date selection?
                      !this.isRecentPointerDateSelect // a new pointer-initiated date selection since last onDocumentPointerUp?
                  ) {
                      let unselectAuto = context.options.unselectAuto;
                      if (unselectAuto && (!unselectAuto || !this.matchesCancel)) {
                          context.calendarApi.unselect(pev);
                      }
                  }
                  if (calendarState.eventSelection && // an existing event selected?
                      !this.matchesEvent // interaction DIDN'T start on an event
                  ) {
                      context.dispatch({ type: 'UNSELECT_EVENT' });
                  }
              }
              this.isRecentPointerDateSelect = false;
          };
          let documentPointer = this.documentPointer = new PointerDragging(document);
          documentPointer.shouldIgnoreMove = true;
          documentPointer.shouldWatchScroll = false;
          documentPointer.emitter.on('pointerdown', this.onDocumentPointerDown);
          documentPointer.emitter.on('pointerup', this.onDocumentPointerUp);
          /*
          TODO: better way to know about whether there was a selection with the pointer
          */
          context.emitter.on('select', this.onSelect);
      }
      destroy() {
          this.context.emitter.off('select', this.onSelect);
          this.documentPointer.destroy();
      }
  }

  const OPTION_REFINERS$4 = {
      fixedMirrorParent: identity,
  };
  const LISTENER_REFINERS = {
      dateClick: identity,
      eventDragStart: identity,
      eventDragStop: identity,
      eventDrop: identity,
      eventResizeStart: identity,
      eventResizeStop: identity,
      eventResize: identity,
      drop: identity,
      eventReceive: identity,
      eventLeave: identity,
  };

  /*
  Given an already instantiated draggable object for one-or-more elements,
  Interprets any dragging as an attempt to drag an events that lives outside
  of a calendar onto a calendar.
  */
  class ExternalElementDragging {
      constructor(dragging, suppliedDragMeta) {
          this.receivingContext = null;
          this.droppableEvent = null; // will exist for all drags, even if create:false
          this.suppliedDragMeta = null;
          this.dragMeta = null;
          this.handleDragStart = (ev) => {
              this.dragMeta = this.buildDragMeta(ev.subjectEl);
          };
          this.handleHitUpdate = (hit, isFinal, ev) => {
              let { dragging } = this.hitDragging;
              let receivingContext = null;
              let droppableEvent = null;
              let isInvalid = false;
              let interaction = {
                  affectedEvents: createEmptyEventStore(),
                  mutatedEvents: createEmptyEventStore(),
                  isEvent: this.dragMeta.create,
              };
              if (hit) {
                  receivingContext = hit.context;
                  if (this.canDropElOnCalendar(ev.subjectEl, receivingContext)) {
                      droppableEvent = computeEventForDateSpan(hit.dateSpan, this.dragMeta, receivingContext);
                      interaction.mutatedEvents = eventTupleToStore(droppableEvent);
                      isInvalid = !isInteractionValid(interaction, hit.dateProfile, receivingContext);
                      if (isInvalid) {
                          interaction.mutatedEvents = createEmptyEventStore();
                          droppableEvent = null;
                      }
                  }
              }
              this.displayDrag(receivingContext, interaction);
              // show mirror if no already-rendered mirror element OR if we are shutting down the mirror (?)
              // TODO: wish we could somehow wait for dispatch to guarantee render
              dragging.setMirrorIsVisible(isFinal || !droppableEvent || !document.querySelector('.fc-event-mirror'));
              if (!isInvalid) {
                  enableCursor();
              }
              else {
                  disableCursor();
              }
              if (!isFinal) {
                  dragging.setMirrorNeedsRevert(!droppableEvent);
                  this.receivingContext = receivingContext;
                  this.droppableEvent = droppableEvent;
              }
          };
          this.handleDragEnd = (pev) => {
              let { receivingContext, droppableEvent } = this;
              this.clearDrag();
              if (receivingContext && droppableEvent) {
                  let finalHit = this.hitDragging.finalHit;
                  let finalView = finalHit.context.viewApi;
                  let dragMeta = this.dragMeta;
                  receivingContext.emitter.trigger('drop', Object.assign(Object.assign({}, buildDatePointApiWithContext(finalHit.dateSpan, receivingContext)), { draggedEl: pev.subjectEl, jsEvent: pev.origEvent, view: finalView }));
                  if (dragMeta.create) {
                      let addingEvents = eventTupleToStore(droppableEvent);
                      receivingContext.dispatch({
                          type: 'MERGE_EVENTS',
                          eventStore: addingEvents,
                      });
                      if (pev.isTouch) {
                          receivingContext.dispatch({
                              type: 'SELECT_EVENT',
                              eventInstanceId: droppableEvent.instance.instanceId,
                          });
                      }
                      // signal that an external event landed
                      receivingContext.emitter.trigger('eventReceive', {
                          event: new EventImpl(receivingContext, droppableEvent.def, droppableEvent.instance),
                          relatedEvents: [],
                          revert() {
                              receivingContext.dispatch({
                                  type: 'REMOVE_EVENTS',
                                  eventStore: addingEvents,
                              });
                          },
                          draggedEl: pev.subjectEl,
                          view: finalView,
                      });
                  }
              }
              this.receivingContext = null;
              this.droppableEvent = null;
          };
          let hitDragging = this.hitDragging = new HitDragging(dragging, interactionSettingsStore);
          hitDragging.requireInitial = false; // will start outside of a component
          hitDragging.emitter.on('dragstart', this.handleDragStart);
          hitDragging.emitter.on('hitupdate', this.handleHitUpdate);
          hitDragging.emitter.on('dragend', this.handleDragEnd);
          this.suppliedDragMeta = suppliedDragMeta;
      }
      buildDragMeta(subjectEl) {
          if (typeof this.suppliedDragMeta === 'object') {
              return parseDragMeta(this.suppliedDragMeta);
          }
          if (typeof this.suppliedDragMeta === 'function') {
              return parseDragMeta(this.suppliedDragMeta(subjectEl));
          }
          return getDragMetaFromEl(subjectEl);
      }
      displayDrag(nextContext, state) {
          let prevContext = this.receivingContext;
          if (prevContext && prevContext !== nextContext) {
              prevContext.dispatch({ type: 'UNSET_EVENT_DRAG' });
          }
          if (nextContext) {
              nextContext.dispatch({ type: 'SET_EVENT_DRAG', state });
          }
      }
      clearDrag() {
          if (this.receivingContext) {
              this.receivingContext.dispatch({ type: 'UNSET_EVENT_DRAG' });
          }
      }
      canDropElOnCalendar(el, receivingContext) {
          let dropAccept = receivingContext.options.dropAccept;
          if (typeof dropAccept === 'function') {
              return dropAccept.call(receivingContext.calendarApi, el);
          }
          if (typeof dropAccept === 'string' && dropAccept) {
              return Boolean(elementMatches(el, dropAccept));
          }
          return true;
      }
  }
  // Utils for computing event store from the DragMeta
  // ----------------------------------------------------------------------------------------------------
  function computeEventForDateSpan(dateSpan, dragMeta, context) {
      let defProps = Object.assign({}, dragMeta.leftoverProps);
      for (let transform of context.pluginHooks.externalDefTransforms) {
          Object.assign(defProps, transform(dateSpan, dragMeta));
      }
      let { refined, extra } = refineEventDef(defProps, context);
      let def = parseEventDef(refined, extra, dragMeta.sourceId, dateSpan.allDay, context.options.forceEventDuration || Boolean(dragMeta.duration), // hasEnd
      context);
      let start = dateSpan.range.start;
      // only rely on time info if drop zone is all-day,
      // otherwise, we already know the time
      if (dateSpan.allDay && dragMeta.startTime) {
          start = context.dateEnv.add(start, dragMeta.startTime);
      }
      let end = dragMeta.duration ?
          context.dateEnv.add(start, dragMeta.duration) :
          getDefaultEventEnd(dateSpan.allDay, start, context);
      let instance = createEventInstance(def.defId, { start, end });
      return { def, instance };
  }
  // Utils for extracting data from element
  // ----------------------------------------------------------------------------------------------------
  function getDragMetaFromEl(el) {
      let str = getEmbeddedElData(el, 'event');
      let obj = str ?
          JSON.parse(str) :
          { create: false }; // if no embedded data, assume no event creation
      return parseDragMeta(obj);
  }
  config.dataAttrPrefix = '';
  function getEmbeddedElData(el, name) {
      let prefix = config.dataAttrPrefix;
      let prefixedName = (prefix ? prefix + '-' : '') + name;
      return el.getAttribute('data-' + prefixedName) || '';
  }

  /*
  Makes an element (that is *external* to any calendar) draggable.
  Can pass in data that determines how an event will be created when dropped onto a calendar.
  Leverages FullCalendar's internal drag-n-drop functionality WITHOUT a third-party drag system.
  */
  class ExternalDraggable {
      constructor(el, settings = {}) {
          this.handlePointerDown = (ev) => {
              let { dragging } = this;
              let { minDistance, longPressDelay } = this.settings;
              dragging.minDistance =
                  minDistance != null ?
                      minDistance :
                      (ev.isTouch ? 0 : BASE_OPTION_DEFAULTS.eventDragMinDistance);
              dragging.delay =
                  ev.isTouch ? // TODO: eventually read eventLongPressDelay instead vvv
                      (longPressDelay != null ? longPressDelay : BASE_OPTION_DEFAULTS.longPressDelay) :
                      0;
          };
          this.handleDragStart = (ev) => {
              if (ev.isTouch &&
                  this.dragging.delay &&
                  ev.subjectEl.classList.contains('fc-event')) {
                  this.dragging.mirror.getMirrorEl().classList.add('fc-event-selected');
              }
          };
          this.settings = settings;
          let dragging = this.dragging = new FeaturefulElementDragging(el);
          dragging.touchScrollAllowed = false;
          if (settings.itemSelector != null) {
              dragging.pointer.selector = settings.itemSelector;
          }
          if (settings.appendTo != null) {
              dragging.mirror.parentNode = settings.appendTo; // TODO: write tests
          }
          dragging.emitter.on('pointerdown', this.handlePointerDown);
          dragging.emitter.on('dragstart', this.handleDragStart);
          new ExternalElementDragging(dragging, settings.eventData); // eslint-disable-line no-new
      }
      destroy() {
          this.dragging.destroy();
      }
  }

  /*
  Detects when a *THIRD-PARTY* drag-n-drop system interacts with elements.
  The third-party system is responsible for drawing the visuals effects of the drag.
  This class simply monitors for pointer movements and fires events.
  It also has the ability to hide the moving element (the "mirror") during the drag.
  */
  class InferredElementDragging extends ElementDragging {
      constructor(containerEl) {
          super(containerEl);
          this.shouldIgnoreMove = false;
          this.mirrorSelector = '';
          this.currentMirrorEl = null;
          this.handlePointerDown = (ev) => {
              this.emitter.trigger('pointerdown', ev);
              if (!this.shouldIgnoreMove) {
                  // fire dragstart right away. does not support delay or min-distance
                  this.emitter.trigger('dragstart', ev);
              }
          };
          this.handlePointerMove = (ev) => {
              if (!this.shouldIgnoreMove) {
                  this.emitter.trigger('dragmove', ev);
              }
          };
          this.handlePointerUp = (ev) => {
              this.emitter.trigger('pointerup', ev);
              if (!this.shouldIgnoreMove) {
                  // fire dragend right away. does not support a revert animation
                  this.emitter.trigger('dragend', ev);
              }
          };
          let pointer = this.pointer = new PointerDragging(containerEl);
          pointer.emitter.on('pointerdown', this.handlePointerDown);
          pointer.emitter.on('pointermove', this.handlePointerMove);
          pointer.emitter.on('pointerup', this.handlePointerUp);
      }
      destroy() {
          this.pointer.destroy();
      }
      setIgnoreMove(bool) {
          this.shouldIgnoreMove = bool;
      }
      setMirrorIsVisible(bool) {
          if (bool) {
              // restore a previously hidden element.
              // use the reference in case the selector class has already been removed.
              if (this.currentMirrorEl) {
                  this.currentMirrorEl.style.visibility = '';
                  this.currentMirrorEl = null;
              }
          }
          else {
              let mirrorEl = this.mirrorSelector
                  // TODO: somehow query FullCalendars WITHIN shadow-roots
                  ? document.querySelector(this.mirrorSelector)
                  : null;
              if (mirrorEl) {
                  this.currentMirrorEl = mirrorEl;
                  mirrorEl.style.visibility = 'hidden';
              }
          }
      }
  }

  /*
  Bridges third-party drag-n-drop systems with FullCalendar.
  Must be instantiated and destroyed by caller.
  */
  class ThirdPartyDraggable {
      constructor(containerOrSettings, settings) {
          let containerEl = document;
          if (
          // wish we could just test instanceof EventTarget, but doesn't work in IE11
          containerOrSettings === document ||
              containerOrSettings instanceof Element) {
              containerEl = containerOrSettings;
              settings = settings || {};
          }
          else {
              settings = (containerOrSettings || {});
          }
          let dragging = this.dragging = new InferredElementDragging(containerEl);
          if (typeof settings.itemSelector === 'string') {
              dragging.pointer.selector = settings.itemSelector;
          }
          else if (containerEl === document) {
              dragging.pointer.selector = '[data-event]';
          }
          if (typeof settings.mirrorSelector === 'string') {
              dragging.mirrorSelector = settings.mirrorSelector;
          }
          new ExternalElementDragging(dragging, settings.eventData); // eslint-disable-line no-new
      }
      destroy() {
          this.dragging.destroy();
      }
  }

  var index$b = createPlugin({
      name: '@fullcalendar/interaction',
      componentInteractions: [DateClicking, DateSelecting, EventDragging, EventResizing],
      calendarInteractions: [UnselectAuto],
      elementDraggingImpl: FeaturefulElementDragging,
      optionRefiners: OPTION_REFINERS$4,
      listenerRefiners: LISTENER_REFINERS,
  });

  /* An abstract class for the daygrid views, as well as month view. Renders one or more rows of day cells.
  ----------------------------------------------------------------------------------------------------------------------*/
  // It is a manager for a Table subcomponent, which does most of the heavy lifting.
  // It is responsible for managing width/height.
  class TableView extends DateComponent {
      constructor() {
          super(...arguments);
          this.headerElRef = d$1();
      }
      renderSimpleLayout(headerRowContent, bodyContent) {
          let { props, context } = this;
          let sections = [];
          let stickyHeaderDates = getStickyHeaderDates(context.options);
          if (headerRowContent) {
              sections.push({
                  type: 'header',
                  key: 'header',
                  isSticky: stickyHeaderDates,
                  chunk: {
                      elRef: this.headerElRef,
                      tableClassName: 'fc-col-header',
                      rowContent: headerRowContent,
                  },
              });
          }
          sections.push({
              type: 'body',
              key: 'body',
              liquid: true,
              chunk: { content: bodyContent },
          });
          return (y$1(ViewContainer, { elClasses: ['fc-daygrid'], viewSpec: context.viewSpec },
              y$1(SimpleScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, collapsibleWidth: props.forPrint, cols: [] /* TODO: make optional? */, sections: sections })));
      }
      renderHScrollLayout(headerRowContent, bodyContent, colCnt, dayMinWidth) {
          let ScrollGrid = this.context.pluginHooks.scrollGridImpl;
          if (!ScrollGrid) {
              throw new Error('No ScrollGrid implementation');
          }
          let { props, context } = this;
          let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options);
          let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options);
          let sections = [];
          if (headerRowContent) {
              sections.push({
                  type: 'header',
                  key: 'header',
                  isSticky: stickyHeaderDates,
                  chunks: [{
                          key: 'main',
                          elRef: this.headerElRef,
                          tableClassName: 'fc-col-header',
                          rowContent: headerRowContent,
                      }],
              });
          }
          sections.push({
              type: 'body',
              key: 'body',
              liquid: true,
              chunks: [{
                      key: 'main',
                      content: bodyContent,
                  }],
          });
          if (stickyFooterScrollbar) {
              sections.push({
                  type: 'footer',
                  key: 'footer',
                  isSticky: true,
                  chunks: [{
                          key: 'main',
                          content: renderScrollShim,
                      }],
              });
          }
          return (y$1(ViewContainer, { elClasses: ['fc-daygrid'], viewSpec: context.viewSpec },
              y$1(ScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, forPrint: props.forPrint, collapsibleWidth: props.forPrint, colGroups: [{ cols: [{ span: colCnt, minWidth: dayMinWidth }] }], sections: sections })));
      }
  }

  function splitSegsByRow(segs, rowCnt) {
      let byRow = [];
      for (let i = 0; i < rowCnt; i += 1) {
          byRow[i] = [];
      }
      for (let seg of segs) {
          byRow[seg.row].push(seg);
      }
      return byRow;
  }
  function splitSegsByFirstCol(segs, colCnt) {
      let byCol = [];
      for (let i = 0; i < colCnt; i += 1) {
          byCol[i] = [];
      }
      for (let seg of segs) {
          byCol[seg.firstCol].push(seg);
      }
      return byCol;
  }
  function splitInteractionByRow(ui, rowCnt) {
      let byRow = [];
      if (!ui) {
          for (let i = 0; i < rowCnt; i += 1) {
              byRow[i] = null;
          }
      }
      else {
          for (let i = 0; i < rowCnt; i += 1) {
              byRow[i] = {
                  affectedInstances: ui.affectedInstances,
                  isEvent: ui.isEvent,
                  segs: [],
              };
          }
          for (let seg of ui.segs) {
              byRow[seg.row].segs.push(seg);
          }
      }
      return byRow;
  }

  const DEFAULT_TABLE_EVENT_TIME_FORMAT = createFormatter({
      hour: 'numeric',
      minute: '2-digit',
      omitZeroMinute: true,
      meridiem: 'narrow',
  });
  function hasListItemDisplay(seg) {
      let { display } = seg.eventRange.ui;
      return display === 'list-item' || (display === 'auto' &&
          !seg.eventRange.def.allDay &&
          seg.firstCol === seg.lastCol && // can't be multi-day
          seg.isStart && // "
          seg.isEnd // "
      );
  }

  class TableBlockEvent extends BaseComponent {
      render() {
          let { props } = this;
          return (y$1(StandardEvent, Object.assign({}, props, { elClasses: ['fc-daygrid-event', 'fc-daygrid-block-event', 'fc-h-event'], defaultTimeFormat: DEFAULT_TABLE_EVENT_TIME_FORMAT, defaultDisplayEventEnd: props.defaultDisplayEventEnd, disableResizing: !props.seg.eventRange.def.allDay })));
      }
  }

  class TableListItemEvent extends BaseComponent {
      render() {
          let { props, context } = this;
          let { options } = context;
          let { seg } = props;
          let timeFormat = options.eventTimeFormat || DEFAULT_TABLE_EVENT_TIME_FORMAT;
          let timeText = buildSegTimeText(seg, timeFormat, context, true, props.defaultDisplayEventEnd);
          return (y$1(EventContainer, Object.assign({}, props, { elTag: "a", elClasses: ['fc-daygrid-event', 'fc-daygrid-dot-event'], elAttrs: getSegAnchorAttrs(props.seg, context), defaultGenerator: renderInnerContent$2, timeText: timeText, isResizing: false, isDateSelecting: false })));
      }
  }
  function renderInnerContent$2(renderProps) {
      return (y$1(_, null,
          y$1("div", { className: "fc-daygrid-event-dot", style: { borderColor: renderProps.borderColor || renderProps.backgroundColor } }),
          renderProps.timeText && (y$1("div", { className: "fc-event-time" }, renderProps.timeText)),
          y$1("div", { className: "fc-event-title" }, renderProps.event.title || y$1(_, null, "\u00A0"))));
  }

  class TableCellMoreLink extends BaseComponent {
      constructor() {
          super(...arguments);
          this.compileSegs = memoize(compileSegs);
      }
      render() {
          let { props } = this;
          let { allSegs, invisibleSegs } = this.compileSegs(props.singlePlacements);
          return (y$1(MoreLinkContainer, { elClasses: ['fc-daygrid-more-link'], dateProfile: props.dateProfile, todayRange: props.todayRange, allDayDate: props.allDayDate, moreCnt: props.moreCnt, allSegs: allSegs, hiddenSegs: invisibleSegs, alignmentElRef: props.alignmentElRef, alignGridTop: props.alignGridTop, extraDateSpan: props.extraDateSpan, popoverContent: () => {
                  let isForcedInvisible = (props.eventDrag ? props.eventDrag.affectedInstances : null) ||
                      (props.eventResize ? props.eventResize.affectedInstances : null) ||
                      {};
                  return (y$1(_, null, allSegs.map((seg) => {
                      let instanceId = seg.eventRange.instance.instanceId;
                      return (y$1("div", { className: "fc-daygrid-event-harness", key: instanceId, style: {
                              visibility: isForcedInvisible[instanceId] ? 'hidden' : '',
                          } }, hasListItemDisplay(seg) ? (y$1(TableListItemEvent, Object.assign({ seg: seg, isDragging: false, isSelected: instanceId === props.eventSelection, defaultDisplayEventEnd: false }, getSegMeta(seg, props.todayRange)))) : (y$1(TableBlockEvent, Object.assign({ seg: seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: instanceId === props.eventSelection, defaultDisplayEventEnd: false }, getSegMeta(seg, props.todayRange))))));
                  })));
              } }));
      }
  }
  function compileSegs(singlePlacements) {
      let allSegs = [];
      let invisibleSegs = [];
      for (let placement of singlePlacements) {
          allSegs.push(placement.seg);
          if (!placement.isVisible) {
              invisibleSegs.push(placement.seg);
          }
      }
      return { allSegs, invisibleSegs };
  }

  const DEFAULT_WEEK_NUM_FORMAT$1 = createFormatter({ week: 'narrow' });
  class TableCell extends DateComponent {
      constructor() {
          super(...arguments);
          this.rootElRef = d$1();
          this.state = {
              dayNumberId: getUniqueDomId(),
          };
          this.handleRootEl = (el) => {
              setRef(this.rootElRef, el);
              setRef(this.props.elRef, el);
          };
      }
      render() {
          let { context, props, state, rootElRef } = this;
          let { options, dateEnv } = context;
          let { date, dateProfile } = props;
          // TODO: memoize this?
          const isMonthStart = props.showDayNumber &&
              shouldDisplayMonthStart(date, dateProfile.currentRange, dateEnv);
          return (y$1(DayCellContainer, { elTag: "td", elRef: this.handleRootEl, elClasses: [
                  'fc-daygrid-day',
                  ...(props.extraClassNames || []),
              ], elAttrs: Object.assign(Object.assign(Object.assign({}, props.extraDataAttrs), (props.showDayNumber ? { 'aria-labelledby': state.dayNumberId } : {})), { role: 'gridcell' }), defaultGenerator: renderTopInner, date: date, dateProfile: dateProfile, todayRange: props.todayRange, showDayNumber: props.showDayNumber, isMonthStart: isMonthStart, extraRenderProps: props.extraRenderProps }, (InnerContent, renderProps) => (y$1("div", { ref: props.innerElRef, className: "fc-daygrid-day-frame fc-scrollgrid-sync-inner", style: { minHeight: props.minHeight } },
              props.showWeekNumber && (y$1(WeekNumberContainer, { elTag: "a", elClasses: ['fc-daygrid-week-number'], elAttrs: buildNavLinkAttrs(context, date, 'week'), date: date, defaultFormat: DEFAULT_WEEK_NUM_FORMAT$1 })),
              !renderProps.isDisabled &&
                  (props.showDayNumber || hasCustomDayCellContent(options) || props.forceDayTop) ? (y$1("div", { className: "fc-daygrid-day-top" },
                  y$1(InnerContent, { elTag: "a", elClasses: [
                          'fc-daygrid-day-number',
                          isMonthStart && 'fc-daygrid-month-start',
                      ], elAttrs: Object.assign(Object.assign({}, buildNavLinkAttrs(context, date)), { id: state.dayNumberId }) }))) : props.showDayNumber ? (
              // for creating correct amount of space (see issue #7162)
              y$1("div", { className: "fc-daygrid-day-top", style: { visibility: 'hidden' } },
                  y$1("a", { className: "fc-daygrid-day-number" }, "\u00A0"))) : undefined,
              y$1("div", { className: "fc-daygrid-day-events", ref: props.fgContentElRef },
                  props.fgContent,
                  y$1("div", { className: "fc-daygrid-day-bottom", style: { marginTop: props.moreMarginTop } },
                      y$1(TableCellMoreLink, { allDayDate: date, singlePlacements: props.singlePlacements, moreCnt: props.moreCnt, alignmentElRef: rootElRef, alignGridTop: !props.showDayNumber, extraDateSpan: props.extraDateSpan, dateProfile: props.dateProfile, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, todayRange: props.todayRange }))),
              y$1("div", { className: "fc-daygrid-day-bg" }, props.bgContent)))));
      }
  }
  function renderTopInner(props) {
      return props.dayNumberText || y$1(_, null, "\u00A0");
  }
  function shouldDisplayMonthStart(date, currentRange, dateEnv) {
      const { start: currentStart, end: currentEnd } = currentRange;
      const currentEndIncl = addMs(currentEnd, -1);
      const currentFirstYear = dateEnv.getYear(currentStart);
      const currentFirstMonth = dateEnv.getMonth(currentStart);
      const currentLastYear = dateEnv.getYear(currentEndIncl);
      const currentLastMonth = dateEnv.getMonth(currentEndIncl);
      // spans more than one month?
      return !(currentFirstYear === currentLastYear && currentFirstMonth === currentLastMonth) &&
          Boolean(
          // first date in current view?
          date.valueOf() === currentStart.valueOf() ||
              // a month-start that's within the current range?
              (dateEnv.getDay(date) === 1 && date.valueOf() < currentEnd.valueOf()));
  }

  function generateSegKey(seg) {
      return seg.eventRange.instance.instanceId + ':' + seg.firstCol;
  }
  function generateSegUid(seg) {
      return generateSegKey(seg) + ':' + seg.lastCol;
  }
  function computeFgSegPlacement(segs, // assumed already sorted
  dayMaxEvents, dayMaxEventRows, strictOrder, segHeights, maxContentHeight, cells) {
      let hierarchy = new DayGridSegHierarchy((segEntry) => {
          // TODO: more DRY with generateSegUid
          let segUid = segs[segEntry.index].eventRange.instance.instanceId +
              ':' + segEntry.span.start +
              ':' + (segEntry.span.end - 1);
          return segHeights[segUid];
      });
      hierarchy.allowReslicing = true;
      hierarchy.strictOrder = strictOrder;
      if (dayMaxEvents === true || dayMaxEventRows === true) {
          hierarchy.maxCoord = maxContentHeight;
          hierarchy.hiddenConsumes = true;
      }
      else if (typeof dayMaxEvents === 'number') {
          hierarchy.maxStackCnt = dayMaxEvents;
      }
      else if (typeof dayMaxEventRows === 'number') {
          hierarchy.maxStackCnt = dayMaxEventRows;
          hierarchy.hiddenConsumes = true;
      }
      // create segInputs only for segs with known heights
      let segInputs = [];
      let unknownHeightSegs = [];
      for (let i = 0; i < segs.length; i += 1) {
          let seg = segs[i];
          let segUid = generateSegUid(seg);
          let eventHeight = segHeights[segUid];
          if (eventHeight != null) {
              segInputs.push({
                  index: i,
                  span: {
                      start: seg.firstCol,
                      end: seg.lastCol + 1,
                  },
              });
          }
          else {
              unknownHeightSegs.push(seg);
          }
      }
      let hiddenEntries = hierarchy.addSegs(segInputs);
      let segRects = hierarchy.toRects();
      let { singleColPlacements, multiColPlacements, leftoverMargins } = placeRects(segRects, segs, cells);
      let moreCnts = [];
      let moreMarginTops = [];
      // add segs with unknown heights
      for (let seg of unknownHeightSegs) {
          multiColPlacements[seg.firstCol].push({
              seg,
              isVisible: false,
              isAbsolute: true,
              absoluteTop: 0,
              marginTop: 0,
          });
          for (let col = seg.firstCol; col <= seg.lastCol; col += 1) {
              singleColPlacements[col].push({
                  seg: resliceSeg(seg, col, col + 1, cells),
                  isVisible: false,
                  isAbsolute: false,
                  absoluteTop: 0,
                  marginTop: 0,
              });
          }
      }
      // add the hidden entries
      for (let col = 0; col < cells.length; col += 1) {
          moreCnts.push(0);
      }
      for (let hiddenEntry of hiddenEntries) {
          let seg = segs[hiddenEntry.index];
          let hiddenSpan = hiddenEntry.span;
          multiColPlacements[hiddenSpan.start].push({
              seg: resliceSeg(seg, hiddenSpan.start, hiddenSpan.end, cells),
              isVisible: false,
              isAbsolute: true,
              absoluteTop: 0,
              marginTop: 0,
          });
          for (let col = hiddenSpan.start; col < hiddenSpan.end; col += 1) {
              moreCnts[col] += 1;
              singleColPlacements[col].push({
                  seg: resliceSeg(seg, col, col + 1, cells),
                  isVisible: false,
                  isAbsolute: false,
                  absoluteTop: 0,
                  marginTop: 0,
              });
          }
      }
      // deal with leftover margins
      for (let col = 0; col < cells.length; col += 1) {
          moreMarginTops.push(leftoverMargins[col]);
      }
      return { singleColPlacements, multiColPlacements, moreCnts, moreMarginTops };
  }
  // rects ordered by top coord, then left
  function placeRects(allRects, segs, cells) {
      let rectsByEachCol = groupRectsByEachCol(allRects, cells.length);
      let singleColPlacements = [];
      let multiColPlacements = [];
      let leftoverMargins = [];
      for (let col = 0; col < cells.length; col += 1) {
          let rects = rectsByEachCol[col];
          // compute all static segs in singlePlacements
          let singlePlacements = [];
          let currentHeight = 0;
          let currentMarginTop = 0;
          for (let rect of rects) {
              let seg = segs[rect.index];
              singlePlacements.push({
                  seg: resliceSeg(seg, col, col + 1, cells),
                  isVisible: true,
                  isAbsolute: false,
                  absoluteTop: rect.levelCoord,
                  marginTop: rect.levelCoord - currentHeight,
              });
              currentHeight = rect.levelCoord + rect.thickness;
          }
          // compute mixed static/absolute segs in multiPlacements
          let multiPlacements = [];
          currentHeight = 0;
          currentMarginTop = 0;
          for (let rect of rects) {
              let seg = segs[rect.index];
              let isAbsolute = rect.span.end - rect.span.start > 1; // multi-column?
              let isFirstCol = rect.span.start === col;
              currentMarginTop += rect.levelCoord - currentHeight; // amount of space since bottom of previous seg
              currentHeight = rect.levelCoord + rect.thickness; // height will now be bottom of current seg
              if (isAbsolute) {
                  currentMarginTop += rect.thickness;
                  if (isFirstCol) {
                      multiPlacements.push({
                          seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),
                          isVisible: true,
                          isAbsolute: true,
                          absoluteTop: rect.levelCoord,
                          marginTop: 0,
                      });
                  }
              }
              else if (isFirstCol) {
                  multiPlacements.push({
                      seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),
                      isVisible: true,
                      isAbsolute: false,
                      absoluteTop: rect.levelCoord,
                      marginTop: currentMarginTop, // claim the margin
                  });
                  currentMarginTop = 0;
              }
          }
          singleColPlacements.push(singlePlacements);
          multiColPlacements.push(multiPlacements);
          leftoverMargins.push(currentMarginTop);
      }
      return { singleColPlacements, multiColPlacements, leftoverMargins };
  }
  function groupRectsByEachCol(rects, colCnt) {
      let rectsByEachCol = [];
      for (let col = 0; col < colCnt; col += 1) {
          rectsByEachCol.push([]);
      }
      for (let rect of rects) {
          for (let col = rect.span.start; col < rect.span.end; col += 1) {
              rectsByEachCol[col].push(rect);
          }
      }
      return rectsByEachCol;
  }
  function resliceSeg(seg, spanStart, spanEnd, cells) {
      if (seg.firstCol === spanStart && seg.lastCol === spanEnd - 1) {
          return seg;
      }
      let eventRange = seg.eventRange;
      let origRange = eventRange.range;
      let slicedRange = intersectRanges(origRange, {
          start: cells[spanStart].date,
          end: addDays(cells[spanEnd - 1].date, 1),
      });
      return Object.assign(Object.assign({}, seg), { firstCol: spanStart, lastCol: spanEnd - 1, eventRange: {
              def: eventRange.def,
              ui: Object.assign(Object.assign({}, eventRange.ui), { durationEditable: false }),
              instance: eventRange.instance,
              range: slicedRange,
          }, isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(), isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf() });
  }
  class DayGridSegHierarchy extends SegHierarchy {
      constructor() {
          super(...arguments);
          // config
          this.hiddenConsumes = false;
          // allows us to keep hidden entries in the hierarchy so they take up space
          this.forceHidden = {};
      }
      addSegs(segInputs) {
          const hiddenSegs = super.addSegs(segInputs);
          const { entriesByLevel } = this;
          const excludeHidden = (entry) => !this.forceHidden[buildEntryKey(entry)];
          // remove the forced-hidden segs
          for (let level = 0; level < entriesByLevel.length; level += 1) {
              entriesByLevel[level] = entriesByLevel[level].filter(excludeHidden);
          }
          return hiddenSegs;
      }
      handleInvalidInsertion(insertion, entry, hiddenEntries) {
          const { entriesByLevel, forceHidden } = this;
          const { touchingEntry, touchingLevel, touchingLateral } = insertion;
          if (this.hiddenConsumes && touchingEntry) {
              const touchingEntryId = buildEntryKey(touchingEntry);
              // if not already hidden
              if (!forceHidden[touchingEntryId]) {
                  if (this.allowReslicing) {
                      const placeholderEntry = Object.assign(Object.assign({}, touchingEntry), { span: intersectSpans(touchingEntry.span, entry.span) });
                      const placeholderEntryId = buildEntryKey(placeholderEntry);
                      forceHidden[placeholderEntryId] = true;
                      entriesByLevel[touchingLevel][touchingLateral] = placeholderEntry; // replace touchingEntry with our placeholder
                      this.splitEntry(touchingEntry, entry, hiddenEntries); // split up the touchingEntry, reinsert it
                  }
                  else {
                      forceHidden[touchingEntryId] = true;
                      hiddenEntries.push(touchingEntry);
                  }
              }
          }
          return super.handleInvalidInsertion(insertion, entry, hiddenEntries);
      }
  }

  class TableRow extends DateComponent {
      constructor() {
          super(...arguments);
          this.cellElRefs = new RefMap(); // the <td>
          this.frameElRefs = new RefMap(); // the fc-daygrid-day-frame
          this.fgElRefs = new RefMap(); // the fc-daygrid-day-events
          this.segHarnessRefs = new RefMap(); // indexed by "instanceId:firstCol"
          this.rootElRef = d$1();
          this.state = {
              framePositions: null,
              maxContentHeight: null,
              segHeights: {},
          };
          this.handleResize = (isForced) => {
              if (isForced) {
                  this.updateSizing(true); // isExternal=true
              }
          };
      }
      render() {
          let { props, state, context } = this;
          let { options } = context;
          let colCnt = props.cells.length;
          let businessHoursByCol = splitSegsByFirstCol(props.businessHourSegs, colCnt);
          let bgEventSegsByCol = splitSegsByFirstCol(props.bgEventSegs, colCnt);
          let highlightSegsByCol = splitSegsByFirstCol(this.getHighlightSegs(), colCnt);
          let mirrorSegsByCol = splitSegsByFirstCol(this.getMirrorSegs(), colCnt);
          let { singleColPlacements, multiColPlacements, moreCnts, moreMarginTops } = computeFgSegPlacement(sortEventSegs(props.fgEventSegs, options.eventOrder), props.dayMaxEvents, props.dayMaxEventRows, options.eventOrderStrict, state.segHeights, state.maxContentHeight, props.cells);
          let isForcedInvisible = // TODO: messy way to compute this
           (props.eventDrag && props.eventDrag.affectedInstances) ||
              (props.eventResize && props.eventResize.affectedInstances) ||
              {};
          return (y$1("tr", { ref: this.rootElRef, role: "row" },
              props.renderIntro && props.renderIntro(),
              props.cells.map((cell, col) => {
                  let normalFgNodes = this.renderFgSegs(col, props.forPrint ? singleColPlacements[col] : multiColPlacements[col], props.todayRange, isForcedInvisible);
                  let mirrorFgNodes = this.renderFgSegs(col, buildMirrorPlacements(mirrorSegsByCol[col], multiColPlacements), props.todayRange, {}, Boolean(props.eventDrag), Boolean(props.eventResize), false);
                  return (y$1(TableCell, { key: cell.key, elRef: this.cellElRefs.createRef(cell.key), innerElRef: this.frameElRefs.createRef(cell.key) /* FF <td> problem, but okay to use for left/right. TODO: rename prop */, dateProfile: props.dateProfile, date: cell.date, showDayNumber: props.showDayNumbers, showWeekNumber: props.showWeekNumbers && col === 0, forceDayTop: props.showWeekNumbers /* even displaying weeknum for row, not necessarily day */, todayRange: props.todayRange, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, extraRenderProps: cell.extraRenderProps, extraDataAttrs: cell.extraDataAttrs, extraClassNames: cell.extraClassNames, extraDateSpan: cell.extraDateSpan, moreCnt: moreCnts[col], moreMarginTop: moreMarginTops[col], singlePlacements: singleColPlacements[col], fgContentElRef: this.fgElRefs.createRef(cell.key), fgContent: ( // Fragment scopes the keys
                      y$1(_, null,
                          y$1(_, null, normalFgNodes),
                          y$1(_, null, mirrorFgNodes))), bgContent: ( // Fragment scopes the keys
                      y$1(_, null,
                          this.renderFillSegs(highlightSegsByCol[col], 'highlight'),
                          this.renderFillSegs(businessHoursByCol[col], 'non-business'),
                          this.renderFillSegs(bgEventSegsByCol[col], 'bg-event'))), minHeight: props.cellMinHeight }));
              })));
      }
      componentDidMount() {
          this.updateSizing(true);
          this.context.addResizeHandler(this.handleResize);
      }
      componentDidUpdate(prevProps, prevState) {
          let currentProps = this.props;
          this.updateSizing(!isPropsEqual(prevProps, currentProps));
      }
      componentWillUnmount() {
          this.context.removeResizeHandler(this.handleResize);
      }
      getHighlightSegs() {
          let { props } = this;
          if (props.eventDrag && props.eventDrag.segs.length) { // messy check
              return props.eventDrag.segs;
          }
          if (props.eventResize && props.eventResize.segs.length) { // messy check
              return props.eventResize.segs;
          }
          return props.dateSelectionSegs;
      }
      getMirrorSegs() {
          let { props } = this;
          if (props.eventResize && props.eventResize.segs.length) { // messy check
              return props.eventResize.segs;
          }
          return [];
      }
      renderFgSegs(col, segPlacements, todayRange, isForcedInvisible, isDragging, isResizing, isDateSelecting) {
          let { context } = this;
          let { eventSelection } = this.props;
          let { framePositions } = this.state;
          let defaultDisplayEventEnd = this.props.cells.length === 1; // colCnt === 1
          let isMirror = isDragging || isResizing || isDateSelecting;
          let nodes = [];
          if (framePositions) {
              for (let placement of segPlacements) {
                  let { seg } = placement;
                  let { instanceId } = seg.eventRange.instance;
                  let isVisible = placement.isVisible && !isForcedInvisible[instanceId];
                  let isAbsolute = placement.isAbsolute;
                  let left = '';
                  let right = '';
                  if (isAbsolute) {
                      if (context.isRtl) {
                          right = 0;
                          left = framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol];
                      }
                      else {
                          left = 0;
                          right = framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol];
                      }
                  }
                  /*
                  known bug: events that are force to be list-item but span multiple days still take up space in later columns
                  todo: in print view, for multi-day events, don't display title within non-start/end segs
                  */
                  nodes.push(y$1("div", { className: 'fc-daygrid-event-harness' + (isAbsolute ? ' fc-daygrid-event-harness-abs' : ''), key: generateSegKey(seg), ref: isMirror ? null : this.segHarnessRefs.createRef(generateSegUid(seg)), style: {
                          visibility: isVisible ? '' : 'hidden',
                          marginTop: isAbsolute ? '' : placement.marginTop,
                          top: isAbsolute ? placement.absoluteTop : '',
                          left,
                          right,
                      } }, hasListItemDisplay(seg) ? (y$1(TableListItemEvent, Object.assign({ seg: seg, isDragging: isDragging, isSelected: instanceId === eventSelection, defaultDisplayEventEnd: defaultDisplayEventEnd }, getSegMeta(seg, todayRange)))) : (y$1(TableBlockEvent, Object.assign({ seg: seg, isDragging: isDragging, isResizing: isResizing, isDateSelecting: isDateSelecting, isSelected: instanceId === eventSelection, defaultDisplayEventEnd: defaultDisplayEventEnd }, getSegMeta(seg, todayRange))))));
              }
          }
          return nodes;
      }
      renderFillSegs(segs, fillType) {
          let { isRtl } = this.context;
          let { todayRange } = this.props;
          let { framePositions } = this.state;
          let nodes = [];
          if (framePositions) {
              for (let seg of segs) {
                  let leftRightCss = isRtl ? {
                      right: 0,
                      left: framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol],
                  } : {
                      left: 0,
                      right: framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol],
                  };
                  nodes.push(y$1("div", { key: buildEventRangeKey(seg.eventRange), className: "fc-daygrid-bg-harness", style: leftRightCss }, fillType === 'bg-event' ?
                      y$1(BgEvent, Object.assign({ seg: seg }, getSegMeta(seg, todayRange))) :
                      renderFill(fillType)));
              }
          }
          return y$1(_, {}, ...nodes);
      }
      updateSizing(isExternalSizingChange) {
          let { props, state, frameElRefs } = this;
          if (!props.forPrint &&
              props.clientWidth !== null // positioning ready?
          ) {
              if (isExternalSizingChange) {
                  let frameEls = props.cells.map((cell) => frameElRefs.currentMap[cell.key]);
                  if (frameEls.length) {
                      let originEl = this.rootElRef.current;
                      let newPositionCache = new PositionCache(originEl, frameEls, true, // isHorizontal
                      false);
                      if (!state.framePositions || !state.framePositions.similarTo(newPositionCache)) {
                          this.setState({
                              framePositions: new PositionCache(originEl, frameEls, true, // isHorizontal
                              false),
                          });
                      }
                  }
              }
              const oldSegHeights = this.state.segHeights;
              const newSegHeights = this.querySegHeights();
              const limitByContentHeight = props.dayMaxEvents === true || props.dayMaxEventRows === true;
              this.safeSetState({
                  // HACK to prevent oscillations of events being shown/hidden from max-event-rows
                  // Essentially, once you compute an element's height, never null-out.
                  // TODO: always display all events, as visibility:hidden?
                  segHeights: Object.assign(Object.assign({}, oldSegHeights), newSegHeights),
                  maxContentHeight: limitByContentHeight ? this.computeMaxContentHeight() : null,
              });
          }
      }
      querySegHeights() {
          let segElMap = this.segHarnessRefs.currentMap;
          let segHeights = {};
          // get the max height amongst instance segs
          for (let segUid in segElMap) {
              let height = Math.round(segElMap[segUid].getBoundingClientRect().height);
              segHeights[segUid] = Math.max(segHeights[segUid] || 0, height);
          }
          return segHeights;
      }
      computeMaxContentHeight() {
          let firstKey = this.props.cells[0].key;
          let cellEl = this.cellElRefs.currentMap[firstKey];
          let fcContainerEl = this.fgElRefs.currentMap[firstKey];
          return cellEl.getBoundingClientRect().bottom - fcContainerEl.getBoundingClientRect().top;
      }
      getCellEls() {
          let elMap = this.cellElRefs.currentMap;
          return this.props.cells.map((cell) => elMap[cell.key]);
      }
  }
  TableRow.addStateEquality({
      segHeights: isPropsEqual,
  });
  function buildMirrorPlacements(mirrorSegs, colPlacements) {
      if (!mirrorSegs.length) {
          return [];
      }
      let topsByInstanceId = buildAbsoluteTopHash(colPlacements); // TODO: cache this at first render?
      return mirrorSegs.map((seg) => ({
          seg,
          isVisible: true,
          isAbsolute: true,
          absoluteTop: topsByInstanceId[seg.eventRange.instance.instanceId],
          marginTop: 0,
      }));
  }
  function buildAbsoluteTopHash(colPlacements) {
      let topsByInstanceId = {};
      for (let placements of colPlacements) {
          for (let placement of placements) {
              topsByInstanceId[placement.seg.eventRange.instance.instanceId] = placement.absoluteTop;
          }
      }
      return topsByInstanceId;
  }

  class TableRows extends DateComponent {
      constructor() {
          super(...arguments);
          this.splitBusinessHourSegs = memoize(splitSegsByRow);
          this.splitBgEventSegs = memoize(splitSegsByRow);
          this.splitFgEventSegs = memoize(splitSegsByRow);
          this.splitDateSelectionSegs = memoize(splitSegsByRow);
          this.splitEventDrag = memoize(splitInteractionByRow);
          this.splitEventResize = memoize(splitInteractionByRow);
          this.rowRefs = new RefMap();
      }
      render() {
          let { props, context } = this;
          let rowCnt = props.cells.length;
          let businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, rowCnt);
          let bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, rowCnt);
          let fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, rowCnt);
          let dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, rowCnt);
          let eventDragByRow = this.splitEventDrag(props.eventDrag, rowCnt);
          let eventResizeByRow = this.splitEventResize(props.eventResize, rowCnt);
          // for DayGrid view with many rows, force a min-height on cells so doesn't appear squished
          // choose 7 because a month view will have max 6 rows
          let cellMinHeight = (rowCnt >= 7 && props.clientWidth) ?
              props.clientWidth / context.options.aspectRatio / 6 :
              null;
          return (y$1(NowTimer, { unit: "day" }, (nowDate, todayRange) => (y$1(_, null, props.cells.map((cells, row) => (y$1(TableRow, { ref: this.rowRefs.createRef(row), key: cells.length
                  ? cells[0].date.toISOString() /* best? or put key on cell? or use diff formatter? */
                  : row // in case there are no cells (like when resource view is loading)
              , showDayNumbers: rowCnt > 1, showWeekNumbers: props.showWeekNumbers, todayRange: todayRange, dateProfile: props.dateProfile, cells: cells, renderIntro: props.renderRowIntro, businessHourSegs: businessHourSegsByRow[row], eventSelection: props.eventSelection, bgEventSegs: bgEventSegsByRow[row].filter(isSegAllDay) /* hack */, fgEventSegs: fgEventSegsByRow[row], dateSelectionSegs: dateSelectionSegsByRow[row], eventDrag: eventDragByRow[row], eventResize: eventResizeByRow[row], dayMaxEvents: props.dayMaxEvents, dayMaxEventRows: props.dayMaxEventRows, clientWidth: props.clientWidth, clientHeight: props.clientHeight, cellMinHeight: cellMinHeight, forPrint: props.forPrint })))))));
      }
      componentDidMount() {
          this.registerInteractiveComponent();
      }
      componentDidUpdate() {
          // for if started with zero cells
          this.registerInteractiveComponent();
      }
      registerInteractiveComponent() {
          if (!this.rootEl) {
              // HACK: need a daygrid wrapper parent to do positioning
              // NOTE: a daygrid resource view w/o resources can have zero cells
              const firstCellEl = this.rowRefs.currentMap[0].getCellEls()[0];
              const rootEl = firstCellEl ? firstCellEl.closest('.fc-daygrid-body') : null;
              if (rootEl) {
                  this.rootEl = rootEl;
                  this.context.registerInteractiveComponent(this, {
                      el: rootEl,
                      isHitComboAllowed: this.props.isHitComboAllowed,
                  });
              }
          }
      }
      componentWillUnmount() {
          if (this.rootEl) {
              this.context.unregisterInteractiveComponent(this);
              this.rootEl = null;
          }
      }
      // Hit System
      // ----------------------------------------------------------------------------------------------------
      prepareHits() {
          this.rowPositions = new PositionCache(this.rootEl, this.rowRefs.collect().map((rowObj) => rowObj.getCellEls()[0]), // first cell el in each row. TODO: not optimal
          false, true);
          this.colPositions = new PositionCache(this.rootEl, this.rowRefs.currentMap[0].getCellEls(), // cell els in first row
          true, // horizontal
          false);
      }
      queryHit(positionLeft, positionTop) {
          let { colPositions, rowPositions } = this;
          let col = colPositions.leftToIndex(positionLeft);
          let row = rowPositions.topToIndex(positionTop);
          if (row != null && col != null) {
              let cell = this.props.cells[row][col];
              return {
                  dateProfile: this.props.dateProfile,
                  dateSpan: Object.assign({ range: this.getCellRange(row, col), allDay: true }, cell.extraDateSpan),
                  dayEl: this.getCellEl(row, col),
                  rect: {
                      left: colPositions.lefts[col],
                      right: colPositions.rights[col],
                      top: rowPositions.tops[row],
                      bottom: rowPositions.bottoms[row],
                  },
                  layer: 0,
              };
          }
          return null;
      }
      getCellEl(row, col) {
          return this.rowRefs.currentMap[row].getCellEls()[col]; // TODO: not optimal
      }
      getCellRange(row, col) {
          let start = this.props.cells[row][col].date;
          let end = addDays(start, 1);
          return { start, end };
      }
  }
  function isSegAllDay(seg) {
      return seg.eventRange.def.allDay;
  }

  class Table extends DateComponent {
      constructor() {
          super(...arguments);
          this.elRef = d$1();
          this.needsScrollReset = false;
      }
      render() {
          let { props } = this;
          let { dayMaxEventRows, dayMaxEvents, expandRows } = props;
          let limitViaBalanced = dayMaxEvents === true || dayMaxEventRows === true;
          // if rows can't expand to fill fixed height, can't do balanced-height event limit
          // TODO: best place to normalize these options?
          if (limitViaBalanced && !expandRows) {
              limitViaBalanced = false;
              dayMaxEventRows = null;
              dayMaxEvents = null;
          }
          let classNames = [
              'fc-daygrid-body',
              limitViaBalanced ? 'fc-daygrid-body-balanced' : 'fc-daygrid-body-unbalanced',
              expandRows ? '' : 'fc-daygrid-body-natural', // will height of one row depend on the others?
          ];
          return (y$1("div", { ref: this.elRef, className: classNames.join(' '), style: {
                  // these props are important to give this wrapper correct dimensions for interactions
                  // TODO: if we set it here, can we avoid giving to inner tables?
                  width: props.clientWidth,
                  minWidth: props.tableMinWidth,
              } },
              y$1("table", { role: "presentation", className: "fc-scrollgrid-sync-table", style: {
                      width: props.clientWidth,
                      minWidth: props.tableMinWidth,
                      height: expandRows ? props.clientHeight : '',
                  } },
                  props.colGroupNode,
                  y$1("tbody", { role: "presentation" },
                      y$1(TableRows, { dateProfile: props.dateProfile, cells: props.cells, renderRowIntro: props.renderRowIntro, showWeekNumbers: props.showWeekNumbers, clientWidth: props.clientWidth, clientHeight: props.clientHeight, businessHourSegs: props.businessHourSegs, bgEventSegs: props.bgEventSegs, fgEventSegs: props.fgEventSegs, dateSelectionSegs: props.dateSelectionSegs, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, dayMaxEvents: dayMaxEvents, dayMaxEventRows: dayMaxEventRows, forPrint: props.forPrint, isHitComboAllowed: props.isHitComboAllowed })))));
      }
      componentDidMount() {
          this.requestScrollReset();
      }
      componentDidUpdate(prevProps) {
          if (prevProps.dateProfile !== this.props.dateProfile) {
              this.requestScrollReset();
          }
          else {
              this.flushScrollReset();
          }
      }
      requestScrollReset() {
          this.needsScrollReset = true;
          this.flushScrollReset();
      }
      flushScrollReset() {
          if (this.needsScrollReset &&
              this.props.clientWidth // sizes computed?
          ) {
              const subjectEl = getScrollSubjectEl(this.elRef.current, this.props.dateProfile);
              if (subjectEl) {
                  const originEl = subjectEl.closest('.fc-daygrid-body');
                  const scrollEl = originEl.closest('.fc-scroller');
                  const scrollTop = subjectEl.getBoundingClientRect().top -
                      originEl.getBoundingClientRect().top;
                  scrollEl.scrollTop = scrollTop ? (scrollTop + 1) : 0; // overcome border
              }
              this.needsScrollReset = false;
          }
      }
  }
  function getScrollSubjectEl(containerEl, dateProfile) {
      let el;
      if (dateProfile.currentRangeUnit.match(/year|month/)) {
          el = containerEl.querySelector(`[data-date="${formatIsoMonthStr(dateProfile.currentDate)}-01"]`);
          // even if view is month-based, first-of-month might be hidden...
      }
      if (!el) {
          el = containerEl.querySelector(`[data-date="${formatDayString(dateProfile.currentDate)}"]`);
          // could still be hidden if an interior-view hidden day
      }
      return el;
  }

  class DayTableSlicer extends Slicer {
      constructor() {
          super(...arguments);
          this.forceDayIfListItem = true;
      }
      sliceRange(dateRange, dayTableModel) {
          return dayTableModel.sliceRange(dateRange);
      }
  }

  class DayTable extends DateComponent {
      constructor() {
          super(...arguments);
          this.slicer = new DayTableSlicer();
          this.tableRef = d$1();
      }
      render() {
          let { props, context } = this;
          return (y$1(Table, Object.assign({ ref: this.tableRef }, this.slicer.sliceProps(props, props.dateProfile, props.nextDayThreshold, context, props.dayTableModel), { dateProfile: props.dateProfile, cells: props.dayTableModel.cells, colGroupNode: props.colGroupNode, tableMinWidth: props.tableMinWidth, renderRowIntro: props.renderRowIntro, dayMaxEvents: props.dayMaxEvents, dayMaxEventRows: props.dayMaxEventRows, showWeekNumbers: props.showWeekNumbers, expandRows: props.expandRows, headerAlignElRef: props.headerAlignElRef, clientWidth: props.clientWidth, clientHeight: props.clientHeight, forPrint: props.forPrint })));
      }
  }

  class DayTableView extends TableView {
      constructor() {
          super(...arguments);
          this.buildDayTableModel = memoize(buildDayTableModel);
          this.headerRef = d$1();
          this.tableRef = d$1();
          // can't override any lifecycle methods from parent
      }
      render() {
          let { options, dateProfileGenerator } = this.context;
          let { props } = this;
          let dayTableModel = this.buildDayTableModel(props.dateProfile, dateProfileGenerator);
          let headerContent = options.dayHeaders && (y$1(DayHeader, { ref: this.headerRef, dateProfile: props.dateProfile, dates: dayTableModel.headerDates, datesRepDistinctDays: dayTableModel.rowCnt === 1 }));
          let bodyContent = (contentArg) => (y$1(DayTable, { ref: this.tableRef, dateProfile: props.dateProfile, dayTableModel: dayTableModel, businessHours: props.businessHours, dateSelection: props.dateSelection, eventStore: props.eventStore, eventUiBases: props.eventUiBases, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, nextDayThreshold: options.nextDayThreshold, colGroupNode: contentArg.tableColGroupNode, tableMinWidth: contentArg.tableMinWidth, dayMaxEvents: options.dayMaxEvents, dayMaxEventRows: options.dayMaxEventRows, showWeekNumbers: options.weekNumbers, expandRows: !props.isHeightAuto, headerAlignElRef: this.headerElRef, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, forPrint: props.forPrint }));
          return options.dayMinWidth
              ? this.renderHScrollLayout(headerContent, bodyContent, dayTableModel.colCnt, options.dayMinWidth)
              : this.renderSimpleLayout(headerContent, bodyContent);
      }
  }
  function buildDayTableModel(dateProfile, dateProfileGenerator) {
      let daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);
      return new DayTableModel(daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));
  }

  class TableDateProfileGenerator extends DateProfileGenerator {
      // Computes the date range that will be rendered
      buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay) {
          let renderRange = super.buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay);
          let { props } = this;
          return buildDayTableRenderRange({
              currentRange: renderRange,
              snapToWeek: /^(year|month)$/.test(currentRangeUnit),
              fixedWeekCount: props.fixedWeekCount,
              dateEnv: props.dateEnv,
          });
      }
  }
  function buildDayTableRenderRange(props) {
      let { dateEnv, currentRange } = props;
      let { start, end } = currentRange;
      let endOfWeek;
      // year and month views should be aligned with weeks. this is already done for week
      if (props.snapToWeek) {
          start = dateEnv.startOfWeek(start);
          // make end-of-week if not already
          endOfWeek = dateEnv.startOfWeek(end);
          if (endOfWeek.valueOf() !== end.valueOf()) {
              end = addWeeks(endOfWeek, 1);
          }
      }
      // ensure 6 weeks
      if (props.fixedWeekCount) {
          // TODO: instead of these date-math gymnastics (for multimonth view),
          // compute dateprofiles of all months, then use start of first and end of last.
          let lastMonthRenderStart = dateEnv.startOfWeek(dateEnv.startOfMonth(addDays(currentRange.end, -1)));
          let rowCnt = Math.ceil(// could be partial weeks due to hiddenDays
          diffWeeks(lastMonthRenderStart, end));
          end = addWeeks(end, 6 - rowCnt);
      }
      return { start, end };
  }

  var css_248z$4 = ":root{--fc-daygrid-event-dot-width:8px}.fc-daygrid-day-events:after,.fc-daygrid-day-events:before,.fc-daygrid-day-frame:after,.fc-daygrid-day-frame:before,.fc-daygrid-event-harness:after,.fc-daygrid-event-harness:before{clear:both;content:\"\";display:table}.fc .fc-daygrid-body{position:relative;z-index:1}.fc .fc-daygrid-day.fc-day-today{background-color:var(--fc-today-bg-color)}.fc .fc-daygrid-day-frame{min-height:100%;position:relative}.fc .fc-daygrid-day-top{display:flex;flex-direction:row-reverse}.fc .fc-day-other .fc-daygrid-day-top{opacity:.3}.fc .fc-daygrid-day-number{padding:4px;position:relative;z-index:4}.fc .fc-daygrid-month-start{font-size:1.1em;font-weight:700}.fc .fc-daygrid-day-events{margin-top:1px}.fc .fc-daygrid-body-balanced .fc-daygrid-day-events{left:0;position:absolute;right:0}.fc .fc-daygrid-body-unbalanced .fc-daygrid-day-events{min-height:2em;position:relative}.fc .fc-daygrid-body-natural .fc-daygrid-day-events{margin-bottom:1em}.fc .fc-daygrid-event-harness{position:relative}.fc .fc-daygrid-event-harness-abs{left:0;position:absolute;right:0;top:0}.fc .fc-daygrid-bg-harness{bottom:0;position:absolute;top:0}.fc .fc-daygrid-day-bg .fc-non-business{z-index:1}.fc .fc-daygrid-day-bg .fc-bg-event{z-index:2}.fc .fc-daygrid-day-bg .fc-highlight{z-index:3}.fc .fc-daygrid-event{margin-top:1px;z-index:6}.fc .fc-daygrid-event.fc-event-mirror{z-index:7}.fc .fc-daygrid-day-bottom{font-size:.85em;margin:0 2px}.fc .fc-daygrid-day-bottom:after,.fc .fc-daygrid-day-bottom:before{clear:both;content:\"\";display:table}.fc .fc-daygrid-more-link{border-radius:3px;cursor:pointer;line-height:1;margin-top:1px;max-width:100%;overflow:hidden;padding:2px;position:relative;white-space:nowrap;z-index:4}.fc .fc-daygrid-more-link:hover{background-color:rgba(0,0,0,.1)}.fc .fc-daygrid-week-number{background-color:var(--fc-neutral-bg-color);color:var(--fc-neutral-text-color);min-width:1.5em;padding:2px;position:absolute;text-align:center;top:0;z-index:5}.fc .fc-more-popover .fc-popover-body{min-width:220px;padding:10px}.fc-direction-ltr .fc-daygrid-event.fc-event-start,.fc-direction-rtl .fc-daygrid-event.fc-event-end{margin-left:2px}.fc-direction-ltr .fc-daygrid-event.fc-event-end,.fc-direction-rtl .fc-daygrid-event.fc-event-start{margin-right:2px}.fc-direction-ltr .fc-daygrid-more-link{float:left}.fc-direction-ltr .fc-daygrid-week-number{border-radius:0 0 3px 0;left:0}.fc-direction-rtl .fc-daygrid-more-link{float:right}.fc-direction-rtl .fc-daygrid-week-number{border-radius:0 0 0 3px;right:0}.fc-liquid-hack .fc-daygrid-day-frame{position:static}.fc-daygrid-event{border-radius:3px;font-size:var(--fc-small-font-size);position:relative;white-space:nowrap}.fc-daygrid-block-event .fc-event-time{font-weight:700}.fc-daygrid-block-event .fc-event-time,.fc-daygrid-block-event .fc-event-title{padding:1px}.fc-daygrid-dot-event{align-items:center;display:flex;padding:2px 0}.fc-daygrid-dot-event .fc-event-title{flex-grow:1;flex-shrink:1;font-weight:700;min-width:0;overflow:hidden}.fc-daygrid-dot-event.fc-event-mirror,.fc-daygrid-dot-event:hover{background:rgba(0,0,0,.1)}.fc-daygrid-dot-event.fc-event-selected:before{bottom:-10px;top:-10px}.fc-daygrid-event-dot{border:calc(var(--fc-daygrid-event-dot-width)/2) solid var(--fc-event-border-color);border-radius:calc(var(--fc-daygrid-event-dot-width)/2);box-sizing:content-box;height:0;margin:0 4px;width:0}.fc-direction-ltr .fc-daygrid-event .fc-event-time{margin-right:3px}.fc-direction-rtl .fc-daygrid-event .fc-event-time{margin-left:3px}";
  injectStyles(css_248z$4);

  var index$a = createPlugin({
      name: '@fullcalendar/daygrid',
      initialView: 'dayGridMonth',
      views: {
          dayGrid: {
              component: DayTableView,
              dateProfileGeneratorClass: TableDateProfileGenerator,
          },
          dayGridDay: {
              type: 'dayGrid',
              duration: { days: 1 },
          },
          dayGridWeek: {
              type: 'dayGrid',
              duration: { weeks: 1 },
          },
          dayGridMonth: {
              type: 'dayGrid',
              duration: { months: 1 },
              fixedWeekCount: true,
          },
          dayGridYear: {
              type: 'dayGrid',
              duration: { years: 1 },
          },
      },
  });

  var css_248z$3 = ".fc-v-event{background-color:var(--fc-event-bg-color);border:1px solid var(--fc-event-border-color);display:block}.fc-v-event .fc-event-main{color:var(--fc-event-text-color);height:100%}.fc-v-event .fc-event-main-frame{display:flex;flex-direction:column;height:100%}.fc-v-event .fc-event-time{flex-grow:0;flex-shrink:0;max-height:100%;overflow:hidden}.fc-v-event .fc-event-title-container{flex-grow:1;flex-shrink:1;min-height:0}.fc-v-event .fc-event-title{bottom:0;max-height:100%;overflow:hidden;top:0}.fc-v-event:not(.fc-event-start){border-top-left-radius:0;border-top-right-radius:0;border-top-width:0}.fc-v-event:not(.fc-event-end){border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-width:0}.fc-v-event.fc-event-selected:before{left:-10px;right:-10px}.fc-v-event .fc-event-resizer-start{cursor:n-resize}.fc-v-event .fc-event-resizer-end{cursor:s-resize}.fc-v-event:not(.fc-event-selected) .fc-event-resizer{height:var(--fc-event-resizer-thickness);left:0;right:0}.fc-v-event:not(.fc-event-selected) .fc-event-resizer-start{top:calc(var(--fc-event-resizer-thickness)/-2)}.fc-v-event:not(.fc-event-selected) .fc-event-resizer-end{bottom:calc(var(--fc-event-resizer-thickness)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer{left:50%;margin-left:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer-start{top:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer-end{bottom:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc .fc-timegrid .fc-daygrid-body{z-index:2}.fc .fc-timegrid-divider{padding:0 0 2px}.fc .fc-timegrid-body{min-height:100%;position:relative;z-index:1}.fc .fc-timegrid-axis-chunk{position:relative}.fc .fc-timegrid-axis-chunk>table,.fc .fc-timegrid-slots{position:relative;z-index:1}.fc .fc-timegrid-slot{border-bottom:0;height:1.5em}.fc .fc-timegrid-slot:empty:before{content:\"\\00a0\"}.fc .fc-timegrid-slot-minor{border-top-style:dotted}.fc .fc-timegrid-slot-label-cushion{display:inline-block;white-space:nowrap}.fc .fc-timegrid-slot-label{vertical-align:middle}.fc .fc-timegrid-axis-cushion,.fc .fc-timegrid-slot-label-cushion{padding:0 4px}.fc .fc-timegrid-axis-frame-liquid{height:100%}.fc .fc-timegrid-axis-frame{align-items:center;display:flex;justify-content:flex-end;overflow:hidden}.fc .fc-timegrid-axis-cushion{flex-shrink:0;max-width:60px}.fc-direction-ltr .fc-timegrid-slot-label-frame{text-align:right}.fc-direction-rtl .fc-timegrid-slot-label-frame{text-align:left}.fc-liquid-hack .fc-timegrid-axis-frame-liquid{bottom:0;height:auto;left:0;position:absolute;right:0;top:0}.fc .fc-timegrid-col.fc-day-today{background-color:var(--fc-today-bg-color)}.fc .fc-timegrid-col-frame{min-height:100%;position:relative}.fc-media-screen.fc-liquid-hack .fc-timegrid-col-frame{bottom:0;height:auto;left:0;position:absolute;right:0;top:0}.fc-media-screen .fc-timegrid-cols{bottom:0;left:0;position:absolute;right:0;top:0}.fc-media-screen .fc-timegrid-cols>table{height:100%}.fc-media-screen .fc-timegrid-col-bg,.fc-media-screen .fc-timegrid-col-events,.fc-media-screen .fc-timegrid-now-indicator-container{left:0;position:absolute;right:0;top:0}.fc .fc-timegrid-col-bg{z-index:2}.fc .fc-timegrid-col-bg .fc-non-business{z-index:1}.fc .fc-timegrid-col-bg .fc-bg-event{z-index:2}.fc .fc-timegrid-col-bg .fc-highlight{z-index:3}.fc .fc-timegrid-bg-harness{left:0;position:absolute;right:0}.fc .fc-timegrid-col-events{z-index:3}.fc .fc-timegrid-now-indicator-container{bottom:0;overflow:hidden}.fc-direction-ltr .fc-timegrid-col-events{margin:0 2.5% 0 2px}.fc-direction-rtl .fc-timegrid-col-events{margin:0 2px 0 2.5%}.fc-timegrid-event-harness{position:absolute}.fc-timegrid-event-harness>.fc-timegrid-event{bottom:0;left:0;position:absolute;right:0;top:0}.fc-timegrid-event-harness-inset .fc-timegrid-event,.fc-timegrid-event.fc-event-mirror,.fc-timegrid-more-link{box-shadow:0 0 0 1px var(--fc-page-bg-color)}.fc-timegrid-event,.fc-timegrid-more-link{border-radius:3px;font-size:var(--fc-small-font-size)}.fc-timegrid-event{margin-bottom:1px}.fc-timegrid-event .fc-event-main{padding:1px 1px 0}.fc-timegrid-event .fc-event-time{font-size:var(--fc-small-font-size);margin-bottom:1px;white-space:nowrap}.fc-timegrid-event-short .fc-event-main-frame{flex-direction:row;overflow:hidden}.fc-timegrid-event-short .fc-event-time:after{content:\"\\00a0-\\00a0\"}.fc-timegrid-event-short .fc-event-title{font-size:var(--fc-small-font-size)}.fc-timegrid-more-link{background:var(--fc-more-link-bg-color);color:var(--fc-more-link-text-color);cursor:pointer;margin-bottom:1px;position:absolute;z-index:9999}.fc-timegrid-more-link-inner{padding:3px 2px;top:0}.fc-direction-ltr .fc-timegrid-more-link{right:0}.fc-direction-rtl .fc-timegrid-more-link{left:0}.fc .fc-timegrid-now-indicator-line{border-color:var(--fc-now-indicator-color);border-style:solid;border-width:1px 0 0;left:0;position:absolute;right:0;z-index:4}.fc .fc-timegrid-now-indicator-arrow{border-color:var(--fc-now-indicator-color);border-style:solid;margin-top:-5px;position:absolute;z-index:4}.fc-direction-ltr .fc-timegrid-now-indicator-arrow{border-bottom-color:transparent;border-top-color:transparent;border-width:5px 0 5px 6px;left:0}.fc-direction-rtl .fc-timegrid-now-indicator-arrow{border-bottom-color:transparent;border-top-color:transparent;border-width:5px 6px 5px 0;right:0}";
  injectStyles(css_248z$3);

  class AllDaySplitter extends Splitter {
      getKeyInfo() {
          return {
              allDay: {},
              timed: {},
          };
      }
      getKeysForDateSpan(dateSpan) {
          if (dateSpan.allDay) {
              return ['allDay'];
          }
          return ['timed'];
      }
      getKeysForEventDef(eventDef) {
          if (!eventDef.allDay) {
              return ['timed'];
          }
          if (hasBgRendering(eventDef)) {
              return ['timed', 'allDay'];
          }
          return ['allDay'];
      }
  }

  const DEFAULT_SLAT_LABEL_FORMAT = createFormatter({
      hour: 'numeric',
      minute: '2-digit',
      omitZeroMinute: true,
      meridiem: 'short',
  });
  function TimeColsAxisCell(props) {
      let classNames = [
          'fc-timegrid-slot',
          'fc-timegrid-slot-label',
          props.isLabeled ? 'fc-scrollgrid-shrink' : 'fc-timegrid-slot-minor',
      ];
      return (y$1(ViewContextType.Consumer, null, (context) => {
          if (!props.isLabeled) {
              return (y$1("td", { className: classNames.join(' '), "data-time": props.isoTimeStr }));
          }
          let { dateEnv, options, viewApi } = context;
          let labelFormat = // TODO: fully pre-parse
           options.slotLabelFormat == null ? DEFAULT_SLAT_LABEL_FORMAT :
              Array.isArray(options.slotLabelFormat) ? createFormatter(options.slotLabelFormat[0]) :
                  createFormatter(options.slotLabelFormat);
          let renderProps = {
              level: 0,
              time: props.time,
              date: dateEnv.toDate(props.date),
              view: viewApi,
              text: dateEnv.format(props.date, labelFormat),
          };
          return (y$1(ContentContainer, { elTag: "td", elClasses: classNames, elAttrs: {
                  'data-time': props.isoTimeStr,
              }, renderProps: renderProps, generatorName: "slotLabelContent", customGenerator: options.slotLabelContent, defaultGenerator: renderInnerContent$1, classNameGenerator: options.slotLabelClassNames, didMount: options.slotLabelDidMount, willUnmount: options.slotLabelWillUnmount }, (InnerContent) => (y$1("div", { className: "fc-timegrid-slot-label-frame fc-scrollgrid-shrink-frame" },
              y$1(InnerContent, { elTag: "div", elClasses: [
                      'fc-timegrid-slot-label-cushion',
                      'fc-scrollgrid-shrink-cushion',
                  ] })))));
      }));
  }
  function renderInnerContent$1(props) {
      return props.text;
  }

  class TimeBodyAxis extends BaseComponent {
      render() {
          return this.props.slatMetas.map((slatMeta) => (y$1("tr", { key: slatMeta.key },
              y$1(TimeColsAxisCell, Object.assign({}, slatMeta)))));
      }
  }

  const DEFAULT_WEEK_NUM_FORMAT = createFormatter({ week: 'short' });
  const AUTO_ALL_DAY_MAX_EVENT_ROWS = 5;
  class TimeColsView extends DateComponent {
      constructor() {
          super(...arguments);
          this.allDaySplitter = new AllDaySplitter(); // for use by subclasses
          this.headerElRef = d$1();
          this.rootElRef = d$1();
          this.scrollerElRef = d$1();
          this.state = {
              slatCoords: null,
          };
          this.handleScrollTopRequest = (scrollTop) => {
              let scrollerEl = this.scrollerElRef.current;
              if (scrollerEl) { // TODO: not sure how this could ever be null. weirdness with the reducer
                  scrollerEl.scrollTop = scrollTop;
              }
          };
          /* Header Render Methods
          ------------------------------------------------------------------------------------------------------------------*/
          this.renderHeadAxis = (rowKey, frameHeight = '') => {
              let { options } = this.context;
              let { dateProfile } = this.props;
              let range = dateProfile.renderRange;
              let dayCnt = diffDays(range.start, range.end);
              // only do in day views (to avoid doing in week views that dont need it)
              let navLinkAttrs = (dayCnt === 1)
                  ? buildNavLinkAttrs(this.context, range.start, 'week')
                  : {};
              if (options.weekNumbers && rowKey === 'day') {
                  return (y$1(WeekNumberContainer, { elTag: "th", elClasses: [
                          'fc-timegrid-axis',
                          'fc-scrollgrid-shrink',
                      ], elAttrs: {
                          'aria-hidden': true,
                      }, date: range.start, defaultFormat: DEFAULT_WEEK_NUM_FORMAT }, (InnerContent) => (y$1("div", { className: [
                          'fc-timegrid-axis-frame',
                          'fc-scrollgrid-shrink-frame',
                          'fc-timegrid-axis-frame-liquid',
                      ].join(' '), style: { height: frameHeight } },
                      y$1(InnerContent, { elTag: "a", elClasses: [
                              'fc-timegrid-axis-cushion',
                              'fc-scrollgrid-shrink-cushion',
                              'fc-scrollgrid-sync-inner',
                          ], elAttrs: navLinkAttrs })))));
              }
              return (y$1("th", { "aria-hidden": true, className: "fc-timegrid-axis" },
                  y$1("div", { className: "fc-timegrid-axis-frame", style: { height: frameHeight } })));
          };
          /* Table Component Render Methods
          ------------------------------------------------------------------------------------------------------------------*/
          // only a one-way height sync. we don't send the axis inner-content height to the DayGrid,
          // but DayGrid still needs to have classNames on inner elements in order to measure.
          this.renderTableRowAxis = (rowHeight) => {
              let { options, viewApi } = this.context;
              let renderProps = {
                  text: options.allDayText,
                  view: viewApi,
              };
              return (
              // TODO: make reusable hook. used in list view too
              y$1(ContentContainer, { elTag: "td", elClasses: [
                      'fc-timegrid-axis',
                      'fc-scrollgrid-shrink',
                  ], elAttrs: {
                      'aria-hidden': true,
                  }, renderProps: renderProps, generatorName: "allDayContent", customGenerator: options.allDayContent, defaultGenerator: renderAllDayInner$1, classNameGenerator: options.allDayClassNames, didMount: options.allDayDidMount, willUnmount: options.allDayWillUnmount }, (InnerContent) => (y$1("div", { className: [
                      'fc-timegrid-axis-frame',
                      'fc-scrollgrid-shrink-frame',
                      rowHeight == null ? ' fc-timegrid-axis-frame-liquid' : '',
                  ].join(' '), style: { height: rowHeight } },
                  y$1(InnerContent, { elTag: "span", elClasses: [
                          'fc-timegrid-axis-cushion',
                          'fc-scrollgrid-shrink-cushion',
                          'fc-scrollgrid-sync-inner',
                      ] })))));
          };
          this.handleSlatCoords = (slatCoords) => {
              this.setState({ slatCoords });
          };
      }
      // rendering
      // ----------------------------------------------------------------------------------------------------
      renderSimpleLayout(headerRowContent, allDayContent, timeContent) {
          let { context, props } = this;
          let sections = [];
          let stickyHeaderDates = getStickyHeaderDates(context.options);
          if (headerRowContent) {
              sections.push({
                  type: 'header',
                  key: 'header',
                  isSticky: stickyHeaderDates,
                  chunk: {
                      elRef: this.headerElRef,
                      tableClassName: 'fc-col-header',
                      rowContent: headerRowContent,
                  },
              });
          }
          if (allDayContent) {
              sections.push({
                  type: 'body',
                  key: 'all-day',
                  chunk: { content: allDayContent },
              });
              sections.push({
                  type: 'body',
                  key: 'all-day-divider',
                  outerContent: ( // TODO: rename to cellContent so don't need to define <tr>?
                  y$1("tr", { role: "presentation", className: "fc-scrollgrid-section" },
                      y$1("td", { className: 'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded') }))),
              });
          }
          sections.push({
              type: 'body',
              key: 'body',
              liquid: true,
              expandRows: Boolean(context.options.expandRows),
              chunk: {
                  scrollerElRef: this.scrollerElRef,
                  content: timeContent,
              },
          });
          return (y$1(ViewContainer, { elRef: this.rootElRef, elClasses: ['fc-timegrid'], viewSpec: context.viewSpec },
              y$1(SimpleScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, collapsibleWidth: props.forPrint, cols: [{ width: 'shrink' }], sections: sections })));
      }
      renderHScrollLayout(headerRowContent, allDayContent, timeContent, colCnt, dayMinWidth, slatMetas, slatCoords) {
          let ScrollGrid = this.context.pluginHooks.scrollGridImpl;
          if (!ScrollGrid) {
              throw new Error('No ScrollGrid implementation');
          }
          let { context, props } = this;
          let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options);
          let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options);
          let sections = [];
          if (headerRowContent) {
              sections.push({
                  type: 'header',
                  key: 'header',
                  isSticky: stickyHeaderDates,
                  syncRowHeights: true,
                  chunks: [
                      {
                          key: 'axis',
                          rowContent: (arg) => (y$1("tr", { role: "presentation" }, this.renderHeadAxis('day', arg.rowSyncHeights[0]))),
                      },
                      {
                          key: 'cols',
                          elRef: this.headerElRef,
                          tableClassName: 'fc-col-header',
                          rowContent: headerRowContent,
                      },
                  ],
              });
          }
          if (allDayContent) {
              sections.push({
                  type: 'body',
                  key: 'all-day',
                  syncRowHeights: true,
                  chunks: [
                      {
                          key: 'axis',
                          rowContent: (contentArg) => (y$1("tr", { role: "presentation" }, this.renderTableRowAxis(contentArg.rowSyncHeights[0]))),
                      },
                      {
                          key: 'cols',
                          content: allDayContent,
                      },
                  ],
              });
              sections.push({
                  key: 'all-day-divider',
                  type: 'body',
                  outerContent: ( // TODO: rename to cellContent so don't need to define <tr>?
                  y$1("tr", { role: "presentation", className: "fc-scrollgrid-section" },
                      y$1("td", { colSpan: 2, className: 'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded') }))),
              });
          }
          let isNowIndicator = context.options.nowIndicator;
          sections.push({
              type: 'body',
              key: 'body',
              liquid: true,
              expandRows: Boolean(context.options.expandRows),
              chunks: [
                  {
                      key: 'axis',
                      content: (arg) => (
                      // TODO: make this now-indicator arrow more DRY with TimeColsContent
                      y$1("div", { className: "fc-timegrid-axis-chunk" },
                          y$1("table", { "aria-hidden": true, style: { height: arg.expandRows ? arg.clientHeight : '' } },
                              arg.tableColGroupNode,
                              y$1("tbody", null,
                                  y$1(TimeBodyAxis, { slatMetas: slatMetas }))),
                          y$1("div", { className: "fc-timegrid-now-indicator-container" },
                              y$1(NowTimer, { unit: isNowIndicator ? 'minute' : 'day' /* hacky */ }, (nowDate) => {
                                  let nowIndicatorTop = isNowIndicator &&
                                      slatCoords &&
                                      slatCoords.safeComputeTop(nowDate); // might return void
                                  if (typeof nowIndicatorTop === 'number') {
                                      return (y$1(NowIndicatorContainer, { elClasses: ['fc-timegrid-now-indicator-arrow'], elStyle: { top: nowIndicatorTop }, isAxis: true, date: nowDate }));
                                  }
                                  return null;
                              })))),
                  },
                  {
                      key: 'cols',
                      scrollerElRef: this.scrollerElRef,
                      content: timeContent,
                  },
              ],
          });
          if (stickyFooterScrollbar) {
              sections.push({
                  key: 'footer',
                  type: 'footer',
                  isSticky: true,
                  chunks: [
                      {
                          key: 'axis',
                          content: renderScrollShim,
                      },
                      {
                          key: 'cols',
                          content: renderScrollShim,
                      },
                  ],
              });
          }
          return (y$1(ViewContainer, { elRef: this.rootElRef, elClasses: ['fc-timegrid'], viewSpec: context.viewSpec },
              y$1(ScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, forPrint: props.forPrint, collapsibleWidth: false, colGroups: [
                      { width: 'shrink', cols: [{ width: 'shrink' }] },
                      { cols: [{ span: colCnt, minWidth: dayMinWidth }] },
                  ], sections: sections })));
      }
      /* Dimensions
      ------------------------------------------------------------------------------------------------------------------*/
      getAllDayMaxEventProps() {
          let { dayMaxEvents, dayMaxEventRows } = this.context.options;
          if (dayMaxEvents === true || dayMaxEventRows === true) { // is auto?
              dayMaxEvents = undefined;
              dayMaxEventRows = AUTO_ALL_DAY_MAX_EVENT_ROWS; // make sure "auto" goes to a real number
          }
          return { dayMaxEvents, dayMaxEventRows };
      }
  }
  function renderAllDayInner$1(renderProps) {
      return renderProps.text;
  }

  class TimeColsSlatsCoords {
      constructor(positions, dateProfile, slotDuration) {
          this.positions = positions;
          this.dateProfile = dateProfile;
          this.slotDuration = slotDuration;
      }
      safeComputeTop(date) {
          let { dateProfile } = this;
          if (rangeContainsMarker(dateProfile.currentRange, date)) {
              let startOfDayDate = startOfDay(date);
              let timeMs = date.valueOf() - startOfDayDate.valueOf();
              if (timeMs >= asRoughMs(dateProfile.slotMinTime) &&
                  timeMs < asRoughMs(dateProfile.slotMaxTime)) {
                  return this.computeTimeTop(createDuration(timeMs));
              }
          }
          return null;
      }
      // Computes the top coordinate, relative to the bounds of the grid, of the given date.
      // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.
      computeDateTop(when, startOfDayDate) {
          if (!startOfDayDate) {
              startOfDayDate = startOfDay(when);
          }
          return this.computeTimeTop(createDuration(when.valueOf() - startOfDayDate.valueOf()));
      }
      // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).
      // This is a makeshify way to compute the time-top. Assumes all slatMetas dates are uniform.
      // Eventually allow computation with arbirary slat dates.
      computeTimeTop(duration) {
          let { positions, dateProfile } = this;
          let len = positions.els.length;
          // floating-point value of # of slots covered
          let slatCoverage = (duration.milliseconds - asRoughMs(dateProfile.slotMinTime)) / asRoughMs(this.slotDuration);
          let slatIndex;
          let slatRemainder;
          // compute a floating-point number for how many slats should be progressed through.
          // from 0 to number of slats (inclusive)
          // constrained because slotMinTime/slotMaxTime might be customized.
          slatCoverage = Math.max(0, slatCoverage);
          slatCoverage = Math.min(len, slatCoverage);
          // an integer index of the furthest whole slat
          // from 0 to number slats (*exclusive*, so len-1)
          slatIndex = Math.floor(slatCoverage);
          slatIndex = Math.min(slatIndex, len - 1);
          // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.
          // could be 1.0 if slatCoverage is covering *all* the slots
          slatRemainder = slatCoverage - slatIndex;
          return positions.tops[slatIndex] +
              positions.getHeight(slatIndex) * slatRemainder;
      }
  }

  class TimeColsSlatsBody extends BaseComponent {
      render() {
          let { props, context } = this;
          let { options } = context;
          let { slatElRefs } = props;
          return (y$1("tbody", null, props.slatMetas.map((slatMeta, i) => {
              let renderProps = {
                  time: slatMeta.time,
                  date: context.dateEnv.toDate(slatMeta.date),
                  view: context.viewApi,
              };
              return (y$1("tr", { key: slatMeta.key, ref: slatElRefs.createRef(slatMeta.key) },
                  props.axis && (y$1(TimeColsAxisCell, Object.assign({}, slatMeta))),
                  y$1(ContentContainer, { elTag: "td", elClasses: [
                          'fc-timegrid-slot',
                          'fc-timegrid-slot-lane',
                          !slatMeta.isLabeled && 'fc-timegrid-slot-minor',
                      ], elAttrs: {
                          'data-time': slatMeta.isoTimeStr,
                      }, renderProps: renderProps, generatorName: "slotLaneContent", customGenerator: options.slotLaneContent, classNameGenerator: options.slotLaneClassNames, didMount: options.slotLaneDidMount, willUnmount: options.slotLaneWillUnmount })));
          })));
      }
  }

  /*
  for the horizontal "slats" that run width-wise. Has a time axis on a side. Depends on RTL.
  */
  class TimeColsSlats extends BaseComponent {
      constructor() {
          super(...arguments);
          this.rootElRef = d$1();
          this.slatElRefs = new RefMap();
      }
      render() {
          let { props, context } = this;
          return (y$1("div", { ref: this.rootElRef, className: "fc-timegrid-slots" },
              y$1("table", { "aria-hidden": true, className: context.theme.getClass('table'), style: {
                      minWidth: props.tableMinWidth,
                      width: props.clientWidth,
                      height: props.minHeight,
                  } },
                  props.tableColGroupNode /* relies on there only being a single <col> for the axis */,
                  y$1(TimeColsSlatsBody, { slatElRefs: this.slatElRefs, axis: props.axis, slatMetas: props.slatMetas }))));
      }
      componentDidMount() {
          this.updateSizing();
      }
      componentDidUpdate() {
          this.updateSizing();
      }
      componentWillUnmount() {
          if (this.props.onCoords) {
              this.props.onCoords(null);
          }
      }
      updateSizing() {
          let { context, props } = this;
          if (props.onCoords &&
              props.clientWidth !== null // means sizing has stabilized
          ) {
              let rootEl = this.rootElRef.current;
              if (rootEl.offsetHeight) { // not hidden by css
                  props.onCoords(new TimeColsSlatsCoords(new PositionCache(this.rootElRef.current, collectSlatEls(this.slatElRefs.currentMap, props.slatMetas), false, true), this.props.dateProfile, context.options.slotDuration));
              }
          }
      }
  }
  function collectSlatEls(elMap, slatMetas) {
      return slatMetas.map((slatMeta) => elMap[slatMeta.key]);
  }

  function splitSegsByCol(segs, colCnt) {
      let segsByCol = [];
      let i;
      for (i = 0; i < colCnt; i += 1) {
          segsByCol.push([]);
      }
      if (segs) {
          for (i = 0; i < segs.length; i += 1) {
              segsByCol[segs[i].col].push(segs[i]);
          }
      }
      return segsByCol;
  }
  function splitInteractionByCol(ui, colCnt) {
      let byRow = [];
      if (!ui) {
          for (let i = 0; i < colCnt; i += 1) {
              byRow[i] = null;
          }
      }
      else {
          for (let i = 0; i < colCnt; i += 1) {
              byRow[i] = {
                  affectedInstances: ui.affectedInstances,
                  isEvent: ui.isEvent,
                  segs: [],
              };
          }
          for (let seg of ui.segs) {
              byRow[seg.col].segs.push(seg);
          }
      }
      return byRow;
  }

  class TimeColMoreLink extends BaseComponent {
      render() {
          let { props } = this;
          return (y$1(MoreLinkContainer, { elClasses: ['fc-timegrid-more-link'], elStyle: {
                  top: props.top,
                  bottom: props.bottom,
              }, allDayDate: null, moreCnt: props.hiddenSegs.length, allSegs: props.hiddenSegs, hiddenSegs: props.hiddenSegs, extraDateSpan: props.extraDateSpan, dateProfile: props.dateProfile, todayRange: props.todayRange, popoverContent: () => renderPlainFgSegs(props.hiddenSegs, props), defaultGenerator: renderMoreLinkInner, forceTimed: true }, (InnerContent) => (y$1(InnerContent, { elTag: "div", elClasses: ['fc-timegrid-more-link-inner', 'fc-sticky'] }))));
      }
  }
  function renderMoreLinkInner(props) {
      return props.shortText;
  }

  // segInputs assumed sorted
  function buildPositioning(segInputs, strictOrder, maxStackCnt) {
      let hierarchy = new SegHierarchy();
      if (strictOrder != null) {
          hierarchy.strictOrder = strictOrder;
      }
      if (maxStackCnt != null) {
          hierarchy.maxStackCnt = maxStackCnt;
      }
      let hiddenEntries = hierarchy.addSegs(segInputs);
      let hiddenGroups = groupIntersectingEntries(hiddenEntries);
      let web = buildWeb(hierarchy);
      web = stretchWeb(web, 1); // all levelCoords/thickness will have 0.0-1.0
      let segRects = webToRects(web);
      return { segRects, hiddenGroups };
  }
  function buildWeb(hierarchy) {
      const { entriesByLevel } = hierarchy;
      const buildNode = cacheable((level, lateral) => level + ':' + lateral, (level, lateral) => {
          let siblingRange = findNextLevelSegs(hierarchy, level, lateral);
          let nextLevelRes = buildNodes(siblingRange, buildNode);
          let entry = entriesByLevel[level][lateral];
          return [
              Object.assign(Object.assign({}, entry), { nextLevelNodes: nextLevelRes[0] }),
              entry.thickness + nextLevelRes[1], // the pressure builds
          ];
      });
      return buildNodes(entriesByLevel.length
          ? { level: 0, lateralStart: 0, lateralEnd: entriesByLevel[0].length }
          : null, buildNode)[0];
  }
  function buildNodes(siblingRange, buildNode) {
      if (!siblingRange) {
          return [[], 0];
      }
      let { level, lateralStart, lateralEnd } = siblingRange;
      let lateral = lateralStart;
      let pairs = [];
      while (lateral < lateralEnd) {
          pairs.push(buildNode(level, lateral));
          lateral += 1;
      }
      pairs.sort(cmpDescPressures);
      return [
          pairs.map(extractNode),
          pairs[0][1], // first item's pressure
      ];
  }
  function cmpDescPressures(a, b) {
      return b[1] - a[1];
  }
  function extractNode(a) {
      return a[0];
  }
  function findNextLevelSegs(hierarchy, subjectLevel, subjectLateral) {
      let { levelCoords, entriesByLevel } = hierarchy;
      let subjectEntry = entriesByLevel[subjectLevel][subjectLateral];
      let afterSubject = levelCoords[subjectLevel] + subjectEntry.thickness;
      let levelCnt = levelCoords.length;
      let level = subjectLevel;
      // skip past levels that are too high up
      for (; level < levelCnt && levelCoords[level] < afterSubject; level += 1)
          ; // do nothing
      for (; level < levelCnt; level += 1) {
          let entries = entriesByLevel[level];
          let entry;
          let searchIndex = binarySearch(entries, subjectEntry.span.start, getEntrySpanEnd);
          let lateralStart = searchIndex[0] + searchIndex[1]; // if exact match (which doesn't collide), go to next one
          let lateralEnd = lateralStart;
          while ( // loop through entries that horizontally intersect
          (entry = entries[lateralEnd]) && // but not past the whole seg list
              entry.span.start < subjectEntry.span.end) {
              lateralEnd += 1;
          }
          if (lateralStart < lateralEnd) {
              return { level, lateralStart, lateralEnd };
          }
      }
      return null;
  }
  function stretchWeb(topLevelNodes, totalThickness) {
      const stretchNode = cacheable((node, startCoord, prevThickness) => buildEntryKey(node), (node, startCoord, prevThickness) => {
          let { nextLevelNodes, thickness } = node;
          let allThickness = thickness + prevThickness;
          let thicknessFraction = thickness / allThickness;
          let endCoord;
          let newChildren = [];
          if (!nextLevelNodes.length) {
              endCoord = totalThickness;
          }
          else {
              for (let childNode of nextLevelNodes) {
                  if (endCoord === undefined) {
                      let res = stretchNode(childNode, startCoord, allThickness);
                      endCoord = res[0];
                      newChildren.push(res[1]);
                  }
                  else {
                      let res = stretchNode(childNode, endCoord, 0);
                      newChildren.push(res[1]);
                  }
              }
          }
          let newThickness = (endCoord - startCoord) * thicknessFraction;
          return [endCoord - newThickness, Object.assign(Object.assign({}, node), { thickness: newThickness, nextLevelNodes: newChildren })];
      });
      return topLevelNodes.map((node) => stretchNode(node, 0, 0)[1]);
  }
  // not sorted in any particular order
  function webToRects(topLevelNodes) {
      let rects = [];
      const processNode = cacheable((node, levelCoord, stackDepth) => buildEntryKey(node), (node, levelCoord, stackDepth) => {
          let rect = Object.assign(Object.assign({}, node), { levelCoord,
              stackDepth, stackForward: 0 });
          rects.push(rect);
          return (rect.stackForward = processNodes(node.nextLevelNodes, levelCoord + node.thickness, stackDepth + 1) + 1);
      });
      function processNodes(nodes, levelCoord, stackDepth) {
          let stackForward = 0;
          for (let node of nodes) {
              stackForward = Math.max(processNode(node, levelCoord, stackDepth), stackForward);
          }
          return stackForward;
      }
      processNodes(topLevelNodes, 0, 0);
      return rects; // TODO: sort rects by levelCoord to be consistent with toRects?
  }
  // TODO: move to general util
  function cacheable(keyFunc, workFunc) {
      const cache = {};
      return (...args) => {
          let key = keyFunc(...args);
          return (key in cache)
              ? cache[key]
              : (cache[key] = workFunc(...args));
      };
  }

  function computeSegVCoords(segs, colDate, slatCoords = null, eventMinHeight = 0) {
      let vcoords = [];
      if (slatCoords) {
          for (let i = 0; i < segs.length; i += 1) {
              let seg = segs[i];
              let spanStart = slatCoords.computeDateTop(seg.start, colDate);
              let spanEnd = Math.max(spanStart + (eventMinHeight || 0), // :(
              slatCoords.computeDateTop(seg.end, colDate));
              vcoords.push({
                  start: Math.round(spanStart),
                  end: Math.round(spanEnd), //
              });
          }
      }
      return vcoords;
  }
  function computeFgSegPlacements(segs, segVCoords, // might not have for every seg
  eventOrderStrict, eventMaxStack) {
      let segInputs = [];
      let dumbSegs = []; // segs without coords
      for (let i = 0; i < segs.length; i += 1) {
          let vcoords = segVCoords[i];
          if (vcoords) {
              segInputs.push({
                  index: i,
                  thickness: 1,
                  span: vcoords,
              });
          }
          else {
              dumbSegs.push(segs[i]);
          }
      }
      let { segRects, hiddenGroups } = buildPositioning(segInputs, eventOrderStrict, eventMaxStack);
      let segPlacements = [];
      for (let segRect of segRects) {
          segPlacements.push({
              seg: segs[segRect.index],
              rect: segRect,
          });
      }
      for (let dumbSeg of dumbSegs) {
          segPlacements.push({ seg: dumbSeg, rect: null });
      }
      return { segPlacements, hiddenGroups };
  }

  const DEFAULT_TIME_FORMAT$1 = createFormatter({
      hour: 'numeric',
      minute: '2-digit',
      meridiem: false,
  });
  class TimeColEvent extends BaseComponent {
      render() {
          return (y$1(StandardEvent, Object.assign({}, this.props, { elClasses: [
                  'fc-timegrid-event',
                  'fc-v-event',
                  this.props.isShort && 'fc-timegrid-event-short',
              ], defaultTimeFormat: DEFAULT_TIME_FORMAT$1 })));
      }
  }

  class TimeCol extends BaseComponent {
      constructor() {
          super(...arguments);
          this.sortEventSegs = memoize(sortEventSegs);
      }
      // TODO: memoize event-placement?
      render() {
          let { props, context } = this;
          let { options } = context;
          let isSelectMirror = options.selectMirror;
          let mirrorSegs = // yuck
           (props.eventDrag && props.eventDrag.segs) ||
              (props.eventResize && props.eventResize.segs) ||
              (isSelectMirror && props.dateSelectionSegs) ||
              [];
          let interactionAffectedInstances = // TODO: messy way to compute this
           (props.eventDrag && props.eventDrag.affectedInstances) ||
              (props.eventResize && props.eventResize.affectedInstances) ||
              {};
          let sortedFgSegs = this.sortEventSegs(props.fgEventSegs, options.eventOrder);
          return (y$1(DayCellContainer, { elTag: "td", elRef: props.elRef, elClasses: [
                  'fc-timegrid-col',
                  ...(props.extraClassNames || []),
              ], elAttrs: Object.assign({ role: 'gridcell' }, props.extraDataAttrs), date: props.date, dateProfile: props.dateProfile, todayRange: props.todayRange, extraRenderProps: props.extraRenderProps }, (InnerContent) => (y$1("div", { className: "fc-timegrid-col-frame" },
              y$1("div", { className: "fc-timegrid-col-bg" },
                  this.renderFillSegs(props.businessHourSegs, 'non-business'),
                  this.renderFillSegs(props.bgEventSegs, 'bg-event'),
                  this.renderFillSegs(props.dateSelectionSegs, 'highlight')),
              y$1("div", { className: "fc-timegrid-col-events" }, this.renderFgSegs(sortedFgSegs, interactionAffectedInstances, false, false, false)),
              y$1("div", { className: "fc-timegrid-col-events" }, this.renderFgSegs(mirrorSegs, {}, Boolean(props.eventDrag), Boolean(props.eventResize), Boolean(isSelectMirror), 'mirror')),
              y$1("div", { className: "fc-timegrid-now-indicator-container" }, this.renderNowIndicator(props.nowIndicatorSegs)),
              hasCustomDayCellContent(options) && (y$1(InnerContent, { elTag: "div", elClasses: ['fc-timegrid-col-misc'] }))))));
      }
      renderFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting, forcedKey) {
          let { props } = this;
          if (props.forPrint) {
              return renderPlainFgSegs(sortedFgSegs, props);
          }
          return this.renderPositionedFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting, forcedKey);
      }
      renderPositionedFgSegs(segs, // if not mirror, needs to be sorted
      segIsInvisible, isDragging, isResizing, isDateSelecting, forcedKey) {
          let { eventMaxStack, eventShortHeight, eventOrderStrict, eventMinHeight } = this.context.options;
          let { date, slatCoords, eventSelection, todayRange, nowDate } = this.props;
          let isMirror = isDragging || isResizing || isDateSelecting;
          let segVCoords = computeSegVCoords(segs, date, slatCoords, eventMinHeight);
          let { segPlacements, hiddenGroups } = computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack);
          return (y$1(_, null,
              this.renderHiddenGroups(hiddenGroups, segs),
              segPlacements.map((segPlacement) => {
                  let { seg, rect } = segPlacement;
                  let instanceId = seg.eventRange.instance.instanceId;
                  let isVisible = isMirror || Boolean(!segIsInvisible[instanceId] && rect);
                  let vStyle = computeSegVStyle(rect && rect.span);
                  let hStyle = (!isMirror && rect) ? this.computeSegHStyle(rect) : { left: 0, right: 0 };
                  let isInset = Boolean(rect) && rect.stackForward > 0;
                  let isShort = Boolean(rect) && (rect.span.end - rect.span.start) < eventShortHeight; // look at other places for this problem
                  return (y$1("div", { className: 'fc-timegrid-event-harness' +
                          (isInset ? ' fc-timegrid-event-harness-inset' : ''), key: forcedKey || instanceId, style: Object.assign(Object.assign({ visibility: isVisible ? '' : 'hidden' }, vStyle), hStyle) },
                      y$1(TimeColEvent, Object.assign({ seg: seg, isDragging: isDragging, isResizing: isResizing, isDateSelecting: isDateSelecting, isSelected: instanceId === eventSelection, isShort: isShort }, getSegMeta(seg, todayRange, nowDate)))));
              })));
      }
      // will already have eventMinHeight applied because segInputs already had it
      renderHiddenGroups(hiddenGroups, segs) {
          let { extraDateSpan, dateProfile, todayRange, nowDate, eventSelection, eventDrag, eventResize } = this.props;
          return (y$1(_, null, hiddenGroups.map((hiddenGroup) => {
              let positionCss = computeSegVStyle(hiddenGroup.span);
              let hiddenSegs = compileSegsFromEntries(hiddenGroup.entries, segs);
              return (y$1(TimeColMoreLink, { key: buildIsoString(computeEarliestSegStart(hiddenSegs)), hiddenSegs: hiddenSegs, top: positionCss.top, bottom: positionCss.bottom, extraDateSpan: extraDateSpan, dateProfile: dateProfile, todayRange: todayRange, nowDate: nowDate, eventSelection: eventSelection, eventDrag: eventDrag, eventResize: eventResize }));
          })));
      }
      renderFillSegs(segs, fillType) {
          let { props, context } = this;
          let segVCoords = computeSegVCoords(segs, props.date, props.slatCoords, context.options.eventMinHeight); // don't assume all populated
          let children = segVCoords.map((vcoords, i) => {
              let seg = segs[i];
              return (y$1("div", { key: buildEventRangeKey(seg.eventRange), className: "fc-timegrid-bg-harness", style: computeSegVStyle(vcoords) }, fillType === 'bg-event' ?
                  y$1(BgEvent, Object.assign({ seg: seg }, getSegMeta(seg, props.todayRange, props.nowDate))) :
                  renderFill(fillType)));
          });
          return y$1(_, null, children);
      }
      renderNowIndicator(segs) {
          let { slatCoords, date } = this.props;
          if (!slatCoords) {
              return null;
          }
          return segs.map((seg, i) => (y$1(NowIndicatorContainer
          // key doesn't matter. will only ever be one
          , { 
              // key doesn't matter. will only ever be one
              key: i, elClasses: ['fc-timegrid-now-indicator-line'], elStyle: {
                  top: slatCoords.computeDateTop(seg.start, date),
              }, isAxis: false, date: date })));
      }
      computeSegHStyle(segHCoords) {
          let { isRtl, options } = this.context;
          let shouldOverlap = options.slotEventOverlap;
          let nearCoord = segHCoords.levelCoord; // the left side if LTR. the right side if RTL. floating-point
          let farCoord = segHCoords.levelCoord + segHCoords.thickness; // the right side if LTR. the left side if RTL. floating-point
          let left; // amount of space from left edge, a fraction of the total width
          let right; // amount of space from right edge, a fraction of the total width
          if (shouldOverlap) {
              // double the width, but don't go beyond the maximum forward coordinate (1.0)
              farCoord = Math.min(1, nearCoord + (farCoord - nearCoord) * 2);
          }
          if (isRtl) {
              left = 1 - farCoord;
              right = nearCoord;
          }
          else {
              left = nearCoord;
              right = 1 - farCoord;
          }
          let props = {
              zIndex: segHCoords.stackDepth + 1,
              left: left * 100 + '%',
              right: right * 100 + '%',
          };
          if (shouldOverlap && !segHCoords.stackForward) {
              // add padding to the edge so that forward stacked events don't cover the resizer's icon
              props[isRtl ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width
          }
          return props;
      }
  }
  function renderPlainFgSegs(sortedFgSegs, { todayRange, nowDate, eventSelection, eventDrag, eventResize }) {
      let hiddenInstances = (eventDrag ? eventDrag.affectedInstances : null) ||
          (eventResize ? eventResize.affectedInstances : null) ||
          {};
      return (y$1(_, null, sortedFgSegs.map((seg) => {
          let instanceId = seg.eventRange.instance.instanceId;
          return (y$1("div", { key: instanceId, style: { visibility: hiddenInstances[instanceId] ? 'hidden' : '' } },
              y$1(TimeColEvent, Object.assign({ seg: seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: instanceId === eventSelection, isShort: false }, getSegMeta(seg, todayRange, nowDate)))));
      })));
  }
  function computeSegVStyle(segVCoords) {
      if (!segVCoords) {
          return { top: '', bottom: '' };
      }
      return {
          top: segVCoords.start,
          bottom: -segVCoords.end,
      };
  }
  function compileSegsFromEntries(segEntries, allSegs) {
      return segEntries.map((segEntry) => allSegs[segEntry.index]);
  }

  class TimeColsContent extends BaseComponent {
      constructor() {
          super(...arguments);
          this.splitFgEventSegs = memoize(splitSegsByCol);
          this.splitBgEventSegs = memoize(splitSegsByCol);
          this.splitBusinessHourSegs = memoize(splitSegsByCol);
          this.splitNowIndicatorSegs = memoize(splitSegsByCol);
          this.splitDateSelectionSegs = memoize(splitSegsByCol);
          this.splitEventDrag = memoize(splitInteractionByCol);
          this.splitEventResize = memoize(splitInteractionByCol);
          this.rootElRef = d$1();
          this.cellElRefs = new RefMap();
      }
      render() {
          let { props, context } = this;
          let nowIndicatorTop = context.options.nowIndicator &&
              props.slatCoords &&
              props.slatCoords.safeComputeTop(props.nowDate); // might return void
          let colCnt = props.cells.length;
          let fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, colCnt);
          let bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, colCnt);
          let businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, colCnt);
          let nowIndicatorSegsByRow = this.splitNowIndicatorSegs(props.nowIndicatorSegs, colCnt);
          let dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, colCnt);
          let eventDragByRow = this.splitEventDrag(props.eventDrag, colCnt);
          let eventResizeByRow = this.splitEventResize(props.eventResize, colCnt);
          return (y$1("div", { className: "fc-timegrid-cols", ref: this.rootElRef },
              y$1("table", { role: "presentation", style: {
                      minWidth: props.tableMinWidth,
                      width: props.clientWidth,
                  } },
                  props.tableColGroupNode,
                  y$1("tbody", { role: "presentation" },
                      y$1("tr", { role: "row" },
                          props.axis && (y$1("td", { "aria-hidden": true, className: "fc-timegrid-col fc-timegrid-axis" },
                              y$1("div", { className: "fc-timegrid-col-frame" },
                                  y$1("div", { className: "fc-timegrid-now-indicator-container" }, typeof nowIndicatorTop === 'number' && (y$1(NowIndicatorContainer, { elClasses: ['fc-timegrid-now-indicator-arrow'], elStyle: { top: nowIndicatorTop }, isAxis: true, date: props.nowDate })))))),
                          props.cells.map((cell, i) => (y$1(TimeCol, { key: cell.key, elRef: this.cellElRefs.createRef(cell.key), dateProfile: props.dateProfile, date: cell.date, nowDate: props.nowDate, todayRange: props.todayRange, extraRenderProps: cell.extraRenderProps, extraDataAttrs: cell.extraDataAttrs, extraClassNames: cell.extraClassNames, extraDateSpan: cell.extraDateSpan, fgEventSegs: fgEventSegsByRow[i], bgEventSegs: bgEventSegsByRow[i], businessHourSegs: businessHourSegsByRow[i], nowIndicatorSegs: nowIndicatorSegsByRow[i], dateSelectionSegs: dateSelectionSegsByRow[i], eventDrag: eventDragByRow[i], eventResize: eventResizeByRow[i], slatCoords: props.slatCoords, eventSelection: props.eventSelection, forPrint: props.forPrint }))))))));
      }
      componentDidMount() {
          this.updateCoords();
      }
      componentDidUpdate() {
          this.updateCoords();
      }
      updateCoords() {
          let { props } = this;
          if (props.onColCoords &&
              props.clientWidth !== null // means sizing has stabilized
          ) {
              props.onColCoords(new PositionCache(this.rootElRef.current, collectCellEls(this.cellElRefs.currentMap, props.cells), true, // horizontal
              false));
          }
      }
  }
  function collectCellEls(elMap, cells) {
      return cells.map((cell) => elMap[cell.key]);
  }

  /* A component that renders one or more columns of vertical time slots
  ----------------------------------------------------------------------------------------------------------------------*/
  class TimeCols extends DateComponent {
      constructor() {
          super(...arguments);
          this.processSlotOptions = memoize(processSlotOptions);
          this.state = {
              slatCoords: null,
          };
          this.handleRootEl = (el) => {
              if (el) {
                  this.context.registerInteractiveComponent(this, {
                      el,
                      isHitComboAllowed: this.props.isHitComboAllowed,
                  });
              }
              else {
                  this.context.unregisterInteractiveComponent(this);
              }
          };
          this.handleScrollRequest = (request) => {
              let { onScrollTopRequest } = this.props;
              let { slatCoords } = this.state;
              if (onScrollTopRequest && slatCoords) {
                  if (request.time) {
                      let top = slatCoords.computeTimeTop(request.time);
                      top = Math.ceil(top); // zoom can give weird floating-point values. rather scroll a little bit further
                      if (top) {
                          top += 1; // to overcome top border that slots beyond the first have. looks better
                      }
                      onScrollTopRequest(top);
                  }
                  return true;
              }
              return false;
          };
          this.handleColCoords = (colCoords) => {
              this.colCoords = colCoords;
          };
          this.handleSlatCoords = (slatCoords) => {
              this.setState({ slatCoords });
              if (this.props.onSlatCoords) {
                  this.props.onSlatCoords(slatCoords);
              }
          };
      }
      render() {
          let { props, state } = this;
          return (y$1("div", { className: "fc-timegrid-body", ref: this.handleRootEl, style: {
                  // these props are important to give this wrapper correct dimensions for interactions
                  // TODO: if we set it here, can we avoid giving to inner tables?
                  width: props.clientWidth,
                  minWidth: props.tableMinWidth,
              } },
              y$1(TimeColsSlats, { axis: props.axis, dateProfile: props.dateProfile, slatMetas: props.slatMetas, clientWidth: props.clientWidth, minHeight: props.expandRows ? props.clientHeight : '', tableMinWidth: props.tableMinWidth, tableColGroupNode: props.axis ? props.tableColGroupNode : null /* axis depends on the colgroup's shrinking */, onCoords: this.handleSlatCoords }),
              y$1(TimeColsContent, { cells: props.cells, axis: props.axis, dateProfile: props.dateProfile, businessHourSegs: props.businessHourSegs, bgEventSegs: props.bgEventSegs, fgEventSegs: props.fgEventSegs, dateSelectionSegs: props.dateSelectionSegs, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, todayRange: props.todayRange, nowDate: props.nowDate, nowIndicatorSegs: props.nowIndicatorSegs, clientWidth: props.clientWidth, tableMinWidth: props.tableMinWidth, tableColGroupNode: props.tableColGroupNode, slatCoords: state.slatCoords, onColCoords: this.handleColCoords, forPrint: props.forPrint })));
      }
      componentDidMount() {
          this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);
      }
      componentDidUpdate(prevProps) {
          this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);
      }
      componentWillUnmount() {
          this.scrollResponder.detach();
      }
      queryHit(positionLeft, positionTop) {
          let { dateEnv, options } = this.context;
          let { colCoords } = this;
          let { dateProfile } = this.props;
          let { slatCoords } = this.state;
          let { snapDuration, snapsPerSlot } = this.processSlotOptions(this.props.slotDuration, options.snapDuration);
          let colIndex = colCoords.leftToIndex(positionLeft);
          let slatIndex = slatCoords.positions.topToIndex(positionTop);
          if (colIndex != null && slatIndex != null) {
              let cell = this.props.cells[colIndex];
              let slatTop = slatCoords.positions.tops[slatIndex];
              let slatHeight = slatCoords.positions.getHeight(slatIndex);
              let partial = (positionTop - slatTop) / slatHeight; // floating point number between 0 and 1
              let localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat
              let snapIndex = slatIndex * snapsPerSlot + localSnapIndex;
              let dayDate = this.props.cells[colIndex].date;
              let time = addDurations(dateProfile.slotMinTime, multiplyDuration(snapDuration, snapIndex));
              let start = dateEnv.add(dayDate, time);
              let end = dateEnv.add(start, snapDuration);
              return {
                  dateProfile,
                  dateSpan: Object.assign({ range: { start, end }, allDay: false }, cell.extraDateSpan),
                  dayEl: colCoords.els[colIndex],
                  rect: {
                      left: colCoords.lefts[colIndex],
                      right: colCoords.rights[colIndex],
                      top: slatTop,
                      bottom: slatTop + slatHeight,
                  },
                  layer: 0,
              };
          }
          return null;
      }
  }
  function processSlotOptions(slotDuration, snapDurationOverride) {
      let snapDuration = snapDurationOverride || slotDuration;
      let snapsPerSlot = wholeDivideDurations(slotDuration, snapDuration);
      if (snapsPerSlot === null) {
          snapDuration = slotDuration;
          snapsPerSlot = 1;
          // TODO: say warning?
      }
      return { snapDuration, snapsPerSlot };
  }

  class DayTimeColsSlicer extends Slicer {
      sliceRange(range, dayRanges) {
          let segs = [];
          for (let col = 0; col < dayRanges.length; col += 1) {
              let segRange = intersectRanges(range, dayRanges[col]);
              if (segRange) {
                  segs.push({
                      start: segRange.start,
                      end: segRange.end,
                      isStart: segRange.start.valueOf() === range.start.valueOf(),
                      isEnd: segRange.end.valueOf() === range.end.valueOf(),
                      col,
                  });
              }
          }
          return segs;
      }
  }

  class DayTimeCols extends DateComponent {
      constructor() {
          super(...arguments);
          this.buildDayRanges = memoize(buildDayRanges);
          this.slicer = new DayTimeColsSlicer();
          this.timeColsRef = d$1();
      }
      render() {
          let { props, context } = this;
          let { dateProfile, dayTableModel } = props;
          let { nowIndicator, nextDayThreshold } = context.options;
          let dayRanges = this.buildDayRanges(dayTableModel, dateProfile, context.dateEnv);
          // give it the first row of cells
          // TODO: would move this further down hierarchy, but sliceNowDate needs it
          return (y$1(NowTimer, { unit: nowIndicator ? 'minute' : 'day' }, (nowDate, todayRange) => (y$1(TimeCols, Object.assign({ ref: this.timeColsRef }, this.slicer.sliceProps(props, dateProfile, null, context, dayRanges), { forPrint: props.forPrint, axis: props.axis, dateProfile: dateProfile, slatMetas: props.slatMetas, slotDuration: props.slotDuration, cells: dayTableModel.cells[0], tableColGroupNode: props.tableColGroupNode, tableMinWidth: props.tableMinWidth, clientWidth: props.clientWidth, clientHeight: props.clientHeight, expandRows: props.expandRows, nowDate: nowDate, nowIndicatorSegs: nowIndicator && this.slicer.sliceNowDate(nowDate, dateProfile, nextDayThreshold, context, dayRanges), todayRange: todayRange, onScrollTopRequest: props.onScrollTopRequest, onSlatCoords: props.onSlatCoords })))));
      }
  }
  function buildDayRanges(dayTableModel, dateProfile, dateEnv) {
      let ranges = [];
      for (let date of dayTableModel.headerDates) {
          ranges.push({
              start: dateEnv.add(date, dateProfile.slotMinTime),
              end: dateEnv.add(date, dateProfile.slotMaxTime),
          });
      }
      return ranges;
  }

  // potential nice values for the slot-duration and interval-duration
  // from largest to smallest
  const STOCK_SUB_DURATIONS = [
      { hours: 1 },
      { minutes: 30 },
      { minutes: 15 },
      { seconds: 30 },
      { seconds: 15 },
  ];
  function buildSlatMetas(slotMinTime, slotMaxTime, explicitLabelInterval, slotDuration, dateEnv) {
      let dayStart = new Date(0);
      let slatTime = slotMinTime;
      let slatIterator = createDuration(0);
      let labelInterval = explicitLabelInterval || computeLabelInterval(slotDuration);
      let metas = [];
      while (asRoughMs(slatTime) < asRoughMs(slotMaxTime)) {
          let date = dateEnv.add(dayStart, slatTime);
          let isLabeled = wholeDivideDurations(slatIterator, labelInterval) !== null;
          metas.push({
              date,
              time: slatTime,
              key: date.toISOString(),
              isoTimeStr: formatIsoTimeString(date),
              isLabeled,
          });
          slatTime = addDurations(slatTime, slotDuration);
          slatIterator = addDurations(slatIterator, slotDuration);
      }
      return metas;
  }
  // Computes an automatic value for slotLabelInterval
  function computeLabelInterval(slotDuration) {
      let i;
      let labelInterval;
      let slotsPerLabel;
      // find the smallest stock label interval that results in more than one slots-per-label
      for (i = STOCK_SUB_DURATIONS.length - 1; i >= 0; i -= 1) {
          labelInterval = createDuration(STOCK_SUB_DURATIONS[i]);
          slotsPerLabel = wholeDivideDurations(labelInterval, slotDuration);
          if (slotsPerLabel !== null && slotsPerLabel > 1) {
              return labelInterval;
          }
      }
      return slotDuration; // fall back
  }

  class DayTimeColsView extends TimeColsView {
      constructor() {
          super(...arguments);
          this.buildTimeColsModel = memoize(buildTimeColsModel);
          this.buildSlatMetas = memoize(buildSlatMetas);
      }
      render() {
          let { options, dateEnv, dateProfileGenerator } = this.context;
          let { props } = this;
          let { dateProfile } = props;
          let dayTableModel = this.buildTimeColsModel(dateProfile, dateProfileGenerator);
          let splitProps = this.allDaySplitter.splitProps(props);
          let slatMetas = this.buildSlatMetas(dateProfile.slotMinTime, dateProfile.slotMaxTime, options.slotLabelInterval, options.slotDuration, dateEnv);
          let { dayMinWidth } = options;
          let hasAttachedAxis = !dayMinWidth;
          let hasDetachedAxis = dayMinWidth;
          let headerContent = options.dayHeaders && (y$1(DayHeader, { dates: dayTableModel.headerDates, dateProfile: dateProfile, datesRepDistinctDays: true, renderIntro: hasAttachedAxis ? this.renderHeadAxis : null }));
          let allDayContent = (options.allDaySlot !== false) && ((contentArg) => (y$1(DayTable, Object.assign({}, splitProps.allDay, { dateProfile: dateProfile, dayTableModel: dayTableModel, nextDayThreshold: options.nextDayThreshold, tableMinWidth: contentArg.tableMinWidth, colGroupNode: contentArg.tableColGroupNode, renderRowIntro: hasAttachedAxis ? this.renderTableRowAxis : null, showWeekNumbers: false, expandRows: false, headerAlignElRef: this.headerElRef, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, forPrint: props.forPrint }, this.getAllDayMaxEventProps()))));
          let timeGridContent = (contentArg) => (y$1(DayTimeCols, Object.assign({}, splitProps.timed, { dayTableModel: dayTableModel, dateProfile: dateProfile, axis: hasAttachedAxis, slotDuration: options.slotDuration, slatMetas: slatMetas, forPrint: props.forPrint, tableColGroupNode: contentArg.tableColGroupNode, tableMinWidth: contentArg.tableMinWidth, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, onSlatCoords: this.handleSlatCoords, expandRows: contentArg.expandRows, onScrollTopRequest: this.handleScrollTopRequest })));
          return hasDetachedAxis
              ? this.renderHScrollLayout(headerContent, allDayContent, timeGridContent, dayTableModel.colCnt, dayMinWidth, slatMetas, this.state.slatCoords)
              : this.renderSimpleLayout(headerContent, allDayContent, timeGridContent);
      }
  }
  function buildTimeColsModel(dateProfile, dateProfileGenerator) {
      let daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);
      return new DayTableModel(daySeries, false);
  }

  const OPTION_REFINERS$3 = {
      allDaySlot: Boolean,
  };

  var index$9 = createPlugin({
      name: '@fullcalendar/timegrid',
      initialView: 'timeGridWeek',
      optionRefiners: OPTION_REFINERS$3,
      views: {
          timeGrid: {
              component: DayTimeColsView,
              usesMinMaxTime: true,
              allDaySlot: true,
              slotDuration: '00:30:00',
              slotEventOverlap: true, // a bad name. confused with overlap/constraint system
          },
          timeGridDay: {
              type: 'timeGrid',
              duration: { days: 1 },
          },
          timeGridWeek: {
              type: 'timeGrid',
              duration: { weeks: 1 },
          },
      },
  });

  class ListViewHeaderRow extends BaseComponent {
      constructor() {
          super(...arguments);
          this.state = {
              textId: getUniqueDomId(),
          };
      }
      render() {
          let { theme, dateEnv, options, viewApi } = this.context;
          let { cellId, dayDate, todayRange } = this.props;
          let { textId } = this.state;
          let dayMeta = getDateMeta(dayDate, todayRange);
          // will ever be falsy?
          let text = options.listDayFormat ? dateEnv.format(dayDate, options.listDayFormat) : '';
          // will ever be falsy? also, BAD NAME "alt"
          let sideText = options.listDaySideFormat ? dateEnv.format(dayDate, options.listDaySideFormat) : '';
          let renderProps = Object.assign({ date: dateEnv.toDate(dayDate), view: viewApi, textId,
              text,
              sideText, navLinkAttrs: buildNavLinkAttrs(this.context, dayDate), sideNavLinkAttrs: buildNavLinkAttrs(this.context, dayDate, 'day', false) }, dayMeta);
          // TODO: make a reusable HOC for dayHeader (used in daygrid/timegrid too)
          return (y$1(ContentContainer, { elTag: "tr", elClasses: [
                  'fc-list-day',
                  ...getDayClassNames(dayMeta, theme),
              ], elAttrs: {
                  'data-date': formatDayString(dayDate),
              }, renderProps: renderProps, generatorName: "dayHeaderContent", customGenerator: options.dayHeaderContent, defaultGenerator: renderInnerContent, classNameGenerator: options.dayHeaderClassNames, didMount: options.dayHeaderDidMount, willUnmount: options.dayHeaderWillUnmount }, (InnerContent) => ( // TODO: force-hide top border based on :first-child
          y$1("th", { scope: "colgroup", colSpan: 3, id: cellId, "aria-labelledby": textId },
              y$1(InnerContent, { elTag: "div", elClasses: [
                      'fc-list-day-cushion',
                      theme.getClass('tableCellShaded'),
                  ] })))));
      }
  }
  function renderInnerContent(props) {
      return (y$1(_, null,
          props.text && (y$1("a", Object.assign({ id: props.textId, className: "fc-list-day-text" }, props.navLinkAttrs), props.text)),
          props.sideText && ( /* not keyboard tabbable */y$1("a", Object.assign({ "aria-hidden": true, className: "fc-list-day-side-text" }, props.sideNavLinkAttrs), props.sideText))));
  }

  const DEFAULT_TIME_FORMAT = createFormatter({
      hour: 'numeric',
      minute: '2-digit',
      meridiem: 'short',
  });
  class ListViewEventRow extends BaseComponent {
      render() {
          let { props, context } = this;
          let { options } = context;
          let { seg, timeHeaderId, eventHeaderId, dateHeaderId } = props;
          let timeFormat = options.eventTimeFormat || DEFAULT_TIME_FORMAT;
          return (y$1(EventContainer, Object.assign({}, props, { elTag: "tr", elClasses: [
                  'fc-list-event',
                  seg.eventRange.def.url && 'fc-event-forced-url',
              ], defaultGenerator: () => renderEventInnerContent(seg, context) /* weird */, seg: seg, timeText: "", disableDragging: true, disableResizing: true }), (InnerContent, eventContentArg) => (y$1(_, null,
              buildTimeContent(seg, timeFormat, context, timeHeaderId, dateHeaderId),
              y$1("td", { "aria-hidden": true, className: "fc-list-event-graphic" },
                  y$1("span", { className: "fc-list-event-dot", style: {
                          borderColor: eventContentArg.borderColor || eventContentArg.backgroundColor,
                      } })),
              y$1(InnerContent, { elTag: "td", elClasses: ['fc-list-event-title'], elAttrs: { headers: `${eventHeaderId} ${dateHeaderId}` } })))));
      }
  }
  function renderEventInnerContent(seg, context) {
      let interactiveAttrs = getSegAnchorAttrs(seg, context);
      return (y$1("a", Object.assign({}, interactiveAttrs), seg.eventRange.def.title));
  }
  function buildTimeContent(seg, timeFormat, context, timeHeaderId, dateHeaderId) {
      let { options } = context;
      if (options.displayEventTime !== false) {
          let eventDef = seg.eventRange.def;
          let eventInstance = seg.eventRange.instance;
          let doAllDay = false;
          let timeText;
          if (eventDef.allDay) {
              doAllDay = true;
          }
          else if (isMultiDayRange(seg.eventRange.range)) { // TODO: use (!isStart || !isEnd) instead?
              if (seg.isStart) {
                  timeText = buildSegTimeText(seg, timeFormat, context, null, null, eventInstance.range.start, seg.end);
              }
              else if (seg.isEnd) {
                  timeText = buildSegTimeText(seg, timeFormat, context, null, null, seg.start, eventInstance.range.end);
              }
              else {
                  doAllDay = true;
              }
          }
          else {
              timeText = buildSegTimeText(seg, timeFormat, context);
          }
          if (doAllDay) {
              let renderProps = {
                  text: context.options.allDayText,
                  view: context.viewApi,
              };
              return (y$1(ContentContainer, { elTag: "td", elClasses: ['fc-list-event-time'], elAttrs: {
                      headers: `${timeHeaderId} ${dateHeaderId}`,
                  }, renderProps: renderProps, generatorName: "allDayContent", customGenerator: options.allDayContent, defaultGenerator: renderAllDayInner, classNameGenerator: options.allDayClassNames, didMount: options.allDayDidMount, willUnmount: options.allDayWillUnmount }));
          }
          return (y$1("td", { className: "fc-list-event-time" }, timeText));
      }
      return null;
  }
  function renderAllDayInner(renderProps) {
      return renderProps.text;
  }

  /*
  Responsible for the scroller, and forwarding event-related actions into the "grid".
  */
  class ListView extends DateComponent {
      constructor() {
          super(...arguments);
          this.computeDateVars = memoize(computeDateVars);
          this.eventStoreToSegs = memoize(this._eventStoreToSegs);
          this.state = {
              timeHeaderId: getUniqueDomId(),
              eventHeaderId: getUniqueDomId(),
              dateHeaderIdRoot: getUniqueDomId(),
          };
          this.setRootEl = (rootEl) => {
              if (rootEl) {
                  this.context.registerInteractiveComponent(this, {
                      el: rootEl,
                  });
              }
              else {
                  this.context.unregisterInteractiveComponent(this);
              }
          };
      }
      render() {
          let { props, context } = this;
          let { dayDates, dayRanges } = this.computeDateVars(props.dateProfile);
          let eventSegs = this.eventStoreToSegs(props.eventStore, props.eventUiBases, dayRanges);
          return (y$1(ViewContainer, { elRef: this.setRootEl, elClasses: [
                  'fc-list',
                  context.theme.getClass('table'),
                  context.options.stickyHeaderDates !== false ?
                      'fc-list-sticky' :
                      '',
              ], viewSpec: context.viewSpec },
              y$1(Scroller, { liquid: !props.isHeightAuto, overflowX: props.isHeightAuto ? 'visible' : 'hidden', overflowY: props.isHeightAuto ? 'visible' : 'auto' }, eventSegs.length > 0 ?
                  this.renderSegList(eventSegs, dayDates) :
                  this.renderEmptyMessage())));
      }
      renderEmptyMessage() {
          let { options, viewApi } = this.context;
          let renderProps = {
              text: options.noEventsText,
              view: viewApi,
          };
          return (y$1(ContentContainer, { elTag: "div", elClasses: ['fc-list-empty'], renderProps: renderProps, generatorName: "noEventsContent", customGenerator: options.noEventsContent, defaultGenerator: renderNoEventsInner, classNameGenerator: options.noEventsClassNames, didMount: options.noEventsDidMount, willUnmount: options.noEventsWillUnmount }, (InnerContent) => (y$1(InnerContent, { elTag: "div", elClasses: ['fc-list-empty-cushion'] }))));
      }
      renderSegList(allSegs, dayDates) {
          let { theme, options } = this.context;
          let { timeHeaderId, eventHeaderId, dateHeaderIdRoot } = this.state;
          let segsByDay = groupSegsByDay(allSegs); // sparse array
          return (y$1(NowTimer, { unit: "day" }, (nowDate, todayRange) => {
              let innerNodes = [];
              for (let dayIndex = 0; dayIndex < segsByDay.length; dayIndex += 1) {
                  let daySegs = segsByDay[dayIndex];
                  if (daySegs) { // sparse array, so might be undefined
                      let dayStr = formatDayString(dayDates[dayIndex]);
                      let dateHeaderId = dateHeaderIdRoot + '-' + dayStr;
                      // append a day header
                      innerNodes.push(y$1(ListViewHeaderRow, { key: dayStr, cellId: dateHeaderId, dayDate: dayDates[dayIndex], todayRange: todayRange }));
                      daySegs = sortEventSegs(daySegs, options.eventOrder);
                      for (let seg of daySegs) {
                          innerNodes.push(y$1(ListViewEventRow, Object.assign({ key: dayStr + ':' + seg.eventRange.instance.instanceId /* are multiple segs for an instanceId */, seg: seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: false, timeHeaderId: timeHeaderId, eventHeaderId: eventHeaderId, dateHeaderId: dateHeaderId }, getSegMeta(seg, todayRange, nowDate))));
                      }
                  }
              }
              return (y$1("table", { className: 'fc-list-table ' + theme.getClass('table') },
                  y$1("thead", null,
                      y$1("tr", null,
                          y$1("th", { scope: "col", id: timeHeaderId }, options.timeHint),
                          y$1("th", { scope: "col", "aria-hidden": true }),
                          y$1("th", { scope: "col", id: eventHeaderId }, options.eventHint))),
                  y$1("tbody", null, innerNodes)));
          }));
      }
      _eventStoreToSegs(eventStore, eventUiBases, dayRanges) {
          return this.eventRangesToSegs(sliceEventStore(eventStore, eventUiBases, this.props.dateProfile.activeRange, this.context.options.nextDayThreshold).fg, dayRanges);
      }
      eventRangesToSegs(eventRanges, dayRanges) {
          let segs = [];
          for (let eventRange of eventRanges) {
              segs.push(...this.eventRangeToSegs(eventRange, dayRanges));
          }
          return segs;
      }
      eventRangeToSegs(eventRange, dayRanges) {
          let { dateEnv } = this.context;
          let { nextDayThreshold } = this.context.options;
          let range = eventRange.range;
          let allDay = eventRange.def.allDay;
          let dayIndex;
          let segRange;
          let seg;
          let segs = [];
          for (dayIndex = 0; dayIndex < dayRanges.length; dayIndex += 1) {
              segRange = intersectRanges(range, dayRanges[dayIndex]);
              if (segRange) {
                  seg = {
                      component: this,
                      eventRange,
                      start: segRange.start,
                      end: segRange.end,
                      isStart: eventRange.isStart && segRange.start.valueOf() === range.start.valueOf(),
                      isEnd: eventRange.isEnd && segRange.end.valueOf() === range.end.valueOf(),
                      dayIndex,
                  };
                  segs.push(seg);
                  // detect when range won't go fully into the next day,
                  // and mutate the latest seg to the be the end.
                  if (!seg.isEnd && !allDay &&
                      dayIndex + 1 < dayRanges.length &&
                      range.end <
                          dateEnv.add(dayRanges[dayIndex + 1].start, nextDayThreshold)) {
                      seg.end = range.end;
                      seg.isEnd = true;
                      break;
                  }
              }
          }
          return segs;
      }
  }
  function renderNoEventsInner(renderProps) {
      return renderProps.text;
  }
  function computeDateVars(dateProfile) {
      let dayStart = startOfDay(dateProfile.renderRange.start);
      let viewEnd = dateProfile.renderRange.end;
      let dayDates = [];
      let dayRanges = [];
      while (dayStart < viewEnd) {
          dayDates.push(dayStart);
          dayRanges.push({
              start: dayStart,
              end: addDays(dayStart, 1),
          });
          dayStart = addDays(dayStart, 1);
      }
      return { dayDates, dayRanges };
  }
  // Returns a sparse array of arrays, segs grouped by their dayIndex
  function groupSegsByDay(segs) {
      let segsByDay = []; // sparse array
      let i;
      let seg;
      for (i = 0; i < segs.length; i += 1) {
          seg = segs[i];
          (segsByDay[seg.dayIndex] || (segsByDay[seg.dayIndex] = []))
              .push(seg);
      }
      return segsByDay;
  }

  var css_248z$2 = ":root{--fc-list-event-dot-width:10px;--fc-list-event-hover-bg-color:#f5f5f5}.fc-theme-standard .fc-list{border:1px solid var(--fc-border-color)}.fc .fc-list-empty{align-items:center;background-color:var(--fc-neutral-bg-color);display:flex;height:100%;justify-content:center}.fc .fc-list-empty-cushion{margin:5em 0}.fc .fc-list-table{border-style:hidden;width:100%}.fc .fc-list-table tr>*{border-left:0;border-right:0}.fc .fc-list-sticky .fc-list-day>*{background:var(--fc-page-bg-color);position:sticky;top:0}.fc .fc-list-table thead{left:-10000px;position:absolute}.fc .fc-list-table tbody>tr:first-child th{border-top:0}.fc .fc-list-table th{padding:0}.fc .fc-list-day-cushion,.fc .fc-list-table td{padding:8px 14px}.fc .fc-list-day-cushion:after{clear:both;content:\"\";display:table}.fc-theme-standard .fc-list-day-cushion{background-color:var(--fc-neutral-bg-color)}.fc-direction-ltr .fc-list-day-text,.fc-direction-rtl .fc-list-day-side-text{float:left}.fc-direction-ltr .fc-list-day-side-text,.fc-direction-rtl .fc-list-day-text{float:right}.fc-direction-ltr .fc-list-table .fc-list-event-graphic{padding-right:0}.fc-direction-rtl .fc-list-table .fc-list-event-graphic{padding-left:0}.fc .fc-list-event.fc-event-forced-url{cursor:pointer}.fc .fc-list-event:hover td{background-color:var(--fc-list-event-hover-bg-color)}.fc .fc-list-event-graphic,.fc .fc-list-event-time{white-space:nowrap;width:1px}.fc .fc-list-event-dot{border:calc(var(--fc-list-event-dot-width)/2) solid var(--fc-event-border-color);border-radius:calc(var(--fc-list-event-dot-width)/2);box-sizing:content-box;display:inline-block;height:0;width:0}.fc .fc-list-event-title a{color:inherit;text-decoration:none}.fc .fc-list-event.fc-event-forced-url:hover a{text-decoration:underline}";
  injectStyles(css_248z$2);

  const OPTION_REFINERS$2 = {
      listDayFormat: createFalsableFormatter,
      listDaySideFormat: createFalsableFormatter,
      noEventsClassNames: identity,
      noEventsContent: identity,
      noEventsDidMount: identity,
      noEventsWillUnmount: identity,
      // noEventsText is defined in base options
  };
  function createFalsableFormatter(input) {
      return input === false ? null : createFormatter(input);
  }

  var index$8 = createPlugin({
      name: '@fullcalendar/list',
      optionRefiners: OPTION_REFINERS$2,
      views: {
          list: {
              component: ListView,
              buttonTextKey: 'list',
              listDayFormat: { month: 'long', day: 'numeric', year: 'numeric' }, // like "January 1, 2016"
          },
          listDay: {
              type: 'list',
              duration: { days: 1 },
              listDayFormat: { weekday: 'long' }, // day-of-week is all we need. full date is probably in headerToolbar
          },
          listWeek: {
              type: 'list',
              duration: { weeks: 1 },
              listDayFormat: { weekday: 'long' },
              listDaySideFormat: { month: 'long', day: 'numeric', year: 'numeric' },
          },
          listMonth: {
              type: 'list',
              duration: { month: 1 },
              listDaySideFormat: { weekday: 'long' }, // day-of-week is nice-to-have
          },
          listYear: {
              type: 'list',
              duration: { year: 1 },
              listDaySideFormat: { weekday: 'long' }, // day-of-week is nice-to-have
          },
      },
  });

  class SingleMonth extends DateComponent {
      constructor() {
          super(...arguments);
          this.buildDayTableModel = memoize(buildDayTableModel);
          this.slicer = new DayTableSlicer();
          this.state = {
              labelId: getUniqueDomId(),
          };
      }
      render() {
          const { props, state, context } = this;
          const { dateProfile, forPrint } = props;
          const { options } = context;
          const dayTableModel = this.buildDayTableModel(dateProfile, context.dateProfileGenerator);
          const slicedProps = this.slicer.sliceProps(props, dateProfile, options.nextDayThreshold, context, dayTableModel);
          // ensure single-month has aspect ratio
          const tableHeight = props.tableWidth != null ? props.tableWidth / options.aspectRatio : null;
          const rowCnt = dayTableModel.cells.length;
          const rowHeight = tableHeight != null ? tableHeight / rowCnt : null;
          return (y$1("div", { ref: props.elRef, "data-date": props.isoDateStr, className: "fc-multimonth-month", style: { width: props.width }, role: "grid", "aria-labelledby": state.labelId },
              y$1("div", { className: "fc-multimonth-header", style: { marginBottom: rowHeight }, role: "presentation" },
                  y$1("div", { className: "fc-multimonth-title", id: state.labelId }, context.dateEnv.format(props.dateProfile.currentRange.start, props.titleFormat)),
                  y$1("table", { className: [
                          'fc-multimonth-header-table',
                          context.theme.getClass('table'),
                      ].join(' '), role: "presentation" },
                      y$1("thead", { role: "rowgroup" },
                          y$1(DayHeader, { dateProfile: props.dateProfile, dates: dayTableModel.headerDates, datesRepDistinctDays: false })))),
              y$1("div", { className: [
                      'fc-multimonth-daygrid',
                      'fc-daygrid',
                      'fc-daygrid-body',
                      !forPrint && 'fc-daygrid-body-balanced',
                      forPrint && 'fc-daygrid-body-unbalanced',
                      forPrint && 'fc-daygrid-body-natural',
                  ].join(' '), style: { marginTop: -rowHeight } },
                  y$1("table", { className: [
                          'fc-multimonth-daygrid-table',
                          context.theme.getClass('table'),
                      ].join(' '), style: { height: forPrint ? '' : tableHeight }, role: "presentation" },
                      y$1("tbody", { role: "rowgroup" },
                          y$1(TableRows, Object.assign({}, slicedProps, { dateProfile: dateProfile, cells: dayTableModel.cells, eventSelection: props.eventSelection, dayMaxEvents: !forPrint, dayMaxEventRows: !forPrint, showWeekNumbers: options.weekNumbers, clientWidth: props.clientWidth, clientHeight: props.clientHeight, forPrint: forPrint })))))));
      }
  }

  class MultiMonthView extends DateComponent {
      constructor() {
          super(...arguments);
          this.splitDateProfileByMonth = memoize(splitDateProfileByMonth);
          this.buildMonthFormat = memoize(buildMonthFormat);
          this.scrollElRef = d$1();
          this.firstMonthElRef = d$1();
          this.needsScrollReset = false;
          this.handleSizing = (isForced) => {
              if (isForced) {
                  this.updateSize();
              }
          };
      }
      render() {
          const { context, props, state } = this;
          const { options } = context;
          const { clientWidth, clientHeight } = state;
          const monthHPadding = state.monthHPadding || 0;
          const colCount = Math.min(clientWidth != null ?
              Math.floor(clientWidth / (options.multiMonthMinWidth + monthHPadding)) :
              1, options.multiMonthMaxColumns) || 1;
          const monthWidthPct = (100 / colCount) + '%';
          const monthTableWidth = clientWidth == null ? null :
              (clientWidth / colCount) - monthHPadding;
          const isLegitSingleCol = clientWidth != null && colCount === 1;
          const monthDateProfiles = this.splitDateProfileByMonth(context.dateProfileGenerator, props.dateProfile, context.dateEnv, isLegitSingleCol ? false : options.fixedWeekCount, options.showNonCurrentDates);
          const monthTitleFormat = this.buildMonthFormat(options.multiMonthTitleFormat, monthDateProfiles);
          const rootClassNames = [
              'fc-multimonth',
              isLegitSingleCol ?
                  'fc-multimonth-singlecol' :
                  'fc-multimonth-multicol',
              (monthTableWidth != null && monthTableWidth < 400) ?
                  'fc-multimonth-compact' :
                  '',
          ];
          return (y$1(ViewContainer, { elRef: this.scrollElRef, elClasses: rootClassNames, viewSpec: context.viewSpec }, monthDateProfiles.map((monthDateProfile, i) => {
              const monthStr = formatIsoMonthStr(monthDateProfile.currentRange.start);
              return (y$1(SingleMonth, Object.assign({}, props, { key: monthStr, isoDateStr: monthStr, elRef: i === 0 ? this.firstMonthElRef : undefined, titleFormat: monthTitleFormat, dateProfile: monthDateProfile, width: monthWidthPct, tableWidth: monthTableWidth, clientWidth: clientWidth, clientHeight: clientHeight })));
          })));
      }
      componentDidMount() {
          this.updateSize();
          this.context.addResizeHandler(this.handleSizing);
          this.requestScrollReset();
      }
      componentDidUpdate(prevProps) {
          if (!isPropsEqual(prevProps, this.props)) { // an external change?
              this.handleSizing(false);
          }
          if (prevProps.dateProfile !== this.props.dateProfile) {
              this.requestScrollReset();
          }
          else {
              this.flushScrollReset();
          }
      }
      componentWillUnmount() {
          this.context.removeResizeHandler(this.handleSizing);
      }
      updateSize() {
          const scrollEl = this.scrollElRef.current;
          const firstMonthEl = this.firstMonthElRef.current;
          if (scrollEl) {
              this.setState({
                  clientWidth: scrollEl.clientWidth,
                  clientHeight: scrollEl.clientHeight,
              });
          }
          if (firstMonthEl && scrollEl) {
              if (this.state.monthHPadding == null) { // always remember initial non-zero value
                  this.setState({
                      monthHPadding: scrollEl.clientWidth - // go within padding
                          firstMonthEl.firstChild.offsetWidth,
                  });
              }
          }
      }
      requestScrollReset() {
          this.needsScrollReset = true;
          this.flushScrollReset();
      }
      flushScrollReset() {
          if (this.needsScrollReset &&
              this.state.monthHPadding != null // indicates sizing already happened
          ) {
              const { currentDate } = this.props.dateProfile;
              const scrollEl = this.scrollElRef.current;
              const monthEl = scrollEl.querySelector(`[data-date="${formatIsoMonthStr(currentDate)}"]`);
              scrollEl.scrollTop = monthEl.getBoundingClientRect().top -
                  this.firstMonthElRef.current.getBoundingClientRect().top;
              this.needsScrollReset = false;
          }
      }
      // workaround for when queued setState render (w/ clientWidth) gets cancelled because
      // subsequent update and shouldComponentUpdate says not to render :(
      shouldComponentUpdate() {
          return true;
      }
  }
  // date profile
  // -------------------------------------------------------------------------------------------------
  const oneMonthDuration = createDuration(1, 'month');
  function splitDateProfileByMonth(dateProfileGenerator, dateProfile, dateEnv, fixedWeekCount, showNonCurrentDates) {
      const { start, end } = dateProfile.currentRange;
      let monthStart = start;
      const monthDateProfiles = [];
      while (monthStart.valueOf() < end.valueOf()) {
          const monthEnd = dateEnv.add(monthStart, oneMonthDuration);
          const currentRange = {
              // yuck
              start: dateProfileGenerator.skipHiddenDays(monthStart),
              end: dateProfileGenerator.skipHiddenDays(monthEnd, -1, true),
          };
          let renderRange = buildDayTableRenderRange({
              currentRange,
              snapToWeek: true,
              fixedWeekCount,
              dateEnv,
          });
          renderRange = {
              // yuck
              start: dateProfileGenerator.skipHiddenDays(renderRange.start),
              end: dateProfileGenerator.skipHiddenDays(renderRange.end, -1, true),
          };
          const activeRange = dateProfile.activeRange ?
              intersectRanges(dateProfile.activeRange, showNonCurrentDates ? renderRange : currentRange) :
              null;
          monthDateProfiles.push({
              currentDate: dateProfile.currentDate,
              isValid: dateProfile.isValid,
              validRange: dateProfile.validRange,
              renderRange,
              activeRange,
              currentRange,
              currentRangeUnit: 'month',
              isRangeAllDay: true,
              dateIncrement: dateProfile.dateIncrement,
              slotMinTime: dateProfile.slotMaxTime,
              slotMaxTime: dateProfile.slotMinTime,
          });
          monthStart = monthEnd;
      }
      return monthDateProfiles;
  }
  // date formatting
  // -------------------------------------------------------------------------------------------------
  const YEAR_MONTH_FORMATTER = createFormatter({ year: 'numeric', month: 'long' });
  const YEAR_FORMATTER = createFormatter({ month: 'long' });
  function buildMonthFormat(formatOverride, monthDateProfiles) {
      return formatOverride ||
          ((monthDateProfiles[0].currentRange.start.getUTCFullYear() !==
              monthDateProfiles[monthDateProfiles.length - 1].currentRange.start.getUTCFullYear())
              ? YEAR_MONTH_FORMATTER
              : YEAR_FORMATTER);
  }

  const OPTION_REFINERS$1 = {
      multiMonthTitleFormat: createFormatter,
      multiMonthMaxColumns: Number,
      multiMonthMinWidth: Number,
  };

  var css_248z$1 = ".fc .fc-multimonth{border:1px solid var(--fc-border-color);display:flex;flex-wrap:wrap;overflow-x:hidden;overflow-y:auto}.fc .fc-multimonth-title{font-size:1.2em;font-weight:700;padding:1em 0;text-align:center}.fc .fc-multimonth-daygrid{background:var(--fc-page-bg-color)}.fc .fc-multimonth-daygrid-table,.fc .fc-multimonth-header-table{table-layout:fixed;width:100%}.fc .fc-multimonth-daygrid-table{border-top-style:hidden!important}.fc .fc-multimonth-singlecol .fc-multimonth{position:relative}.fc .fc-multimonth-singlecol .fc-multimonth-header{background:var(--fc-page-bg-color);position:relative;top:0;z-index:2}.fc .fc-multimonth-singlecol .fc-multimonth-daygrid{position:relative;z-index:1}.fc .fc-multimonth-singlecol .fc-multimonth-daygrid-table,.fc .fc-multimonth-singlecol .fc-multimonth-header-table{border-left-style:hidden;border-right-style:hidden}.fc .fc-multimonth-singlecol .fc-multimonth-month:last-child .fc-multimonth-daygrid-table{border-bottom-style:hidden}.fc .fc-multimonth-multicol{line-height:1}.fc .fc-multimonth-multicol .fc-multimonth-month{padding:0 1.2em 1.2em}.fc .fc-multimonth-multicol .fc-daygrid-more-link{border:1px solid var(--fc-event-border-color);display:block;float:none;padding:1px}.fc .fc-multimonth-compact{line-height:1}.fc .fc-multimonth-compact .fc-multimonth-daygrid-table,.fc .fc-multimonth-compact .fc-multimonth-header-table{font-size:.9em}.fc-media-screen .fc-multimonth-singlecol .fc-multimonth-header{position:sticky}.fc-media-print .fc-multimonth{overflow:visible}";
  injectStyles(css_248z$1);

  var index$7 = createPlugin({
      name: '@fullcalendar/multimonth',
      initialView: 'multiMonthYear',
      optionRefiners: OPTION_REFINERS$1,
      views: {
          multiMonth: {
              component: MultiMonthView,
              dateProfileGeneratorClass: TableDateProfileGenerator,
              multiMonthMinWidth: 350,
              multiMonthMaxColumns: 3,
          },
          multiMonthYear: {
              type: 'multiMonth',
              duration: { years: 1 },
              fixedWeekCount: true,
              showNonCurrentDates: false,
          },
      },
  });

  const DEFAULT_PLUGINS = [
      index$b,
      index$a,
      index$9,
      index$8,
      index$7,
  ];
  pushOptions({
      plugins: DEFAULT_PLUGINS,
  });

  describe('Event::setAllDay', () => {
      describe('when setting from all-day to all-day', () => {
          it('causes no change', () => {
              initCalendar({
                  events: [
                      { id: '1', start: '2018-09-03', end: '2018-09-05', allDay: true },
                  ],
              });
              let event = currentCalendar.getEventById('1');
              event.setAllDay(true);
              expect(event.start).toEqualDate('2018-09-03');
              expect(event.end).toEqualDate('2018-09-05');
              expect(event.allDay).toBe(true);
          });
      });
      describe('when setting from timed to timed', () => {
          it('causes no change', () => {
              initCalendar({
                  events: [
                      { id: '1', start: '2018-09-03T09:00:00', end: '2018-09-05T09:00:00', allDay: false },
                  ],
              });
              let event = currentCalendar.getEventById('1');
              event.setAllDay(false);
              expect(event.start).toEqualDate('2018-09-03T09:00:00Z');
              expect(event.end).toEqualDate('2018-09-05T09:00:00Z');
              expect(event.allDay).toBe(false);
          });
      });
      describe('when setting from all-day to timed', () => {
          describe('when not maintaining duration', () => {
              it('removes the end', () => {
                  initCalendar({
                      events: [
                          { id: '1', start: '2018-09-03', end: '2018-09-05', allDay: true },
                      ],
                  });
                  let event = currentCalendar.getEventById('1');
                  event.setAllDay(false);
                  expect(event.start).toEqualDate('2018-09-03');
                  expect(event.end).toBe(null);
                  expect(event.allDay).toBe(false);
              });
          });
          describe('when maintaining duration', () => {
              it('keeps exact duration', () => {
                  initCalendar({
                      events: [
                          { id: '1', start: '2018-09-03', end: '2018-09-05', allDay: true },
                      ],
                  });
                  let event = currentCalendar.getEventById('1');
                  event.setAllDay(false, { maintainDuration: true });
                  expect(event.start).toEqualDate('2018-09-03');
                  expect(event.end).toEqualDate('2018-09-05');
                  expect(event.allDay).toBe(false);
              });
          });
      });
      describe('when setting from timed to all-day', () => {
          describe('when not maintaining duration', () => {
              it('removes the end', () => {
                  initCalendar({
                      events: [
                          { id: '1', start: '2018-09-03T09:00:00', end: '2018-09-05T09:00:00', allDay: false },
                      ],
                  });
                  let event = currentCalendar.getEventById('1');
                  event.setAllDay(true);
                  expect(event.start).toEqualDate('2018-09-03');
                  expect(event.end).toBe(null);
                  expect(event.allDay).toBe(true);
              });
          });
          describe('when maintaining duration', () => {
              it('rounds the end down to the prev whole day', () => {
                  initCalendar({
                      events: [
                          { id: '1', start: '2018-09-03T09:00:00', end: '2018-09-05T10:00:00', allDay: false },
                      ],
                  });
                  let event = currentCalendar.getEventById('1');
                  event.setAllDay(true, { maintainDuration: true });
                  expect(event.start).toEqualDate('2018-09-03');
                  expect(event.end).toEqualDate('2018-09-05');
                  expect(event.allDay).toBe(true);
              });
          });
          describe('when maintaining duration (from calendar setting)', () => {
              it('rounds the end to the next whole day', () => {
                  initCalendar({
                      allDayMaintainDuration: true,
                      events: [
                          { id: '1', start: '2018-09-03T09:00:00', end: '2018-09-05T10:00:00', allDay: false },
                      ],
                  });
                  let event = currentCalendar.getEventById('1');
                  event.setAllDay(true);
                  expect(event.start).toEqualDate('2018-09-03');
                  expect(event.end).toEqualDate('2018-09-05');
                  expect(event.allDay).toBe(true);
              });
          });
      });
  });

  describe('events as a function', () => {
      pushOptions({
          timeZone: 'UTC',
      });
      it('requests the correct dates when days at the start/end of the month are hidden', (done) => {
          initCalendar({
              initialView: 'dayGridMonth',
              initialDate: '2013-06-01',
              weekends: false,
              fixedWeekCount: false,
              events(arg, callback) {
                  expect(arg.start).toEqualDate('2013-06-03T00:00:00Z');
                  expect(arg.end).toEqualDate('2013-06-29T00:00:00Z');
                  expect(arg.timeZone).toBe('UTC');
                  expect(typeof callback).toBe('function');
                  done();
              },
          });
      });
      it('does not request dates excluded by showNonCurrentDates:false', (done) => {
          initCalendar({
              initialView: 'dayGridMonth',
              initialDate: '2013-06-01',
              showNonCurrentDates: false,
              events(arg) {
                  expect(arg.start).toEqualDate('2013-06-01T00:00:00Z');
                  expect(arg.end).toEqualDate('2013-07-01T00:00:00Z');
                  done();
              },
          });
      });
      it('requests a timed range when slotMinTime is negative', (done) => {
          initCalendar({
              initialView: 'timeGridWeek',
              initialDate: '2017-06-08',
              slotMinTime: { hours: -2 },
              events(arg) {
                  expect(arg.start).toEqualDate('2017-06-03T22:00:00Z');
                  expect(arg.end).toEqualDate('2017-06-11T00:00:00Z');
                  done();
              },
          });
      });
      it('requests a timed range when slotMaxTime exceeds 24 hours', (done) => {
          initCalendar({
              initialView: 'timeGridWeek',
              initialDate: '2017-06-08',
              slotMaxTime: '26:00',
              events(arg) {
                  expect(arg.start).toEqualDate('2017-06-04T00:00:00Z');
                  expect(arg.end).toEqualDate('2017-06-11T02:00:00Z');
                  done();
              },
          });
      });
      it('calls loading callback', (done) => {
          let loadingCallArgs = [];
          initCalendar({
              loading(bool) {
                  loadingCallArgs.push(bool);
              },
              events(arg, callback) {
                  setTimeout(() => {
                      expect(loadingCallArgs).toEqual([true]);
                      callback([]);
                      setTimeout(() => {
                          expect(loadingCallArgs).toEqual([true, false]);
                          done();
                      }, 0);
                  }, 0);
              },
          });
      });
      it('calls loading callback only once for multiple sources', (done) => {
          let loadingCallArgs = [];
          initCalendar({
              loading(bool) {
                  loadingCallArgs.push(bool);
              },
              eventSources: [
                  (arg, callback) => {
                      setTimeout(() => {
                          callback([]);
                      }, 0);
                  },
                  (arg, callback) => {
                      setTimeout(() => {
                          callback([]);
                      }, 10);
                  },
              ],
          });
          setTimeout(() => {
              expect(loadingCallArgs).toEqual([true, false]);
              done();
          }, 20);
      });
      it('can call failure callback with error', () => {
          let calledFailure = false;
          initCalendar({
              events(arg, successCallback, failureCallback) {
                  failureCallback(new Error());
              },
              eventSourceFailure(error) {
                  calledFailure = true;
                  expect(error instanceof Error).toBe(true);
              },
          });
          expect(calledFailure).toBe(true);
      });
  });

  describe('eventDataTransform', () => {
      let transform = (raw) => ($.extend({}, raw, {
          was_processed: true,
      }));
      describeOptions({
          'when on the calendar': {
              events: [
                  { start: '2017-10-23' },
              ],
              eventDataTransform: transform,
          },
          'when on an event source': {
              eventSources: [{
                      events: [
                          { start: '2017-10-23' },
                      ],
                      eventDataTransform: transform,
                  }],
          },
      }, () => {
          it('affects parsing of the event', () => {
              initCalendar();
              let eventObj = currentCalendar.getEvents()[0];
              expect(eventObj.extendedProps.was_processed).toBe(true);
          });
      });
  });

  describe('Event::formatRange', () => {
      pushOptions({
          timeZone: 'America/New_York',
          locale: 'en',
      });
      const FORMAT_SETTINGS = {
          month: 'long',
          day: 'numeric',
          year: 'numeric',
          timeZoneName: 'short',
          separator: ' to ',
          omitCommas: true, // for cross-browser
      };
      describe('when event has an end', () => {
          pushOptions({
              events: [
                  { start: '2018-09-04T12:00:00-05:00', end: '2018-09-05T12:00:00-05:00' },
              ],
          });
          it('formats start and end', () => {
              initCalendar();
              let event = currentCalendar.getEvents()[0];
              let str = event.formatRange(FORMAT_SETTINGS);
              expect(str.replace(' at ', ' '))
                  .toBe('September 4 to 5 2018 12:00 PM GMT-5');
          });
      });
      describe('when event has NO end', () => {
          pushOptions({
              events: [
                  { start: '2018-09-04T12:00:00-05:00' },
              ],
          });
          it('formats start', () => {
              initCalendar();
              let event = currentCalendar.getEvents()[0];
              let str = event.formatRange(FORMAT_SETTINGS);
              expect(str.replace(' at ', ' '))
                  .toBe('September 4 2018 12:00 PM GMT-5');
          });
      });
  });

  describe('Event::moveDates', () => {
      pushOptions({
          timeZone: 'UTC',
      });
      describe('when event doesn\'t have an end', () => {
          it('moves start and keeps end null', () => {
              initCalendar({
                  events: [
                      { id: '1', start: '2018-09-03T00:00:00' },
                  ],
              });
              let event = currentCalendar.getEventById('1');
              event.moveDates({ days: 1, hours: 1 });
              expect(event.start).toEqualDate('2018-09-04T01:00:00Z');
              expect(event.end).toBe(null);
          });
      });
      describe('when event does have an end', () => {
          it('moves start and end by same delta', () => {
              initCalendar({
                  events: [
                      { id: '1', start: '2018-09-03T00:00:00', end: '2018-09-04T12:00:00' },
                  ],
              });
              let event = currentCalendar.getEventById('1');
              event.moveDates({ days: 1, hours: 1 });
              expect(event.start).toEqualDate('2018-09-04T01:00:00Z');
              expect(event.end).toEqualDate('2018-09-05T13:00:00Z');
          });
      });
      it('moves related events of different duration by same delta', () => {
          initCalendar({
              events: [
                  { id: '1', groupId: 'a', start: '2018-09-03T00:00:00', end: '2018-09-04T12:00:00' },
                  { id: '2', groupId: 'a', start: '2018-10-03T00:00:00', end: '2018-10-04T12:00:00' },
              ],
          });
          let event1 = currentCalendar.getEventById('1');
          event1.moveDates({ days: 1, hours: 1 });
          expect(event1.start).toEqualDate('2018-09-04T01:00:00Z');
          expect(event1.end).toEqualDate('2018-09-05T13:00:00Z');
          let event2 = currentCalendar.getEventById('2');
          expect(event2.start).toEqualDate('2018-10-04T01:00:00Z');
          expect(event2.end).toEqualDate('2018-10-05T13:00:00Z');
      });
      it('does not move unrelated events', () => {
          initCalendar({
              events: [
                  { id: '1', groupId: 'a', start: '2018-09-03T00:00:00', end: '2018-09-04T12:00:00' },
                  { id: '2', groupId: 'bbb', start: '2018-10-03T00:00:00', end: '2018-10-04T12:00:00' },
              ],
          });
          let event1 = currentCalendar.getEventById('1');
          event1.moveDates({ days: 1, hours: 1 });
          expect(event1.start).toEqualDate('2018-09-04T01:00:00Z');
          expect(event1.end).toEqualDate('2018-09-05T13:00:00Z');
          let event2 = currentCalendar.getEventById('2');
          expect(event2.start).toEqualDate('2018-10-03T00:00:00Z'); // same
          expect(event2.end).toEqualDate('2018-10-04T12:00:00Z'); // same
      });
  });

  describe('Event::moveEnd', () => {
      pushOptions({
          timeZone: 'UTC',
          defaultTimedEventDuration: '01:00',
      });
      describe('when event doesn\'t have an end', () => {
          pushOptions({
              events: [
                  { id: '1', start: '2018-09-03T12:00:00' },
              ],
          });
          it('generates a new end', () => {
              initCalendar();
              let event = currentCalendar.getEventById('1');
              event.moveEnd('01:00');
              expect(event.start).toEqualDate('2018-09-03T12:00:00Z');
              expect(event.end).toEqualDate('2018-09-03T14:00:00Z');
          });
      });
      describe('when event does have an end', () => {
          pushOptions({
              events: [
                  { id: '1', start: '2018-09-03T12:00:00', end: '2018-09-03T15:00:00' },
              ],
          });
          it('moves end', () => {
              initCalendar();
              let event = currentCalendar.getEventById('1');
              event.moveEnd('01:00');
              expect(event.start).toEqualDate('2018-09-03T12:00:00Z');
              expect(event.end).toEqualDate('2018-09-03T16:00:00Z');
          });
      });
  });

  describe('lazyFetching', () => {
      pushOptions({
          timeZone: 'UTC',
          initialView: 'dayGridMonth',
          initialDate: '2017-10-04',
      });
      describe('when on', () => {
          pushOptions({
              lazyFetching: true,
          });
          it('won\'t fetch weeks already queried', () => {
              let options = {
                  events(fetchInfo, callback) {
                      callback([]);
                  },
              };
              spyOn(options, 'events').and.callThrough();
              initCalendar(options);
              currentCalendar.changeView('timeGridWeek');
              currentCalendar.next();
              currentCalendar.next();
              currentCalendar.next();
              expect(options.events.calls.count()).toBe(1);
              let arg = options.events.calls.argsFor(0)[0];
              expect(arg.start).toEqualDate('2017-10-01T00:00:00Z');
              expect(arg.end).toEqualDate('2017-11-12T00:00:00Z');
          });
      });
      describe('when off', () => {
          pushOptions({
              lazyFetching: false,
          });
          it('will fetch each new week range', () => {
              let options = {
                  events(fetchInfo, callback) {
                      callback([]);
                  },
              };
              spyOn(options, 'events');
              initCalendar(options);
              currentCalendar.changeView('timeGridWeek');
              currentCalendar.next();
              currentCalendar.next();
              currentCalendar.next();
              expect(options.events.calls.count()).toBe(5);
              let arg = options.events.calls.argsFor(0)[0];
              expect(arg.start).toEqualDate('2017-10-01T00:00:00Z');
              expect(arg.end).toEqualDate('2017-11-12T00:00:00Z');
              arg = options.events.calls.argsFor(1)[0];
              expect(arg.start).toEqualDate('2017-10-01T00:00:00Z');
              expect(arg.end).toEqualDate('2017-10-08T00:00:00Z');
              arg = options.events.calls.argsFor(2)[0];
              expect(arg.start).toEqualDate('2017-10-08T00:00:00Z');
              expect(arg.end).toEqualDate('2017-10-15T00:00:00Z');
              arg = options.events.calls.argsFor(3)[0];
              expect(arg.start).toEqualDate('2017-10-15T00:00:00Z');
              expect(arg.end).toEqualDate('2017-10-22T00:00:00Z');
              arg = options.events.calls.argsFor(4)[0];
              expect(arg.start).toEqualDate('2017-10-22T00:00:00Z');
              expect(arg.end).toEqualDate('2017-10-29T00:00:00Z');
          });
      });
  });

  describe('Event::setDates', () => {
      pushOptions({
          now: '2018-09-03',
          timeZone: 'UTC',
          defaultTimedEventDuration: '01:00',
          events: [
              { id: '1', start: '2018-09-05T12:00:00' },
          ],
      });
      describe('when setting different start', () => {
          it('changes start and gives it an end', () => {
              initCalendar();
              let event = currentCalendar.getEventById('1');
              event.setDates('2018-09-05T14:00:00', '2018-09-05T16:00:00');
              expect(event.start).toEqualDate('2018-09-05T14:00:00Z');
              expect(event.end).toEqualDate('2018-09-05T16:00:00Z');
          });
      });
      describe('when setting same start and end', () => {
          it('changes nothing and end remains null', () => {
              initCalendar();
              let event = currentCalendar.getEventById('1');
              event.setDates('2018-09-05T12:00:00', '2018-09-05T13:00:00');
              expect(event.start).toEqualDate('2018-09-05T12:00:00Z');
              expect(event.end).toBe(null);
          });
      });
      describe('when setting different end', () => {
          it('changes end and gives it an end', () => {
              initCalendar();
              let event = currentCalendar.getEventById('1');
              event.setDates('2018-09-05T12:00:00', '2018-09-05T18:00:00');
              expect(event.start).toEqualDate('2018-09-05T12:00:00Z');
              expect(event.end).toEqualDate('2018-09-05T18:00:00Z');
          });
      });
      describe('when setting different start AND end', () => {
          describe('if duration is effectively the same', () => {
              it('changes start and leaves end null', () => {
                  initCalendar();
                  let event = currentCalendar.getEventById('1');
                  event.setDates('2018-09-06T01:00:00', '2018-09-06T02:00:00');
                  expect(event.start).toEqualDate('2018-09-06T01:00:00Z');
                  expect(event.end).toBe(null);
              });
          });
      });
      describe('when called with a null end', () => {
          pushOptions({
              events: [
                  { id: '1', start: '2018-09-05T12:00:00', end: '2018-09-05T14:00:00' },
              ],
          });
          it('clears the end', () => {
              initCalendar();
              let event = currentCalendar.getEventById('1');
              event.setDates('2018-09-06T01:00:00', null);
              expect(event.start).toEqualDate('2018-09-06T01:00:00Z');
              expect(event.end).toBe(null);
          });
      });
      it('can set allDay to true', () => {
          initCalendar(); // { id: '1', start: '2018-09-05T12:00:00' }
          let event = currentCalendar.getEventById('1');
          event.setDates('2018-09-06', '2018-09-10', { allDay: true });
          expect(event.start).toEqualDate('2018-09-06');
          expect(event.end).toEqualDate('2018-09-10');
          expect(event.allDay).toBe(true);
      });
      it('can set allDay to false', () => {
          initCalendar({
              events: [
                  { id: '1', start: '2018-09-05', end: '2018-09-08' },
              ],
          });
          let event = currentCalendar.getEventById('1');
          event.setDates('2018-09-06T10:00:00', '2018-09-10T02:00:00', { allDay: false });
          expect(event.start).toEqualDate('2018-09-06T10:00:00Z');
          expect(event.end).toEqualDate('2018-09-10T02:00:00Z');
          expect(event.allDay).toBe(false);
      });
      it('shortens related events of different duration by same delta', () => {
          initCalendar({
              events: [
                  { id: '1', groupId: 'a', start: '2018-09-03', end: '2018-09-05' },
                  { id: '2', groupId: 'a', start: '2018-09-13', end: '2018-09-15' },
              ],
          });
          let event1 = currentCalendar.getEventById('1');
          event1.setDates('2018-09-02', '2018-09-06'); // start back by 1, end ahead by 1
          expect(event1.start).toEqualDate('2018-09-02');
          expect(event1.end).toEqualDate('2018-09-06');
          let event2 = currentCalendar.getEventById('2');
          expect(event2.start).toEqualDate('2018-09-12');
          expect(event2.end).toEqualDate('2018-09-16');
      });
  });

  describe('Event::source', () => {
      it('returns the correct source', () => {
          initCalendar({
              eventSources: [{
                      id: 'sourceA',
                      events: [
                          { id: 'eventA', start: '2018-09-07' },
                      ],
                  }],
          });
          let event = currentCalendar.getEventById('eventA');
          let source = event.source;
          expect(source.id).toBe('sourceA');
      });
      it('returns null for events with no source', () => {
          initCalendar();
          currentCalendar.addEvent({ id: 'eventA', start: '2018-09-07' });
          let event = currentCalendar.getEventById('eventA');
          let source = event.source;
          expect(source).toBe(null);
      });
  });

  describe('Event::setEnd', () => {
      pushOptions({
          now: '2018-09-03',
          timeZone: 'UTC',
          defaultTimedEventDuration: '01:00',
      });
      describe('when event doesn\'t have an end', () => {
          pushOptions({
              events: [
                  { id: '1', start: '2018-09-10T00:00:00' },
              ],
          });
          it('sets end and keeps start', () => {
              initCalendar();
              let event = currentCalendar.getEventById('1');
              event.setEnd('2018-09-12T02:00:00');
              expect(event.start).toEqualDate('2018-09-10T00:00:00Z');
              expect(event.end).toEqualDate('2018-09-12T02:00:00Z');
          });
      });
      describe('when event does have an end', () => {
          pushOptions({
              events: [
                  { id: '1', start: '2018-09-10T00:00:00', end: '2018-09-11T00:00:00' },
              ],
          });
          it('changes end and keeps start', () => {
              initCalendar();
              let event = currentCalendar.getEventById('1');
              event.setEnd('2018-09-12T02:00:00');
              expect(event.start).toEqualDate('2018-09-10T00:00:00Z');
              expect(event.end).toEqualDate('2018-09-12T02:00:00Z');
          });
      });
      it('shortens related events of different duration by same delta', () => {
          initCalendar({
              events: [
                  { id: '1', groupId: 'a', start: '2018-09-10T00:00:00', end: '2018-09-11T00:00:00' },
                  { id: '2', groupId: 'a', start: '2018-09-14T00:00:00', end: '2018-09-16T00:00:00' },
              ],
          });
          let event1 = currentCalendar.getEventById('1');
          event1.setEnd('2018-09-12T02:00:00'); // move end forward by 1 day, 2 hours
          expect(event1.start).toEqualDate('2018-09-10T00:00:00Z');
          expect(event1.end).toEqualDate('2018-09-12T02:00:00Z');
          let event2 = currentCalendar.getEventById('2');
          expect(event2.start).toEqualDate('2018-09-14T00:00:00Z');
          expect(event2.end).toEqualDate('2018-09-17T02:00:00Z');
      });
  });

  describe('Event Object parsing', () => {
      it('records _id as an extended prop', () => {
          initCalendar({
              initialDate: '2017-09-05',
              initialView: 'dayGridMonth',
              events: [
                  { _id: 'a', start: '2017-09-05' },
              ],
          });
          let events = currentCalendar.getEvents();
          expect(events[0].extendedProps._id).toBe('a');
      });
      it('parses an all-day event with timed same-day start/end', () => {
          initCalendar({
              initialView: 'dayGridMonth',
              initialDate: '2017-11-01',
              timeZone: 'local',
              events: [
                  {
                      title: 'All Day with time',
                      allDay: true,
                      start: new Date(2017, 10, 1, 10, 0, 0),
                      end: new Date(2017, 10, 1, 18, 0, 0), // same-day. will result in null
                  },
              ],
          });
          let events = currentCalendar.getEvents();
          expect(events.length).toBe(1);
          expect(events[0].start).toEqualLocalDate('2017-11-01T00:00:00');
          expect(events[0].end).toBe(null);
      });
      xit('won\'t accept two events with the same ID', () => {
          initCalendar({
              initialView: 'dayGridDay',
              initialDate: '2018-01-01',
              events: [
                  { id: '1', start: '2018-01-01', title: 'cool' },
                  { id: '1', start: '2018-01-01' },
              ],
          });
          let events = currentCalendar.getEvents();
          expect(events.length).toBe(1);
          expect(events[0].title).toBe('cool');
      });
  });

  class ViewWrapper {
      constructor(calendar, className) {
          let viewEl = calendar.el.querySelector('.fc-view');
          if (!viewEl || !viewEl.classList.contains(className)) {
              throw new Error(`Can't find view with className '${className}' in test model`);
          }
          this.el = viewEl;
      }
  }

  function formatIsoTimeZoneOffset(date) {
      let minutes = date.getTimezoneOffset();
      let sign = minutes < 0 ? '+' : '-'; // whaaa
      let abs = Math.abs(minutes);
      let hours = Math.floor(abs / 60);
      let mins = Math.round(abs % 60);
      return sign + pad(hours) + ':' + pad(mins);
  }
  function formatPrettyTimeZoneOffset(date) {
      let minutes = date.getTimezoneOffset();
      let sign = minutes < 0 ? '+' : '-'; // whaaa
      let abs = Math.abs(minutes);
      let hours = Math.floor(abs / 60);
      let mins = Math.round(abs % 60);
      return 'GMT' + sign + hours + (mins ? ':' + pad(mins) : '');
  }
  function pad(n) {
      return n < 10 ? '0' + n : '' + n;
  }
  function formatIsoDay(date) {
      return date.toISOString().replace(/T.*/, '');
  }
  function formatIsoTime(date) {
      return pad(date.getUTCHours()) + ':' +
          pad(date.getUTCMinutes()) + ':' +
          pad(date.getUTCSeconds());
  }
  function formatIsoWithoutTz(date) {
      return date.toISOString().replace(/(Z|[-+]\d\d:\d\d)$/, '').replace('.000', '');
  }
  function parseIsoAsUtc(s) {
      if (s.length <= 10) {
          s += 'T00:00:00Z';
      }
      else if (s.indexOf('Z') === -1) {
          s += 'Z';
      }
      let d = new Date(s);
      if (isNaN(d.valueOf())) {
          throw new Error(s + ' is not valid date input');
      }
      return d;
  }
  function ensureDate(input) {
      if (input instanceof Date) {
          return input;
      }
      if (typeof input === 'string') {
          return parseIsoAsUtc(input);
      }
      if (typeof input === 'number') {
          return new Date(input);
      }
      throw new Error(input + ' is invalid date input');
  }

  function getRectCenter(rect) {
      return buildPoint(rect.left + rect.width / 2, rect.top + rect.height / 2);
  }
  function intersectRects(rect0, rect1) {
      return buildRectViaEdges(Math.max(rect0.left, rect1.left), Math.max(rect0.top, rect1.top), Math.min(rect0.right, rect1.right), Math.min(rect0.bottom, rect1.bottom));
  }
  function rectsIntersect(rect0, rect1) {
      return rect0.left < rect1.right && rect0.right > rect1.left && rect0.top < rect1.bottom && rect0.bottom > rect1.top;
  }
  function rectContainersOther(rect0, rect1) {
      return rect1.left >= rect0.left && rect1.right <= rect0.right && rect1.top >= rect0.top && rect1.bottom <= rect0.bottom;
  }
  function buildRectViaEdges(left, top, right, bottom) {
      return {
          left,
          top,
          width: right - left,
          height: bottom - top,
          right,
          bottom,
      };
  }
  function buildPoint(left, top) {
      return {
          left,
          top,
      };
  }
  function subtractPoints(point1, point0) {
      return buildPoint(point1.left - point0.left, point1.top - point0.top);
  }
  function addPoints(point0, point1) {
      return buildPoint(point0.left + point1.left, point0.top + point1.top);
  }
  function isRect(input) {
      return typeof input === 'object' && 'left' in input && 'right' in input && 'top' in input && 'bottom' in input;
  }
  function isRectMostlyAbove(subjectRect, otherRect) {
      return (subjectRect.bottom - otherRect.top) < // overlap is less than
          ((subjectRect.bottom - subjectRect.top) / 2); // half the height
  }
  function isRectMostlyLeft(subjectRect, otherRect) {
      return (subjectRect.right - otherRect.left) < // overlap is less then
          ((subjectRect.right - subjectRect.left) / 2); // half the width
  }
  function isRectMostlyBounded(subjectRect, boundRect) {
      return isRectMostlyHBounded(subjectRect, boundRect) &&
          isRectMostlyVBounded(subjectRect, boundRect);
  }
  function isRectMostlyHBounded(subjectRect, boundRect) {
      return (Math.min(subjectRect.right, boundRect.right) -
          Math.max(subjectRect.left, boundRect.left)) > // overlap area is greater than
          ((subjectRect.right - subjectRect.left) / 2); // half the width
  }
  function isRectMostlyVBounded(subjectRect, boundRect) {
      return (Math.min(subjectRect.bottom, boundRect.bottom) -
          Math.max(subjectRect.top, boundRect.top)) > // overlap area is greater than
          ((subjectRect.bottom - subjectRect.top) / 2); // half the height
  }
  function isRectsSimilar(rect1, rect2) {
      return isRectsHSimilar(rect1, rect2) && isRectsVSimilar(rect1, rect2);
  }
  function isRectsHSimilar(rect1, rect2) {
      return (Math.abs(rect1.left - rect2.left) <= 2) && (Math.abs(rect1.right - rect2.right) <= 3); // :(
  }
  function isRectsVSimilar(rect1, rect2) {
      return (Math.abs(rect1.top - rect2.top) <= 2) && (Math.abs(rect1.bottom - rect2.bottom) <= 3); // :(
  }

  class ToolbarWrapper {
      constructor(el) {
          this.el = el;
      }
      getButtonEnabled(name) {
          let buttonEl = this.el.querySelector('.fc-' + name + '-button');
          return buttonEl && !buttonEl.disabled;
      }
      getButtonInfo(name, iconPrefix = 'fc-icon') {
          let el = this.getButtonEl(name);
          if (el) {
              let iconEl = el.querySelector(`.${iconPrefix}`);
              let iconNameMatch = iconEl && iconEl.className.match(new RegExp(`${iconPrefix}-([^ ]+)`));
              return {
                  text: $(el).text(),
                  iconEl,
                  iconName: iconNameMatch ? iconNameMatch[1] : '',
              };
          }
          return null;
      }
      getButtonEl(name) {
          return this.el.querySelector(`.fc-${name}-button`);
      }
      getTitleText() {
          return this.el.querySelector('.fc-toolbar-title').innerText.trim();
      }
      getSectionContent(index) {
          return processSectionItems(this.el.querySelectorAll('.fc-toolbar-chunk')[index]);
      }
  }
  function processSectionItems(sectionEl) {
      let children = Array.prototype.slice.call(sectionEl.children);
      return children.map((childEl) => {
          if (childEl.classList.contains('fc-button')) {
              return {
                  type: 'button',
                  name: childEl.className.match(/fc-(\w+)-button/)[1],
              };
          }
          if (childEl.classList.contains('fc-button-group')) {
              return {
                  type: 'button-group',
                  children: processSectionItems(childEl),
              };
          }
          if (childEl.nodeName === 'H2') {
              return {
                  type: 'title',
              };
          }
          throw new Error('Unknown type of content in toolbar');
      });
  }

  class CalendarWrapper {
      constructor(calendar) {
          this.calendar = calendar;
      }
      // TODO: distinguish between header/footerToolbar
      get toolbar() {
          let toolbarEl = this.calendar.el.querySelector('.fc-toolbar');
          return toolbarEl ? new ToolbarWrapper(toolbarEl) : null;
      }
      get footerToolbar() {
          let toolbarEl = this.calendar.el.querySelector('.fc-footer-toolbar');
          return toolbarEl ? new ToolbarWrapper(toolbarEl) : null;
      }
      getViewContainerEl() {
          return this.calendar.el.querySelector('.fc-view-harness');
      }
      getViewEl() {
          return this.calendar.el.querySelector('.fc-view');
      }
      getViewName() {
          return this.getViewEl().getAttribute('class').match(/fc-(\w+)-view/)[1];
      }
      // DISCOURAGE use of the following...
      getNonBusinessDayEls() {
          return findElements(this.calendar.el, '.fc-non-business');
      }
      getEventEls() {
          return findElements(this.calendar.el, '.fc-event:not(.fc-bg-event)');
      }
      getFirstEventEl() {
          return this.calendar.el.querySelector('.fc-event:not(.fc-bg-event)');
      }
      getTodayEls() {
          return findElements(this.calendar.el, '.fc-day-today');
      }
      getEventElInfo(eventEl) {
          return {
              isStart: eventEl.classList.contains(CalendarWrapper.EVENT_IS_START_CLASSNAME),
              isEnd: eventEl.classList.contains(CalendarWrapper.EVENT_IS_END_CLASSNAME),
              timeText: $(eventEl).find('.' + CalendarWrapper.EVENT_TIME_CLASSNAME).text() || '',
              titleEl: eventEl.querySelector('.' + CalendarWrapper.EVENT_TITLE_CLASSNAME),
              resizerEl: eventEl.querySelector('.' + CalendarWrapper.EVENT_RESIZER_CLASSNAME),
          };
      }
      getBgEventEls() {
          return findElements(this.calendar.el, '.' + CalendarWrapper.BG_EVENT_CLASSNAME);
      }
      getFirstDateEl() {
          return this.calendar.el.querySelector('.fc [data-date]');
      }
      getDateCellEl(dateStr) {
          return this.calendar.el.querySelector('td.fc-day[data-date="' + dateStr + '"]');
      }
      getLicenseMessage() {
          return $('.fc-license-message', this.calendar.el).text();
      }
      isAllowingDragging() {
          return !$('body').hasClass('fc-not-allowed');
      }
  }
  CalendarWrapper.EVENT_CLASSNAME = 'fc-event'; // TODO: put this everywhere?
  CalendarWrapper.EVENT_IS_START_CLASSNAME = 'fc-event-start';
  CalendarWrapper.EVENT_IS_END_CLASSNAME = 'fc-event-end';
  CalendarWrapper.EVENT_TIME_CLASSNAME = 'fc-event-time';
  CalendarWrapper.EVENT_TITLE_CLASSNAME = 'fc-event-title';
  CalendarWrapper.EVENT_RESIZER_CLASSNAME = 'fc-event-resizer';
  CalendarWrapper.EVENT_START_RESIZER_CLASSNAME = 'fc-event-resizer-start';
  CalendarWrapper.EVENT_END_RESIZER_CLASSNAME = 'fc-event-resizer-end';
  CalendarWrapper.BG_EVENT_CLASSNAME = 'fc-bg-event';
  CalendarWrapper.DAY_PAST_CLASSNAME = 'fc-day-past';
  CalendarWrapper.DAY_FUTURE_CLASSNAME = 'fc-day-future';
  CalendarWrapper.SLOT_PAST_CLASSNAME = 'fc-slot-past';
  CalendarWrapper.SLOT_FUTURE_CLASSNAME = 'fc-slot-future';
  CalendarWrapper.TODAY_CLASSNAME = 'fc-day-today';
  CalendarWrapper.SLOT_TODAY_CLASSNAME = 'fc-slot-today';
  CalendarWrapper.DOW_CLASSNAMES = ['fc-day-sun', 'fc-day-mon', 'fc-day-tue', 'fc-day-wed', 'fc-day-thu', 'fc-day-fri', 'fc-day-sat'];
  CalendarWrapper.DOW_SLOT_CLASSNAMES = ['fc-slot-sun', 'fc-slot-mon', 'fc-slot-tue', 'fc-slot-wed', 'fc-slot-thu', 'fc-slot-fri', 'fc-slot-sat'];
  CalendarWrapper.LTR_CLASSNAME = 'fc-direction-ltr';
  CalendarWrapper.RTL_CLASSNAME = 'fc-direction-rtl';
  CalendarWrapper.BOOTSTRAP_CLASSNAME = 'fc-theme-bootstrap';
  CalendarWrapper.UNTHEMED_CLASSNAME = 'fc-theme-standard';
  CalendarWrapper.ROOT_CLASSNAME = 'fc';

  class DayGridWrapper {
      constructor(el) {
          this.el = el;
      }
      getRootTableEl() {
          return $(this.el).find('> table')[0];
      }
      getAllDayEls() {
          return findElements(this.el, '.fc-day[data-date]');
      }
      getMirrorEls() {
          return findElements(this.el, '.fc-event.fc-event-mirror');
      }
      getDayEl(date) {
          if (typeof date === 'string') {
              date = new Date(date);
          }
          return this.el.querySelector('.fc-day[data-date="' + formatIsoDay(date) + '"]');
      }
      getDayEls(date) {
          if (typeof date === 'number') {
              return findElements(this.el, `.fc-day.${CalendarWrapper.DOW_CLASSNAMES[date]}`);
          }
          if (typeof date === 'string') {
              date = new Date(date);
          }
          return findElements(this.el, '.fc-day[data-date="' + formatIsoDay(date) + '"]');
      }
      getDayNumberText(date) {
          return $(this.getDayEl(date).querySelector('.fc-daygrid-day-top')).text();
      }
      getDayElsInRow(row) {
          return findElements(this.getRowEl(row), '.fc-day');
      }
      // TODO: discourage use
      getNonBusinessDayEls() {
          return findElements(this.el, '.fc-non-business');
      }
      // example: gets all the Mondays in the first row of days
      // TODO: discourage use
      getDowEls(dayAbbrev) {
          return findElements(this.el, `tr:first-child > td.fc-day-${dayAbbrev}`);
      }
      getMonthStartEls() {
          return findElements(this.el, '.fc-daygrid-month-start');
      }
      getDisabledDayEls() {
          return findElements(this.el, '.fc-day-disabled');
      }
      getMoreEl() {
          return this.el.querySelector('.fc-daygrid-more-link');
      }
      getMoreEls() {
          return findElements(this.el, '.fc-daygrid-more-link');
      }
      getWeekNavLinkEls() {
          return findElements(this.el, '.fc-daygrid-week-number[data-navlink]');
      }
      getWeekNumberEls() {
          return findElements(this.el, '.fc-daygrid-week-number');
      }
      getWeekNumberEl(rowIndex) {
          return this.getRowEl(rowIndex).querySelector('.fc-daygrid-week-number');
      }
      getWeekNumberText(rowIndex) {
          return $(this.getWeekNumberEl(rowIndex)).text();
      }
      getNavLinkEl(date) {
          return this.getDayEl(date).querySelector('.fc-daygrid-day-number[data-navlink]');
      }
      clickNavLink(date) {
          $.simulateMouseClick(this.getNavLinkEl(date));
      }
      openMorePopover(index) {
          if (index == null) {
              $(this.getMoreEl()).simulate('click');
          }
          else {
              $(this.el.querySelectorAll('.fc-daygrid-more-link')[index]).simulate('click');
          }
      }
      getMorePopoverEl() {
          let viewWrapperEl = this.el.closest('.fc-view-harness');
          return viewWrapperEl.querySelector('.fc-more-popover');
      }
      getMorePopoverHeaderEl() {
          return this.getMorePopoverEl().querySelector('.fc-popover-header');
      }
      getMorePopoverEventEls() {
          return findElements(this.getMorePopoverEl(), '.fc-event');
      }
      getMorePopoverEventCnt() {
          return this.getMorePopoverEventEls().length;
      }
      getMorePopoverEventTitles() {
          return this.getMorePopoverEventEls().map((el) => $(el.querySelector('.fc-event-title')).text());
      }
      getMorePopoverBgEventCnt() {
          return this.getMorePopoverEl().querySelectorAll('.fc-bg-event').length;
      }
      closeMorePopover() {
          $(this.getMorePopoverEl().querySelector('.fc-popover-close')).simulate('click');
      }
      getMorePopoverTitle() {
          return $(this.getMorePopoverEl().querySelector('.fc-popover-title')).text();
      }
      getRowEl(i) {
          return this.el.querySelector(`tr:nth-child(${i + 1})`); // nth-child is 1-indexed!
      }
      getRowEls() {
          return findElements(this.el, 'tr');
      }
      getBgEventEls(row) {
          let parentEl = row == null ? this.el : this.getRowEl(row);
          return findElements(parentEl, '.fc-bg-event');
      }
      getEventEls() {
          return findElements(this.el, '.fc-daygrid-event');
      }
      isEventListItem(el) {
          return el.classList.contains('fc-daygrid-dot-event');
      }
      getFirstEventEl() {
          return this.el.querySelector('.fc-daygrid-event');
      }
      getHighlightEls() {
          return findElements(this.el, '.fc-highlight');
      }
      static getEventElInfo(eventEl) {
          return {
              title: $(eventEl).find('.fc-event-title').text(),
              timeText: $(eventEl).find('.fc-event-time').text(),
          };
      }
      clickDate(date) {
          $.simulateMouseClick(this.getDayEl(date));
      }
      selectDates(start, inclusiveEnd) {
          return new Promise((resolve) => {
              $(this.getDayEls(start)).simulate('drag', {
                  point: getRectCenter(this.getDayEl(start).getBoundingClientRect()),
                  end: getRectCenter(this.getDayEl(inclusiveEnd).getBoundingClientRect()),
                  onRelease: () => resolve(),
              });
          });
      }
      selectDatesTouch(start, inclusiveEnd, debug = false) {
          return new Promise((resolve) => {
              let startEl = this.getDayEl(start);
              setTimeout(() => {
                  // QUESTION: why do we not need to do press-down first?
                  $(startEl).simulate('drag', {
                      debug,
                      isTouch: true,
                      end: getRectCenter(this.getDayEl(inclusiveEnd).getBoundingClientRect()),
                      onRelease: () => resolve(),
                  });
              }, 0);
          });
      }
      dragEventToDate(eventEl, startDate, endDate, isTouch, onBeforeRelease) {
          return new Promise((resolve) => {
              if (!startDate) {
                  let rect1 = this.getDayEl(endDate).getBoundingClientRect();
                  let point1 = getRectCenter(rect1);
                  $(eventEl).simulate('drag', {
                      isTouch: isTouch || false,
                      delay: isTouch ? 200 : 0,
                      end: point1,
                      onBeforeRelease,
                      onRelease: () => resolve(),
                  });
              }
              else {
                  let rect0 = this.getDayEl(startDate).getBoundingClientRect();
                  let rect1 = this.getDayEl(endDate).getBoundingClientRect();
                  let eventRect = eventEl.getBoundingClientRect();
                  let point0 = getRectCenter(intersectRects(eventRect, rect0));
                  let point1 = getRectCenter(rect1);
                  $(eventEl).simulate('drag', {
                      isTouch: isTouch || false,
                      delay: isTouch ? 200 : 0,
                      point: point0,
                      end: point1,
                      onBeforeRelease,
                      onRelease: () => resolve(),
                  });
              }
          });
      }
      resizeEvent(eventEl, origEndDate, newEndDate, fromStart, onBeforeRelease) {
          return new Promise((resolve) => {
              let rect0 = this.getDayEl(origEndDate).getBoundingClientRect();
              let rect1 = this.getDayEl(newEndDate).getBoundingClientRect();
              let resizerEl = $(eventEl).find('.' + (fromStart ? CalendarWrapper.EVENT_START_RESIZER_CLASSNAME : CalendarWrapper.EVENT_END_RESIZER_CLASSNAME)).css('display', 'block')[0]; // usually only displays on hover. force display
              let resizerRect = resizerEl.getBoundingClientRect();
              let resizerCenter = getRectCenter(resizerRect);
              let vector = subtractPoints(resizerCenter, rect0);
              let endPoint = addPoints(rect1, vector);
              $(resizerEl).simulate('drag', {
                  point: resizerCenter,
                  end: endPoint,
                  onBeforeRelease,
                  onRelease: () => resolve(),
              });
          });
      }
      resizeEventTouch(eventEl, origEndDate, newEndDate, fromStart) {
          return new Promise((resolve) => {
              let rect0 = this.getDayEl(origEndDate).getBoundingClientRect();
              let rect1 = this.getDayEl(newEndDate).getBoundingClientRect();
              setTimeout(() => {
                  $(eventEl).simulate('drag', {
                      isTouch: true,
                      delay: 200,
                      onRelease: () => {
                          let resizerEl = eventEl.querySelector('.' + (fromStart ? CalendarWrapper.EVENT_START_RESIZER_CLASSNAME : CalendarWrapper.EVENT_END_RESIZER_CLASSNAME));
                          let resizerRect = resizerEl.getBoundingClientRect();
                          let resizerCenter = getRectCenter(resizerRect);
                          let vector = subtractPoints(resizerCenter, rect0);
                          let endPoint = addPoints(rect1, vector);
                          $(resizerEl).simulate('drag', {
                              isTouch: true,
                              point: resizerCenter,
                              end: endPoint,
                              onRelease: () => resolve(),
                          });
                      },
                  });
              }, 0);
          });
      }
  }
  DayGridWrapper.EVENT_IS_START_CLASSNAME = 'fc-event-start';
  DayGridWrapper.EVENT_IS_END_CLASSNAME = 'fc-event-end';

  class DayHeaderWrapper {
      constructor(el) {
          this.el = el;
      }
      getDates() {
          return this.getCellEls().map((cellEl) => parseIsoAsUtc(cellEl.getAttribute('data-date')));
      }
      getCellEls() {
          return findElements(this.el, '.fc-col-header-cell');
      }
      getCellEl(dateOrDow) {
          if (typeof dateOrDow === 'number') {
              return this.el.querySelector(`.fc-col-header-cell.${CalendarWrapper.DOW_CLASSNAMES[dateOrDow]}`);
          }
          if (typeof dateOrDow === 'string') {
              dateOrDow = parseUtcDate(dateOrDow);
          }
          return this.el.querySelector(`.fc-col-header-cell[data-date="${formatIsoDay(dateOrDow)}"]`);
      }
      getCellText(dateOrDow) {
          return $(this.getCellEl(dateOrDow)).text();
      }
      getCellInfo() {
          return this.getCellEls().map((cellEl) => ({
              text: $(cellEl).text(),
              date: parseIsoAsUtc(cellEl.getAttribute('data-date')),
              isToday: cellEl.classList.contains('fc-day-today'),
          }));
      }
      getNavLinkEls() {
          return findElements(this.el, '.fc-col-header-cell[data-date] a[data-navlink]');
      }
      getNavLinkEl(dayDate) {
          if (typeof dayDate === 'string') {
              dayDate = new Date(dayDate);
          }
          return this.el.querySelector('.fc-col-header-cell[data-date="' + formatIsoDay(dayDate) + '"] a');
      }
      clickNavLink(date) {
          $.simulateMouseClick(this.getNavLinkEl(date));
      }
  }

  class DayGridViewWrapper extends ViewWrapper {
      constructor(calendar) {
          super(calendar, 'fc-daygrid');
      }
      get header() {
          let headerEl = this.el.querySelector('.fc-col-header');
          return headerEl ? new DayHeaderWrapper(headerEl) : null;
      }
      get dayGrid() {
          return new DayGridWrapper(this.el.querySelector('.fc-daygrid-body'));
      }
      getScrollerEl() {
          return this.el.querySelector('.fc-daygrid-body').parentElement; // TODO: use closest
      }
  }

  describe('refetchEvents', () => {
      it('retains scroll when in month view', () => {
          let el = $('<div id="calendar" style="width:300px"/>').appendTo('body');
          let scrollEl;
          let scrollTop;
          let calendar = initCalendar({
              initialView: 'dayGridMonth',
              initialDate: '2017-04-25',
              events: [
                  { start: '2017-04-04', title: 'event' },
                  { start: '2017-04-04', title: 'event' },
                  { start: '2017-04-04', title: 'event' },
                  { start: '2017-04-04', title: 'event' },
                  { start: '2017-04-04', title: 'event' },
                  { start: '2017-04-04', title: 'event' },
                  { start: '2017-04-04', title: 'event' },
                  { start: '2017-04-04', title: 'event' },
              ],
          }, el);
          let calendarWrapper = new CalendarWrapper(calendar);
          expect(calendarWrapper.getEventEls().length).toBe(8);
          let viewWrapper = new DayGridViewWrapper(calendar);
          scrollEl = viewWrapper.getScrollerEl();
          scrollEl.scrollTop = 1000;
          scrollTop = scrollEl.scrollTop;
          // verify that we queried the correct scroller el
          expect(scrollTop).toBeGreaterThan(10);
          currentCalendar.refetchEvents();
          expect(calendarWrapper.getEventEls().length).toBe(8);
          expect(scrollEl.scrollTop).toBe(scrollTop);
      });
  });

  describe('setting option dynamically', () => {
      it('does not cause refetch of events', (done) => {
          let fetchCnt = 0;
          initCalendar({
              initialView: 'dayGridMonth',
              events(arg, callback) {
                  fetchCnt += 1;
                  callback([]);
              },
          });
          expect(fetchCnt).toBe(1);
          currentCalendar.setOption('selectable', true);
          setTimeout(() => {
              expect(fetchCnt).toBe(1);
              done();
          }, 0);
      });
  });

  describe('Event::moveStart', () => {
      pushOptions({
          timeZone: 'UTC',
          defaultTimedEventDuration: '01:00',
      });
      describe('when event doesn\'t have an end', () => {
          pushOptions({
              events: [
                  { id: '1', start: '2018-09-03T12:00:00' },
              ],
          });
          it('moves start and generates an end', () => {
              initCalendar();
              let event = currentCalendar.getEventById('1');
              event.moveStart({ hours: -5 });
              expect(event.start).toEqualDate('2018-09-03T07:00:00Z');
              expect(event.end).toEqualDate('2018-09-03T13:00:00Z');
          });
      });
      describe('when event does have an end', () => {
          pushOptions({
              events: [
                  { id: '1', start: '2018-09-03T12:00:00', end: '2018-09-03T15:00:00' },
              ],
          });
          it('moves start and keeps end', () => {
              initCalendar();
              let event = currentCalendar.getEventById('1');
              event.moveStart({ hours: -5 });
              expect(event.start).toEqualDate('2018-09-03T07:00:00Z');
              expect(event.end).toEqualDate('2018-09-03T15:00:00Z');
          });
      });
      describe('when moving start past end', () => {
          pushOptions({
              events: [
                  { id: '1', start: '2018-09-03T12:00:00', end: '2018-09-03T15:00:00' },
              ],
          });
          it('resets end to reflect default duration', () => {
              initCalendar();
              let event = currentCalendar.getEventById('1');
              event.moveStart({ days: 1 });
              expect(event.start).toEqualDate('2018-09-04T12:00:00Z');
              expect(event.end).toEqualDate('2018-09-04T13:00:00Z');
          });
      });
  });

  describe('Event::setProps', () => {
      it('allows setting id', () => {
          const calendar = initCalendar({
              events: [
                  { id: '123', start: '2021-01-01' },
              ],
          });
          let events = calendar.getEvents();
          let event = events[0];
          expect(event.id).toBe('123');
          event.setProp('id', '456');
          expect(event.id).toBe('456');
          events = calendar.getEvents();
          event = events[0];
          expect(event.id).toBe('456');
      });
  });

  // these aren't really private, but nor are they really useful to document

  /**
   * @private
   */
  class LuxonError extends Error {}

  /**
   * @private
   */
  class InvalidDateTimeError extends LuxonError {
    constructor(reason) {
      super(`Invalid DateTime: ${reason.toMessage()}`);
    }
  }

  /**
   * @private
   */
  class InvalidIntervalError extends LuxonError {
    constructor(reason) {
      super(`Invalid Interval: ${reason.toMessage()}`);
    }
  }

  /**
   * @private
   */
  class InvalidDurationError extends LuxonError {
    constructor(reason) {
      super(`Invalid Duration: ${reason.toMessage()}`);
    }
  }

  /**
   * @private
   */
  class ConflictingSpecificationError extends LuxonError {}

  /**
   * @private
   */
  class InvalidUnitError extends LuxonError {
    constructor(unit) {
      super(`Invalid unit ${unit}`);
    }
  }

  /**
   * @private
   */
  class InvalidArgumentError extends LuxonError {}

  /**
   * @private
   */
  class ZoneIsAbstractError extends LuxonError {
    constructor() {
      super("Zone is an abstract class");
    }
  }

  /**
   * @private
   */

  const n = "numeric",
    s$1 = "short",
    l = "long";

  const DATE_SHORT = {
    year: n,
    month: n,
    day: n,
  };

  const DATE_MED = {
    year: n,
    month: s$1,
    day: n,
  };

  const DATE_MED_WITH_WEEKDAY = {
    year: n,
    month: s$1,
    day: n,
    weekday: s$1,
  };

  const DATE_FULL = {
    year: n,
    month: l,
    day: n,
  };

  const DATE_HUGE = {
    year: n,
    month: l,
    day: n,
    weekday: l,
  };

  const TIME_SIMPLE = {
    hour: n,
    minute: n,
  };

  const TIME_WITH_SECONDS = {
    hour: n,
    minute: n,
    second: n,
  };

  const TIME_WITH_SHORT_OFFSET = {
    hour: n,
    minute: n,
    second: n,
    timeZoneName: s$1,
  };

  const TIME_WITH_LONG_OFFSET = {
    hour: n,
    minute: n,
    second: n,
    timeZoneName: l,
  };

  const TIME_24_SIMPLE = {
    hour: n,
    minute: n,
    hourCycle: "h23",
  };

  const TIME_24_WITH_SECONDS = {
    hour: n,
    minute: n,
    second: n,
    hourCycle: "h23",
  };

  const TIME_24_WITH_SHORT_OFFSET = {
    hour: n,
    minute: n,
    second: n,
    hourCycle: "h23",
    timeZoneName: s$1,
  };

  const TIME_24_WITH_LONG_OFFSET = {
    hour: n,
    minute: n,
    second: n,
    hourCycle: "h23",
    timeZoneName: l,
  };

  const DATETIME_SHORT = {
    year: n,
    month: n,
    day: n,
    hour: n,
    minute: n,
  };

  const DATETIME_SHORT_WITH_SECONDS = {
    year: n,
    month: n,
    day: n,
    hour: n,
    minute: n,
    second: n,
  };

  const DATETIME_MED = {
    year: n,
    month: s$1,
    day: n,
    hour: n,
    minute: n,
  };

  const DATETIME_MED_WITH_SECONDS = {
    year: n,
    month: s$1,
    day: n,
    hour: n,
    minute: n,
    second: n,
  };

  const DATETIME_MED_WITH_WEEKDAY = {
    year: n,
    month: s$1,
    day: n,
    weekday: s$1,
    hour: n,
    minute: n,
  };

  const DATETIME_FULL = {
    year: n,
    month: l,
    day: n,
    hour: n,
    minute: n,
    timeZoneName: s$1,
  };

  const DATETIME_FULL_WITH_SECONDS = {
    year: n,
    month: l,
    day: n,
    hour: n,
    minute: n,
    second: n,
    timeZoneName: s$1,
  };

  const DATETIME_HUGE = {
    year: n,
    month: l,
    day: n,
    weekday: l,
    hour: n,
    minute: n,
    timeZoneName: l,
  };

  const DATETIME_HUGE_WITH_SECONDS = {
    year: n,
    month: l,
    day: n,
    weekday: l,
    hour: n,
    minute: n,
    second: n,
    timeZoneName: l,
  };

  /**
   * @interface
   */
  class Zone {
    /**
     * The type of zone
     * @abstract
     * @type {string}
     */
    get type() {
      throw new ZoneIsAbstractError();
    }

    /**
     * The name of this zone.
     * @abstract
     * @type {string}
     */
    get name() {
      throw new ZoneIsAbstractError();
    }

    get ianaName() {
      return this.name;
    }

    /**
     * Returns whether the offset is known to be fixed for the whole year.
     * @abstract
     * @type {boolean}
     */
    get isUniversal() {
      throw new ZoneIsAbstractError();
    }

    /**
     * Returns the offset's common name (such as EST) at the specified timestamp
     * @abstract
     * @param {number} ts - Epoch milliseconds for which to get the name
     * @param {Object} opts - Options to affect the format
     * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
     * @param {string} opts.locale - What locale to return the offset name in.
     * @return {string}
     */
    offsetName(ts, opts) {
      throw new ZoneIsAbstractError();
    }

    /**
     * Returns the offset's value as a string
     * @abstract
     * @param {number} ts - Epoch milliseconds for which to get the offset
     * @param {string} format - What style of offset to return.
     *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
     * @return {string}
     */
    formatOffset(ts, format) {
      throw new ZoneIsAbstractError();
    }

    /**
     * Return the offset in minutes for this zone at the specified timestamp.
     * @abstract
     * @param {number} ts - Epoch milliseconds for which to compute the offset
     * @return {number}
     */
    offset(ts) {
      throw new ZoneIsAbstractError();
    }

    /**
     * Return whether this Zone is equal to another zone
     * @abstract
     * @param {Zone} otherZone - the zone to compare
     * @return {boolean}
     */
    equals(otherZone) {
      throw new ZoneIsAbstractError();
    }

    /**
     * Return whether this Zone is valid.
     * @abstract
     * @type {boolean}
     */
    get isValid() {
      throw new ZoneIsAbstractError();
    }
  }

  let singleton$1 = null;

  /**
   * Represents the local zone for this JavaScript environment.
   * @implements {Zone}
   */
  class SystemZone extends Zone {
    /**
     * Get a singleton instance of the local zone
     * @return {SystemZone}
     */
    static get instance() {
      if (singleton$1 === null) {
        singleton$1 = new SystemZone();
      }
      return singleton$1;
    }

    /** @override **/
    get type() {
      return "system";
    }

    /** @override **/
    get name() {
      return new Intl.DateTimeFormat().resolvedOptions().timeZone;
    }

    /** @override **/
    get isUniversal() {
      return false;
    }

    /** @override **/
    offsetName(ts, { format, locale }) {
      return parseZoneInfo(ts, format, locale);
    }

    /** @override **/
    formatOffset(ts, format) {
      return formatOffset(this.offset(ts), format);
    }

    /** @override **/
    offset(ts) {
      return -new Date(ts).getTimezoneOffset();
    }

    /** @override **/
    equals(otherZone) {
      return otherZone.type === "system";
    }

    /** @override **/
    get isValid() {
      return true;
    }
  }

  let dtfCache = {};
  function makeDTF(zone) {
    if (!dtfCache[zone]) {
      dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
        hour12: false,
        timeZone: zone,
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        era: "short",
      });
    }
    return dtfCache[zone];
  }

  const typeToPos = {
    year: 0,
    month: 1,
    day: 2,
    era: 3,
    hour: 4,
    minute: 5,
    second: 6,
  };

  function hackyOffset(dtf, date) {
    const formatted = dtf.format(date).replace(/\u200E/g, ""),
      parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted),
      [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
    return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
  }

  function partsOffset(dtf, date) {
    const formatted = dtf.formatToParts(date);
    const filled = [];
    for (let i = 0; i < formatted.length; i++) {
      const { type, value } = formatted[i];
      const pos = typeToPos[type];

      if (type === "era") {
        filled[pos] = value;
      } else if (!isUndefined(pos)) {
        filled[pos] = parseInt(value, 10);
      }
    }
    return filled;
  }

  let ianaZoneCache = {};
  /**
   * A zone identified by an IANA identifier, like America/New_York
   * @implements {Zone}
   */
  class IANAZone extends Zone {
    /**
     * @param {string} name - Zone name
     * @return {IANAZone}
     */
    static create(name) {
      if (!ianaZoneCache[name]) {
        ianaZoneCache[name] = new IANAZone(name);
      }
      return ianaZoneCache[name];
    }

    /**
     * Reset local caches. Should only be necessary in testing scenarios.
     * @return {void}
     */
    static resetCache() {
      ianaZoneCache = {};
      dtfCache = {};
    }

    /**
     * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
     * @param {string} s - The string to check validity on
     * @example IANAZone.isValidSpecifier("America/New_York") //=> true
     * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
     * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
     * @return {boolean}
     */
    static isValidSpecifier(s) {
      return this.isValidZone(s);
    }

    /**
     * Returns whether the provided string identifies a real zone
     * @param {string} zone - The string to check
     * @example IANAZone.isValidZone("America/New_York") //=> true
     * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
     * @example IANAZone.isValidZone("Sport~~blorp") //=> false
     * @return {boolean}
     */
    static isValidZone(zone) {
      if (!zone) {
        return false;
      }
      try {
        new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
        return true;
      } catch (e) {
        return false;
      }
    }

    constructor(name) {
      super();
      /** @private **/
      this.zoneName = name;
      /** @private **/
      this.valid = IANAZone.isValidZone(name);
    }

    /** @override **/
    get type() {
      return "iana";
    }

    /** @override **/
    get name() {
      return this.zoneName;
    }

    /** @override **/
    get isUniversal() {
      return false;
    }

    /** @override **/
    offsetName(ts, { format, locale }) {
      return parseZoneInfo(ts, format, locale, this.name);
    }

    /** @override **/
    formatOffset(ts, format) {
      return formatOffset(this.offset(ts), format);
    }

    /** @override **/
    offset(ts) {
      const date = new Date(ts);

      if (isNaN(date)) return NaN;

      const dtf = makeDTF(this.name);
      let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts
        ? partsOffset(dtf, date)
        : hackyOffset(dtf, date);

      if (adOrBc === "BC") {
        year = -Math.abs(year) + 1;
      }

      // because we're using hour12 and https://bugs.chromium.org/p/chromium/issues/detail?id=1025564&can=2&q=%2224%3A00%22%20datetimeformat
      const adjustedHour = hour === 24 ? 0 : hour;

      const asUTC = objToLocalTS({
        year,
        month,
        day,
        hour: adjustedHour,
        minute,
        second,
        millisecond: 0,
      });

      let asTS = +date;
      const over = asTS % 1000;
      asTS -= over >= 0 ? over : 1000 + over;
      return (asUTC - asTS) / (60 * 1000);
    }

    /** @override **/
    equals(otherZone) {
      return otherZone.type === "iana" && otherZone.name === this.name;
    }

    /** @override **/
    get isValid() {
      return this.valid;
    }
  }

  // todo - remap caching

  let intlLFCache = {};
  function getCachedLF(locString, opts = {}) {
    const key = JSON.stringify([locString, opts]);
    let dtf = intlLFCache[key];
    if (!dtf) {
      dtf = new Intl.ListFormat(locString, opts);
      intlLFCache[key] = dtf;
    }
    return dtf;
  }

  let intlDTCache = {};
  function getCachedDTF(locString, opts = {}) {
    const key = JSON.stringify([locString, opts]);
    let dtf = intlDTCache[key];
    if (!dtf) {
      dtf = new Intl.DateTimeFormat(locString, opts);
      intlDTCache[key] = dtf;
    }
    return dtf;
  }

  let intlNumCache = {};
  function getCachedINF(locString, opts = {}) {
    const key = JSON.stringify([locString, opts]);
    let inf = intlNumCache[key];
    if (!inf) {
      inf = new Intl.NumberFormat(locString, opts);
      intlNumCache[key] = inf;
    }
    return inf;
  }

  let intlRelCache = {};
  function getCachedRTF(locString, opts = {}) {
    const { base, ...cacheKeyOpts } = opts; // exclude `base` from the options
    const key = JSON.stringify([locString, cacheKeyOpts]);
    let inf = intlRelCache[key];
    if (!inf) {
      inf = new Intl.RelativeTimeFormat(locString, opts);
      intlRelCache[key] = inf;
    }
    return inf;
  }

  let sysLocaleCache = null;
  function systemLocale() {
    if (sysLocaleCache) {
      return sysLocaleCache;
    } else {
      sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
      return sysLocaleCache;
    }
  }

  function parseLocaleString(localeStr) {
    // I really want to avoid writing a BCP 47 parser
    // see, e.g. https://github.com/wooorm/bcp-47
    // Instead, we'll do this:

    // a) if the string has no -u extensions, just leave it alone
    // b) if it does, use Intl to resolve everything
    // c) if Intl fails, try again without the -u

    // private subtags and unicode subtags have ordering requirements,
    // and we're not properly parsing this, so just strip out the
    // private ones if they exist.
    const xIndex = localeStr.indexOf("-x-");
    if (xIndex !== -1) {
      localeStr = localeStr.substring(0, xIndex);
    }

    const uIndex = localeStr.indexOf("-u-");
    if (uIndex === -1) {
      return [localeStr];
    } else {
      let options;
      let selectedStr;
      try {
        options = getCachedDTF(localeStr).resolvedOptions();
        selectedStr = localeStr;
      } catch (e) {
        const smaller = localeStr.substring(0, uIndex);
        options = getCachedDTF(smaller).resolvedOptions();
        selectedStr = smaller;
      }

      const { numberingSystem, calendar } = options;
      return [selectedStr, numberingSystem, calendar];
    }
  }

  function intlConfigString(localeStr, numberingSystem, outputCalendar) {
    if (outputCalendar || numberingSystem) {
      if (!localeStr.includes("-u-")) {
        localeStr += "-u";
      }

      if (outputCalendar) {
        localeStr += `-ca-${outputCalendar}`;
      }

      if (numberingSystem) {
        localeStr += `-nu-${numberingSystem}`;
      }
      return localeStr;
    } else {
      return localeStr;
    }
  }

  function mapMonths(f) {
    const ms = [];
    for (let i = 1; i <= 12; i++) {
      const dt = DateTime$1.utc(2016, i, 1);
      ms.push(f(dt));
    }
    return ms;
  }

  function mapWeekdays(f) {
    const ms = [];
    for (let i = 1; i <= 7; i++) {
      const dt = DateTime$1.utc(2016, 11, 13 + i);
      ms.push(f(dt));
    }
    return ms;
  }

  function listStuff(loc, length, defaultOK, englishFn, intlFn) {
    const mode = loc.listingMode(defaultOK);

    if (mode === "error") {
      return null;
    } else if (mode === "en") {
      return englishFn(length);
    } else {
      return intlFn(length);
    }
  }

  function supportsFastNumbers(loc) {
    if (loc.numberingSystem && loc.numberingSystem !== "latn") {
      return false;
    } else {
      return (
        loc.numberingSystem === "latn" ||
        !loc.locale ||
        loc.locale.startsWith("en") ||
        new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn"
      );
    }
  }

  /**
   * @private
   */

  class PolyNumberFormatter {
    constructor(intl, forceSimple, opts) {
      this.padTo = opts.padTo || 0;
      this.floor = opts.floor || false;

      const { padTo, floor, ...otherOpts } = opts;

      if (!forceSimple || Object.keys(otherOpts).length > 0) {
        const intlOpts = { useGrouping: false, ...opts };
        if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;
        this.inf = getCachedINF(intl, intlOpts);
      }
    }

    format(i) {
      if (this.inf) {
        const fixed = this.floor ? Math.floor(i) : i;
        return this.inf.format(fixed);
      } else {
        // to match the browser's numberformatter defaults
        const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
        return padStart$1(fixed, this.padTo);
      }
    }
  }

  /**
   * @private
   */

  class PolyDateFormatter {
    constructor(dt, intl, opts) {
      this.opts = opts;
      this.originalZone = undefined;

      let z = undefined;
      if (this.opts.timeZone) {
        // Don't apply any workarounds if a timeZone is explicitly provided in opts
        this.dt = dt;
      } else if (dt.zone.type === "fixed") {
        // UTC-8 or Etc/UTC-8 are not part of tzdata, only Etc/GMT+8 and the like.
        // That is why fixed-offset TZ is set to that unless it is:
        // 1. Representing offset 0 when UTC is used to maintain previous behavior and does not become GMT.
        // 2. Unsupported by the browser:
        //    - some do not support Etc/
        //    - < Etc/GMT-14, > Etc/GMT+12, and 30-minute or 45-minute offsets are not part of tzdata
        const gmtOffset = -1 * (dt.offset / 60);
        const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
        if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
          z = offsetZ;
          this.dt = dt;
        } else {
          // Not all fixed-offset zones like Etc/+4:30 are present in tzdata so
          // we manually apply the offset and substitute the zone as needed.
          z = "UTC";
          this.dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({ minutes: dt.offset });
          this.originalZone = dt.zone;
        }
      } else if (dt.zone.type === "system") {
        this.dt = dt;
      } else if (dt.zone.type === "iana") {
        this.dt = dt;
        z = dt.zone.name;
      } else {
        // Custom zones can have any offset / offsetName so we just manually
        // apply the offset and substitute the zone as needed.
        z = "UTC";
        this.dt = dt.setZone("UTC").plus({ minutes: dt.offset });
        this.originalZone = dt.zone;
      }

      const intlOpts = { ...this.opts };
      intlOpts.timeZone = intlOpts.timeZone || z;
      this.dtf = getCachedDTF(intl, intlOpts);
    }

    format() {
      if (this.originalZone) {
        // If we have to substitute in the actual zone name, we have to use
        // formatToParts so that the timezone can be replaced.
        return this.formatToParts()
          .map(({ value }) => value)
          .join("");
      }
      return this.dtf.format(this.dt.toJSDate());
    }

    formatToParts() {
      const parts = this.dtf.formatToParts(this.dt.toJSDate());
      if (this.originalZone) {
        return parts.map((part) => {
          if (part.type === "timeZoneName") {
            const offsetName = this.originalZone.offsetName(this.dt.ts, {
              locale: this.dt.locale,
              format: this.opts.timeZoneName,
            });
            return {
              ...part,
              value: offsetName,
            };
          } else {
            return part;
          }
        });
      }
      return parts;
    }

    resolvedOptions() {
      return this.dtf.resolvedOptions();
    }
  }

  /**
   * @private
   */
  class PolyRelFormatter {
    constructor(intl, isEnglish, opts) {
      this.opts = { style: "long", ...opts };
      if (!isEnglish && hasRelative()) {
        this.rtf = getCachedRTF(intl, opts);
      }
    }

    format(count, unit) {
      if (this.rtf) {
        return this.rtf.format(count, unit);
      } else {
        return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
      }
    }

    formatToParts(count, unit) {
      if (this.rtf) {
        return this.rtf.formatToParts(count, unit);
      } else {
        return [];
      }
    }
  }

  /**
   * @private
   */

  class Locale {
    static fromOpts(opts) {
      return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
    }

    static create(locale, numberingSystem, outputCalendar, defaultToEN = false) {
      const specifiedLocale = locale || Settings.defaultLocale;
      // the system locale is useful for human readable strings but annoying for parsing/formatting known formats
      const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
      const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
      const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
      return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
    }

    static resetCache() {
      sysLocaleCache = null;
      intlDTCache = {};
      intlNumCache = {};
      intlRelCache = {};
    }

    static fromObject({ locale, numberingSystem, outputCalendar } = {}) {
      return Locale.create(locale, numberingSystem, outputCalendar);
    }

    constructor(locale, numbering, outputCalendar, specifiedLocale) {
      const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);

      this.locale = parsedLocale;
      this.numberingSystem = numbering || parsedNumberingSystem || null;
      this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
      this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);

      this.weekdaysCache = { format: {}, standalone: {} };
      this.monthsCache = { format: {}, standalone: {} };
      this.meridiemCache = null;
      this.eraCache = {};

      this.specifiedLocale = specifiedLocale;
      this.fastNumbersCached = null;
    }

    get fastNumbers() {
      if (this.fastNumbersCached == null) {
        this.fastNumbersCached = supportsFastNumbers(this);
      }

      return this.fastNumbersCached;
    }

    listingMode() {
      const isActuallyEn = this.isEnglish();
      const hasNoWeirdness =
        (this.numberingSystem === null || this.numberingSystem === "latn") &&
        (this.outputCalendar === null || this.outputCalendar === "gregory");
      return isActuallyEn && hasNoWeirdness ? "en" : "intl";
    }

    clone(alts) {
      if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
        return this;
      } else {
        return Locale.create(
          alts.locale || this.specifiedLocale,
          alts.numberingSystem || this.numberingSystem,
          alts.outputCalendar || this.outputCalendar,
          alts.defaultToEN || false
        );
      }
    }

    redefaultToEN(alts = {}) {
      return this.clone({ ...alts, defaultToEN: true });
    }

    redefaultToSystem(alts = {}) {
      return this.clone({ ...alts, defaultToEN: false });
    }

    months(length, format = false, defaultOK = true) {
      return listStuff(this, length, defaultOK, months, () => {
        const intl = format ? { month: length, day: "numeric" } : { month: length },
          formatStr = format ? "format" : "standalone";
        if (!this.monthsCache[formatStr][length]) {
          this.monthsCache[formatStr][length] = mapMonths((dt) => this.extract(dt, intl, "month"));
        }
        return this.monthsCache[formatStr][length];
      });
    }

    weekdays(length, format = false, defaultOK = true) {
      return listStuff(this, length, defaultOK, weekdays, () => {
        const intl = format
            ? { weekday: length, year: "numeric", month: "long", day: "numeric" }
            : { weekday: length },
          formatStr = format ? "format" : "standalone";
        if (!this.weekdaysCache[formatStr][length]) {
          this.weekdaysCache[formatStr][length] = mapWeekdays((dt) =>
            this.extract(dt, intl, "weekday")
          );
        }
        return this.weekdaysCache[formatStr][length];
      });
    }

    meridiems(defaultOK = true) {
      return listStuff(
        this,
        undefined,
        defaultOK,
        () => meridiems,
        () => {
          // In theory there could be aribitrary day periods. We're gonna assume there are exactly two
          // for AM and PM. This is probably wrong, but it's makes parsing way easier.
          if (!this.meridiemCache) {
            const intl = { hour: "numeric", hourCycle: "h12" };
            this.meridiemCache = [DateTime$1.utc(2016, 11, 13, 9), DateTime$1.utc(2016, 11, 13, 19)].map(
              (dt) => this.extract(dt, intl, "dayperiod")
            );
          }

          return this.meridiemCache;
        }
      );
    }

    eras(length, defaultOK = true) {
      return listStuff(this, length, defaultOK, eras, () => {
        const intl = { era: length };

        // This is problematic. Different calendars are going to define eras totally differently. What I need is the minimum set of dates
        // to definitely enumerate them.
        if (!this.eraCache[length]) {
          this.eraCache[length] = [DateTime$1.utc(-40, 1, 1), DateTime$1.utc(2017, 1, 1)].map((dt) =>
            this.extract(dt, intl, "era")
          );
        }

        return this.eraCache[length];
      });
    }

    extract(dt, intlOpts, field) {
      const df = this.dtFormatter(dt, intlOpts),
        results = df.formatToParts(),
        matching = results.find((m) => m.type.toLowerCase() === field);
      return matching ? matching.value : null;
    }

    numberFormatter(opts = {}) {
      // this forcesimple option is never used (the only caller short-circuits on it, but it seems safer to leave)
      // (in contrast, the rest of the condition is used heavily)
      return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
    }

    dtFormatter(dt, intlOpts = {}) {
      return new PolyDateFormatter(dt, this.intl, intlOpts);
    }

    relFormatter(opts = {}) {
      return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
    }

    listFormatter(opts = {}) {
      return getCachedLF(this.intl, opts);
    }

    isEnglish() {
      return (
        this.locale === "en" ||
        this.locale.toLowerCase() === "en-us" ||
        new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us")
      );
    }

    equals(other) {
      return (
        this.locale === other.locale &&
        this.numberingSystem === other.numberingSystem &&
        this.outputCalendar === other.outputCalendar
      );
    }
  }

  let singleton = null;

  /**
   * A zone with a fixed offset (meaning no DST)
   * @implements {Zone}
   */
  class FixedOffsetZone extends Zone {
    /**
     * Get a singleton instance of UTC
     * @return {FixedOffsetZone}
     */
    static get utcInstance() {
      if (singleton === null) {
        singleton = new FixedOffsetZone(0);
      }
      return singleton;
    }

    /**
     * Get an instance with a specified offset
     * @param {number} offset - The offset in minutes
     * @return {FixedOffsetZone}
     */
    static instance(offset) {
      return offset === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset);
    }

    /**
     * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
     * @param {string} s - The offset string to parse
     * @example FixedOffsetZone.parseSpecifier("UTC+6")
     * @example FixedOffsetZone.parseSpecifier("UTC+06")
     * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
     * @return {FixedOffsetZone}
     */
    static parseSpecifier(s) {
      if (s) {
        const r = s.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
        if (r) {
          return new FixedOffsetZone(signedOffset(r[1], r[2]));
        }
      }
      return null;
    }

    constructor(offset) {
      super();
      /** @private **/
      this.fixed = offset;
    }

    /** @override **/
    get type() {
      return "fixed";
    }

    /** @override **/
    get name() {
      return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
    }

    get ianaName() {
      if (this.fixed === 0) {
        return "Etc/UTC";
      } else {
        return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
      }
    }

    /** @override **/
    offsetName() {
      return this.name;
    }

    /** @override **/
    formatOffset(ts, format) {
      return formatOffset(this.fixed, format);
    }

    /** @override **/
    get isUniversal() {
      return true;
    }

    /** @override **/
    offset() {
      return this.fixed;
    }

    /** @override **/
    equals(otherZone) {
      return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
    }

    /** @override **/
    get isValid() {
      return true;
    }
  }

  /**
   * A zone that failed to parse. You should never need to instantiate this.
   * @implements {Zone}
   */
  class InvalidZone extends Zone {
    constructor(zoneName) {
      super();
      /**  @private */
      this.zoneName = zoneName;
    }

    /** @override **/
    get type() {
      return "invalid";
    }

    /** @override **/
    get name() {
      return this.zoneName;
    }

    /** @override **/
    get isUniversal() {
      return false;
    }

    /** @override **/
    offsetName() {
      return null;
    }

    /** @override **/
    formatOffset() {
      return "";
    }

    /** @override **/
    offset() {
      return NaN;
    }

    /** @override **/
    equals() {
      return false;
    }

    /** @override **/
    get isValid() {
      return false;
    }
  }

  /**
   * @private
   */

  function normalizeZone(input, defaultZone) {
    if (isUndefined(input) || input === null) {
      return defaultZone;
    } else if (input instanceof Zone) {
      return input;
    } else if (isString(input)) {
      const lowered = input.toLowerCase();
      if (lowered === "default") return defaultZone;
      else if (lowered === "local" || lowered === "system") return SystemZone.instance;
      else if (lowered === "utc" || lowered === "gmt") return FixedOffsetZone.utcInstance;
      else return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
    } else if (isNumber$1(input)) {
      return FixedOffsetZone.instance(input);
    } else if (typeof input === "object" && input.offset && typeof input.offset === "number") {
      // This is dumb, but the instanceof check above doesn't seem to really work
      // so we're duck checking it
      return input;
    } else {
      return new InvalidZone(input);
    }
  }

  let now = () => Date.now(),
    defaultZone = "system",
    defaultLocale = null,
    defaultNumberingSystem = null,
    defaultOutputCalendar = null,
    twoDigitCutoffYear = 60,
    throwOnInvalid;

  /**
   * Settings contains static getters and setters that control Luxon's overall behavior. Luxon is a simple library with few options, but the ones it does have live here.
   */
  class Settings {
    /**
     * Get the callback for returning the current timestamp.
     * @type {function}
     */
    static get now() {
      return now;
    }

    /**
     * Set the callback for returning the current timestamp.
     * The function should return a number, which will be interpreted as an Epoch millisecond count
     * @type {function}
     * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
     * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
     */
    static set now(n) {
      now = n;
    }

    /**
     * Set the default time zone to create DateTimes in. Does not affect existing instances.
     * Use the value "system" to reset this value to the system's time zone.
     * @type {string}
     */
    static set defaultZone(zone) {
      defaultZone = zone;
    }

    /**
     * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
     * The default value is the system's time zone (the one set on the machine that runs this code).
     * @type {Zone}
     */
    static get defaultZone() {
      return normalizeZone(defaultZone, SystemZone.instance);
    }

    /**
     * Get the default locale to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static get defaultLocale() {
      return defaultLocale;
    }

    /**
     * Set the default locale to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static set defaultLocale(locale) {
      defaultLocale = locale;
    }

    /**
     * Get the default numbering system to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static get defaultNumberingSystem() {
      return defaultNumberingSystem;
    }

    /**
     * Set the default numbering system to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static set defaultNumberingSystem(numberingSystem) {
      defaultNumberingSystem = numberingSystem;
    }

    /**
     * Get the default output calendar to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static get defaultOutputCalendar() {
      return defaultOutputCalendar;
    }

    /**
     * Set the default output calendar to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static set defaultOutputCalendar(outputCalendar) {
      defaultOutputCalendar = outputCalendar;
    }

    /**
     * Get the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
     * @type {number}
     */
    static get twoDigitCutoffYear() {
      return twoDigitCutoffYear;
    }

    /**
     * Set the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
     * @type {number}
     * @example Settings.twoDigitCutoffYear = 0 // cut-off year is 0, so all 'yy' are interpretted as current century
     * @example Settings.twoDigitCutoffYear = 50 // '49' -> 1949; '50' -> 2050
     * @example Settings.twoDigitCutoffYear = 1950 // interpretted as 50
     * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpretted as 50
     */
    static set twoDigitCutoffYear(cutoffYear) {
      twoDigitCutoffYear = cutoffYear % 100;
    }

    /**
     * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
     * @type {boolean}
     */
    static get throwOnInvalid() {
      return throwOnInvalid;
    }

    /**
     * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
     * @type {boolean}
     */
    static set throwOnInvalid(t) {
      throwOnInvalid = t;
    }

    /**
     * Reset Luxon's global caches. Should only be necessary in testing scenarios.
     * @return {void}
     */
    static resetCaches() {
      Locale.resetCache();
      IANAZone.resetCache();
    }
  }

  /*
    This is just a junk drawer, containing anything used across multiple classes.
    Because Luxon is small(ish), this should stay small and we won't worry about splitting
    it up into, say, parsingUtil.js and basicUtil.js and so on. But they are divided up by feature area.
  */

  /**
   * @private
   */

  // TYPES

  function isUndefined(o) {
    return typeof o === "undefined";
  }

  function isNumber$1(o) {
    return typeof o === "number";
  }

  function isInteger(o) {
    return typeof o === "number" && o % 1 === 0;
  }

  function isString(o) {
    return typeof o === "string";
  }

  function isDate(o) {
    return Object.prototype.toString.call(o) === "[object Date]";
  }

  // CAPABILITIES

  function hasRelative() {
    try {
      return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
    } catch (e) {
      return false;
    }
  }

  // OBJECTS AND ARRAYS

  function maybeArray(thing) {
    return Array.isArray(thing) ? thing : [thing];
  }

  function bestBy(arr, by, compare) {
    if (arr.length === 0) {
      return undefined;
    }
    return arr.reduce((best, next) => {
      const pair = [by(next), next];
      if (!best) {
        return pair;
      } else if (compare(best[0], pair[0]) === best[0]) {
        return best;
      } else {
        return pair;
      }
    }, null)[1];
  }

  function pick(obj, keys) {
    return keys.reduce((a, k) => {
      a[k] = obj[k];
      return a;
    }, {});
  }

  function hasOwnProperty$1(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  // NUMBERS AND STRINGS

  function integerBetween(thing, bottom, top) {
    return isInteger(thing) && thing >= bottom && thing <= top;
  }

  // x % n but takes the sign of n instead of x
  function floorMod(x, n) {
    return x - n * Math.floor(x / n);
  }

  function padStart$1(input, n = 2) {
    const isNeg = input < 0;
    let padded;
    if (isNeg) {
      padded = "-" + ("" + -input).padStart(n, "0");
    } else {
      padded = ("" + input).padStart(n, "0");
    }
    return padded;
  }

  function parseInteger(string) {
    if (isUndefined(string) || string === null || string === "") {
      return undefined;
    } else {
      return parseInt(string, 10);
    }
  }

  function parseFloating(string) {
    if (isUndefined(string) || string === null || string === "") {
      return undefined;
    } else {
      return parseFloat(string);
    }
  }

  function parseMillis(fraction) {
    // Return undefined (instead of 0) in these cases, where fraction is not set
    if (isUndefined(fraction) || fraction === null || fraction === "") {
      return undefined;
    } else {
      const f = parseFloat("0." + fraction) * 1000;
      return Math.floor(f);
    }
  }

  function roundTo(number, digits, towardZero = false) {
    const factor = 10 ** digits,
      rounder = towardZero ? Math.trunc : Math.round;
    return rounder(number * factor) / factor;
  }

  // DATE BASICS

  function isLeapYear(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  }

  function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
  }

  function daysInMonth(year, month) {
    const modMonth = floorMod(month - 1, 12) + 1,
      modYear = year + (month - modMonth) / 12;

    if (modMonth === 2) {
      return isLeapYear(modYear) ? 29 : 28;
    } else {
      return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
    }
  }

  // covert a calendar object to a local timestamp (epoch, but with the offset baked in)
  function objToLocalTS(obj) {
    let d = Date.UTC(
      obj.year,
      obj.month - 1,
      obj.day,
      obj.hour,
      obj.minute,
      obj.second,
      obj.millisecond
    );

    // for legacy reasons, years between 0 and 99 are interpreted as 19XX; revert that
    if (obj.year < 100 && obj.year >= 0) {
      d = new Date(d);
      // set the month and day again, this is necessary because year 2000 is a leap year, but year 100 is not
      // so if obj.year is in 99, but obj.day makes it roll over into year 100,
      // the calculations done by Date.UTC are using year 2000 - which is incorrect
      d.setUTCFullYear(obj.year, obj.month - 1, obj.day);
    }
    return +d;
  }

  function weeksInWeekYear(weekYear) {
    const p1 =
        (weekYear +
          Math.floor(weekYear / 4) -
          Math.floor(weekYear / 100) +
          Math.floor(weekYear / 400)) %
        7,
      last = weekYear - 1,
      p2 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
    return p1 === 4 || p2 === 3 ? 53 : 52;
  }

  function untruncateYear(year) {
    if (year > 99) {
      return year;
    } else return year > Settings.twoDigitCutoffYear ? 1900 + year : 2000 + year;
  }

  // PARSING

  function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
    const date = new Date(ts),
      intlOpts = {
        hourCycle: "h23",
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
      };

    if (timeZone) {
      intlOpts.timeZone = timeZone;
    }

    const modified = { timeZoneName: offsetFormat, ...intlOpts };

    const parsed = new Intl.DateTimeFormat(locale, modified)
      .formatToParts(date)
      .find((m) => m.type.toLowerCase() === "timezonename");
    return parsed ? parsed.value : null;
  }

  // signedOffset('-5', '30') -> -330
  function signedOffset(offHourStr, offMinuteStr) {
    let offHour = parseInt(offHourStr, 10);

    // don't || this because we want to preserve -0
    if (Number.isNaN(offHour)) {
      offHour = 0;
    }

    const offMin = parseInt(offMinuteStr, 10) || 0,
      offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
    return offHour * 60 + offMinSigned;
  }

  // COERCION

  function asNumber(value) {
    const numericValue = Number(value);
    if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
      throw new InvalidArgumentError(`Invalid unit value ${value}`);
    return numericValue;
  }

  function normalizeObject(obj, normalizer) {
    const normalized = {};
    for (const u in obj) {
      if (hasOwnProperty$1(obj, u)) {
        const v = obj[u];
        if (v === undefined || v === null) continue;
        normalized[normalizer(u)] = asNumber(v);
      }
    }
    return normalized;
  }

  function formatOffset(offset, format) {
    const hours = Math.trunc(Math.abs(offset / 60)),
      minutes = Math.trunc(Math.abs(offset % 60)),
      sign = offset >= 0 ? "+" : "-";

    switch (format) {
      case "short":
        return `${sign}${padStart$1(hours, 2)}:${padStart$1(minutes, 2)}`;
      case "narrow":
        return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
      case "techie":
        return `${sign}${padStart$1(hours, 2)}${padStart$1(minutes, 2)}`;
      default:
        throw new RangeError(`Value format ${format} is out of range for property format`);
    }
  }

  function timeObject(obj) {
    return pick(obj, ["hour", "minute", "second", "millisecond"]);
  }

  /**
   * @private
   */

  const monthsLong = [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December",
  ];

  const monthsShort = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec",
  ];

  const monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];

  function months(length) {
    switch (length) {
      case "narrow":
        return [...monthsNarrow];
      case "short":
        return [...monthsShort];
      case "long":
        return [...monthsLong];
      case "numeric":
        return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
      case "2-digit":
        return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
      default:
        return null;
    }
  }

  const weekdaysLong = [
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday",
    "Sunday",
  ];

  const weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];

  const weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];

  function weekdays(length) {
    switch (length) {
      case "narrow":
        return [...weekdaysNarrow];
      case "short":
        return [...weekdaysShort];
      case "long":
        return [...weekdaysLong];
      case "numeric":
        return ["1", "2", "3", "4", "5", "6", "7"];
      default:
        return null;
    }
  }

  const meridiems = ["AM", "PM"];

  const erasLong = ["Before Christ", "Anno Domini"];

  const erasShort = ["BC", "AD"];

  const erasNarrow = ["B", "A"];

  function eras(length) {
    switch (length) {
      case "narrow":
        return [...erasNarrow];
      case "short":
        return [...erasShort];
      case "long":
        return [...erasLong];
      default:
        return null;
    }
  }

  function meridiemForDateTime(dt) {
    return meridiems[dt.hour < 12 ? 0 : 1];
  }

  function weekdayForDateTime(dt, length) {
    return weekdays(length)[dt.weekday - 1];
  }

  function monthForDateTime(dt, length) {
    return months(length)[dt.month - 1];
  }

  function eraForDateTime(dt, length) {
    return eras(length)[dt.year < 0 ? 0 : 1];
  }

  function formatRelativeTime(unit, count, numeric = "always", narrow = false) {
    const units = {
      years: ["year", "yr."],
      quarters: ["quarter", "qtr."],
      months: ["month", "mo."],
      weeks: ["week", "wk."],
      days: ["day", "day", "days"],
      hours: ["hour", "hr."],
      minutes: ["minute", "min."],
      seconds: ["second", "sec."],
    };

    const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;

    if (numeric === "auto" && lastable) {
      const isDay = unit === "days";
      switch (count) {
        case 1:
          return isDay ? "tomorrow" : `next ${units[unit][0]}`;
        case -1:
          return isDay ? "yesterday" : `last ${units[unit][0]}`;
        case 0:
          return isDay ? "today" : `this ${units[unit][0]}`;
      }
    }

    const isInPast = Object.is(count, -0) || count < 0,
      fmtValue = Math.abs(count),
      singular = fmtValue === 1,
      lilUnits = units[unit],
      fmtUnit = narrow
        ? singular
          ? lilUnits[1]
          : lilUnits[2] || lilUnits[1]
        : singular
        ? units[unit][0]
        : unit;
    return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
  }

  function stringifyTokens(splits, tokenToString) {
    let s = "";
    for (const token of splits) {
      if (token.literal) {
        s += token.val;
      } else {
        s += tokenToString(token.val);
      }
    }
    return s;
  }

  const macroTokenToFormatOpts = {
    D: DATE_SHORT,
    DD: DATE_MED,
    DDD: DATE_FULL,
    DDDD: DATE_HUGE,
    t: TIME_SIMPLE,
    tt: TIME_WITH_SECONDS,
    ttt: TIME_WITH_SHORT_OFFSET,
    tttt: TIME_WITH_LONG_OFFSET,
    T: TIME_24_SIMPLE,
    TT: TIME_24_WITH_SECONDS,
    TTT: TIME_24_WITH_SHORT_OFFSET,
    TTTT: TIME_24_WITH_LONG_OFFSET,
    f: DATETIME_SHORT,
    ff: DATETIME_MED,
    fff: DATETIME_FULL,
    ffff: DATETIME_HUGE,
    F: DATETIME_SHORT_WITH_SECONDS,
    FF: DATETIME_MED_WITH_SECONDS,
    FFF: DATETIME_FULL_WITH_SECONDS,
    FFFF: DATETIME_HUGE_WITH_SECONDS,
  };

  /**
   * @private
   */

  class Formatter {
    static create(locale, opts = {}) {
      return new Formatter(locale, opts);
    }

    static parseFormat(fmt) {
      // white-space is always considered a literal in user-provided formats
      // the " " token has a special meaning (see unitForToken)

      let current = null,
        currentFull = "",
        bracketed = false;
      const splits = [];
      for (let i = 0; i < fmt.length; i++) {
        const c = fmt.charAt(i);
        if (c === "'") {
          if (currentFull.length > 0) {
            splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
          }
          current = null;
          currentFull = "";
          bracketed = !bracketed;
        } else if (bracketed) {
          currentFull += c;
        } else if (c === current) {
          currentFull += c;
        } else {
          if (currentFull.length > 0) {
            splits.push({ literal: /^\s+$/.test(currentFull), val: currentFull });
          }
          currentFull = c;
          current = c;
        }
      }

      if (currentFull.length > 0) {
        splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
      }

      return splits;
    }

    static macroTokenToFormatOpts(token) {
      return macroTokenToFormatOpts[token];
    }

    constructor(locale, formatOpts) {
      this.opts = formatOpts;
      this.loc = locale;
      this.systemLoc = null;
    }

    formatWithSystemDefault(dt, opts) {
      if (this.systemLoc === null) {
        this.systemLoc = this.loc.redefaultToSystem();
      }
      const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });
      return df.format();
    }

    formatDateTime(dt, opts = {}) {
      const df = this.loc.dtFormatter(dt, { ...this.opts, ...opts });
      return df.format();
    }

    formatDateTimeParts(dt, opts = {}) {
      const df = this.loc.dtFormatter(dt, { ...this.opts, ...opts });
      return df.formatToParts();
    }

    formatInterval(interval, opts = {}) {
      const df = this.loc.dtFormatter(interval.start, { ...this.opts, ...opts });
      return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
    }

    resolvedOptions(dt, opts = {}) {
      const df = this.loc.dtFormatter(dt, { ...this.opts, ...opts });
      return df.resolvedOptions();
    }

    num(n, p = 0) {
      // we get some perf out of doing this here, annoyingly
      if (this.opts.forceSimple) {
        return padStart$1(n, p);
      }

      const opts = { ...this.opts };

      if (p > 0) {
        opts.padTo = p;
      }

      return this.loc.numberFormatter(opts).format(n);
    }

    formatDateTimeFromString(dt, fmt) {
      const knownEnglish = this.loc.listingMode() === "en",
        useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory",
        string = (opts, extract) => this.loc.extract(dt, opts, extract),
        formatOffset = (opts) => {
          if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
            return "Z";
          }

          return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
        },
        meridiem = () =>
          knownEnglish
            ? meridiemForDateTime(dt)
            : string({ hour: "numeric", hourCycle: "h12" }, "dayperiod"),
        month = (length, standalone) =>
          knownEnglish
            ? monthForDateTime(dt, length)
            : string(standalone ? { month: length } : { month: length, day: "numeric" }, "month"),
        weekday = (length, standalone) =>
          knownEnglish
            ? weekdayForDateTime(dt, length)
            : string(
                standalone ? { weekday: length } : { weekday: length, month: "long", day: "numeric" },
                "weekday"
              ),
        maybeMacro = (token) => {
          const formatOpts = Formatter.macroTokenToFormatOpts(token);
          if (formatOpts) {
            return this.formatWithSystemDefault(dt, formatOpts);
          } else {
            return token;
          }
        },
        era = (length) =>
          knownEnglish ? eraForDateTime(dt, length) : string({ era: length }, "era"),
        tokenToString = (token) => {
          // Where possible: http://cldr.unicode.org/translation/date-time-1/date-time#TOC-Standalone-vs.-Format-Styles
          switch (token) {
            // ms
            case "S":
              return this.num(dt.millisecond);
            case "u":
            // falls through
            case "SSS":
              return this.num(dt.millisecond, 3);
            // seconds
            case "s":
              return this.num(dt.second);
            case "ss":
              return this.num(dt.second, 2);
            // fractional seconds
            case "uu":
              return this.num(Math.floor(dt.millisecond / 10), 2);
            case "uuu":
              return this.num(Math.floor(dt.millisecond / 100));
            // minutes
            case "m":
              return this.num(dt.minute);
            case "mm":
              return this.num(dt.minute, 2);
            // hours
            case "h":
              return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
            case "hh":
              return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
            case "H":
              return this.num(dt.hour);
            case "HH":
              return this.num(dt.hour, 2);
            // offset
            case "Z":
              // like +6
              return formatOffset({ format: "narrow", allowZ: this.opts.allowZ });
            case "ZZ":
              // like +06:00
              return formatOffset({ format: "short", allowZ: this.opts.allowZ });
            case "ZZZ":
              // like +0600
              return formatOffset({ format: "techie", allowZ: this.opts.allowZ });
            case "ZZZZ":
              // like EST
              return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
            case "ZZZZZ":
              // like Eastern Standard Time
              return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
            // zone
            case "z":
              // like America/New_York
              return dt.zoneName;
            // meridiems
            case "a":
              return meridiem();
            // dates
            case "d":
              return useDateTimeFormatter ? string({ day: "numeric" }, "day") : this.num(dt.day);
            case "dd":
              return useDateTimeFormatter ? string({ day: "2-digit" }, "day") : this.num(dt.day, 2);
            // weekdays - standalone
            case "c":
              // like 1
              return this.num(dt.weekday);
            case "ccc":
              // like 'Tues'
              return weekday("short", true);
            case "cccc":
              // like 'Tuesday'
              return weekday("long", true);
            case "ccccc":
              // like 'T'
              return weekday("narrow", true);
            // weekdays - format
            case "E":
              // like 1
              return this.num(dt.weekday);
            case "EEE":
              // like 'Tues'
              return weekday("short", false);
            case "EEEE":
              // like 'Tuesday'
              return weekday("long", false);
            case "EEEEE":
              // like 'T'
              return weekday("narrow", false);
            // months - standalone
            case "L":
              // like 1
              return useDateTimeFormatter
                ? string({ month: "numeric", day: "numeric" }, "month")
                : this.num(dt.month);
            case "LL":
              // like 01, doesn't seem to work
              return useDateTimeFormatter
                ? string({ month: "2-digit", day: "numeric" }, "month")
                : this.num(dt.month, 2);
            case "LLL":
              // like Jan
              return month("short", true);
            case "LLLL":
              // like January
              return month("long", true);
            case "LLLLL":
              // like J
              return month("narrow", true);
            // months - format
            case "M":
              // like 1
              return useDateTimeFormatter
                ? string({ month: "numeric" }, "month")
                : this.num(dt.month);
            case "MM":
              // like 01
              return useDateTimeFormatter
                ? string({ month: "2-digit" }, "month")
                : this.num(dt.month, 2);
            case "MMM":
              // like Jan
              return month("short", false);
            case "MMMM":
              // like January
              return month("long", false);
            case "MMMMM":
              // like J
              return month("narrow", false);
            // years
            case "y":
              // like 2014
              return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year);
            case "yy":
              // like 14
              return useDateTimeFormatter
                ? string({ year: "2-digit" }, "year")
                : this.num(dt.year.toString().slice(-2), 2);
            case "yyyy":
              // like 0012
              return useDateTimeFormatter
                ? string({ year: "numeric" }, "year")
                : this.num(dt.year, 4);
            case "yyyyyy":
              // like 000012
              return useDateTimeFormatter
                ? string({ year: "numeric" }, "year")
                : this.num(dt.year, 6);
            // eras
            case "G":
              // like AD
              return era("short");
            case "GG":
              // like Anno Domini
              return era("long");
            case "GGGGG":
              return era("narrow");
            case "kk":
              return this.num(dt.weekYear.toString().slice(-2), 2);
            case "kkkk":
              return this.num(dt.weekYear, 4);
            case "W":
              return this.num(dt.weekNumber);
            case "WW":
              return this.num(dt.weekNumber, 2);
            case "o":
              return this.num(dt.ordinal);
            case "ooo":
              return this.num(dt.ordinal, 3);
            case "q":
              // like 1
              return this.num(dt.quarter);
            case "qq":
              // like 01
              return this.num(dt.quarter, 2);
            case "X":
              return this.num(Math.floor(dt.ts / 1000));
            case "x":
              return this.num(dt.ts);
            default:
              return maybeMacro(token);
          }
        };

      return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
    }

    formatDurationFromString(dur, fmt) {
      const tokenToField = (token) => {
          switch (token[0]) {
            case "S":
              return "millisecond";
            case "s":
              return "second";
            case "m":
              return "minute";
            case "h":
              return "hour";
            case "d":
              return "day";
            case "w":
              return "week";
            case "M":
              return "month";
            case "y":
              return "year";
            default:
              return null;
          }
        },
        tokenToString = (lildur) => (token) => {
          const mapped = tokenToField(token);
          if (mapped) {
            return this.num(lildur.get(mapped), token.length);
          } else {
            return token;
          }
        },
        tokens = Formatter.parseFormat(fmt),
        realTokens = tokens.reduce(
          (found, { literal, val }) => (literal ? found : found.concat(val)),
          []
        ),
        collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t) => t));
      return stringifyTokens(tokens, tokenToString(collapsed));
    }
  }

  class Invalid {
    constructor(reason, explanation) {
      this.reason = reason;
      this.explanation = explanation;
    }

    toMessage() {
      if (this.explanation) {
        return `${this.reason}: ${this.explanation}`;
      } else {
        return this.reason;
      }
    }
  }

  /*
   * This file handles parsing for well-specified formats. Here's how it works:
   * Two things go into parsing: a regex to match with and an extractor to take apart the groups in the match.
   * An extractor is just a function that takes a regex match array and returns a { year: ..., month: ... } object
   * parse() does the work of executing the regex and applying the extractor. It takes multiple regex/extractor pairs to try in sequence.
   * Extractors can take a "cursor" representing the offset in the match to look at. This makes it easy to combine extractors.
   * combineExtractors() does the work of combining them, keeping track of the cursor through multiple extractions.
   * Some extractions are super dumb and simpleParse and fromStrings help DRY them.
   */

  const ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;

  function combineRegexes(...regexes) {
    const full = regexes.reduce((f, r) => f + r.source, "");
    return RegExp(`^${full}$`);
  }

  function combineExtractors(...extractors) {
    return (m) =>
      extractors
        .reduce(
          ([mergedVals, mergedZone, cursor], ex) => {
            const [val, zone, next] = ex(m, cursor);
            return [{ ...mergedVals, ...val }, zone || mergedZone, next];
          },
          [{}, null, 1]
        )
        .slice(0, 2);
  }

  function parse$2(s, ...patterns) {
    if (s == null) {
      return [null, null];
    }

    for (const [regex, extractor] of patterns) {
      const m = regex.exec(s);
      if (m) {
        return extractor(m);
      }
    }
    return [null, null];
  }

  function simpleParse(...keys) {
    return (match, cursor) => {
      const ret = {};
      let i;

      for (i = 0; i < keys.length; i++) {
        ret[keys[i]] = parseInteger(match[cursor + i]);
      }
      return [ret, null, cursor + i];
    };
  }

  // ISO and SQL parsing
  const offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
  const isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
  const isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
  const isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
  const isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
  const isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
  const isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
  const isoOrdinalRegex = /(\d{4})-?(\d{3})/;
  const extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
  const extractISOOrdinalData = simpleParse("year", "ordinal");
  const sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/; // dumbed-down version of the ISO one
  const sqlTimeRegex = RegExp(
    `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`
  );
  const sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);

  function int(match, pos, fallback) {
    const m = match[pos];
    return isUndefined(m) ? fallback : parseInteger(m);
  }

  function extractISOYmd(match, cursor) {
    const item = {
      year: int(match, cursor),
      month: int(match, cursor + 1, 1),
      day: int(match, cursor + 2, 1),
    };

    return [item, null, cursor + 3];
  }

  function extractISOTime(match, cursor) {
    const item = {
      hours: int(match, cursor, 0),
      minutes: int(match, cursor + 1, 0),
      seconds: int(match, cursor + 2, 0),
      milliseconds: parseMillis(match[cursor + 3]),
    };

    return [item, null, cursor + 4];
  }

  function extractISOOffset(match, cursor) {
    const local = !match[cursor] && !match[cursor + 1],
      fullOffset = signedOffset(match[cursor + 1], match[cursor + 2]),
      zone = local ? null : FixedOffsetZone.instance(fullOffset);
    return [{}, zone, cursor + 3];
  }

  function extractIANAZone(match, cursor) {
    const zone = match[cursor] ? IANAZone.create(match[cursor]) : null;
    return [{}, zone, cursor + 1];
  }

  // ISO time parsing

  const isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);

  // ISO duration parsing

  const isoDuration =
    /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;

  function extractISODuration(match) {
    const [s, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] =
      match;

    const hasNegativePrefix = s[0] === "-";
    const negativeSeconds = secondStr && secondStr[0] === "-";

    const maybeNegate = (num, force = false) =>
      num !== undefined && (force || (num && hasNegativePrefix)) ? -num : num;

    return [
      {
        years: maybeNegate(parseFloating(yearStr)),
        months: maybeNegate(parseFloating(monthStr)),
        weeks: maybeNegate(parseFloating(weekStr)),
        days: maybeNegate(parseFloating(dayStr)),
        hours: maybeNegate(parseFloating(hourStr)),
        minutes: maybeNegate(parseFloating(minuteStr)),
        seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
        milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds),
      },
    ];
  }

  // These are a little braindead. EDT *should* tell us that we're in, say, America/New_York
  // and not just that we're in -240 *right now*. But since I don't think these are used that often
  // I'm just going to ignore that
  const obsOffsets = {
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60,
  };

  function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
    const result = {
      year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
      month: monthsShort.indexOf(monthStr) + 1,
      day: parseInteger(dayStr),
      hour: parseInteger(hourStr),
      minute: parseInteger(minuteStr),
    };

    if (secondStr) result.second = parseInteger(secondStr);
    if (weekdayStr) {
      result.weekday =
        weekdayStr.length > 3
          ? weekdaysLong.indexOf(weekdayStr) + 1
          : weekdaysShort.indexOf(weekdayStr) + 1;
    }

    return result;
  }

  // RFC 2822/5322
  const rfc2822 =
    /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;

  function extractRFC2822(match) {
    const [
        ,
        weekdayStr,
        dayStr,
        monthStr,
        yearStr,
        hourStr,
        minuteStr,
        secondStr,
        obsOffset,
        milOffset,
        offHourStr,
        offMinuteStr,
      ] = match,
      result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);

    let offset;
    if (obsOffset) {
      offset = obsOffsets[obsOffset];
    } else if (milOffset) {
      offset = 0;
    } else {
      offset = signedOffset(offHourStr, offMinuteStr);
    }

    return [result, new FixedOffsetZone(offset)];
  }

  function preprocessRFC2822(s) {
    // Remove comments and folding whitespace and replace multiple-spaces with a single space
    return s
      .replace(/\([^()]*\)|[\n\t]/g, " ")
      .replace(/(\s\s+)/g, " ")
      .trim();
  }

  // http date

  const rfc1123 =
      /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/,
    rfc850 =
      /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/,
    ascii =
      /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;

  function extractRFC1123Or850(match) {
    const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match,
      result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
    return [result, FixedOffsetZone.utcInstance];
  }

  function extractASCII(match) {
    const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match,
      result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
    return [result, FixedOffsetZone.utcInstance];
  }

  const isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
  const isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
  const isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
  const isoTimeCombinedRegex = combineRegexes(isoTimeRegex);

  const extractISOYmdTimeAndOffset = combineExtractors(
    extractISOYmd,
    extractISOTime,
    extractISOOffset,
    extractIANAZone
  );
  const extractISOWeekTimeAndOffset = combineExtractors(
    extractISOWeekData,
    extractISOTime,
    extractISOOffset,
    extractIANAZone
  );
  const extractISOOrdinalDateAndTime = combineExtractors(
    extractISOOrdinalData,
    extractISOTime,
    extractISOOffset,
    extractIANAZone
  );
  const extractISOTimeAndOffset = combineExtractors(
    extractISOTime,
    extractISOOffset,
    extractIANAZone
  );

  /*
   * @private
   */

  function parseISODate(s) {
    return parse$2(
      s,
      [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
      [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],
      [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],
      [isoTimeCombinedRegex, extractISOTimeAndOffset]
    );
  }

  function parseRFC2822Date(s) {
    return parse$2(preprocessRFC2822(s), [rfc2822, extractRFC2822]);
  }

  function parseHTTPDate(s) {
    return parse$2(
      s,
      [rfc1123, extractRFC1123Or850],
      [rfc850, extractRFC1123Or850],
      [ascii, extractASCII]
    );
  }

  function parseISODuration(s) {
    return parse$2(s, [isoDuration, extractISODuration]);
  }

  const extractISOTimeOnly = combineExtractors(extractISOTime);

  function parseISOTimeOnly(s) {
    return parse$2(s, [isoTimeOnly, extractISOTimeOnly]);
  }

  const sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
  const sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);

  const extractISOTimeOffsetAndIANAZone = combineExtractors(
    extractISOTime,
    extractISOOffset,
    extractIANAZone
  );

  function parseSQL(s) {
    return parse$2(
      s,
      [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
      [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]
    );
  }

  const INVALID$2 = "Invalid Duration";

  // unit conversion constants
  const lowOrderMatrix = {
      weeks: {
        days: 7,
        hours: 7 * 24,
        minutes: 7 * 24 * 60,
        seconds: 7 * 24 * 60 * 60,
        milliseconds: 7 * 24 * 60 * 60 * 1000,
      },
      days: {
        hours: 24,
        minutes: 24 * 60,
        seconds: 24 * 60 * 60,
        milliseconds: 24 * 60 * 60 * 1000,
      },
      hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1000 },
      minutes: { seconds: 60, milliseconds: 60 * 1000 },
      seconds: { milliseconds: 1000 },
    },
    casualMatrix = {
      years: {
        quarters: 4,
        months: 12,
        weeks: 52,
        days: 365,
        hours: 365 * 24,
        minutes: 365 * 24 * 60,
        seconds: 365 * 24 * 60 * 60,
        milliseconds: 365 * 24 * 60 * 60 * 1000,
      },
      quarters: {
        months: 3,
        weeks: 13,
        days: 91,
        hours: 91 * 24,
        minutes: 91 * 24 * 60,
        seconds: 91 * 24 * 60 * 60,
        milliseconds: 91 * 24 * 60 * 60 * 1000,
      },
      months: {
        weeks: 4,
        days: 30,
        hours: 30 * 24,
        minutes: 30 * 24 * 60,
        seconds: 30 * 24 * 60 * 60,
        milliseconds: 30 * 24 * 60 * 60 * 1000,
      },

      ...lowOrderMatrix,
    },
    daysInYearAccurate = 146097.0 / 400,
    daysInMonthAccurate = 146097.0 / 4800,
    accurateMatrix = {
      years: {
        quarters: 4,
        months: 12,
        weeks: daysInYearAccurate / 7,
        days: daysInYearAccurate,
        hours: daysInYearAccurate * 24,
        minutes: daysInYearAccurate * 24 * 60,
        seconds: daysInYearAccurate * 24 * 60 * 60,
        milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000,
      },
      quarters: {
        months: 3,
        weeks: daysInYearAccurate / 28,
        days: daysInYearAccurate / 4,
        hours: (daysInYearAccurate * 24) / 4,
        minutes: (daysInYearAccurate * 24 * 60) / 4,
        seconds: (daysInYearAccurate * 24 * 60 * 60) / 4,
        milliseconds: (daysInYearAccurate * 24 * 60 * 60 * 1000) / 4,
      },
      months: {
        weeks: daysInMonthAccurate / 7,
        days: daysInMonthAccurate,
        hours: daysInMonthAccurate * 24,
        minutes: daysInMonthAccurate * 24 * 60,
        seconds: daysInMonthAccurate * 24 * 60 * 60,
        milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1000,
      },
      ...lowOrderMatrix,
    };

  // units ordered by size
  const orderedUnits$1 = [
    "years",
    "quarters",
    "months",
    "weeks",
    "days",
    "hours",
    "minutes",
    "seconds",
    "milliseconds",
  ];

  const reverseUnits = orderedUnits$1.slice(0).reverse();

  // clone really means "create another instance just like this one, but with these changes"
  function clone$1(dur, alts, clear = false) {
    // deep merge for vals
    const conf = {
      values: clear ? alts.values : { ...dur.values, ...(alts.values || {}) },
      loc: dur.loc.clone(alts.loc),
      conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
      matrix: alts.matrix || dur.matrix,
    };
    return new Duration(conf);
  }

  function antiTrunc(n) {
    return n < 0 ? Math.floor(n) : Math.ceil(n);
  }

  // NB: mutates parameters
  function convert(matrix, fromMap, fromUnit, toMap, toUnit) {
    const conv = matrix[toUnit][fromUnit],
      raw = fromMap[fromUnit] / conv,
      sameSign = Math.sign(raw) === Math.sign(toMap[toUnit]),
      // ok, so this is wild, but see the matrix in the tests
      added =
        !sameSign && toMap[toUnit] !== 0 && Math.abs(raw) <= 1 ? antiTrunc(raw) : Math.trunc(raw);
    toMap[toUnit] += added;
    fromMap[fromUnit] -= added * conv;
  }

  // NB: mutates parameters
  function normalizeValues(matrix, vals) {
    reverseUnits.reduce((previous, current) => {
      if (!isUndefined(vals[current])) {
        if (previous) {
          convert(matrix, vals, previous, vals, current);
        }
        return current;
      } else {
        return previous;
      }
    }, null);
  }

  // Remove all properties with a value of 0 from an object
  function removeZeroes(vals) {
    const newVals = {};
    for (const [key, value] of Object.entries(vals)) {
      if (value !== 0) {
        newVals[key] = value;
      }
    }
    return newVals;
  }

  /**
   * A Duration object represents a period of time, like "2 months" or "1 day, 1 hour". Conceptually, it's just a map of units to their quantities, accompanied by some additional configuration and methods for creating, parsing, interrogating, transforming, and formatting them. They can be used on their own or in conjunction with other Luxon types; for example, you can use {@link DateTime#plus} to add a Duration object to a DateTime, producing another DateTime.
   *
   * Here is a brief overview of commonly used methods and getters in Duration:
   *
   * * **Creation** To create a Duration, use {@link Duration.fromMillis}, {@link Duration.fromObject}, or {@link Duration.fromISO}.
   * * **Unit values** See the {@link Duration#years}, {@link Duration#months}, {@link Duration#weeks}, {@link Duration#days}, {@link Duration#hours}, {@link Duration#minutes}, {@link Duration#seconds}, {@link Duration#milliseconds} accessors.
   * * **Configuration** See  {@link Duration#locale} and {@link Duration#numberingSystem} accessors.
   * * **Transformation** To create new Durations out of old ones use {@link Duration#plus}, {@link Duration#minus}, {@link Duration#normalize}, {@link Duration#set}, {@link Duration#reconfigure}, {@link Duration#shiftTo}, and {@link Duration#negate}.
   * * **Output** To convert the Duration into other representations, see {@link Duration#as}, {@link Duration#toISO}, {@link Duration#toFormat}, and {@link Duration#toJSON}
   *
   * There's are more methods documented below. In addition, for more information on subtler topics like internationalization and validity, see the external documentation.
   */
  class Duration {
    /**
     * @private
     */
    constructor(config) {
      const accurate = config.conversionAccuracy === "longterm" || false;
      let matrix = accurate ? accurateMatrix : casualMatrix;

      if (config.matrix) {
        matrix = config.matrix;
      }

      /**
       * @access private
       */
      this.values = config.values;
      /**
       * @access private
       */
      this.loc = config.loc || Locale.create();
      /**
       * @access private
       */
      this.conversionAccuracy = accurate ? "longterm" : "casual";
      /**
       * @access private
       */
      this.invalid = config.invalid || null;
      /**
       * @access private
       */
      this.matrix = matrix;
      /**
       * @access private
       */
      this.isLuxonDuration = true;
    }

    /**
     * Create Duration from a number of milliseconds.
     * @param {number} count of milliseconds
     * @param {Object} opts - options for parsing
     * @param {string} [opts.locale='en-US'] - the locale to use
     * @param {string} opts.numberingSystem - the numbering system to use
     * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
     * @return {Duration}
     */
    static fromMillis(count, opts) {
      return Duration.fromObject({ milliseconds: count }, opts);
    }

    /**
     * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
     * If this object is empty then a zero milliseconds duration is returned.
     * @param {Object} obj - the object to create the DateTime from
     * @param {number} obj.years
     * @param {number} obj.quarters
     * @param {number} obj.months
     * @param {number} obj.weeks
     * @param {number} obj.days
     * @param {number} obj.hours
     * @param {number} obj.minutes
     * @param {number} obj.seconds
     * @param {number} obj.milliseconds
     * @param {Object} [opts=[]] - options for creating this Duration
     * @param {string} [opts.locale='en-US'] - the locale to use
     * @param {string} opts.numberingSystem - the numbering system to use
     * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
     * @param {string} [opts.matrix=Object] - the custom conversion system to use
     * @return {Duration}
     */
    static fromObject(obj, opts = {}) {
      if (obj == null || typeof obj !== "object") {
        throw new InvalidArgumentError(
          `Duration.fromObject: argument expected to be an object, got ${
          obj === null ? "null" : typeof obj
        }`
        );
      }

      return new Duration({
        values: normalizeObject(obj, Duration.normalizeUnit),
        loc: Locale.fromObject(opts),
        conversionAccuracy: opts.conversionAccuracy,
        matrix: opts.matrix,
      });
    }

    /**
     * Create a Duration from DurationLike.
     *
     * @param {Object | number | Duration} durationLike
     * One of:
     * - object with keys like 'years' and 'hours'.
     * - number representing milliseconds
     * - Duration instance
     * @return {Duration}
     */
    static fromDurationLike(durationLike) {
      if (isNumber$1(durationLike)) {
        return Duration.fromMillis(durationLike);
      } else if (Duration.isDuration(durationLike)) {
        return durationLike;
      } else if (typeof durationLike === "object") {
        return Duration.fromObject(durationLike);
      } else {
        throw new InvalidArgumentError(
          `Unknown duration argument ${durationLike} of type ${typeof durationLike}`
        );
      }
    }

    /**
     * Create a Duration from an ISO 8601 duration string.
     * @param {string} text - text to parse
     * @param {Object} opts - options for parsing
     * @param {string} [opts.locale='en-US'] - the locale to use
     * @param {string} opts.numberingSystem - the numbering system to use
     * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
     * @param {string} [opts.matrix=Object] - the preset conversion system to use
     * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
     * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
     * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
     * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
     * @return {Duration}
     */
    static fromISO(text, opts) {
      const [parsed] = parseISODuration(text);
      if (parsed) {
        return Duration.fromObject(parsed, opts);
      } else {
        return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
      }
    }

    /**
     * Create a Duration from an ISO 8601 time string.
     * @param {string} text - text to parse
     * @param {Object} opts - options for parsing
     * @param {string} [opts.locale='en-US'] - the locale to use
     * @param {string} opts.numberingSystem - the numbering system to use
     * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
     * @param {string} [opts.matrix=Object] - the conversion system to use
     * @see https://en.wikipedia.org/wiki/ISO_8601#Times
     * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
     * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
     * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
     * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
     * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
     * @return {Duration}
     */
    static fromISOTime(text, opts) {
      const [parsed] = parseISOTimeOnly(text);
      if (parsed) {
        return Duration.fromObject(parsed, opts);
      } else {
        return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
      }
    }

    /**
     * Create an invalid Duration.
     * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
     * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
     * @return {Duration}
     */
    static invalid(reason, explanation = null) {
      if (!reason) {
        throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
      }

      const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);

      if (Settings.throwOnInvalid) {
        throw new InvalidDurationError(invalid);
      } else {
        return new Duration({ invalid });
      }
    }

    /**
     * @private
     */
    static normalizeUnit(unit) {
      const normalized = {
        year: "years",
        years: "years",
        quarter: "quarters",
        quarters: "quarters",
        month: "months",
        months: "months",
        week: "weeks",
        weeks: "weeks",
        day: "days",
        days: "days",
        hour: "hours",
        hours: "hours",
        minute: "minutes",
        minutes: "minutes",
        second: "seconds",
        seconds: "seconds",
        millisecond: "milliseconds",
        milliseconds: "milliseconds",
      }[unit ? unit.toLowerCase() : unit];

      if (!normalized) throw new InvalidUnitError(unit);

      return normalized;
    }

    /**
     * Check if an object is a Duration. Works across context boundaries
     * @param {object} o
     * @return {boolean}
     */
    static isDuration(o) {
      return (o && o.isLuxonDuration) || false;
    }

    /**
     * Get  the locale of a Duration, such 'en-GB'
     * @type {string}
     */
    get locale() {
      return this.isValid ? this.loc.locale : null;
    }

    /**
     * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
     *
     * @type {string}
     */
    get numberingSystem() {
      return this.isValid ? this.loc.numberingSystem : null;
    }

    /**
     * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
     * * `S` for milliseconds
     * * `s` for seconds
     * * `m` for minutes
     * * `h` for hours
     * * `d` for days
     * * `w` for weeks
     * * `M` for months
     * * `y` for years
     * Notes:
     * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
     * * Tokens can be escaped by wrapping with single quotes.
     * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
     * @param {string} fmt - the format string
     * @param {Object} opts - options
     * @param {boolean} [opts.floor=true] - floor numerical values
     * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
     * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
     * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
     * @return {string}
     */
    toFormat(fmt, opts = {}) {
      // reverse-compat since 1.2; we always round down now, never up, and we do it by default
      const fmtOpts = {
        ...opts,
        floor: opts.round !== false && opts.floor !== false,
      };
      return this.isValid
        ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt)
        : INVALID$2;
    }

    /**
     * Returns a string representation of a Duration with all units included.
     * To modify its behavior use the `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat
     * @param opts - On option object to override the formatting. Accepts the same keys as the options parameter of the native `Int.NumberFormat` constructor, as well as `listStyle`.
     * @example
     * ```js
     * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
     * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
     * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
     * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
     * ```
     */
    toHuman(opts = {}) {
      const l = orderedUnits$1
        .map((unit) => {
          const val = this.values[unit];
          if (isUndefined(val)) {
            return null;
          }
          return this.loc
            .numberFormatter({ style: "unit", unitDisplay: "long", ...opts, unit: unit.slice(0, -1) })
            .format(val);
        })
        .filter((n) => n);

      return this.loc
        .listFormatter({ type: "conjunction", style: opts.listStyle || "narrow", ...opts })
        .format(l);
    }

    /**
     * Returns a JavaScript object with this Duration's values.
     * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
     * @return {Object}
     */
    toObject() {
      if (!this.isValid) return {};
      return { ...this.values };
    }

    /**
     * Returns an ISO 8601-compliant string representation of this Duration.
     * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
     * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
     * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
     * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
     * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
     * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
     * @return {string}
     */
    toISO() {
      // we could use the formatter, but this is an easier way to get the minimum string
      if (!this.isValid) return null;

      let s = "P";
      if (this.years !== 0) s += this.years + "Y";
      if (this.months !== 0 || this.quarters !== 0) s += this.months + this.quarters * 3 + "M";
      if (this.weeks !== 0) s += this.weeks + "W";
      if (this.days !== 0) s += this.days + "D";
      if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
        s += "T";
      if (this.hours !== 0) s += this.hours + "H";
      if (this.minutes !== 0) s += this.minutes + "M";
      if (this.seconds !== 0 || this.milliseconds !== 0)
        // this will handle "floating point madness" by removing extra decimal places
        // https://stackoverflow.com/questions/588004/is-floating-point-math-broken
        s += roundTo(this.seconds + this.milliseconds / 1000, 3) + "S";
      if (s === "P") s += "T0S";
      return s;
    }

    /**
     * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
     * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
     * @see https://en.wikipedia.org/wiki/ISO_8601#Times
     * @param {Object} opts - options
     * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
     * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
     * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
     * @param {string} [opts.format='extended'] - choose between the basic and extended format
     * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
     * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
     * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
     * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
     * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
     * @return {string}
     */
    toISOTime(opts = {}) {
      if (!this.isValid) return null;

      const millis = this.toMillis();
      if (millis < 0 || millis >= 86400000) return null;

      opts = {
        suppressMilliseconds: false,
        suppressSeconds: false,
        includePrefix: false,
        format: "extended",
        ...opts,
      };

      const value = this.shiftTo("hours", "minutes", "seconds", "milliseconds");

      let fmt = opts.format === "basic" ? "hhmm" : "hh:mm";

      if (!opts.suppressSeconds || value.seconds !== 0 || value.milliseconds !== 0) {
        fmt += opts.format === "basic" ? "ss" : ":ss";
        if (!opts.suppressMilliseconds || value.milliseconds !== 0) {
          fmt += ".SSS";
        }
      }

      let str = value.toFormat(fmt);

      if (opts.includePrefix) {
        str = "T" + str;
      }

      return str;
    }

    /**
     * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
     * @return {string}
     */
    toJSON() {
      return this.toISO();
    }

    /**
     * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
     * @return {string}
     */
    toString() {
      return this.toISO();
    }

    /**
     * Returns an milliseconds value of this Duration.
     * @return {number}
     */
    toMillis() {
      return this.as("milliseconds");
    }

    /**
     * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
     * @return {number}
     */
    valueOf() {
      return this.toMillis();
    }

    /**
     * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
     * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
     * @return {Duration}
     */
    plus(duration) {
      if (!this.isValid) return this;

      const dur = Duration.fromDurationLike(duration),
        result = {};

      for (const k of orderedUnits$1) {
        if (hasOwnProperty$1(dur.values, k) || hasOwnProperty$1(this.values, k)) {
          result[k] = dur.get(k) + this.get(k);
        }
      }

      return clone$1(this, { values: result }, true);
    }

    /**
     * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
     * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
     * @return {Duration}
     */
    minus(duration) {
      if (!this.isValid) return this;

      const dur = Duration.fromDurationLike(duration);
      return this.plus(dur.negate());
    }

    /**
     * Scale this Duration by the specified amount. Return a newly-constructed Duration.
     * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
     * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
     * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
     * @return {Duration}
     */
    mapUnits(fn) {
      if (!this.isValid) return this;
      const result = {};
      for (const k of Object.keys(this.values)) {
        result[k] = asNumber(fn(this.values[k], k));
      }
      return clone$1(this, { values: result }, true);
    }

    /**
     * Get the value of unit.
     * @param {string} unit - a unit such as 'minute' or 'day'
     * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
     * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
     * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
     * @return {number}
     */
    get(unit) {
      return this[Duration.normalizeUnit(unit)];
    }

    /**
     * "Set" the values of specified units. Return a newly-constructed Duration.
     * @param {Object} values - a mapping of units to numbers
     * @example dur.set({ years: 2017 })
     * @example dur.set({ hours: 8, minutes: 30 })
     * @return {Duration}
     */
    set(values) {
      if (!this.isValid) return this;

      const mixed = { ...this.values, ...normalizeObject(values, Duration.normalizeUnit) };
      return clone$1(this, { values: mixed });
    }

    /**
     * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
     * @example dur.reconfigure({ locale: 'en-GB' })
     * @return {Duration}
     */
    reconfigure({ locale, numberingSystem, conversionAccuracy, matrix } = {}) {
      const loc = this.loc.clone({ locale, numberingSystem });
      const opts = { loc, matrix, conversionAccuracy };
      return clone$1(this, opts);
    }

    /**
     * Return the length of the duration in the specified unit.
     * @param {string} unit - a unit such as 'minutes' or 'days'
     * @example Duration.fromObject({years: 1}).as('days') //=> 365
     * @example Duration.fromObject({years: 1}).as('months') //=> 12
     * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
     * @return {number}
     */
    as(unit) {
      return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
    }

    /**
     * Reduce this Duration to its canonical representation in its current units.
     * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
     * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
     * @return {Duration}
     */
    normalize() {
      if (!this.isValid) return this;
      const vals = this.toObject();
      normalizeValues(this.matrix, vals);
      return clone$1(this, { values: vals }, true);
    }

    /**
     * Rescale units to its largest representation
     * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
     * @return {Duration}
     */
    rescale() {
      if (!this.isValid) return this;
      const vals = removeZeroes(this.normalize().shiftToAll().toObject());
      return clone$1(this, { values: vals }, true);
    }

    /**
     * Convert this Duration into its representation in a different set of units.
     * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
     * @return {Duration}
     */
    shiftTo(...units) {
      if (!this.isValid) return this;

      if (units.length === 0) {
        return this;
      }

      units = units.map((u) => Duration.normalizeUnit(u));

      const built = {},
        accumulated = {},
        vals = this.toObject();
      let lastUnit;

      for (const k of orderedUnits$1) {
        if (units.indexOf(k) >= 0) {
          lastUnit = k;

          let own = 0;

          // anything we haven't boiled down yet should get boiled to this unit
          for (const ak in accumulated) {
            own += this.matrix[ak][k] * accumulated[ak];
            accumulated[ak] = 0;
          }

          // plus anything that's already in this unit
          if (isNumber$1(vals[k])) {
            own += vals[k];
          }

          const i = Math.trunc(own);
          built[k] = i;
          accumulated[k] = (own * 1000 - i * 1000) / 1000;

          // plus anything further down the chain that should be rolled up in to this
          for (const down in vals) {
            if (orderedUnits$1.indexOf(down) > orderedUnits$1.indexOf(k)) {
              convert(this.matrix, vals, down, built, k);
            }
          }
          // otherwise, keep it in the wings to boil it later
        } else if (isNumber$1(vals[k])) {
          accumulated[k] = vals[k];
        }
      }

      // anything leftover becomes the decimal for the last unit
      // lastUnit must be defined since units is not empty
      for (const key in accumulated) {
        if (accumulated[key] !== 0) {
          built[lastUnit] +=
            key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
        }
      }

      return clone$1(this, { values: built }, true).normalize();
    }

    /**
     * Shift this Duration to all available units.
     * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
     * @return {Duration}
     */
    shiftToAll() {
      if (!this.isValid) return this;
      return this.shiftTo(
        "years",
        "months",
        "weeks",
        "days",
        "hours",
        "minutes",
        "seconds",
        "milliseconds"
      );
    }

    /**
     * Return the negative of this Duration.
     * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
     * @return {Duration}
     */
    negate() {
      if (!this.isValid) return this;
      const negated = {};
      for (const k of Object.keys(this.values)) {
        negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
      }
      return clone$1(this, { values: negated }, true);
    }

    /**
     * Get the years.
     * @type {number}
     */
    get years() {
      return this.isValid ? this.values.years || 0 : NaN;
    }

    /**
     * Get the quarters.
     * @type {number}
     */
    get quarters() {
      return this.isValid ? this.values.quarters || 0 : NaN;
    }

    /**
     * Get the months.
     * @type {number}
     */
    get months() {
      return this.isValid ? this.values.months || 0 : NaN;
    }

    /**
     * Get the weeks
     * @type {number}
     */
    get weeks() {
      return this.isValid ? this.values.weeks || 0 : NaN;
    }

    /**
     * Get the days.
     * @type {number}
     */
    get days() {
      return this.isValid ? this.values.days || 0 : NaN;
    }

    /**
     * Get the hours.
     * @type {number}
     */
    get hours() {
      return this.isValid ? this.values.hours || 0 : NaN;
    }

    /**
     * Get the minutes.
     * @type {number}
     */
    get minutes() {
      return this.isValid ? this.values.minutes || 0 : NaN;
    }

    /**
     * Get the seconds.
     * @return {number}
     */
    get seconds() {
      return this.isValid ? this.values.seconds || 0 : NaN;
    }

    /**
     * Get the milliseconds.
     * @return {number}
     */
    get milliseconds() {
      return this.isValid ? this.values.milliseconds || 0 : NaN;
    }

    /**
     * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
     * on invalid DateTimes or Intervals.
     * @return {boolean}
     */
    get isValid() {
      return this.invalid === null;
    }

    /**
     * Returns an error code if this Duration became invalid, or null if the Duration is valid
     * @return {string}
     */
    get invalidReason() {
      return this.invalid ? this.invalid.reason : null;
    }

    /**
     * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
     * @type {string}
     */
    get invalidExplanation() {
      return this.invalid ? this.invalid.explanation : null;
    }

    /**
     * Equality check
     * Two Durations are equal iff they have the same units and the same values for each unit.
     * @param {Duration} other
     * @return {boolean}
     */
    equals(other) {
      if (!this.isValid || !other.isValid) {
        return false;
      }

      if (!this.loc.equals(other.loc)) {
        return false;
      }

      function eq(v1, v2) {
        // Consider 0 and undefined as equal
        if (v1 === undefined || v1 === 0) return v2 === undefined || v2 === 0;
        return v1 === v2;
      }

      for (const u of orderedUnits$1) {
        if (!eq(this.values[u], other.values[u])) {
          return false;
        }
      }
      return true;
    }
  }

  const INVALID$1 = "Invalid Interval";

  // checks if the start is equal to or before the end
  function validateStartEnd(start, end) {
    if (!start || !start.isValid) {
      return Interval.invalid("missing or invalid start");
    } else if (!end || !end.isValid) {
      return Interval.invalid("missing or invalid end");
    } else if (end < start) {
      return Interval.invalid(
        "end before start",
        `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`
      );
    } else {
      return null;
    }
  }

  /**
   * An Interval object represents a half-open interval of time, where each endpoint is a {@link DateTime}. Conceptually, it's a container for those two endpoints, accompanied by methods for creating, parsing, interrogating, comparing, transforming, and formatting them.
   *
   * Here is a brief overview of the most commonly used methods and getters in Interval:
   *
   * * **Creation** To create an Interval, use {@link Interval.fromDateTimes}, {@link Interval.after}, {@link Interval.before}, or {@link Interval.fromISO}.
   * * **Accessors** Use {@link Interval#start} and {@link Interval#end} to get the start and end.
   * * **Interrogation** To analyze the Interval, use {@link Interval#count}, {@link Interval#length}, {@link Interval#hasSame}, {@link Interval#contains}, {@link Interval#isAfter}, or {@link Interval#isBefore}.
   * * **Transformation** To create other Intervals out of this one, use {@link Interval#set}, {@link Interval#splitAt}, {@link Interval#splitBy}, {@link Interval#divideEqually}, {@link Interval.merge}, {@link Interval.xor}, {@link Interval#union}, {@link Interval#intersection}, or {@link Interval#difference}.
   * * **Comparison** To compare this Interval to another one, use {@link Interval#equals}, {@link Interval#overlaps}, {@link Interval#abutsStart}, {@link Interval#abutsEnd}, {@link Interval#engulfs}
   * * **Output** To convert the Interval into other representations, see {@link Interval#toString}, {@link Interval#toLocaleString}, {@link Interval#toISO}, {@link Interval#toISODate}, {@link Interval#toISOTime}, {@link Interval#toFormat}, and {@link Interval#toDuration}.
   */
  class Interval {
    /**
     * @private
     */
    constructor(config) {
      /**
       * @access private
       */
      this.s = config.start;
      /**
       * @access private
       */
      this.e = config.end;
      /**
       * @access private
       */
      this.invalid = config.invalid || null;
      /**
       * @access private
       */
      this.isLuxonInterval = true;
    }

    /**
     * Create an invalid Interval.
     * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
     * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
     * @return {Interval}
     */
    static invalid(reason, explanation = null) {
      if (!reason) {
        throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
      }

      const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);

      if (Settings.throwOnInvalid) {
        throw new InvalidIntervalError(invalid);
      } else {
        return new Interval({ invalid });
      }
    }

    /**
     * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
     * @param {DateTime|Date|Object} start
     * @param {DateTime|Date|Object} end
     * @return {Interval}
     */
    static fromDateTimes(start, end) {
      const builtStart = friendlyDateTime(start),
        builtEnd = friendlyDateTime(end);

      const validateError = validateStartEnd(builtStart, builtEnd);

      if (validateError == null) {
        return new Interval({
          start: builtStart,
          end: builtEnd,
        });
      } else {
        return validateError;
      }
    }

    /**
     * Create an Interval from a start DateTime and a Duration to extend to.
     * @param {DateTime|Date|Object} start
     * @param {Duration|Object|number} duration - the length of the Interval.
     * @return {Interval}
     */
    static after(start, duration) {
      const dur = Duration.fromDurationLike(duration),
        dt = friendlyDateTime(start);
      return Interval.fromDateTimes(dt, dt.plus(dur));
    }

    /**
     * Create an Interval from an end DateTime and a Duration to extend backwards to.
     * @param {DateTime|Date|Object} end
     * @param {Duration|Object|number} duration - the length of the Interval.
     * @return {Interval}
     */
    static before(end, duration) {
      const dur = Duration.fromDurationLike(duration),
        dt = friendlyDateTime(end);
      return Interval.fromDateTimes(dt.minus(dur), dt);
    }

    /**
     * Create an Interval from an ISO 8601 string.
     * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
     * @param {string} text - the ISO string to parse
     * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
     * @return {Interval}
     */
    static fromISO(text, opts) {
      const [s, e] = (text || "").split("/", 2);
      if (s && e) {
        let start, startIsValid;
        try {
          start = DateTime$1.fromISO(s, opts);
          startIsValid = start.isValid;
        } catch (e) {
          startIsValid = false;
        }

        let end, endIsValid;
        try {
          end = DateTime$1.fromISO(e, opts);
          endIsValid = end.isValid;
        } catch (e) {
          endIsValid = false;
        }

        if (startIsValid && endIsValid) {
          return Interval.fromDateTimes(start, end);
        }

        if (startIsValid) {
          const dur = Duration.fromISO(e, opts);
          if (dur.isValid) {
            return Interval.after(start, dur);
          }
        } else if (endIsValid) {
          const dur = Duration.fromISO(s, opts);
          if (dur.isValid) {
            return Interval.before(end, dur);
          }
        }
      }
      return Interval.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }

    /**
     * Check if an object is an Interval. Works across context boundaries
     * @param {object} o
     * @return {boolean}
     */
    static isInterval(o) {
      return (o && o.isLuxonInterval) || false;
    }

    /**
     * Returns the start of the Interval
     * @type {DateTime}
     */
    get start() {
      return this.isValid ? this.s : null;
    }

    /**
     * Returns the end of the Interval
     * @type {DateTime}
     */
    get end() {
      return this.isValid ? this.e : null;
    }

    /**
     * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
     * @type {boolean}
     */
    get isValid() {
      return this.invalidReason === null;
    }

    /**
     * Returns an error code if this Interval is invalid, or null if the Interval is valid
     * @type {string}
     */
    get invalidReason() {
      return this.invalid ? this.invalid.reason : null;
    }

    /**
     * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
     * @type {string}
     */
    get invalidExplanation() {
      return this.invalid ? this.invalid.explanation : null;
    }

    /**
     * Returns the length of the Interval in the specified unit.
     * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
     * @return {number}
     */
    length(unit = "milliseconds") {
      return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
    }

    /**
     * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
     * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
     * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
     * @param {string} [unit='milliseconds'] - the unit of time to count.
     * @return {number}
     */
    count(unit = "milliseconds") {
      if (!this.isValid) return NaN;
      const start = this.start.startOf(unit),
        end = this.end.startOf(unit);
      return Math.floor(end.diff(start, unit).get(unit)) + (end.valueOf() !== this.end.valueOf());
    }

    /**
     * Returns whether this Interval's start and end are both in the same unit of time
     * @param {string} unit - the unit of time to check sameness on
     * @return {boolean}
     */
    hasSame(unit) {
      return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
    }

    /**
     * Return whether this Interval has the same start and end DateTimes.
     * @return {boolean}
     */
    isEmpty() {
      return this.s.valueOf() === this.e.valueOf();
    }

    /**
     * Return whether this Interval's start is after the specified DateTime.
     * @param {DateTime} dateTime
     * @return {boolean}
     */
    isAfter(dateTime) {
      if (!this.isValid) return false;
      return this.s > dateTime;
    }

    /**
     * Return whether this Interval's end is before the specified DateTime.
     * @param {DateTime} dateTime
     * @return {boolean}
     */
    isBefore(dateTime) {
      if (!this.isValid) return false;
      return this.e <= dateTime;
    }

    /**
     * Return whether this Interval contains the specified DateTime.
     * @param {DateTime} dateTime
     * @return {boolean}
     */
    contains(dateTime) {
      if (!this.isValid) return false;
      return this.s <= dateTime && this.e > dateTime;
    }

    /**
     * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
     * @param {Object} values - the values to set
     * @param {DateTime} values.start - the starting DateTime
     * @param {DateTime} values.end - the ending DateTime
     * @return {Interval}
     */
    set({ start, end } = {}) {
      if (!this.isValid) return this;
      return Interval.fromDateTimes(start || this.s, end || this.e);
    }

    /**
     * Split this Interval at each of the specified DateTimes
     * @param {...DateTime} dateTimes - the unit of time to count.
     * @return {Array}
     */
    splitAt(...dateTimes) {
      if (!this.isValid) return [];
      const sorted = dateTimes
          .map(friendlyDateTime)
          .filter((d) => this.contains(d))
          .sort(),
        results = [];
      let { s } = this,
        i = 0;

      while (s < this.e) {
        const added = sorted[i] || this.e,
          next = +added > +this.e ? this.e : added;
        results.push(Interval.fromDateTimes(s, next));
        s = next;
        i += 1;
      }

      return results;
    }

    /**
     * Split this Interval into smaller Intervals, each of the specified length.
     * Left over time is grouped into a smaller interval
     * @param {Duration|Object|number} duration - The length of each resulting interval.
     * @return {Array}
     */
    splitBy(duration) {
      const dur = Duration.fromDurationLike(duration);

      if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
        return [];
      }

      let { s } = this,
        idx = 1,
        next;

      const results = [];
      while (s < this.e) {
        const added = this.start.plus(dur.mapUnits((x) => x * idx));
        next = +added > +this.e ? this.e : added;
        results.push(Interval.fromDateTimes(s, next));
        s = next;
        idx += 1;
      }

      return results;
    }

    /**
     * Split this Interval into the specified number of smaller intervals.
     * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
     * @return {Array}
     */
    divideEqually(numberOfParts) {
      if (!this.isValid) return [];
      return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
    }

    /**
     * Return whether this Interval overlaps with the specified Interval
     * @param {Interval} other
     * @return {boolean}
     */
    overlaps(other) {
      return this.e > other.s && this.s < other.e;
    }

    /**
     * Return whether this Interval's end is adjacent to the specified Interval's start.
     * @param {Interval} other
     * @return {boolean}
     */
    abutsStart(other) {
      if (!this.isValid) return false;
      return +this.e === +other.s;
    }

    /**
     * Return whether this Interval's start is adjacent to the specified Interval's end.
     * @param {Interval} other
     * @return {boolean}
     */
    abutsEnd(other) {
      if (!this.isValid) return false;
      return +other.e === +this.s;
    }

    /**
     * Return whether this Interval engulfs the start and end of the specified Interval.
     * @param {Interval} other
     * @return {boolean}
     */
    engulfs(other) {
      if (!this.isValid) return false;
      return this.s <= other.s && this.e >= other.e;
    }

    /**
     * Return whether this Interval has the same start and end as the specified Interval.
     * @param {Interval} other
     * @return {boolean}
     */
    equals(other) {
      if (!this.isValid || !other.isValid) {
        return false;
      }

      return this.s.equals(other.s) && this.e.equals(other.e);
    }

    /**
     * Return an Interval representing the intersection of this Interval and the specified Interval.
     * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
     * Returns null if the intersection is empty, meaning, the intervals don't intersect.
     * @param {Interval} other
     * @return {Interval}
     */
    intersection(other) {
      if (!this.isValid) return this;
      const s = this.s > other.s ? this.s : other.s,
        e = this.e < other.e ? this.e : other.e;

      if (s >= e) {
        return null;
      } else {
        return Interval.fromDateTimes(s, e);
      }
    }

    /**
     * Return an Interval representing the union of this Interval and the specified Interval.
     * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
     * @param {Interval} other
     * @return {Interval}
     */
    union(other) {
      if (!this.isValid) return this;
      const s = this.s < other.s ? this.s : other.s,
        e = this.e > other.e ? this.e : other.e;
      return Interval.fromDateTimes(s, e);
    }

    /**
     * Merge an array of Intervals into a equivalent minimal set of Intervals.
     * Combines overlapping and adjacent Intervals.
     * @param {Array} intervals
     * @return {Array}
     */
    static merge(intervals) {
      const [found, final] = intervals
        .sort((a, b) => a.s - b.s)
        .reduce(
          ([sofar, current], item) => {
            if (!current) {
              return [sofar, item];
            } else if (current.overlaps(item) || current.abutsStart(item)) {
              return [sofar, current.union(item)];
            } else {
              return [sofar.concat([current]), item];
            }
          },
          [[], null]
        );
      if (final) {
        found.push(final);
      }
      return found;
    }

    /**
     * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
     * @param {Array} intervals
     * @return {Array}
     */
    static xor(intervals) {
      let start = null,
        currentCount = 0;
      const results = [],
        ends = intervals.map((i) => [
          { time: i.s, type: "s" },
          { time: i.e, type: "e" },
        ]),
        flattened = Array.prototype.concat(...ends),
        arr = flattened.sort((a, b) => a.time - b.time);

      for (const i of arr) {
        currentCount += i.type === "s" ? 1 : -1;

        if (currentCount === 1) {
          start = i.time;
        } else {
          if (start && +start !== +i.time) {
            results.push(Interval.fromDateTimes(start, i.time));
          }

          start = null;
        }
      }

      return Interval.merge(results);
    }

    /**
     * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
     * @param {...Interval} intervals
     * @return {Array}
     */
    difference(...intervals) {
      return Interval.xor([this].concat(intervals))
        .map((i) => this.intersection(i))
        .filter((i) => i && !i.isEmpty());
    }

    /**
     * Returns a string representation of this Interval appropriate for debugging.
     * @return {string}
     */
    toString() {
      if (!this.isValid) return INVALID$1;
      return `[${this.s.toISO()} – ${this.e.toISO()})`;
    }

    /**
     * Returns a localized string representing this Interval. Accepts the same options as the
     * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
     * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
     * is browser-specific, but in general it will return an appropriate representation of the
     * Interval in the assigned locale. Defaults to the system's locale if no locale has been
     * specified.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
     * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
     * Intl.DateTimeFormat constructor options.
     * @param {Object} opts - Options to override the configuration of the start DateTime.
     * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022 – 11/8/2022
     * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7 – 8, 2022
     * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 7–8 novembre 2022
     * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00 – 8:00 PM
     * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00 – 8:00 p
     * @return {string}
     */
    toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
      return this.isValid
        ? Formatter.create(this.s.loc.clone(opts), formatOpts).formatInterval(this)
        : INVALID$1;
    }

    /**
     * Returns an ISO 8601-compliant string representation of this Interval.
     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
     * @param {Object} opts - The same options as {@link DateTime#toISO}
     * @return {string}
     */
    toISO(opts) {
      if (!this.isValid) return INVALID$1;
      return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
    }

    /**
     * Returns an ISO 8601-compliant string representation of date of this Interval.
     * The time components are ignored.
     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
     * @return {string}
     */
    toISODate() {
      if (!this.isValid) return INVALID$1;
      return `${this.s.toISODate()}/${this.e.toISODate()}`;
    }

    /**
     * Returns an ISO 8601-compliant string representation of time of this Interval.
     * The date components are ignored.
     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
     * @param {Object} opts - The same options as {@link DateTime#toISO}
     * @return {string}
     */
    toISOTime(opts) {
      if (!this.isValid) return INVALID$1;
      return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
    }

    /**
     * Returns a string representation of this Interval formatted according to the specified format
     * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
     * formatting tool.
     * @param {string} dateFormat - The format string. This string formats the start and end time.
     * See {@link DateTime#toFormat} for details.
     * @param {Object} opts - Options.
     * @param {string} [opts.separator =  ' – '] - A separator to place between the start and end
     * representations.
     * @return {string}
     */
    toFormat(dateFormat, { separator = " – " } = {}) {
      if (!this.isValid) return INVALID$1;
      return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
    }

    /**
     * Return a Duration representing the time spanned by this interval.
     * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
     * @param {Object} opts - options that affect the creation of the Duration
     * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
     * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
     * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
     * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
     * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
     * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
     * @return {Duration}
     */
    toDuration(unit, opts) {
      if (!this.isValid) {
        return Duration.invalid(this.invalidReason);
      }
      return this.e.diff(this.s, unit, opts);
    }

    /**
     * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
     * @param {function} mapFn
     * @return {Interval}
     * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
     * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
     */
    mapEndpoints(mapFn) {
      return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
    }
  }

  /**
   * The Info class contains static methods for retrieving general time and date related data. For example, it has methods for finding out if a time zone has a DST, for listing the months in any supported locale, and for discovering which of Luxon features are available in the current environment.
   */
  class Info {
    /**
     * Return whether the specified zone contains a DST.
     * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
     * @return {boolean}
     */
    static hasDST(zone = Settings.defaultZone) {
      const proto = DateTime$1.now().setZone(zone).set({ month: 12 });

      return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
    }

    /**
     * Return whether the specified zone is a valid IANA specifier.
     * @param {string} zone - Zone to check
     * @return {boolean}
     */
    static isValidIANAZone(zone) {
      return IANAZone.isValidZone(zone);
    }

    /**
     * Converts the input into a {@link Zone} instance.
     *
     * * If `input` is already a Zone instance, it is returned unchanged.
     * * If `input` is a string containing a valid time zone name, a Zone instance
     *   with that name is returned.
     * * If `input` is a string that doesn't refer to a known time zone, a Zone
     *   instance with {@link Zone#isValid} == false is returned.
     * * If `input is a number, a Zone instance with the specified fixed offset
     *   in minutes is returned.
     * * If `input` is `null` or `undefined`, the default zone is returned.
     * @param {string|Zone|number} [input] - the value to be converted
     * @return {Zone}
     */
    static normalizeZone(input) {
      return normalizeZone(input, Settings.defaultZone);
    }

    /**
     * Return an array of standalone month names.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
     * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @param {string} [opts.numberingSystem=null] - the numbering system
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @param {string} [opts.outputCalendar='gregory'] - the calendar
     * @example Info.months()[0] //=> 'January'
     * @example Info.months('short')[0] //=> 'Jan'
     * @example Info.months('numeric')[0] //=> '1'
     * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
     * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'
     * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'
     * @return {Array}
     */
    static months(
      length = "long",
      { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}
    ) {
      return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
    }

    /**
     * Return an array of format month names.
     * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
     * changes the string.
     * See {@link Info#months}
     * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @param {string} [opts.numberingSystem=null] - the numbering system
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @param {string} [opts.outputCalendar='gregory'] - the calendar
     * @return {Array}
     */
    static monthsFormat(
      length = "long",
      { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}
    ) {
      return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
    }

    /**
     * Return an array of standalone week names.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
     * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @param {string} [opts.numberingSystem=null] - the numbering system
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @example Info.weekdays()[0] //=> 'Monday'
     * @example Info.weekdays('short')[0] //=> 'Mon'
     * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
     * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'
     * @return {Array}
     */
    static weekdays(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
      return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
    }

    /**
     * Return an array of format week names.
     * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
     * changes the string.
     * See {@link Info#weekdays}
     * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
     * @param {Object} opts - options
     * @param {string} [opts.locale=null] - the locale code
     * @param {string} [opts.numberingSystem=null] - the numbering system
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @return {Array}
     */
    static weekdaysFormat(
      length = "long",
      { locale = null, numberingSystem = null, locObj = null } = {}
    ) {
      return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
    }

    /**
     * Return an array of meridiems.
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @example Info.meridiems() //=> [ 'AM', 'PM' ]
     * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]
     * @return {Array}
     */
    static meridiems({ locale = null } = {}) {
      return Locale.create(locale).meridiems();
    }

    /**
     * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
     * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @example Info.eras() //=> [ 'BC', 'AD' ]
     * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
     * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]
     * @return {Array}
     */
    static eras(length = "short", { locale = null } = {}) {
      return Locale.create(locale, null, "gregory").eras(length);
    }

    /**
     * Return the set of available features in this environment.
     * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
     * Keys:
     * * `relative`: whether this environment supports relative time formatting
     * @example Info.features() //=> { relative: false }
     * @return {Object}
     */
    static features() {
      return { relative: hasRelative() };
    }
  }

  function dayDiff(earlier, later) {
    const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(),
      ms = utcDayStart(later) - utcDayStart(earlier);
    return Math.floor(Duration.fromMillis(ms).as("days"));
  }

  function highOrderDiffs(cursor, later, units) {
    const differs = [
      ["years", (a, b) => b.year - a.year],
      ["quarters", (a, b) => b.quarter - a.quarter + (b.year - a.year) * 4],
      ["months", (a, b) => b.month - a.month + (b.year - a.year) * 12],
      [
        "weeks",
        (a, b) => {
          const days = dayDiff(a, b);
          return (days - (days % 7)) / 7;
        },
      ],
      ["days", dayDiff],
    ];

    const results = {};
    const earlier = cursor;
    let lowestOrder, highWater;

    for (const [unit, differ] of differs) {
      if (units.indexOf(unit) >= 0) {
        lowestOrder = unit;

        results[unit] = differ(cursor, later);
        highWater = earlier.plus(results);

        if (highWater > later) {
          results[unit]--;
          cursor = earlier.plus(results);
        } else {
          cursor = highWater;
        }
      }
    }

    return [cursor, results, highWater, lowestOrder];
  }

  function diff (earlier, later, units, opts) {
    let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);

    const remainingMillis = later - cursor;

    const lowerOrderUnits = units.filter(
      (u) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0
    );

    if (lowerOrderUnits.length === 0) {
      if (highWater < later) {
        highWater = cursor.plus({ [lowestOrder]: 1 });
      }

      if (highWater !== cursor) {
        results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
      }
    }

    const duration = Duration.fromObject(results, opts);

    if (lowerOrderUnits.length > 0) {
      return Duration.fromMillis(remainingMillis, opts)
        .shiftTo(...lowerOrderUnits)
        .plus(duration);
    } else {
      return duration;
    }
  }

  const numberingSystems = {
    arab: "[\u0660-\u0669]",
    arabext: "[\u06F0-\u06F9]",
    bali: "[\u1B50-\u1B59]",
    beng: "[\u09E6-\u09EF]",
    deva: "[\u0966-\u096F]",
    fullwide: "[\uFF10-\uFF19]",
    gujr: "[\u0AE6-\u0AEF]",
    hanidec: "[〇|一|二|三|四|五|六|七|八|九]",
    khmr: "[\u17E0-\u17E9]",
    knda: "[\u0CE6-\u0CEF]",
    laoo: "[\u0ED0-\u0ED9]",
    limb: "[\u1946-\u194F]",
    mlym: "[\u0D66-\u0D6F]",
    mong: "[\u1810-\u1819]",
    mymr: "[\u1040-\u1049]",
    orya: "[\u0B66-\u0B6F]",
    tamldec: "[\u0BE6-\u0BEF]",
    telu: "[\u0C66-\u0C6F]",
    thai: "[\u0E50-\u0E59]",
    tibt: "[\u0F20-\u0F29]",
    latn: "\\d",
  };

  const numberingSystemsUTF16 = {
    arab: [1632, 1641],
    arabext: [1776, 1785],
    bali: [6992, 7001],
    beng: [2534, 2543],
    deva: [2406, 2415],
    fullwide: [65296, 65303],
    gujr: [2790, 2799],
    khmr: [6112, 6121],
    knda: [3302, 3311],
    laoo: [3792, 3801],
    limb: [6470, 6479],
    mlym: [3430, 3439],
    mong: [6160, 6169],
    mymr: [4160, 4169],
    orya: [2918, 2927],
    tamldec: [3046, 3055],
    telu: [3174, 3183],
    thai: [3664, 3673],
    tibt: [3872, 3881],
  };

  const hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");

  function parseDigits(str) {
    let value = parseInt(str, 10);
    if (isNaN(value)) {
      value = "";
      for (let i = 0; i < str.length; i++) {
        const code = str.charCodeAt(i);

        if (str[i].search(numberingSystems.hanidec) !== -1) {
          value += hanidecChars.indexOf(str[i]);
        } else {
          for (const key in numberingSystemsUTF16) {
            const [min, max] = numberingSystemsUTF16[key];
            if (code >= min && code <= max) {
              value += code - min;
            }
          }
        }
      }
      return parseInt(value, 10);
    } else {
      return value;
    }
  }

  function digitRegex({ numberingSystem }, append = "") {
    return new RegExp(`${numberingSystems[numberingSystem || "latn"]}${append}`);
  }

  const MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";

  function intUnit(regex, post = (i) => i) {
    return { regex, deser: ([s]) => post(parseDigits(s)) };
  }

  const NBSP = String.fromCharCode(160);
  const spaceOrNBSP = `[ ${NBSP}]`;
  const spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");

  function fixListRegex(s) {
    // make dots optional and also make them literal
    // make space and non breakable space characters interchangeable
    return s.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
  }

  function stripInsensitivities(s) {
    return s
      .replace(/\./g, "") // ignore dots that were made optional
      .replace(spaceOrNBSPRegExp, " ") // interchange space and nbsp
      .toLowerCase();
  }

  function oneOf(strings, startIndex) {
    if (strings === null) {
      return null;
    } else {
      return {
        regex: RegExp(strings.map(fixListRegex).join("|")),
        deser: ([s]) =>
          strings.findIndex((i) => stripInsensitivities(s) === stripInsensitivities(i)) + startIndex,
      };
    }
  }

  function offset(regex, groups) {
    return { regex, deser: ([, h, m]) => signedOffset(h, m), groups };
  }

  function simple(regex) {
    return { regex, deser: ([s]) => s };
  }

  function escapeToken(value) {
    return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
  }

  function unitForToken(token, loc) {
    const one = digitRegex(loc),
      two = digitRegex(loc, "{2}"),
      three = digitRegex(loc, "{3}"),
      four = digitRegex(loc, "{4}"),
      six = digitRegex(loc, "{6}"),
      oneOrTwo = digitRegex(loc, "{1,2}"),
      oneToThree = digitRegex(loc, "{1,3}"),
      oneToSix = digitRegex(loc, "{1,6}"),
      oneToNine = digitRegex(loc, "{1,9}"),
      twoToFour = digitRegex(loc, "{2,4}"),
      fourToSix = digitRegex(loc, "{4,6}"),
      literal = (t) => ({ regex: RegExp(escapeToken(t.val)), deser: ([s]) => s, literal: true }),
      unitate = (t) => {
        if (token.literal) {
          return literal(t);
        }
        switch (t.val) {
          // era
          case "G":
            return oneOf(loc.eras("short", false), 0);
          case "GG":
            return oneOf(loc.eras("long", false), 0);
          // years
          case "y":
            return intUnit(oneToSix);
          case "yy":
            return intUnit(twoToFour, untruncateYear);
          case "yyyy":
            return intUnit(four);
          case "yyyyy":
            return intUnit(fourToSix);
          case "yyyyyy":
            return intUnit(six);
          // months
          case "M":
            return intUnit(oneOrTwo);
          case "MM":
            return intUnit(two);
          case "MMM":
            return oneOf(loc.months("short", true, false), 1);
          case "MMMM":
            return oneOf(loc.months("long", true, false), 1);
          case "L":
            return intUnit(oneOrTwo);
          case "LL":
            return intUnit(two);
          case "LLL":
            return oneOf(loc.months("short", false, false), 1);
          case "LLLL":
            return oneOf(loc.months("long", false, false), 1);
          // dates
          case "d":
            return intUnit(oneOrTwo);
          case "dd":
            return intUnit(two);
          // ordinals
          case "o":
            return intUnit(oneToThree);
          case "ooo":
            return intUnit(three);
          // time
          case "HH":
            return intUnit(two);
          case "H":
            return intUnit(oneOrTwo);
          case "hh":
            return intUnit(two);
          case "h":
            return intUnit(oneOrTwo);
          case "mm":
            return intUnit(two);
          case "m":
            return intUnit(oneOrTwo);
          case "q":
            return intUnit(oneOrTwo);
          case "qq":
            return intUnit(two);
          case "s":
            return intUnit(oneOrTwo);
          case "ss":
            return intUnit(two);
          case "S":
            return intUnit(oneToThree);
          case "SSS":
            return intUnit(three);
          case "u":
            return simple(oneToNine);
          case "uu":
            return simple(oneOrTwo);
          case "uuu":
            return intUnit(one);
          // meridiem
          case "a":
            return oneOf(loc.meridiems(), 0);
          // weekYear (k)
          case "kkkk":
            return intUnit(four);
          case "kk":
            return intUnit(twoToFour, untruncateYear);
          // weekNumber (W)
          case "W":
            return intUnit(oneOrTwo);
          case "WW":
            return intUnit(two);
          // weekdays
          case "E":
          case "c":
            return intUnit(one);
          case "EEE":
            return oneOf(loc.weekdays("short", false, false), 1);
          case "EEEE":
            return oneOf(loc.weekdays("long", false, false), 1);
          case "ccc":
            return oneOf(loc.weekdays("short", true, false), 1);
          case "cccc":
            return oneOf(loc.weekdays("long", true, false), 1);
          // offset/zone
          case "Z":
          case "ZZ":
            return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
          case "ZZZ":
            return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
          // we don't support ZZZZ (PST) or ZZZZZ (Pacific Standard Time) in parsing
          // because we don't have any way to figure out what they are
          case "z":
            return simple(/[a-z_+-/]{1,256}?/i);
          // this special-case "token" represents a place where a macro-token expanded into a white-space literal
          // in this case we accept any non-newline white-space
          case " ":
            return simple(/[^\S\n\r]/);
          default:
            return literal(t);
        }
      };

    const unit = unitate(token) || {
      invalidReason: MISSING_FTP,
    };

    unit.token = token;

    return unit;
  }

  const partTypeStyleToTokenVal = {
    year: {
      "2-digit": "yy",
      numeric: "yyyyy",
    },
    month: {
      numeric: "M",
      "2-digit": "MM",
      short: "MMM",
      long: "MMMM",
    },
    day: {
      numeric: "d",
      "2-digit": "dd",
    },
    weekday: {
      short: "EEE",
      long: "EEEE",
    },
    dayperiod: "a",
    dayPeriod: "a",
    hour: {
      numeric: "h",
      "2-digit": "hh",
    },
    minute: {
      numeric: "m",
      "2-digit": "mm",
    },
    second: {
      numeric: "s",
      "2-digit": "ss",
    },
    timeZoneName: {
      long: "ZZZZZ",
      short: "ZZZ",
    },
  };

  function tokenForPart(part, formatOpts) {
    const { type, value } = part;

    if (type === "literal") {
      const isSpace = /^\s+$/.test(value);
      return {
        literal: !isSpace,
        val: isSpace ? " " : value,
      };
    }

    const style = formatOpts[type];

    let val = partTypeStyleToTokenVal[type];
    if (typeof val === "object") {
      val = val[style];
    }

    if (val) {
      return {
        literal: false,
        val,
      };
    }

    return undefined;
  }

  function buildRegex(units) {
    const re = units.map((u) => u.regex).reduce((f, r) => `${f}(${r.source})`, "");
    return [`^${re}$`, units];
  }

  function match(input, regex, handlers) {
    const matches = input.match(regex);

    if (matches) {
      const all = {};
      let matchIndex = 1;
      for (const i in handlers) {
        if (hasOwnProperty$1(handlers, i)) {
          const h = handlers[i],
            groups = h.groups ? h.groups + 1 : 1;
          if (!h.literal && h.token) {
            all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
          }
          matchIndex += groups;
        }
      }
      return [matches, all];
    } else {
      return [matches, {}];
    }
  }

  function dateTimeFromMatches(matches) {
    const toField = (token) => {
      switch (token) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
        case "H":
          return "hour";
        case "d":
          return "day";
        case "o":
          return "ordinal";
        case "L":
        case "M":
          return "month";
        case "y":
          return "year";
        case "E":
        case "c":
          return "weekday";
        case "W":
          return "weekNumber";
        case "k":
          return "weekYear";
        case "q":
          return "quarter";
        default:
          return null;
      }
    };

    let zone = null;
    let specificOffset;
    if (!isUndefined(matches.z)) {
      zone = IANAZone.create(matches.z);
    }

    if (!isUndefined(matches.Z)) {
      if (!zone) {
        zone = new FixedOffsetZone(matches.Z);
      }
      specificOffset = matches.Z;
    }

    if (!isUndefined(matches.q)) {
      matches.M = (matches.q - 1) * 3 + 1;
    }

    if (!isUndefined(matches.h)) {
      if (matches.h < 12 && matches.a === 1) {
        matches.h += 12;
      } else if (matches.h === 12 && matches.a === 0) {
        matches.h = 0;
      }
    }

    if (matches.G === 0 && matches.y) {
      matches.y = -matches.y;
    }

    if (!isUndefined(matches.u)) {
      matches.S = parseMillis(matches.u);
    }

    const vals = Object.keys(matches).reduce((r, k) => {
      const f = toField(k);
      if (f) {
        r[f] = matches[k];
      }

      return r;
    }, {});

    return [vals, zone, specificOffset];
  }

  let dummyDateTimeCache = null;

  function getDummyDateTime() {
    if (!dummyDateTimeCache) {
      dummyDateTimeCache = DateTime$1.fromMillis(1555555555555);
    }

    return dummyDateTimeCache;
  }

  function maybeExpandMacroToken(token, locale) {
    if (token.literal) {
      return token;
    }

    const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
    const tokens = formatOptsToTokens(formatOpts, locale);

    if (tokens == null || tokens.includes(undefined)) {
      return token;
    }

    return tokens;
  }

  function expandMacroTokens(tokens, locale) {
    return Array.prototype.concat(...tokens.map((t) => maybeExpandMacroToken(t, locale)));
  }

  /**
   * @private
   */

  function explainFromTokens(locale, input, format) {
    const tokens = expandMacroTokens(Formatter.parseFormat(format), locale),
      units = tokens.map((t) => unitForToken(t, locale)),
      disqualifyingUnit = units.find((t) => t.invalidReason);

    if (disqualifyingUnit) {
      return { input, tokens, invalidReason: disqualifyingUnit.invalidReason };
    } else {
      const [regexString, handlers] = buildRegex(units),
        regex = RegExp(regexString, "i"),
        [rawMatches, matches] = match(input, regex, handlers),
        [result, zone, specificOffset] = matches
          ? dateTimeFromMatches(matches)
          : [null, null, undefined];
      if (hasOwnProperty$1(matches, "a") && hasOwnProperty$1(matches, "H")) {
        throw new ConflictingSpecificationError(
          "Can't include meridiem when specifying 24-hour format"
        );
      }
      return { input, tokens, regex, rawMatches, matches, result, zone, specificOffset };
    }
  }

  function parseFromTokens(locale, input, format) {
    const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale, input, format);
    return [result, zone, specificOffset, invalidReason];
  }

  function formatOptsToTokens(formatOpts, locale) {
    if (!formatOpts) {
      return null;
    }

    const formatter = Formatter.create(locale, formatOpts);
    const parts = formatter.formatDateTimeParts(getDummyDateTime());
    return parts.map((p) => tokenForPart(p, formatOpts));
  }

  const nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],
    leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];

  function unitOutOfRange(unit, value) {
    return new Invalid(
      "unit out of range",
      `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`
    );
  }

  function dayOfWeek(year, month, day) {
    const d = new Date(Date.UTC(year, month - 1, day));

    if (year < 100 && year >= 0) {
      d.setUTCFullYear(d.getUTCFullYear() - 1900);
    }

    const js = d.getUTCDay();

    return js === 0 ? 7 : js;
  }

  function computeOrdinal(year, month, day) {
    return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
  }

  function uncomputeOrdinal(year, ordinal) {
    const table = isLeapYear(year) ? leapLadder : nonLeapLadder,
      month0 = table.findIndex((i) => i < ordinal),
      day = ordinal - table[month0];
    return { month: month0 + 1, day };
  }

  /**
   * @private
   */

  function gregorianToWeek(gregObj) {
    const { year, month, day } = gregObj,
      ordinal = computeOrdinal(year, month, day),
      weekday = dayOfWeek(year, month, day);

    let weekNumber = Math.floor((ordinal - weekday + 10) / 7),
      weekYear;

    if (weekNumber < 1) {
      weekYear = year - 1;
      weekNumber = weeksInWeekYear(weekYear);
    } else if (weekNumber > weeksInWeekYear(year)) {
      weekYear = year + 1;
      weekNumber = 1;
    } else {
      weekYear = year;
    }

    return { weekYear, weekNumber, weekday, ...timeObject(gregObj) };
  }

  function weekToGregorian(weekData) {
    const { weekYear, weekNumber, weekday } = weekData,
      weekdayOfJan4 = dayOfWeek(weekYear, 1, 4),
      yearInDays = daysInYear(weekYear);

    let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3,
      year;

    if (ordinal < 1) {
      year = weekYear - 1;
      ordinal += daysInYear(year);
    } else if (ordinal > yearInDays) {
      year = weekYear + 1;
      ordinal -= daysInYear(weekYear);
    } else {
      year = weekYear;
    }

    const { month, day } = uncomputeOrdinal(year, ordinal);
    return { year, month, day, ...timeObject(weekData) };
  }

  function gregorianToOrdinal(gregData) {
    const { year, month, day } = gregData;
    const ordinal = computeOrdinal(year, month, day);
    return { year, ordinal, ...timeObject(gregData) };
  }

  function ordinalToGregorian(ordinalData) {
    const { year, ordinal } = ordinalData;
    const { month, day } = uncomputeOrdinal(year, ordinal);
    return { year, month, day, ...timeObject(ordinalData) };
  }

  function hasInvalidWeekData(obj) {
    const validYear = isInteger(obj.weekYear),
      validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)),
      validWeekday = integerBetween(obj.weekday, 1, 7);

    if (!validYear) {
      return unitOutOfRange("weekYear", obj.weekYear);
    } else if (!validWeek) {
      return unitOutOfRange("week", obj.week);
    } else if (!validWeekday) {
      return unitOutOfRange("weekday", obj.weekday);
    } else return false;
  }

  function hasInvalidOrdinalData(obj) {
    const validYear = isInteger(obj.year),
      validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));

    if (!validYear) {
      return unitOutOfRange("year", obj.year);
    } else if (!validOrdinal) {
      return unitOutOfRange("ordinal", obj.ordinal);
    } else return false;
  }

  function hasInvalidGregorianData(obj) {
    const validYear = isInteger(obj.year),
      validMonth = integerBetween(obj.month, 1, 12),
      validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));

    if (!validYear) {
      return unitOutOfRange("year", obj.year);
    } else if (!validMonth) {
      return unitOutOfRange("month", obj.month);
    } else if (!validDay) {
      return unitOutOfRange("day", obj.day);
    } else return false;
  }

  function hasInvalidTimeData(obj) {
    const { hour, minute, second, millisecond } = obj;
    const validHour =
        integerBetween(hour, 0, 23) ||
        (hour === 24 && minute === 0 && second === 0 && millisecond === 0),
      validMinute = integerBetween(minute, 0, 59),
      validSecond = integerBetween(second, 0, 59),
      validMillisecond = integerBetween(millisecond, 0, 999);

    if (!validHour) {
      return unitOutOfRange("hour", hour);
    } else if (!validMinute) {
      return unitOutOfRange("minute", minute);
    } else if (!validSecond) {
      return unitOutOfRange("second", second);
    } else if (!validMillisecond) {
      return unitOutOfRange("millisecond", millisecond);
    } else return false;
  }

  const INVALID = "Invalid DateTime";
  const MAX_DATE = 8.64e15;

  function unsupportedZone(zone) {
    return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
  }

  // we cache week data on the DT object and this intermediates the cache
  function possiblyCachedWeekData(dt) {
    if (dt.weekData === null) {
      dt.weekData = gregorianToWeek(dt.c);
    }
    return dt.weekData;
  }

  // clone really means, "make a new object with these modifications". all "setters" really use this
  // to create a new object while only changing some of the properties
  function clone(inst, alts) {
    const current = {
      ts: inst.ts,
      zone: inst.zone,
      c: inst.c,
      o: inst.o,
      loc: inst.loc,
      invalid: inst.invalid,
    };
    return new DateTime$1({ ...current, ...alts, old: current });
  }

  // find the right offset a given local time. The o input is our guess, which determines which
  // offset we'll pick in ambiguous cases (e.g. there are two 3 AMs b/c Fallback DST)
  function fixOffset(localTS, o, tz) {
    // Our UTC time is just a guess because our offset is just a guess
    let utcGuess = localTS - o * 60 * 1000;

    // Test whether the zone matches the offset for this ts
    const o2 = tz.offset(utcGuess);

    // If so, offset didn't change and we're done
    if (o === o2) {
      return [utcGuess, o];
    }

    // If not, change the ts by the difference in the offset
    utcGuess -= (o2 - o) * 60 * 1000;

    // If that gives us the local time we want, we're done
    const o3 = tz.offset(utcGuess);
    if (o2 === o3) {
      return [utcGuess, o2];
    }

    // If it's different, we're in a hole time. The offset has changed, but the we don't adjust the time
    return [localTS - Math.min(o2, o3) * 60 * 1000, Math.max(o2, o3)];
  }

  // convert an epoch timestamp into a calendar object with the given offset
  function tsToObj(ts, offset) {
    ts += offset * 60 * 1000;

    const d = new Date(ts);

    return {
      year: d.getUTCFullYear(),
      month: d.getUTCMonth() + 1,
      day: d.getUTCDate(),
      hour: d.getUTCHours(),
      minute: d.getUTCMinutes(),
      second: d.getUTCSeconds(),
      millisecond: d.getUTCMilliseconds(),
    };
  }

  // convert a calendar object to a epoch timestamp
  function objToTS(obj, offset, zone) {
    return fixOffset(objToLocalTS(obj), offset, zone);
  }

  // create a new DT instance by adding a duration, adjusting for DSTs
  function adjustTime(inst, dur) {
    const oPre = inst.o,
      year = inst.c.year + Math.trunc(dur.years),
      month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3,
      c = {
        ...inst.c,
        year,
        month,
        day:
          Math.min(inst.c.day, daysInMonth(year, month)) +
          Math.trunc(dur.days) +
          Math.trunc(dur.weeks) * 7,
      },
      millisToAdd = Duration.fromObject({
        years: dur.years - Math.trunc(dur.years),
        quarters: dur.quarters - Math.trunc(dur.quarters),
        months: dur.months - Math.trunc(dur.months),
        weeks: dur.weeks - Math.trunc(dur.weeks),
        days: dur.days - Math.trunc(dur.days),
        hours: dur.hours,
        minutes: dur.minutes,
        seconds: dur.seconds,
        milliseconds: dur.milliseconds,
      }).as("milliseconds"),
      localTS = objToLocalTS(c);

    let [ts, o] = fixOffset(localTS, oPre, inst.zone);

    if (millisToAdd !== 0) {
      ts += millisToAdd;
      // that could have changed the offset by going over a DST, but we want to keep the ts the same
      o = inst.zone.offset(ts);
    }

    return { ts, o };
  }

  // helper useful in turning the results of parsing into real dates
  // by handling the zone options
  function parseDataToDateTime(parsed, parsedZone, opts, format, text, specificOffset) {
    const { setZone, zone } = opts;
    if ((parsed && Object.keys(parsed).length !== 0) || parsedZone) {
      const interpretationZone = parsedZone || zone,
        inst = DateTime$1.fromObject(parsed, {
          ...opts,
          zone: interpretationZone,
          specificOffset,
        });
      return setZone ? inst : inst.setZone(zone);
    } else {
      return DateTime$1.invalid(
        new Invalid("unparsable", `the input "${text}" can't be parsed as ${format}`)
      );
    }
  }

  // if you want to output a technical format (e.g. RFC 2822), this helper
  // helps handle the details
  function toTechFormat(dt, format, allowZ = true) {
    return dt.isValid
      ? Formatter.create(Locale.create("en-US"), {
          allowZ,
          forceSimple: true,
        }).formatDateTimeFromString(dt, format)
      : null;
  }

  function toISODate(o, extended) {
    const longFormat = o.c.year > 9999 || o.c.year < 0;
    let c = "";
    if (longFormat && o.c.year >= 0) c += "+";
    c += padStart$1(o.c.year, longFormat ? 6 : 4);

    if (extended) {
      c += "-";
      c += padStart$1(o.c.month);
      c += "-";
      c += padStart$1(o.c.day);
    } else {
      c += padStart$1(o.c.month);
      c += padStart$1(o.c.day);
    }
    return c;
  }

  function toISOTime(
    o,
    extended,
    suppressSeconds,
    suppressMilliseconds,
    includeOffset,
    extendedZone
  ) {
    let c = padStart$1(o.c.hour);
    if (extended) {
      c += ":";
      c += padStart$1(o.c.minute);
      if (o.c.second !== 0 || !suppressSeconds) {
        c += ":";
      }
    } else {
      c += padStart$1(o.c.minute);
    }

    if (o.c.second !== 0 || !suppressSeconds) {
      c += padStart$1(o.c.second);

      if (o.c.millisecond !== 0 || !suppressMilliseconds) {
        c += ".";
        c += padStart$1(o.c.millisecond, 3);
      }
    }

    if (includeOffset) {
      if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {
        c += "Z";
      } else if (o.o < 0) {
        c += "-";
        c += padStart$1(Math.trunc(-o.o / 60));
        c += ":";
        c += padStart$1(Math.trunc(-o.o % 60));
      } else {
        c += "+";
        c += padStart$1(Math.trunc(o.o / 60));
        c += ":";
        c += padStart$1(Math.trunc(o.o % 60));
      }
    }

    if (extendedZone) {
      c += "[" + o.zone.ianaName + "]";
    }
    return c;
  }

  // defaults for unspecified units in the supported calendars
  const defaultUnitValues = {
      month: 1,
      day: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0,
    },
    defaultWeekUnitValues = {
      weekNumber: 1,
      weekday: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0,
    },
    defaultOrdinalUnitValues = {
      ordinal: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0,
    };

  // Units in the supported calendars, sorted by bigness
  const orderedUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"],
    orderedWeekUnits = [
      "weekYear",
      "weekNumber",
      "weekday",
      "hour",
      "minute",
      "second",
      "millisecond",
    ],
    orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];

  // standardize case and plurality in units
  function normalizeUnit(unit) {
    const normalized = {
      year: "year",
      years: "year",
      month: "month",
      months: "month",
      day: "day",
      days: "day",
      hour: "hour",
      hours: "hour",
      minute: "minute",
      minutes: "minute",
      quarter: "quarter",
      quarters: "quarter",
      second: "second",
      seconds: "second",
      millisecond: "millisecond",
      milliseconds: "millisecond",
      weekday: "weekday",
      weekdays: "weekday",
      weeknumber: "weekNumber",
      weeksnumber: "weekNumber",
      weeknumbers: "weekNumber",
      weekyear: "weekYear",
      weekyears: "weekYear",
      ordinal: "ordinal",
    }[unit.toLowerCase()];

    if (!normalized) throw new InvalidUnitError(unit);

    return normalized;
  }

  // this is a dumbed down version of fromObject() that runs about 60% faster
  // but doesn't do any validation, makes a bunch of assumptions about what units
  // are present, and so on.
  function quickDT(obj, opts) {
    const zone = normalizeZone(opts.zone, Settings.defaultZone),
      loc = Locale.fromObject(opts),
      tsNow = Settings.now();

    let ts, o;

    // assume we have the higher-order units
    if (!isUndefined(obj.year)) {
      for (const u of orderedUnits) {
        if (isUndefined(obj[u])) {
          obj[u] = defaultUnitValues[u];
        }
      }

      const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
      if (invalid) {
        return DateTime$1.invalid(invalid);
      }

      const offsetProvis = zone.offset(tsNow);
      [ts, o] = objToTS(obj, offsetProvis, zone);
    } else {
      ts = tsNow;
    }

    return new DateTime$1({ ts, zone, loc, o });
  }

  function diffRelative(start, end, opts) {
    const round = isUndefined(opts.round) ? true : opts.round,
      format = (c, unit) => {
        c = roundTo(c, round || opts.calendary ? 0 : 2, true);
        const formatter = end.loc.clone(opts).relFormatter(opts);
        return formatter.format(c, unit);
      },
      differ = (unit) => {
        if (opts.calendary) {
          if (!end.hasSame(start, unit)) {
            return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
          } else return 0;
        } else {
          return end.diff(start, unit).get(unit);
        }
      };

    if (opts.unit) {
      return format(differ(opts.unit), opts.unit);
    }

    for (const unit of opts.units) {
      const count = differ(unit);
      if (Math.abs(count) >= 1) {
        return format(count, unit);
      }
    }
    return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
  }

  function lastOpts(argList) {
    let opts = {},
      args;
    if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
      opts = argList[argList.length - 1];
      args = Array.from(argList).slice(0, argList.length - 1);
    } else {
      args = Array.from(argList);
    }
    return [opts, args];
  }

  /**
   * A DateTime is an immutable data structure representing a specific date and time and accompanying methods. It contains class and instance methods for creating, parsing, interrogating, transforming, and formatting them.
   *
   * A DateTime comprises of:
   * * A timestamp. Each DateTime instance refers to a specific millisecond of the Unix epoch.
   * * A time zone. Each instance is considered in the context of a specific zone (by default the local system's zone).
   * * Configuration properties that effect how output strings are formatted, such as `locale`, `numberingSystem`, and `outputCalendar`.
   *
   * Here is a brief overview of the most commonly used functionality it provides:
   *
   * * **Creation**: To create a DateTime from its components, use one of its factory class methods: {@link DateTime.local}, {@link DateTime.utc}, and (most flexibly) {@link DateTime.fromObject}. To create one from a standard string format, use {@link DateTime.fromISO}, {@link DateTime.fromHTTP}, and {@link DateTime.fromRFC2822}. To create one from a custom string format, use {@link DateTime.fromFormat}. To create one from a native JS date, use {@link DateTime.fromJSDate}.
   * * **Gregorian calendar and time**: To examine the Gregorian properties of a DateTime individually (i.e as opposed to collectively through {@link DateTime#toObject}), use the {@link DateTime#year}, {@link DateTime#month},
   * {@link DateTime#day}, {@link DateTime#hour}, {@link DateTime#minute}, {@link DateTime#second}, {@link DateTime#millisecond} accessors.
   * * **Week calendar**: For ISO week calendar attributes, see the {@link DateTime#weekYear}, {@link DateTime#weekNumber}, and {@link DateTime#weekday} accessors.
   * * **Configuration** See the {@link DateTime#locale} and {@link DateTime#numberingSystem} accessors.
   * * **Transformation**: To transform the DateTime into other DateTimes, use {@link DateTime#set}, {@link DateTime#reconfigure}, {@link DateTime#setZone}, {@link DateTime#setLocale}, {@link DateTime.plus}, {@link DateTime#minus}, {@link DateTime#endOf}, {@link DateTime#startOf}, {@link DateTime#toUTC}, and {@link DateTime#toLocal}.
   * * **Output**: To convert the DateTime to other representations, use the {@link DateTime#toRelative}, {@link DateTime#toRelativeCalendar}, {@link DateTime#toJSON}, {@link DateTime#toISO}, {@link DateTime#toHTTP}, {@link DateTime#toObject}, {@link DateTime#toRFC2822}, {@link DateTime#toString}, {@link DateTime#toLocaleString}, {@link DateTime#toFormat}, {@link DateTime#toMillis} and {@link DateTime#toJSDate}.
   *
   * There's plenty others documented below. In addition, for more information on subtler topics like internationalization, time zones, alternative calendars, validity, and so on, see the external documentation.
   */
  class DateTime$1 {
    /**
     * @access private
     */
    constructor(config) {
      const zone = config.zone || Settings.defaultZone;

      let invalid =
        config.invalid ||
        (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) ||
        (!zone.isValid ? unsupportedZone(zone) : null);
      /**
       * @access private
       */
      this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;

      let c = null,
        o = null;
      if (!invalid) {
        const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);

        if (unchanged) {
          [c, o] = [config.old.c, config.old.o];
        } else {
          const ot = zone.offset(this.ts);
          c = tsToObj(this.ts, ot);
          invalid = Number.isNaN(c.year) ? new Invalid("invalid input") : null;
          c = invalid ? null : c;
          o = invalid ? null : ot;
        }
      }

      /**
       * @access private
       */
      this._zone = zone;
      /**
       * @access private
       */
      this.loc = config.loc || Locale.create();
      /**
       * @access private
       */
      this.invalid = invalid;
      /**
       * @access private
       */
      this.weekData = null;
      /**
       * @access private
       */
      this.c = c;
      /**
       * @access private
       */
      this.o = o;
      /**
       * @access private
       */
      this.isLuxonDateTime = true;
    }

    // CONSTRUCT

    /**
     * Create a DateTime for the current instant, in the system's time zone.
     *
     * Use Settings to override these default values if needed.
     * @example DateTime.now().toISO() //~> now in the ISO format
     * @return {DateTime}
     */
    static now() {
      return new DateTime$1({});
    }

    /**
     * Create a local DateTime
     * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
     * @param {number} [month=1] - The month, 1-indexed
     * @param {number} [day=1] - The day of the month, 1-indexed
     * @param {number} [hour=0] - The hour of the day, in 24-hour time
     * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
     * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
     * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
     * @example DateTime.local()                                  //~> now
     * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
     * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
     * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
     * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
     * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
     * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
     * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
     * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
     * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
     * @return {DateTime}
     */
    static local() {
      const [opts, args] = lastOpts(arguments),
        [year, month, day, hour, minute, second, millisecond] = args;
      return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
    }

    /**
     * Create a DateTime in UTC
     * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
     * @param {number} [month=1] - The month, 1-indexed
     * @param {number} [day=1] - The day of the month
     * @param {number} [hour=0] - The hour of the day, in 24-hour time
     * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
     * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
     * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
     * @param {Object} options - configuration options for the DateTime
     * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
     * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
     * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
     * @example DateTime.utc()                                              //~> now
     * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
     * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
     * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
     * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
     * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
     * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
     * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
     * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
     * @return {DateTime}
     */
    static utc() {
      const [opts, args] = lastOpts(arguments),
        [year, month, day, hour, minute, second, millisecond] = args;

      opts.zone = FixedOffsetZone.utcInstance;
      return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
    }

    /**
     * Create a DateTime from a JavaScript Date object. Uses the default zone.
     * @param {Date} date - a JavaScript Date object
     * @param {Object} options - configuration options for the DateTime
     * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
     * @return {DateTime}
     */
    static fromJSDate(date, options = {}) {
      const ts = isDate(date) ? date.valueOf() : NaN;
      if (Number.isNaN(ts)) {
        return DateTime$1.invalid("invalid input");
      }

      const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
      if (!zoneToUse.isValid) {
        return DateTime$1.invalid(unsupportedZone(zoneToUse));
      }

      return new DateTime$1({
        ts: ts,
        zone: zoneToUse,
        loc: Locale.fromObject(options),
      });
    }

    /**
     * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
     * @param {number} milliseconds - a number of milliseconds since 1970 UTC
     * @param {Object} options - configuration options for the DateTime
     * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
     * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
     * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
     * @return {DateTime}
     */
    static fromMillis(milliseconds, options = {}) {
      if (!isNumber$1(milliseconds)) {
        throw new InvalidArgumentError(
          `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`
        );
      } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
        // this isn't perfect because because we can still end up out of range because of additional shifting, but it's a start
        return DateTime$1.invalid("Timestamp out of range");
      } else {
        return new DateTime$1({
          ts: milliseconds,
          zone: normalizeZone(options.zone, Settings.defaultZone),
          loc: Locale.fromObject(options),
        });
      }
    }

    /**
     * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
     * @param {number} seconds - a number of seconds since 1970 UTC
     * @param {Object} options - configuration options for the DateTime
     * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
     * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
     * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
     * @return {DateTime}
     */
    static fromSeconds(seconds, options = {}) {
      if (!isNumber$1(seconds)) {
        throw new InvalidArgumentError("fromSeconds requires a numerical input");
      } else {
        return new DateTime$1({
          ts: seconds * 1000,
          zone: normalizeZone(options.zone, Settings.defaultZone),
          loc: Locale.fromObject(options),
        });
      }
    }

    /**
     * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
     * @param {Object} obj - the object to create the DateTime from
     * @param {number} obj.year - a year, such as 1987
     * @param {number} obj.month - a month, 1-12
     * @param {number} obj.day - a day of the month, 1-31, depending on the month
     * @param {number} obj.ordinal - day of the year, 1-365 or 366
     * @param {number} obj.weekYear - an ISO week year
     * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
     * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
     * @param {number} obj.hour - hour of the day, 0-23
     * @param {number} obj.minute - minute of the hour, 0-59
     * @param {number} obj.second - second of the minute, 0-59
     * @param {number} obj.millisecond - millisecond of the second, 0-999
     * @param {Object} opts - options for creating this DateTime
     * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
     * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
     * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
     * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
     * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
     * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
     * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
     * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
     * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
     * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
     * @return {DateTime}
     */
    static fromObject(obj, opts = {}) {
      obj = obj || {};
      const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
      if (!zoneToUse.isValid) {
        return DateTime$1.invalid(unsupportedZone(zoneToUse));
      }

      const tsNow = Settings.now(),
        offsetProvis = !isUndefined(opts.specificOffset)
          ? opts.specificOffset
          : zoneToUse.offset(tsNow),
        normalized = normalizeObject(obj, normalizeUnit),
        containsOrdinal = !isUndefined(normalized.ordinal),
        containsGregorYear = !isUndefined(normalized.year),
        containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day),
        containsGregor = containsGregorYear || containsGregorMD,
        definiteWeekDef = normalized.weekYear || normalized.weekNumber,
        loc = Locale.fromObject(opts);

      // cases:
      // just a weekday -> this week's instance of that weekday, no worries
      // (gregorian data or ordinal) + (weekYear or weekNumber) -> error
      // (gregorian month or day) + ordinal -> error
      // otherwise just use weeks or ordinals or gregorian, depending on what's specified

      if ((containsGregor || containsOrdinal) && definiteWeekDef) {
        throw new ConflictingSpecificationError(
          "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
        );
      }

      if (containsGregorMD && containsOrdinal) {
        throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
      }

      const useWeekData = definiteWeekDef || (normalized.weekday && !containsGregor);

      // configure ourselves to deal with gregorian dates or week stuff
      let units,
        defaultValues,
        objNow = tsToObj(tsNow, offsetProvis);
      if (useWeekData) {
        units = orderedWeekUnits;
        defaultValues = defaultWeekUnitValues;
        objNow = gregorianToWeek(objNow);
      } else if (containsOrdinal) {
        units = orderedOrdinalUnits;
        defaultValues = defaultOrdinalUnitValues;
        objNow = gregorianToOrdinal(objNow);
      } else {
        units = orderedUnits;
        defaultValues = defaultUnitValues;
      }

      // set default values for missing stuff
      let foundFirst = false;
      for (const u of units) {
        const v = normalized[u];
        if (!isUndefined(v)) {
          foundFirst = true;
        } else if (foundFirst) {
          normalized[u] = defaultValues[u];
        } else {
          normalized[u] = objNow[u];
        }
      }

      // make sure the values we have are in range
      const higherOrderInvalid = useWeekData
          ? hasInvalidWeekData(normalized)
          : containsOrdinal
          ? hasInvalidOrdinalData(normalized)
          : hasInvalidGregorianData(normalized),
        invalid = higherOrderInvalid || hasInvalidTimeData(normalized);

      if (invalid) {
        return DateTime$1.invalid(invalid);
      }

      // compute the actual time
      const gregorian = useWeekData
          ? weekToGregorian(normalized)
          : containsOrdinal
          ? ordinalToGregorian(normalized)
          : normalized,
        [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse),
        inst = new DateTime$1({
          ts: tsFinal,
          zone: zoneToUse,
          o: offsetFinal,
          loc,
        });

      // gregorian data + weekday serves only to validate
      if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
        return DateTime$1.invalid(
          "mismatched weekday",
          `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`
        );
      }

      return inst;
    }

    /**
     * Create a DateTime from an ISO 8601 string
     * @param {string} text - the ISO string
     * @param {Object} opts - options to affect the creation
     * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
     * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
     * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
     * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
     * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
     * @example DateTime.fromISO('2016-05-25T09:08:34.123')
     * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
     * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
     * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
     * @example DateTime.fromISO('2016-W05-4')
     * @return {DateTime}
     */
    static fromISO(text, opts = {}) {
      const [vals, parsedZone] = parseISODate(text);
      return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
    }

    /**
     * Create a DateTime from an RFC 2822 string
     * @param {string} text - the RFC 2822 string
     * @param {Object} opts - options to affect the creation
     * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
     * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
     * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
     * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
     * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
     * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
     * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
     * @return {DateTime}
     */
    static fromRFC2822(text, opts = {}) {
      const [vals, parsedZone] = parseRFC2822Date(text);
      return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
    }

    /**
     * Create a DateTime from an HTTP header date
     * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
     * @param {string} text - the HTTP header date
     * @param {Object} opts - options to affect the creation
     * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
     * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
     * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
     * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
     * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
     * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
     * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
     * @return {DateTime}
     */
    static fromHTTP(text, opts = {}) {
      const [vals, parsedZone] = parseHTTPDate(text);
      return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
    }

    /**
     * Create a DateTime from an input string and format string.
     * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
     * @param {string} text - the string to parse
     * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
     * @param {Object} opts - options to affect the creation
     * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
     * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
     * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
     * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
     * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @return {DateTime}
     */
    static fromFormat(text, fmt, opts = {}) {
      if (isUndefined(text) || isUndefined(fmt)) {
        throw new InvalidArgumentError("fromFormat requires an input string and a format");
      }

      const { locale = null, numberingSystem = null } = opts,
        localeToUse = Locale.fromOpts({
          locale,
          numberingSystem,
          defaultToEN: true,
        }),
        [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text, fmt);
      if (invalid) {
        return DateTime$1.invalid(invalid);
      } else {
        return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);
      }
    }

    /**
     * @deprecated use fromFormat instead
     */
    static fromString(text, fmt, opts = {}) {
      return DateTime$1.fromFormat(text, fmt, opts);
    }

    /**
     * Create a DateTime from a SQL date, time, or datetime
     * Defaults to en-US if no locale has been specified, regardless of the system's locale
     * @param {string} text - the string to parse
     * @param {Object} opts - options to affect the creation
     * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
     * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
     * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
     * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
     * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @example DateTime.fromSQL('2017-05-15')
     * @example DateTime.fromSQL('2017-05-15 09:12:34')
     * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
     * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
     * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
     * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
     * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
     * @example DateTime.fromSQL('09:12:34.342')
     * @return {DateTime}
     */
    static fromSQL(text, opts = {}) {
      const [vals, parsedZone] = parseSQL(text);
      return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
    }

    /**
     * Create an invalid DateTime.
     * @param {DateTime} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent
     * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
     * @return {DateTime}
     */
    static invalid(reason, explanation = null) {
      if (!reason) {
        throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
      }

      const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);

      if (Settings.throwOnInvalid) {
        throw new InvalidDateTimeError(invalid);
      } else {
        return new DateTime$1({ invalid });
      }
    }

    /**
     * Check if an object is an instance of DateTime. Works across context boundaries
     * @param {object} o
     * @return {boolean}
     */
    static isDateTime(o) {
      return (o && o.isLuxonDateTime) || false;
    }

    /**
     * Produce the format string for a set of options
     * @param formatOpts
     * @param localeOpts
     * @returns {string}
     */
    static parseFormatForOpts(formatOpts, localeOpts = {}) {
      const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
      return !tokenList ? null : tokenList.map((t) => (t ? t.val : null)).join("");
    }

    /**
     * Produce the the fully expanded format token for the locale
     * Does NOT quote characters, so quoted tokens will not round trip correctly
     * @param fmt
     * @param localeOpts
     * @returns {string}
     */
    static expandFormat(fmt, localeOpts = {}) {
      const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
      return expanded.map((t) => t.val).join("");
    }

    // INFO

    /**
     * Get the value of unit.
     * @param {string} unit - a unit such as 'minute' or 'day'
     * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
     * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
     * @return {number}
     */
    get(unit) {
      return this[unit];
    }

    /**
     * Returns whether the DateTime is valid. Invalid DateTimes occur when:
     * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
     * * The DateTime was created by an operation on another invalid date
     * @type {boolean}
     */
    get isValid() {
      return this.invalid === null;
    }

    /**
     * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
     * @type {string}
     */
    get invalidReason() {
      return this.invalid ? this.invalid.reason : null;
    }

    /**
     * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
     * @type {string}
     */
    get invalidExplanation() {
      return this.invalid ? this.invalid.explanation : null;
    }

    /**
     * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
     *
     * @type {string}
     */
    get locale() {
      return this.isValid ? this.loc.locale : null;
    }

    /**
     * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
     *
     * @type {string}
     */
    get numberingSystem() {
      return this.isValid ? this.loc.numberingSystem : null;
    }

    /**
     * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
     *
     * @type {string}
     */
    get outputCalendar() {
      return this.isValid ? this.loc.outputCalendar : null;
    }

    /**
     * Get the time zone associated with this DateTime.
     * @type {Zone}
     */
    get zone() {
      return this._zone;
    }

    /**
     * Get the name of the time zone.
     * @type {string}
     */
    get zoneName() {
      return this.isValid ? this.zone.name : null;
    }

    /**
     * Get the year
     * @example DateTime.local(2017, 5, 25).year //=> 2017
     * @type {number}
     */
    get year() {
      return this.isValid ? this.c.year : NaN;
    }

    /**
     * Get the quarter
     * @example DateTime.local(2017, 5, 25).quarter //=> 2
     * @type {number}
     */
    get quarter() {
      return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
    }

    /**
     * Get the month (1-12).
     * @example DateTime.local(2017, 5, 25).month //=> 5
     * @type {number}
     */
    get month() {
      return this.isValid ? this.c.month : NaN;
    }

    /**
     * Get the day of the month (1-30ish).
     * @example DateTime.local(2017, 5, 25).day //=> 25
     * @type {number}
     */
    get day() {
      return this.isValid ? this.c.day : NaN;
    }

    /**
     * Get the hour of the day (0-23).
     * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
     * @type {number}
     */
    get hour() {
      return this.isValid ? this.c.hour : NaN;
    }

    /**
     * Get the minute of the hour (0-59).
     * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
     * @type {number}
     */
    get minute() {
      return this.isValid ? this.c.minute : NaN;
    }

    /**
     * Get the second of the minute (0-59).
     * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
     * @type {number}
     */
    get second() {
      return this.isValid ? this.c.second : NaN;
    }

    /**
     * Get the millisecond of the second (0-999).
     * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
     * @type {number}
     */
    get millisecond() {
      return this.isValid ? this.c.millisecond : NaN;
    }

    /**
     * Get the week year
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
     * @type {number}
     */
    get weekYear() {
      return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
    }

    /**
     * Get the week number of the week year (1-52ish).
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
     * @type {number}
     */
    get weekNumber() {
      return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
    }

    /**
     * Get the day of the week.
     * 1 is Monday and 7 is Sunday
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2014, 11, 31).weekday //=> 4
     * @type {number}
     */
    get weekday() {
      return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
    }

    /**
     * Get the ordinal (meaning the day of the year)
     * @example DateTime.local(2017, 5, 25).ordinal //=> 145
     * @type {number|DateTime}
     */
    get ordinal() {
      return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
    }

    /**
     * Get the human readable short month name, such as 'Oct'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
     * @type {string}
     */
    get monthShort() {
      return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
    }

    /**
     * Get the human readable long month name, such as 'October'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).monthLong //=> October
     * @type {string}
     */
    get monthLong() {
      return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
    }

    /**
     * Get the human readable short weekday, such as 'Mon'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
     * @type {string}
     */
    get weekdayShort() {
      return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
    }

    /**
     * Get the human readable long weekday, such as 'Monday'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
     * @type {string}
     */
    get weekdayLong() {
      return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
    }

    /**
     * Get the UTC offset of this DateTime in minutes
     * @example DateTime.now().offset //=> -240
     * @example DateTime.utc().offset //=> 0
     * @type {number}
     */
    get offset() {
      return this.isValid ? +this.o : NaN;
    }

    /**
     * Get the short human name for the zone's current offset, for example "EST" or "EDT".
     * Defaults to the system's locale if no locale has been specified
     * @type {string}
     */
    get offsetNameShort() {
      if (this.isValid) {
        return this.zone.offsetName(this.ts, {
          format: "short",
          locale: this.locale,
        });
      } else {
        return null;
      }
    }

    /**
     * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
     * Defaults to the system's locale if no locale has been specified
     * @type {string}
     */
    get offsetNameLong() {
      if (this.isValid) {
        return this.zone.offsetName(this.ts, {
          format: "long",
          locale: this.locale,
        });
      } else {
        return null;
      }
    }

    /**
     * Get whether this zone's offset ever changes, as in a DST.
     * @type {boolean}
     */
    get isOffsetFixed() {
      return this.isValid ? this.zone.isUniversal : null;
    }

    /**
     * Get whether the DateTime is in a DST.
     * @type {boolean}
     */
    get isInDST() {
      if (this.isOffsetFixed) {
        return false;
      } else {
        return (
          this.offset > this.set({ month: 1, day: 1 }).offset ||
          this.offset > this.set({ month: 5 }).offset
        );
      }
    }

    /**
     * Returns true if this DateTime is in a leap year, false otherwise
     * @example DateTime.local(2016).isInLeapYear //=> true
     * @example DateTime.local(2013).isInLeapYear //=> false
     * @type {boolean}
     */
    get isInLeapYear() {
      return isLeapYear(this.year);
    }

    /**
     * Returns the number of days in this DateTime's month
     * @example DateTime.local(2016, 2).daysInMonth //=> 29
     * @example DateTime.local(2016, 3).daysInMonth //=> 31
     * @type {number}
     */
    get daysInMonth() {
      return daysInMonth(this.year, this.month);
    }

    /**
     * Returns the number of days in this DateTime's year
     * @example DateTime.local(2016).daysInYear //=> 366
     * @example DateTime.local(2013).daysInYear //=> 365
     * @type {number}
     */
    get daysInYear() {
      return this.isValid ? daysInYear(this.year) : NaN;
    }

    /**
     * Returns the number of weeks in this DateTime's year
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2004).weeksInWeekYear //=> 53
     * @example DateTime.local(2013).weeksInWeekYear //=> 52
     * @type {number}
     */
    get weeksInWeekYear() {
      return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
    }

    /**
     * Returns the resolved Intl options for this DateTime.
     * This is useful in understanding the behavior of formatting methods
     * @param {Object} opts - the same options as toLocaleString
     * @return {Object}
     */
    resolvedLocaleOptions(opts = {}) {
      const { locale, numberingSystem, calendar } = Formatter.create(
        this.loc.clone(opts),
        opts
      ).resolvedOptions(this);
      return { locale, numberingSystem, outputCalendar: calendar };
    }

    // TRANSFORM

    /**
     * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
     *
     * Equivalent to {@link DateTime#setZone}('utc')
     * @param {number} [offset=0] - optionally, an offset from UTC in minutes
     * @param {Object} [opts={}] - options to pass to `setZone()`
     * @return {DateTime}
     */
    toUTC(offset = 0, opts = {}) {
      return this.setZone(FixedOffsetZone.instance(offset), opts);
    }

    /**
     * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
     *
     * Equivalent to `setZone('local')`
     * @return {DateTime}
     */
    toLocal() {
      return this.setZone(Settings.defaultZone);
    }

    /**
     * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
     *
     * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
     * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
     * @param {Object} opts - options
     * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
     * @return {DateTime}
     */
    setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
      zone = normalizeZone(zone, Settings.defaultZone);
      if (zone.equals(this.zone)) {
        return this;
      } else if (!zone.isValid) {
        return DateTime$1.invalid(unsupportedZone(zone));
      } else {
        let newTS = this.ts;
        if (keepLocalTime || keepCalendarTime) {
          const offsetGuess = zone.offset(this.ts);
          const asObj = this.toObject();
          [newTS] = objToTS(asObj, offsetGuess, zone);
        }
        return clone(this, { ts: newTS, zone });
      }
    }

    /**
     * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
     * @param {Object} properties - the properties to set
     * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
     * @return {DateTime}
     */
    reconfigure({ locale, numberingSystem, outputCalendar } = {}) {
      const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });
      return clone(this, { loc });
    }

    /**
     * "Set" the locale. Returns a newly-constructed DateTime.
     * Just a convenient alias for reconfigure({ locale })
     * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
     * @return {DateTime}
     */
    setLocale(locale) {
      return this.reconfigure({ locale });
    }

    /**
     * "Set" the values of specified units. Returns a newly-constructed DateTime.
     * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
     * @param {Object} values - a mapping of units to numbers
     * @example dt.set({ year: 2017 })
     * @example dt.set({ hour: 8, minute: 30 })
     * @example dt.set({ weekday: 5 })
     * @example dt.set({ year: 2005, ordinal: 234 })
     * @return {DateTime}
     */
    set(values) {
      if (!this.isValid) return this;

      const normalized = normalizeObject(values, normalizeUnit),
        settingWeekStuff =
          !isUndefined(normalized.weekYear) ||
          !isUndefined(normalized.weekNumber) ||
          !isUndefined(normalized.weekday),
        containsOrdinal = !isUndefined(normalized.ordinal),
        containsGregorYear = !isUndefined(normalized.year),
        containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day),
        containsGregor = containsGregorYear || containsGregorMD,
        definiteWeekDef = normalized.weekYear || normalized.weekNumber;

      if ((containsGregor || containsOrdinal) && definiteWeekDef) {
        throw new ConflictingSpecificationError(
          "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
        );
      }

      if (containsGregorMD && containsOrdinal) {
        throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
      }

      let mixed;
      if (settingWeekStuff) {
        mixed = weekToGregorian({ ...gregorianToWeek(this.c), ...normalized });
      } else if (!isUndefined(normalized.ordinal)) {
        mixed = ordinalToGregorian({ ...gregorianToOrdinal(this.c), ...normalized });
      } else {
        mixed = { ...this.toObject(), ...normalized };

        // if we didn't set the day but we ended up on an overflow date,
        // use the last day of the right month
        if (isUndefined(normalized.day)) {
          mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
        }
      }

      const [ts, o] = objToTS(mixed, this.o, this.zone);
      return clone(this, { ts, o });
    }

    /**
     * Add a period of time to this DateTime and return the resulting DateTime
     *
     * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
     * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
     * @example DateTime.now().plus(123) //~> in 123 milliseconds
     * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
     * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
     * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
     * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
     * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
     * @return {DateTime}
     */
    plus(duration) {
      if (!this.isValid) return this;
      const dur = Duration.fromDurationLike(duration);
      return clone(this, adjustTime(this, dur));
    }

    /**
     * Subtract a period of time to this DateTime and return the resulting DateTime
     * See {@link DateTime#plus}
     * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
     @return {DateTime}
     */
    minus(duration) {
      if (!this.isValid) return this;
      const dur = Duration.fromDurationLike(duration).negate();
      return clone(this, adjustTime(this, dur));
    }

    /**
     * "Set" this DateTime to the beginning of a unit of time.
     * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
     * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
     * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
     * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
     * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
     * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
     * @return {DateTime}
     */
    startOf(unit) {
      if (!this.isValid) return this;
      const o = {},
        normalizedUnit = Duration.normalizeUnit(unit);
      switch (normalizedUnit) {
        case "years":
          o.month = 1;
        // falls through
        case "quarters":
        case "months":
          o.day = 1;
        // falls through
        case "weeks":
        case "days":
          o.hour = 0;
        // falls through
        case "hours":
          o.minute = 0;
        // falls through
        case "minutes":
          o.second = 0;
        // falls through
        case "seconds":
          o.millisecond = 0;
          break;
        // no default, invalid units throw in normalizeUnit()
      }

      if (normalizedUnit === "weeks") {
        o.weekday = 1;
      }

      if (normalizedUnit === "quarters") {
        const q = Math.ceil(this.month / 3);
        o.month = (q - 1) * 3 + 1;
      }

      return this.set(o);
    }

    /**
     * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
     * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
     * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
     * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
     * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
     * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
     * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
     * @return {DateTime}
     */
    endOf(unit) {
      return this.isValid
        ? this.plus({ [unit]: 1 })
            .startOf(unit)
            .minus(1)
        : this;
    }

    // OUTPUT

    /**
     * Returns a string representation of this DateTime formatted according to the specified format string.
     * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
     * Defaults to en-US if no locale has been specified, regardless of the system's locale.
     * @param {string} fmt - the format string
     * @param {Object} opts - opts to override the configuration options on this DateTime
     * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
     * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
     * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
     * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
     * @return {string}
     */
    toFormat(fmt, opts = {}) {
      return this.isValid
        ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt)
        : INVALID;
    }

    /**
     * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
     * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
     * of the DateTime in the assigned locale.
     * Defaults to the system's locale if no locale has been specified
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
     * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
     * @param {Object} opts - opts to override the configuration options on this DateTime
     * @example DateTime.now().toLocaleString(); //=> 4/20/2017
     * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
     * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
     * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 août 2022'
     * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
     * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
     * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
     * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
     * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
     * @return {string}
     */
    toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
      return this.isValid
        ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this)
        : INVALID;
    }

    /**
     * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
     * Defaults to the system's locale if no locale has been specified
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
     * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
     * @example DateTime.now().toLocaleParts(); //=> [
     *                                   //=>   { type: 'day', value: '25' },
     *                                   //=>   { type: 'literal', value: '/' },
     *                                   //=>   { type: 'month', value: '05' },
     *                                   //=>   { type: 'literal', value: '/' },
     *                                   //=>   { type: 'year', value: '1982' }
     *                                   //=> ]
     */
    toLocaleParts(opts = {}) {
      return this.isValid
        ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this)
        : [];
    }

    /**
     * Returns an ISO 8601-compliant string representation of this DateTime
     * @param {Object} opts - options
     * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
     * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
     * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
     * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
     * @param {string} [opts.format='extended'] - choose between the basic and extended format
     * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
     * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
     * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
     * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
     * @return {string}
     */
    toISO({
      format = "extended",
      suppressSeconds = false,
      suppressMilliseconds = false,
      includeOffset = true,
      extendedZone = false,
    } = {}) {
      if (!this.isValid) {
        return null;
      }

      const ext = format === "extended";

      let c = toISODate(this, ext);
      c += "T";
      c += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
      return c;
    }

    /**
     * Returns an ISO 8601-compliant string representation of this DateTime's date component
     * @param {Object} opts - options
     * @param {string} [opts.format='extended'] - choose between the basic and extended format
     * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
     * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
     * @return {string}
     */
    toISODate({ format = "extended" } = {}) {
      if (!this.isValid) {
        return null;
      }

      return toISODate(this, format === "extended");
    }

    /**
     * Returns an ISO 8601-compliant string representation of this DateTime's week date
     * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
     * @return {string}
     */
    toISOWeekDate() {
      return toTechFormat(this, "kkkk-'W'WW-c");
    }

    /**
     * Returns an ISO 8601-compliant string representation of this DateTime's time component
     * @param {Object} opts - options
     * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
     * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
     * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
     * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
     * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
     * @param {string} [opts.format='extended'] - choose between the basic and extended format
     * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
     * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
     * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
     * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
     * @return {string}
     */
    toISOTime({
      suppressMilliseconds = false,
      suppressSeconds = false,
      includeOffset = true,
      includePrefix = false,
      extendedZone = false,
      format = "extended",
    } = {}) {
      if (!this.isValid) {
        return null;
      }

      let c = includePrefix ? "T" : "";
      return (
        c +
        toISOTime(
          this,
          format === "extended",
          suppressSeconds,
          suppressMilliseconds,
          includeOffset,
          extendedZone
        )
      );
    }

    /**
     * Returns an RFC 2822-compatible string representation of this DateTime
     * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
     * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
     * @return {string}
     */
    toRFC2822() {
      return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
    }

    /**
     * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
     * Specifically, the string conforms to RFC 1123.
     * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
     * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
     * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
     * @return {string}
     */
    toHTTP() {
      return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
    }

    /**
     * Returns a string representation of this DateTime appropriate for use in SQL Date
     * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
     * @return {string}
     */
    toSQLDate() {
      if (!this.isValid) {
        return null;
      }
      return toISODate(this, true);
    }

    /**
     * Returns a string representation of this DateTime appropriate for use in SQL Time
     * @param {Object} opts - options
     * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
     * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
     * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
     * @example DateTime.utc().toSQL() //=> '05:15:16.345'
     * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
     * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
     * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
     * @return {string}
     */
    toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
      let fmt = "HH:mm:ss.SSS";

      if (includeZone || includeOffset) {
        if (includeOffsetSpace) {
          fmt += " ";
        }
        if (includeZone) {
          fmt += "z";
        } else if (includeOffset) {
          fmt += "ZZ";
        }
      }

      return toTechFormat(this, fmt, true);
    }

    /**
     * Returns a string representation of this DateTime appropriate for use in SQL DateTime
     * @param {Object} opts - options
     * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
     * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
     * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
     * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
     * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
     * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
     * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
     * @return {string}
     */
    toSQL(opts = {}) {
      if (!this.isValid) {
        return null;
      }

      return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
    }

    /**
     * Returns a string representation of this DateTime appropriate for debugging
     * @return {string}
     */
    toString() {
      return this.isValid ? this.toISO() : INVALID;
    }

    /**
     * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
     * @return {number}
     */
    valueOf() {
      return this.toMillis();
    }

    /**
     * Returns the epoch milliseconds of this DateTime.
     * @return {number}
     */
    toMillis() {
      return this.isValid ? this.ts : NaN;
    }

    /**
     * Returns the epoch seconds of this DateTime.
     * @return {number}
     */
    toSeconds() {
      return this.isValid ? this.ts / 1000 : NaN;
    }

    /**
     * Returns the epoch seconds (as a whole number) of this DateTime.
     * @return {number}
     */
    toUnixInteger() {
      return this.isValid ? Math.floor(this.ts / 1000) : NaN;
    }

    /**
     * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
     * @return {string}
     */
    toJSON() {
      return this.toISO();
    }

    /**
     * Returns a BSON serializable equivalent to this DateTime.
     * @return {Date}
     */
    toBSON() {
      return this.toJSDate();
    }

    /**
     * Returns a JavaScript object with this DateTime's year, month, day, and so on.
     * @param opts - options for generating the object
     * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
     * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
     * @return {Object}
     */
    toObject(opts = {}) {
      if (!this.isValid) return {};

      const base = { ...this.c };

      if (opts.includeConfig) {
        base.outputCalendar = this.outputCalendar;
        base.numberingSystem = this.loc.numberingSystem;
        base.locale = this.loc.locale;
      }
      return base;
    }

    /**
     * Returns a JavaScript Date equivalent to this DateTime.
     * @return {Date}
     */
    toJSDate() {
      return new Date(this.isValid ? this.ts : NaN);
    }

    // COMPARE

    /**
     * Return the difference between two DateTimes as a Duration.
     * @param {DateTime} otherDateTime - the DateTime to compare this one to
     * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
     * @param {Object} opts - options that affect the creation of the Duration
     * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
     * @example
     * var i1 = DateTime.fromISO('1982-05-25T09:45'),
     *     i2 = DateTime.fromISO('1983-10-14T10:30');
     * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
     * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
     * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
     * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
     * @return {Duration}
     */
    diff(otherDateTime, unit = "milliseconds", opts = {}) {
      if (!this.isValid || !otherDateTime.isValid) {
        return Duration.invalid("created by diffing an invalid DateTime");
      }

      const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };

      const units = maybeArray(unit).map(Duration.normalizeUnit),
        otherIsLater = otherDateTime.valueOf() > this.valueOf(),
        earlier = otherIsLater ? this : otherDateTime,
        later = otherIsLater ? otherDateTime : this,
        diffed = diff(earlier, later, units, durOpts);

      return otherIsLater ? diffed.negate() : diffed;
    }

    /**
     * Return the difference between this DateTime and right now.
     * See {@link DateTime#diff}
     * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
     * @param {Object} opts - options that affect the creation of the Duration
     * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
     * @return {Duration}
     */
    diffNow(unit = "milliseconds", opts = {}) {
      return this.diff(DateTime$1.now(), unit, opts);
    }

    /**
     * Return an Interval spanning between this DateTime and another DateTime
     * @param {DateTime} otherDateTime - the other end point of the Interval
     * @return {Interval}
     */
    until(otherDateTime) {
      return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
    }

    /**
     * Return whether this DateTime is in the same unit of time as another DateTime.
     * Higher-order units must also be identical for this function to return `true`.
     * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
     * @param {DateTime} otherDateTime - the other DateTime
     * @param {string} unit - the unit of time to check sameness on
     * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
     * @return {boolean}
     */
    hasSame(otherDateTime, unit) {
      if (!this.isValid) return false;

      const inputMs = otherDateTime.valueOf();
      const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
      return adjustedToZone.startOf(unit) <= inputMs && inputMs <= adjustedToZone.endOf(unit);
    }

    /**
     * Equality check
     * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
     * To compare just the millisecond values, use `+dt1 === +dt2`.
     * @param {DateTime} other - the other DateTime
     * @return {boolean}
     */
    equals(other) {
      return (
        this.isValid &&
        other.isValid &&
        this.valueOf() === other.valueOf() &&
        this.zone.equals(other.zone) &&
        this.loc.equals(other.loc)
      );
    }

    /**
     * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
     * platform supports Intl.RelativeTimeFormat. Rounds down by default.
     * @param {Object} options - options that affect the output
     * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
     * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
     * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
     * @param {boolean} [options.round=true] - whether to round the numbers in the output.
     * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
     * @param {string} options.locale - override the locale of this DateTime
     * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
     * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
     * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 día"
     * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
     * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
     * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
     * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
     */
    toRelative(options = {}) {
      if (!this.isValid) return null;
      const base = options.base || DateTime$1.fromObject({}, { zone: this.zone }),
        padding = options.padding ? (this < base ? -options.padding : options.padding) : 0;
      let units = ["years", "months", "days", "hours", "minutes", "seconds"];
      let unit = options.unit;
      if (Array.isArray(options.unit)) {
        units = options.unit;
        unit = undefined;
      }
      return diffRelative(base, this.plus(padding), {
        ...options,
        numeric: "always",
        units,
        unit,
      });
    }

    /**
     * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
     * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
     * @param {Object} options - options that affect the output
     * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
     * @param {string} options.locale - override the locale of this DateTime
     * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
     * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
     * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
     * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""mañana"
     * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
     * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
     */
    toRelativeCalendar(options = {}) {
      if (!this.isValid) return null;

      return diffRelative(options.base || DateTime$1.fromObject({}, { zone: this.zone }), this, {
        ...options,
        numeric: "auto",
        units: ["years", "months", "days"],
        calendary: true,
      });
    }

    /**
     * Return the min of several date times
     * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
     * @return {DateTime} the min DateTime, or undefined if called with no argument
     */
    static min(...dateTimes) {
      if (!dateTimes.every(DateTime$1.isDateTime)) {
        throw new InvalidArgumentError("min requires all arguments be DateTimes");
      }
      return bestBy(dateTimes, (i) => i.valueOf(), Math.min);
    }

    /**
     * Return the max of several date times
     * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
     * @return {DateTime} the max DateTime, or undefined if called with no argument
     */
    static max(...dateTimes) {
      if (!dateTimes.every(DateTime$1.isDateTime)) {
        throw new InvalidArgumentError("max requires all arguments be DateTimes");
      }
      return bestBy(dateTimes, (i) => i.valueOf(), Math.max);
    }

    // MISC

    /**
     * Explain how a string would be parsed by fromFormat()
     * @param {string} text - the string to parse
     * @param {string} fmt - the format the string is expected to be in (see description)
     * @param {Object} options - options taken by fromFormat()
     * @return {Object}
     */
    static fromFormatExplain(text, fmt, options = {}) {
      const { locale = null, numberingSystem = null } = options,
        localeToUse = Locale.fromOpts({
          locale,
          numberingSystem,
          defaultToEN: true,
        });
      return explainFromTokens(localeToUse, text, fmt);
    }

    /**
     * @deprecated use fromFormatExplain instead
     */
    static fromStringExplain(text, fmt, options = {}) {
      return DateTime$1.fromFormatExplain(text, fmt, options);
    }

    // FORMAT PRESETS

    /**
     * {@link DateTime#toLocaleString} format like 10/14/1983
     * @type {Object}
     */
    static get DATE_SHORT() {
      return DATE_SHORT;
    }

    /**
     * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
     * @type {Object}
     */
    static get DATE_MED() {
      return DATE_MED;
    }

    /**
     * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
     * @type {Object}
     */
    static get DATE_MED_WITH_WEEKDAY() {
      return DATE_MED_WITH_WEEKDAY;
    }

    /**
     * {@link DateTime#toLocaleString} format like 'October 14, 1983'
     * @type {Object}
     */
    static get DATE_FULL() {
      return DATE_FULL;
    }

    /**
     * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
     * @type {Object}
     */
    static get DATE_HUGE() {
      return DATE_HUGE;
    }

    /**
     * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get TIME_SIMPLE() {
      return TIME_SIMPLE;
    }

    /**
     * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get TIME_WITH_SECONDS() {
      return TIME_WITH_SECONDS;
    }

    /**
     * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get TIME_WITH_SHORT_OFFSET() {
      return TIME_WITH_SHORT_OFFSET;
    }

    /**
     * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get TIME_WITH_LONG_OFFSET() {
      return TIME_WITH_LONG_OFFSET;
    }

    /**
     * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
     * @type {Object}
     */
    static get TIME_24_SIMPLE() {
      return TIME_24_SIMPLE;
    }

    /**
     * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
     * @type {Object}
     */
    static get TIME_24_WITH_SECONDS() {
      return TIME_24_WITH_SECONDS;
    }

    /**
     * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
     * @type {Object}
     */
    static get TIME_24_WITH_SHORT_OFFSET() {
      return TIME_24_WITH_SHORT_OFFSET;
    }

    /**
     * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
     * @type {Object}
     */
    static get TIME_24_WITH_LONG_OFFSET() {
      return TIME_24_WITH_LONG_OFFSET;
    }

    /**
     * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_SHORT() {
      return DATETIME_SHORT;
    }

    /**
     * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_SHORT_WITH_SECONDS() {
      return DATETIME_SHORT_WITH_SECONDS;
    }

    /**
     * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_MED() {
      return DATETIME_MED;
    }

    /**
     * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_MED_WITH_SECONDS() {
      return DATETIME_MED_WITH_SECONDS;
    }

    /**
     * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_MED_WITH_WEEKDAY() {
      return DATETIME_MED_WITH_WEEKDAY;
    }

    /**
     * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_FULL() {
      return DATETIME_FULL;
    }

    /**
     * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_FULL_WITH_SECONDS() {
      return DATETIME_FULL_WITH_SECONDS;
    }

    /**
     * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_HUGE() {
      return DATETIME_HUGE;
    }

    /**
     * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_HUGE_WITH_SECONDS() {
      return DATETIME_HUGE_WITH_SECONDS;
    }
  }

  /**
   * @private
   */
  function friendlyDateTime(dateTimeish) {
    if (DateTime$1.isDateTime(dateTimeish)) {
      return dateTimeish;
    } else if (dateTimeish && dateTimeish.valueOf && isNumber$1(dateTimeish.valueOf())) {
      return DateTime$1.fromJSDate(dateTimeish);
    } else if (dateTimeish && typeof dateTimeish === "object") {
      return DateTime$1.fromObject(dateTimeish);
    } else {
      throw new InvalidArgumentError(
        `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`
      );
    }
  }

  function toLuxonDateTime(date, calendar) {
      if (!(calendar instanceof CalendarImpl)) {
          throw new Error('must supply a CalendarApi instance');
      }
      let { dateEnv } = calendar.getCurrentData();
      return DateTime$1.fromJSDate(date, {
          zone: dateEnv.timeZone,
          locale: dateEnv.locale.codes[0],
      });
  }
  function toLuxonDuration(duration, calendar) {
      if (!(calendar instanceof CalendarImpl)) {
          throw new Error('must supply a CalendarApi instance');
      }
      let { dateEnv } = calendar.getCurrentData();
      return Duration.fromObject(duration, {
          locale: dateEnv.locale.codes[0],
      });
  }
  // Internal Utils
  function luxonToArray(datetime) {
      return [
          datetime.year,
          datetime.month - 1,
          datetime.day,
          datetime.hour,
          datetime.minute,
          datetime.second,
          datetime.millisecond,
      ];
  }
  function arrayToLuxon(arr, timeZone, locale) {
      return DateTime$1.fromObject({
          year: arr[0],
          month: arr[1] + 1,
          day: arr[2],
          hour: arr[3],
          minute: arr[4],
          second: arr[5],
          millisecond: arr[6],
      }, {
          locale,
          zone: timeZone,
      });
  }

  class LuxonNamedTimeZone extends NamedTimeZoneImpl {
      offsetForArray(a) {
          return arrayToLuxon(a, this.timeZoneName).offset;
      }
      timestampToArray(ms) {
          return luxonToArray(DateTime$1.fromMillis(ms, {
              zone: this.timeZoneName,
          }));
      }
  }

  function formatWithCmdStr$1(cmdStr, arg) {
      let cmd = parseCmdStr$1(cmdStr);
      if (arg.end) {
          let start = arrayToLuxon(arg.start.array, arg.timeZone, arg.localeCodes[0]);
          let end = arrayToLuxon(arg.end.array, arg.timeZone, arg.localeCodes[0]);
          return formatRange$1(cmd, start.toFormat.bind(start), end.toFormat.bind(end), arg.defaultSeparator);
      }
      return arrayToLuxon(arg.date.array, arg.timeZone, arg.localeCodes[0]).toFormat(cmd.whole);
  }
  function parseCmdStr$1(cmdStr) {
      let parts = cmdStr.match(/^(.*?)\{(.*)\}(.*)$/); // TODO: lookbehinds for escape characters
      if (parts) {
          let middle = parseCmdStr$1(parts[2]);
          return {
              head: parts[1],
              middle,
              tail: parts[3],
              whole: parts[1] + middle.whole + parts[3],
          };
      }
      return {
          head: null,
          middle: null,
          tail: null,
          whole: cmdStr,
      };
  }
  function formatRange$1(cmd, formatStart, formatEnd, separator) {
      if (cmd.middle) {
          let startHead = formatStart(cmd.head);
          let startMiddle = formatRange$1(cmd.middle, formatStart, formatEnd, separator);
          let startTail = formatStart(cmd.tail);
          let endHead = formatEnd(cmd.head);
          let endMiddle = formatRange$1(cmd.middle, formatStart, formatEnd, separator);
          let endTail = formatEnd(cmd.tail);
          if (startHead === endHead && startTail === endTail) {
              return startHead +
                  (startMiddle === endMiddle ? startMiddle : startMiddle + separator + endMiddle) +
                  startTail;
          }
      }
      let startWhole = formatStart(cmd.whole);
      let endWhole = formatEnd(cmd.whole);
      if (startWhole === endWhole) {
          return startWhole;
      }
      return startWhole + separator + endWhole;
  }

  var index$6 = createPlugin({
      name: '@fullcalendar/luxon3',
      cmdFormatter: formatWithCmdStr$1,
      namedTimeZonedImpl: LuxonNamedTimeZone,
  });

  describe('recurring events', () => {
      describe('when timed events in local timezone', () => {
          pushOptions({
              initialView: 'timeGridWeek',
              initialDate: '2017-07-03',
              timeZone: 'local',
              events: [
                  { startTime: '09:00', endTime: '11:00', daysOfWeek: [2, 4] },
              ],
          });
          it('expands events with local time', () => {
              initCalendar();
              let events = currentCalendar.getEvents();
              expect(events[0].start).toEqualLocalDate('2017-07-04T09:00:00');
              expect(events[0].end).toEqualLocalDate('2017-07-04T11:00:00');
              expect(events[1].start).toEqualLocalDate('2017-07-06T09:00:00');
              expect(events[1].end).toEqualLocalDate('2017-07-06T11:00:00');
          });
      });
      describe('when given recur range', () => {
          pushOptions({
              initialView: 'dayGridMonth',
              initialDate: '2017-07-03',
              events: [
                  { startTime: '09:00', endTime: '11:00', startRecur: '2017-07-05', endRecur: '2017-07-08' },
              ],
          });
          it('expands within given range', () => {
              initCalendar();
              let events = currentCalendar.getEvents();
              expect(events.length).toBe(3);
              expect(events[0].start).toEqualDate('2017-07-05T09:00:00Z');
              expect(events[1].start).toEqualDate('2017-07-06T09:00:00Z');
              expect(events[2].start).toEqualDate('2017-07-07T09:00:00Z');
          });
          describe('when current range is completely outside of recur-range', () => {
              pushOptions({
                  initialDate: '2017-02-02',
              });
              it('won\'t render any events', () => {
                  initCalendar();
                  let events = currentCalendar.getEvents();
                  expect(events.length).toBe(0);
              });
          });
      });
      describe('when event has a duration', () => {
          pushOptions({
              initialView: 'dayGridWeek',
              initialDate: '2019-06-02',
              events: [
                  { daysOfWeek: [6], duration: { days: 2 } },
              ],
          });
          it('will render from week before', () => {
              initCalendar();
              let events = currentCalendar.getEvents();
              expect(events[0].start).toEqualDate('2019-06-01');
              expect(events[0].end).toEqualDate('2019-06-03');
              expect(events[1].start).toEqualDate('2019-06-08');
              expect(events[1].end).toEqualDate('2019-06-10');
              expect(events.length).toBe(2);
          });
      });
      it('when timeZone changes, events with unspecified timezone offsets move', () => {
          const timeTexts = [];
          const calendar = initCalendar({
              plugins: [index$9, index$6],
              timeZone: 'America/New_York',
              initialView: 'timeGridWeek',
              initialDate: '2023-02-07',
              events: [
                  { startTime: '12:00', daysOfWeek: [2] },
              ],
              eventContent(arg) {
                  timeTexts.push(arg.timeText);
                  return true;
              },
          });
          let events = calendar.getEvents();
          expect(events[0].start).toEqualDate('2023-02-07T17:00:00Z');
          expect(timeTexts.length).toBe(1);
          expect(timeTexts[0]).toBe('12:00');
          calendar.setOption('timeZone', 'America/Chicago');
          expect(events[0].start).toEqualDate('2023-02-07T17:00:00Z');
          expect(timeTexts.length).toBe(2);
          expect(timeTexts[1]).toBe('11:00');
      });
  });

  describe('addEvent', () => {
      pushOptions({
          initialDate: '2018-09-07',
      });
      it('will re-add an event that was previously removed', () => {
          initCalendar({
              events: [
                  { id: 'a', start: '2018-09-07' },
              ],
          });
          let event = currentCalendar.getEventById('a');
          expect(currentCalendar.getEvents().length).toBe(1);
          event.remove();
          expect(currentCalendar.getEvents().length).toBe(0);
          let newEvent = currentCalendar.addEvent(event);
          expect(currentCalendar.getEvents().length).toBe(1);
          expect(newEvent).toBe(event);
      });
      it('won\'t double-add an event that was previously added', () => {
          initCalendar({
              events: [
                  { id: 'a', start: '2018-09-07' },
              ],
          });
          let event = currentCalendar.getEventById('a');
          expect(currentCalendar.getEvents().length).toBe(1);
          let newEvent = currentCalendar.addEvent(event);
          expect(currentCalendar.getEvents().length).toBe(1);
          expect(newEvent).toBe(event);
      });
      it('will accept a string source ID', () => {
          initCalendar({
              eventSources: [
                  {
                      id: '9',
                      color: 'purple',
                      events: [
                          { id: 'a', start: '2018-09-07' },
                      ],
                  },
              ],
          });
          let theSource = currentCalendar.getEventSourceById('9');
          let newEvent = currentCalendar.addEvent({ id: 'b', start: '2018-09-10' }, '9');
          expect(newEvent.source.id === theSource.id);
      });
      it('will accept a number source ID', () => {
          initCalendar({
              eventSources: [
                  {
                      id: '9',
                      color: 'purple',
                      events: [
                          { id: 'a', start: '2018-09-07' },
                      ],
                  },
              ],
          });
          let theSource = currentCalendar.getEventSourceById('9');
          let newEvent = currentCalendar.addEvent({ id: 'b', start: '2018-09-10' }, '9');
          expect(newEvent.source.id === theSource.id);
      });
      it('will accept an object source', () => {
          initCalendar({
              eventSources: [
                  {
                      id: '9',
                      color: 'purple',
                      events: [
                          { id: 'a', start: '2018-09-07' },
                      ],
                  },
              ],
          });
          let theSource = currentCalendar.getEventSourceById('9');
          let newEvent = currentCalendar.addEvent({ id: 'b', start: '2018-09-10' }, theSource);
          expect(newEvent.source.id === theSource.id);
      });
  });

  describe('timeZone change', () => {
      describe('with non-recurring timed events and luxon plugin', () => {
          it('adjusts timed event', () => {
              const timeTexts = [];
              const calendar = initCalendar({
                  plugins: [index$9, index$6],
                  timeZone: 'America/New_York',
                  initialView: 'timeGridWeek',
                  initialDate: '2023-02-07',
                  events: [
                      { start: '2023-02-07T12:00:00' },
                  ],
                  eventContent(arg) {
                      timeTexts.push(arg.timeText);
                      return true;
                  },
              });
              let events = calendar.getEvents();
              expect(events[0].start).toEqualDate('2023-02-07T17:00:00Z');
              expect(timeTexts.length).toBe(1);
              expect(timeTexts[0]).toBe('12:00');
              calendar.setOption('timeZone', 'America/Chicago');
              expect(events[0].start).toEqualDate('2023-02-07T17:00:00Z');
              expect(timeTexts.length).toBe(2);
              expect(timeTexts[1]).toBe('11:00');
          });
      });
  });

  describe('event mutations on non-instances', () => {
      pushOptions({
          initialView: 'dayGridWeek',
          now: '2018-09-03',
          events: [
              { id: '1', start: '2018-09-04', display: 'inverse-background' }, // will make two segs
          ],
      });
      describe('with date mutating', () => {
          it('doesn\'t do anything', () => {
              let renderCnt = 0;
              let calendar = initCalendar({
                  eventContent(arg) {
                      renderCnt += 1;
                      if (renderCnt === 2) {
                          arg.event.setStart('2018-08-04');
                          arg.event.setEnd('2018-10-04');
                          arg.event.setDates('2018-08-04', '2018-10-04');
                      }
                  },
              });
              expect(renderCnt).toBe(2);
              let event = calendar.getEventById('1');
              expect(event.start).toEqualDate('2018-09-04');
              expect(event.end).toBe(null);
              expect(event.allDay).toBe(true);
          });
      });
      // TODO: test for non-instances to have other props and extended props modified
  });

  describe('Event::setStart', () => {
      pushOptions({
          now: '2018-09-03',
          timeZone: 'UTC',
          defaultTimedEventDuration: '01:00',
      });
      describe('when event doesn\'t have an end', () => {
          pushOptions({
              events: [
                  { id: '1', start: '2018-09-05T00:00:00' },
              ],
          });
          describe('when not maintaining duration', () => {
              it('moves start and gives event an end', () => {
                  initCalendar();
                  let event = currentCalendar.getEventById('1');
                  event.setStart('2018-09-01');
                  expect(event.start).toEqualDate('2018-09-01T00:00:00Z');
                  expect(event.end).toEqualDate('2018-09-05T01:00:00Z');
              });
          });
          describe('when maintaining duration', () => {
              it('moves start and keeps no end', () => {
                  initCalendar();
                  let event = currentCalendar.getEventById('1');
                  event.setStart('2018-09-01', { maintainDuration: true });
                  expect(event.start).toEqualDate('2018-09-01');
                  expect(event.end).toBe(null);
              });
          });
          it('can revert', () => {
              let revertCalled = false;
              let calendar = initCalendar({
                  eventChange(info) {
                      revertCalled = true;
                      info.revert();
                  },
              });
              let event = calendar.getEventById('1');
              event.setStart('2018-09-01'); // will be immediately undone
              expect(revertCalled).toBe(true);
              let events = calendar.getEvents();
              expect(events.length).toBe(1);
              expect(events[0].start).toEqualDate('2018-09-05T00:00:00');
          });
      });
      describe('when event does have an end', () => {
          pushOptions({
              events: [
                  { id: '1', start: '2018-09-05T00:00:00', end: '2018-09-07T00:00:00' },
              ],
          });
          describe('when not maintaining duration', () => {
              it('moves start and keeps the same end', () => {
                  initCalendar();
                  let event = currentCalendar.getEventById('1');
                  event.setStart('2018-09-01');
                  expect(event.start).toEqualDate('2018-09-01');
                  expect(event.end).toEqualDate('2018-09-07');
              });
          });
          describe('when maintaining duration', () => {
              it('move start and keeps the end', () => {
                  initCalendar();
                  let event = currentCalendar.getEventById('1');
                  event.setStart('2018-09-01', { maintainDuration: true });
                  expect(event.start).toEqualDate('2018-09-01');
                  expect(event.end).toEqualDate('2018-09-03');
              });
          });
      });
      describe('when event is all-day', () => {
          pushOptions({
              events: [
                  { id: '1', start: '2018-09-05', end: '2018-09-07', allDay: true },
              ],
          });
          describe('when setting start to another all-day', () => {
              it('moves start', () => {
                  initCalendar();
                  let event = currentCalendar.getEventById('1');
                  event.setStart('2018-09-01');
                  expect(event.start).toEqualDate('2018-09-01');
                  expect(event.end).toEqualDate('2018-09-07');
                  expect(event.allDay).toBe(true);
              });
          });
          describe('when setting start to timed', () => {
              it('moves start to rounded-down start-of-day', () => {
                  initCalendar();
                  let event = currentCalendar.getEventById('1');
                  event.setStart('2018-09-01T23:00:00');
                  expect(event.start).toEqualDate('2018-09-01');
                  expect(event.end).toEqualDate('2018-09-07');
                  expect(event.allDay).toBe(true);
              });
          });
      });
      it('shortens related events of different duration by same delta', () => {
          initCalendar({
              events: [
                  { id: '1', groupId: 'a', start: '2018-09-05T00:00:00', end: '2018-09-10T00:00:00' },
                  { id: '2', groupId: 'a', start: '2018-09-06T00:00:00', end: '2018-09-09T00:00:00' },
              ],
          });
          let event1 = currentCalendar.getEventById('1');
          event1.setStart('2018-09-01'); // move start back by 4 days
          expect(event1.start).toEqualDate('2018-09-01');
          expect(event1.end).toEqualDate('2018-09-10');
          let event2 = currentCalendar.getEventById('2');
          expect(event2.start).toEqualDate('2018-09-02');
          expect(event2.end).toEqualDate('2018-09-09');
      });
  });

  var l24 = {
      code: 'es',
      week: {
          dow: 1,
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
      buttonText: {
          prev: 'Ant',
          next: 'Sig',
          today: 'Hoy',
          year: 'Año',
          month: 'Mes',
          week: 'Semana',
          day: 'Día',
          list: 'Agenda',
      },
      buttonHints: {
          prev: '$0 antes',
          next: '$0 siguiente',
          today(buttonText) {
              return (buttonText === 'Día') ? 'Hoy' :
                  ((buttonText === 'Semana') ? 'Esta' : 'Este') + ' ' + buttonText.toLocaleLowerCase();
          },
      },
      viewHint(buttonText) {
          return 'Vista ' + (buttonText === 'Semana' ? 'de la' : 'del') + ' ' + buttonText.toLocaleLowerCase();
      },
      weekText: 'Sm',
      weekTextLong: 'Semana',
      allDayText: 'Todo el día',
      moreLinkText: 'más',
      moreLinkHint(eventCnt) {
          return `Mostrar ${eventCnt} eventos más`;
      },
      noEventsText: 'No hay eventos para mostrar',
      navLinkHint: 'Ir al $0',
      closeHint: 'Cerrar',
      timeHint: 'La hora',
      eventHint: 'Evento',
  };

  function testTimeZoneImpl(timeZoneImplPlugin) {
      describe('named tz implementation', () => {
          pushOptions({
              plugins: [timeZoneImplPlugin, index$a],
          });
          it('computes correct offset for named timezone for View dates', () => {
              initCalendar({
                  initialView: 'dayGridMonth',
                  now: '2018-09-01',
                  timeZone: 'Europe/Moscow',
                  events: [
                      { start: '2018-09-05' },
                  ],
              });
              let view = currentCalendar.view;
              expect(view.currentStart).toEqualDate('2018-09-01T00:00:00+03:00');
              // interprets the ambug iso date string correctly
              let event = currentCalendar.getEvents()[0];
              expect(event.start).toEqualDate('2018-09-05T00:00:00+03:00');
          });
      });
  }

  describe('luxon plugin', () => {
      const PLUGINS = [index$6, index$a]; // for `new Calendar`
      pushOptions({
          plugins: PLUGINS,
      });
      testTimeZoneImpl(index$6);
      describe('toLuxonDateTime', () => {
          describe('timezone transfering', () => {
              it('transfers UTC', () => {
                  let calendar = new Calendar(document.createElement('div'), {
                      plugins: PLUGINS,
                      events: [{ start: '2018-09-05T12:00:00', end: '2018-09-05T18:00:00' }],
                      timeZone: 'UTC',
                  });
                  let event = calendar.getEvents()[0];
                  let start = toLuxonDateTime(event.start, calendar);
                  let end = toLuxonDateTime(event.end, calendar);
                  expect(start.toISO()).toBe('2018-09-05T12:00:00.000Z');
                  expect(start.zoneName).toBe('UTC');
                  expect(end.toISO()).toBe('2018-09-05T18:00:00.000Z');
                  expect(end.zoneName).toBe('UTC');
              });
              it('transfers local timezone', () => {
                  let calendar = new Calendar(document.createElement('div'), {
                      plugins: PLUGINS,
                      events: [{ start: '2018-09-05T12:00:00', end: '2018-09-05T18:00:00' }],
                      timeZone: 'local',
                  });
                  let event = calendar.getEvents()[0];
                  let start = toLuxonDateTime(event.start, calendar);
                  let end = toLuxonDateTime(event.end, calendar);
                  expect(start.toJSDate()).toEqualLocalDate('2018-09-05T12:00:00');
                  expect(start.zoneName).toMatch('/'); // has a named timezone
                  expect(end.toJSDate()).toEqualLocalDate('2018-09-05T18:00:00');
                  expect(end.zoneName).toMatch('/'); // has a named timezone
              });
              it('transfers named timezone', () => {
                  let calendar = new Calendar(document.createElement('div'), {
                      plugins: PLUGINS,
                      events: [{ start: '2018-09-05T12:00:00', end: '2018-09-05T18:00:00' }],
                      timeZone: 'Europe/Moscow',
                  });
                  let event = calendar.getEvents()[0];
                  let start = toLuxonDateTime(event.start, calendar);
                  let end = toLuxonDateTime(event.end, calendar);
                  expect(start.toJSDate()).toEqualDate('2018-09-05T12:00:00+03:00');
                  expect(start.zoneName).toMatch('Europe/Moscow');
                  expect(end.toJSDate()).toEqualDate('2018-09-05T18:00:00+03:00');
                  expect(end.zoneName).toMatch('Europe/Moscow');
              });
          });
          it('transfers locale', () => {
              let calendar = new Calendar(document.createElement('div'), {
                  plugins: PLUGINS,
                  events: [{ start: '2018-09-05T12:00:00', end: '2018-09-05T18:00:00' }],
                  locale: l24,
              });
              let event = calendar.getEvents()[0];
              let datetime = toLuxonDateTime(event.start, calendar);
              expect(datetime.locale).toEqual('es');
          });
      });
      describe('toLuxonDuration', () => {
          it('converts numeric values correctly', () => {
              let calendar = new Calendar(document.createElement('div'), {
                  plugins: PLUGINS,
                  defaultTimedEventDuration: '05:00',
                  defaultAllDayEventDuration: { days: 3 },
              });
              // hacky way to have a duration parsed
              let timedDuration = toLuxonDuration(calendar.getCurrentData().options.defaultTimedEventDuration, calendar);
              let allDayDuration = toLuxonDuration(calendar.getCurrentData().options.defaultAllDayEventDuration, calendar);
              expect(timedDuration.as('hours')).toBe(5);
              expect(allDayDuration.as('days')).toBe(3);
          });
          it('transfers locale correctly', () => {
              let calendar = new Calendar(document.createElement('div'), {
                  plugins: PLUGINS,
                  defaultTimedEventDuration: '05:00',
                  locale: l24,
              });
              // hacky way to have a duration parsed
              let timedDuration = toLuxonDuration(calendar.getCurrentData().options.defaultTimedEventDuration, calendar);
              expect(timedDuration.locale).toBe('es');
          });
      });
      describe('date formatting', () => {
          it('produces event time text', () => {
              let calendar = initCalendar({
                  initialView: 'dayGridMonth',
                  now: '2018-09-06',
                  displayEventEnd: false,
                  eventTimeFormat: 'HH:mm:ss\'abc\'',
                  events: [
                      { title: 'my event', start: '2018-09-06T13:30:20' },
                  ],
              });
              let calendarWrapper = new CalendarWrapper(calendar);
              let eventEl = calendarWrapper.getFirstEventEl();
              let eventInfo = calendarWrapper.getEventElInfo(eventEl);
              expect(eventInfo.timeText).toBe('13:30:20abc');
          });
      });
      describe('range formatting', () => {
          it('renders with same month', () => {
              let calendar = new Calendar(document.createElement('div'), {
                  plugins: PLUGINS,
              });
              let s;
              s = calendar.formatRange('2018-09-03', '2018-09-05', 'MMMM {d}, yyyy \'asdf\'');
              expect(s).toEqual('September 3 - 5, 2018 asdf');
              s = calendar.formatRange('2018-09-03', '2018-09-05', '{d} MMMM, yyyy \'asdf\'');
              expect(s).toEqual('3 - 5 September, 2018 asdf');
          });
          it('renders with same year but different month', () => {
              let calendar = new Calendar(document.createElement('div'), {
                  plugins: PLUGINS,
              });
              let s;
              s = calendar.formatRange('2018-09-03', '2018-10-05', '{MMMM {d}}, yyyy \'asdf\'');
              expect(s).toEqual('September 3 - October 5, 2018 asdf');
              s = calendar.formatRange('2018-09-03', '2018-10-05', '{{d} MMMM}, yyyy \'asdf\'');
              expect(s).toEqual('3 September - 5 October, 2018 asdf');
          });
          it('renders with different years', () => {
              let calendar = new Calendar(document.createElement('div'), {
                  plugins: PLUGINS,
              });
              let s;
              s = calendar.formatRange('2018-09-03', '2019-10-05', '{MMMM {d}}, yyyy \'asdf\'');
              expect(s).toEqual('September 3, 2018 asdf - October 5, 2019 asdf');
              s = calendar.formatRange('2018-09-03', '2019-10-05', '{{d} MMMM}, yyyy \'asdf\'');
              expect(s).toEqual('3 September, 2018 asdf - 5 October, 2019 asdf');
          });
          it('renders the same if same day', () => {
              let calendar = new Calendar(document.createElement('div'), {
                  plugins: PLUGINS,
              });
              let s;
              s = calendar.formatRange('2018-09-03T00:00:00', '2018-09-03T23:59:59', 'MMMM d yyyy');
              expect(s).toEqual('September 3 2018');
          });
          it('inherits defaultRangeSeparator', () => {
              let calendar = new Calendar(document.createElement('div'), {
                  plugins: PLUGINS,
                  defaultRangeSeparator: ' to ',
              });
              let s = calendar.formatRange('2018-09-03', '2018-09-05', 'MMMM d, yyyy \'asdf\'');
              expect(s).toEqual('September 3, 2018 asdf to September 5, 2018 asdf');
          });
          it('produces title with titleRangeSeparator', () => {
              initCalendar({
                  plugins: PLUGINS,
                  initialView: 'dayGridWeek',
                  now: '2018-09-06',
                  titleFormat: 'MMMM {d} yy \'yup\'',
                  titleRangeSeparator: ' to ',
              });
              expect(currentCalendar.view.title).toBe('September 2 to 8 18 yup');
          });
      });
  });

  /*
  Some hours don't exist in local time when a daylight-savings shift happpens.
  This time is called a "dead zone".
  If possible, this function returns an array of two dates,
  the date just before the dead zone (with a 999 millisecond time)
  and the date just after the dead zone.

  I apologize for the unreadability of this code. It was written a long time ago:
  https://github.com/arshaw/xdate/blob/master/test/old.js
  */
  function getDSTDeadZone() {
      let dstDates = getDSTDates();
      if (dstDates) {
          let prior = new Date(dstDates[0].valueOf() - 1);
          if (Math.abs(dstDates[0].getHours() - prior.getHours()) > 1) {
              return [prior, dstDates[0]];
          }
          prior = new Date(dstDates[1].valueOf() - 1);
          if (Math.abs(dstDates[1].getHours() - prior.getHours()) > 1) {
              return [prior, dstDates[1]];
          }
      }
      return null;
  }
  function getDSTDates() {
      let MS_DAY = 86400000;
      let res = [];
      let d0 = new Date();
      let overAYear = new Date(+d0);
      overAYear.setFullYear(overAYear.getFullYear() + 1);
      overAYear = new Date(overAYear.valueOf() + MS_DAY);
      while (d0 < overAYear) {
          let d1 = new Date(d0.valueOf() + MS_DAY);
          if (d0.getTimezoneOffset() !== d1.getTimezoneOffset()) {
              res.push(new Date(narrowDSTDate(+d0, +d1)));
              if (res.length === 2) {
                  break;
              }
          }
          d0 = d1;
      }
      return res.length === 2 ? res : null;
  }
  function narrowDSTDate(start, end) {
      if (end <= start + 1) {
          return end;
      }
      let mid = start + Math.floor((end - start) / 2);
      let midTZO = new Date(mid).getTimezoneOffset();
      let startTZO = new Date(start).getTimezoneOffset();
      let endTZO = new Date(end).getTimezoneOffset();
      if (midTZO === startTZO) {
          return narrowDSTDate(mid, end);
      }
      if (midTZO === endTZO) {
          return narrowDSTDate(start, mid);
      }
      return null;
  }

  describe('datelib', () => {
      let enLocale;
      beforeEach(() => {
          enLocale = new Calendar(document.createElement('div'), {
              plugins: [index$a],
          }).getCurrentData().dateEnv.locale;
      });
      describe('computeWeekNumber', () => {
          it('works with local', () => {
              let env = new DateEnv({
                  timeZone: 'UTC',
                  calendarSystem: 'gregory',
                  locale: enLocale,
              });
              let m1 = env.createMarker('2018-04-07');
              let m2 = env.createMarker('2018-04-08');
              expect(env.computeWeekNumber(m1)).toBe(14);
              expect(env.computeWeekNumber(m2)).toBe(15);
          });
          it('works with ISO', () => {
              let env = new DateEnv({
                  timeZone: 'UTC',
                  calendarSystem: 'gregory',
                  locale: enLocale,
                  weekNumberCalculation: 'ISO',
              });
              let m1 = env.createMarker('2018-04-01');
              let m2 = env.createMarker('2018-04-02');
              expect(env.computeWeekNumber(m1)).toBe(13);
              expect(env.computeWeekNumber(m2)).toBe(14);
          });
          it('works with custom function', () => {
              let env = new DateEnv({
                  timeZone: 'UTC',
                  calendarSystem: 'gregory',
                  locale: enLocale,
                  weekNumberCalculation(date) {
                      expect(date instanceof Date).toBe(true);
                      expect(date.valueOf()).toBe(Date.UTC(2018, 3, 1));
                      return 99;
                  },
              });
              let m1 = env.createMarker('2018-04-01');
              expect(env.computeWeekNumber(m1)).toBe(99);
          });
      });
      it('startOfWeek with different firstDay', () => {
          let env = new DateEnv({
              timeZone: 'UTC',
              calendarSystem: 'gregory',
              locale: enLocale,
              firstDay: 2, // tues
          });
          let m = env.createMarker('2018-04-19');
          let w = env.startOfWeek(m);
          expect(env.toDate(w)).toEqual(new Date(Date.UTC(2018, 3, 17)));
      });
      describe('when UTC', () => {
          let env;
          beforeEach(() => {
              env = new DateEnv({
                  timeZone: 'UTC',
                  calendarSystem: 'gregory',
                  locale: enLocale,
              });
          });
          describe('createMarker', () => {
              it('with date', () => {
                  expect(env.toDate(env.createMarker(new Date(2017, 5, 8)))).toEqual(new Date(2017, 5, 8));
              });
              it('with timestamp', () => {
                  expect(env.toDate(env.createMarker(new Date(2017, 5, 8).valueOf()))).toEqual(new Date(2017, 5, 8));
              });
              it('with array', () => {
                  expect(env.toDate(env.createMarker([2017, 5, 8]))).toEqual(new Date(Date.UTC(2017, 5, 8)));
              });
          });
          describe('ISO8601 parsing', () => {
              it('parses non-tz as UTC', () => {
                  let res = env.createMarkerMeta('2018-06-08');
                  let date = env.toDate(res.marker);
                  expect(date).toEqual(new Date(Date.UTC(2018, 5, 8)));
                  expect(res.forcedTzo).toBeNull();
              });
              it('parses a date already in UTC', () => {
                  let res = env.createMarkerMeta('2018-06-08T00:00:00Z');
                  let date = env.toDate(res.marker);
                  expect(date).toEqual(new Date(Date.UTC(2018, 5, 8)));
                  expect(res.forcedTzo).toBeNull();
              });
              it('parses timezones into UTC', () => {
                  let res = env.createMarkerMeta('2018-06-08T00:00:00+12:00');
                  let date = env.toDate(res.marker);
                  expect(date).toEqual(new Date(Date.UTC(2018, 5, 7, 12)));
                  expect(res.forcedTzo).toBeNull();
              });
              it('detects lack of time', () => {
                  let res = env.createMarkerMeta('2018-06-08');
                  expect(res.isTimeUnspecified).toBe(true);
              });
              it('detects presence of time', () => {
                  let res = env.createMarkerMeta('2018-06-08T00:00:00');
                  expect(res.isTimeUnspecified).toBe(false);
              });
              it('parses a time with no \'T\'', () => {
                  let res = env.createMarkerMeta('2018-06-08 01:00:00');
                  let date = env.toDate(res.marker);
                  expect(date).toEqual(new Date(Date.UTC(2018, 5, 8, 1, 0)));
              });
              it('parses just a month', () => {
                  let res = env.createMarkerMeta('2018-06');
                  let date = env.toDate(res.marker);
                  expect(date).toEqual(new Date(Date.UTC(2018, 5, 1)));
              });
              it('detects presence of time even if timezone', () => {
                  let res = env.createMarkerMeta('2018-06-08T00:00:00+12:00');
                  expect(res.isTimeUnspecified).toBe(false);
              });
          });
          it('outputs ISO8601 formatting', () => {
              let marker = env.createMarker('2018-06-08T00:00:00');
              let s = env.formatIso(marker);
              expect(s).toBe('2018-06-08T00:00:00Z');
          });
          it('outputs pretty format with UTC timezone', () => {
              let marker = env.createMarker('2018-06-08');
              let formatter = createFormatter({
                  weekday: 'long',
                  day: 'numeric',
                  month: 'long',
                  hour: '2-digit',
                  minute: '2-digit',
                  year: 'numeric',
                  timeZoneName: 'short',
                  omitCommas: true, // for cross-browser
              });
              let s = env.format(marker, formatter);
              expect(s.replace(' at ', ' '))
                  .toBe('Friday June 8 2018 12:00 AM UTC');
          });
          describe('week number formatting', () => {
              it('can output only number', () => {
                  let marker = env.createMarker('2018-06-08');
                  let formatter = createFormatter({ week: 'numeric' });
                  let s = env.format(marker, formatter);
                  expect(s).toBe('23');
              });
              it('can output narrow', () => {
                  let marker = env.createMarker('2018-06-08');
                  let formatter = createFormatter({ week: 'narrow' });
                  let s = env.format(marker, formatter);
                  expect(s).toBe('W23');
              });
              it('can output short', () => {
                  let marker = env.createMarker('2018-06-08');
                  let formatter = createFormatter({ week: 'short' });
                  let s = env.format(marker, formatter);
                  expect(s).toBe('W 23');
              });
          });
          describe('range formatting', () => {
              let formatter = createFormatter({
                  day: 'numeric',
                  month: 'long',
                  year: 'numeric',
                  separator: ' - ',
              });
              it('works with different days of same month', () => {
                  let m0 = env.createMarker('2018-06-08');
                  let m1 = env.createMarker('2018-06-09');
                  let s = env.formatRange(m0, m1, formatter);
                  expect(s).toBe('June 8 - 9, 2018');
              });
              it('works with different days of same month, with inprecise formatter', () => {
                  let otherFormatter = createFormatter({
                      month: 'long',
                      year: 'numeric',
                  });
                  let m0 = env.createMarker('2018-06-08');
                  let m1 = env.createMarker('2018-06-09');
                  let s = env.formatRange(m0, m1, otherFormatter);
                  expect(s).toBe('June 2018');
              });
              it('works with different day/month of same year', () => {
                  let m0 = env.createMarker('2018-06-08');
                  let m1 = env.createMarker('2018-07-09');
                  let s = env.formatRange(m0, m1, formatter);
                  expect(s).toBe('June 8 - July 9, 2018');
              });
              it('works with completely different dates', () => {
                  let m0 = env.createMarker('2018-06-08');
                  let m1 = env.createMarker('2020-07-09');
                  let s = env.formatRange(m0, m1, formatter);
                  expect(s).toBe('June 8, 2018 - July 9, 2020');
              });
          });
          // date math
          describe('add', () => {
              it('works with positives', () => {
                  let dur = createDuration({
                      year: 1,
                      month: 2,
                      day: 3,
                      hour: 4,
                      minute: 5,
                      second: 6,
                      ms: 7,
                  });
                  let d0 = env.createMarker(new Date(Date.UTC(2018, 5, 5, 12)));
                  let d1 = env.toDate(env.add(d0, dur));
                  expect(d1).toEqual(new Date(Date.UTC(2019, 7, 8, 16, 5, 6, 7)));
              });
              it('works with negatives', () => {
                  let dur = createDuration({
                      year: -1,
                      month: -2,
                      day: -3,
                      hour: -4,
                      minute: -5,
                      second: -6,
                      millisecond: -7,
                  });
                  let d0 = env.createMarker(new Date(Date.UTC(2018, 5, 5, 12)));
                  let d1 = env.toDate(env.add(d0, dur));
                  expect(d1).toEqual(new Date(Date.UTC(2017, 3, 2, 7, 54, 53, 993)));
              });
          });
          // test in Safari!
          // https://github.com/fullcalendar/fullcalendar/issues/4363
          it('startOfYear', () => {
              let d0 = env.createMarker(new Date(Date.UTC(2018, 5, 5, 12)));
              let d1 = env.toDate(env.startOfYear(d0));
              expect(d1).toEqual(new Date(Date.UTC(2018, 0, 1)));
          });
          it('startOfMonth', () => {
              let d0 = env.createMarker(new Date(Date.UTC(2018, 5, 5, 12)));
              let d1 = env.toDate(env.startOfMonth(d0));
              expect(d1).toEqual(new Date(Date.UTC(2018, 5, 1)));
          });
          it('startOfWeek', () => {
              let d0 = env.createMarker(new Date(Date.UTC(2018, 5, 5, 12)));
              let d1 = env.toDate(env.startOfWeek(d0));
              expect(d1).toEqual(new Date(Date.UTC(2018, 5, 3)));
          });
          it('startOfDay', () => {
              let d0 = env.createMarker(new Date(Date.UTC(2018, 5, 5, 12, 30)));
              let d1 = env.toDate(startOfDay(d0));
              expect(d1).toEqual(new Date(Date.UTC(2018, 5, 5)));
          });
          describe('diffWholeYears', () => {
              it('returns null if not whole', () => {
                  let d0 = new Date(Date.UTC(2018, 5, 5, 12, 0));
                  let d1 = new Date(Date.UTC(2020, 5, 5, 12, 30));
                  let diff = env.diffWholeYears(env.createMarker(d0), env.createMarker(d1));
                  expect(diff).toBe(null);
              });
              it('returns negative', () => {
                  let d0 = new Date(Date.UTC(2020, 5, 5, 12, 0));
                  let d1 = new Date(Date.UTC(2018, 5, 5, 12, 0));
                  let diff = env.diffWholeYears(env.createMarker(d0), env.createMarker(d1));
                  expect(diff).toBe(-2);
              });
              it('returns positive', () => {
                  let d0 = new Date(Date.UTC(2018, 5, 5, 12, 0));
                  let d1 = new Date(Date.UTC(2020, 5, 5, 12, 0));
                  let diff = env.diffWholeYears(env.createMarker(d0), env.createMarker(d1));
                  expect(diff).toBe(2);
              });
          });
          describe('diffWholeMonths', () => {
              it('returns null if not whole', () => {
                  let d0 = new Date(Date.UTC(2018, 5, 5));
                  let d1 = new Date(Date.UTC(2020, 5, 6));
                  let diff = env.diffWholeMonths(env.createMarker(d0), env.createMarker(d1));
                  expect(diff).toBe(null);
              });
              it('returns negative', () => {
                  let d0 = new Date(Date.UTC(2020, 9, 5));
                  let d1 = new Date(Date.UTC(2018, 5, 5));
                  let diff = env.diffWholeMonths(env.createMarker(d0), env.createMarker(d1));
                  expect(diff).toBe(-12 * 2 - 4);
              });
              it('returns positive', () => {
                  let d0 = new Date(Date.UTC(2018, 5, 5));
                  let d1 = new Date(Date.UTC(2020, 9, 5));
                  let diff = env.diffWholeMonths(env.createMarker(d0), env.createMarker(d1));
                  expect(diff).toBe(12 * 2 + 4);
              });
          });
          describe('diffWholeWeeks', () => {
              it('returns null if not whole', () => {
                  let d0 = new Date(Date.UTC(2018, 5, 5));
                  let d1 = new Date(Date.UTC(2018, 5, 20));
                  let diff = diffWholeWeeks(env.createMarker(d0), env.createMarker(d1));
                  expect(diff).toBe(null);
              });
              it('returns negative', () => {
                  let d0 = new Date(Date.UTC(2018, 5, 19));
                  let d1 = new Date(Date.UTC(2018, 5, 5));
                  let diff = diffWholeWeeks(env.createMarker(d0), env.createMarker(d1));
                  expect(diff).toBe(-2);
              });
              it('returns positive', () => {
                  let d0 = new Date(Date.UTC(2018, 5, 5));
                  let d1 = new Date(Date.UTC(2018, 5, 19));
                  let diff = diffWholeWeeks(env.createMarker(d0), env.createMarker(d1));
                  expect(diff).toBe(2);
              });
          });
          describe('diffWholeDays', () => {
              it('returns null if not whole', () => {
                  let d0 = new Date(Date.UTC(2018, 5, 5));
                  let d1 = new Date(Date.UTC(2018, 5, 19, 12));
                  let diff = diffWholeDays(env.createMarker(d0), env.createMarker(d1));
                  expect(diff).toBe(null);
              });
              it('returns negative', () => {
                  let d0 = new Date(Date.UTC(2018, 5, 19));
                  let d1 = new Date(Date.UTC(2018, 5, 5));
                  let diff = diffWholeDays(env.createMarker(d0), env.createMarker(d1));
                  expect(diff).toBe(-14);
              });
              it('returns positive', () => {
                  let d0 = new Date(Date.UTC(2018, 5, 5));
                  let d1 = new Date(Date.UTC(2018, 5, 19));
                  let diff = diffWholeDays(env.createMarker(d0), env.createMarker(d1));
                  expect(diff).toBe(14);
              });
          });
          describe('diffDayAndTime', () => {
              it('returns negative', () => {
                  let d0 = new Date(Date.UTC(2018, 5, 19, 12));
                  let d1 = new Date(Date.UTC(2018, 5, 5));
                  let diff = diffDayAndTime(env.createMarker(d0), env.createMarker(d1));
                  expect(diff).toEqual({
                      years: 0,
                      months: 0,
                      days: -14,
                      milliseconds: -12 * 60 * 60 * 1000,
                  });
              });
              it('returns positive', () => {
                  let d0 = new Date(Date.UTC(2018, 5, 5));
                  let d1 = new Date(Date.UTC(2018, 5, 19, 12));
                  let diff = diffDayAndTime(env.createMarker(d0), env.createMarker(d1));
                  expect(diff).toEqual({
                      years: 0,
                      months: 0,
                      days: 14,
                      milliseconds: 12 * 60 * 60 * 1000,
                  });
              });
          });
      });
      describe('when local', () => {
          let env;
          beforeEach(() => {
              env = new DateEnv({
                  timeZone: 'local',
                  calendarSystem: 'gregory',
                  locale: enLocale,
              });
          });
          describe('ISO8601 parsing', () => {
              it('parses non-tz as local', () => {
                  let res = env.createMarkerMeta('2018-06-08');
                  let date = env.toDate(res.marker);
                  expect(date).toEqual(new Date(2018, 5, 8));
                  expect(res.forcedTzo).toBeNull();
              });
              it('parses timezones into local', () => {
                  let res = env.createMarkerMeta('2018-06-08T00:00:00+12:00');
                  let date = env.toDate(res.marker);
                  expect(date).toEqual(new Date(Date.UTC(2018, 5, 7, 12)));
                  expect(res.forcedTzo).toBeNull();
              });
              it('does not lose info when parsing a dst-dead-zone date', () => {
                  let deadZone = getDSTDeadZone();
                  if (!deadZone) {
                      console.log('could not determine DST dead zone'); // eslint-disable-line no-console
                  }
                  else {
                      // use a utc date to get a ISO8601 string representation of the start of the dead zone
                      let utcDate = new Date(Date.UTC(deadZone[1].getFullYear(), deadZone[1].getMonth(), deadZone[1].getDate(), deadZone[1].getHours() - 1, // back one hour. shouldn't exist in local time
                      deadZone[1].getMinutes(), deadZone[1].getSeconds(), deadZone[1].getMilliseconds()));
                      let s = formatIsoWithoutTz(utcDate);
                      // check that the local date falls out of the dead zone
                      let localDate = new Date(s);
                      expect(localDate.getHours()).not.toBe(deadZone[1].getHours() - 1);
                      // check that is parsed and retained the original hour,
                      // even tho it falls into the dead zone for local time
                      let marker = env.createMarker(s);
                      expect(formatIsoWithoutTz(marker)).toBe(s);
                      // TODO
                      // // when it uses the env to format to local time,
                      // // it should have jumped out of the dead zone.
                      // expect(env.formatIso(marker)).not.toMatch(s)
                  }
              });
          });
          it('outputs ISO8601 formatting', () => {
              let marker = env.createMarker('2018-06-08T00:00:00');
              let s = env.formatIso(marker);
              let realTzo = formatIsoTimeZoneOffset(new Date(2018, 5, 8));
              expect(s).toBe('2018-06-08T00:00:00' + realTzo);
          });
          it('outputs pretty format with local timezone', () => {
              let marker = env.createMarker('2018-06-08');
              let formatter = createFormatter({
                  weekday: 'long',
                  day: 'numeric',
                  month: 'long',
                  year: 'numeric',
                  hour: '2-digit',
                  minute: '2-digit',
                  timeZoneName: 'short',
                  omitCommas: true, // for cross-browser
              });
              let s = env.format(marker, formatter);
              expect(s.replace(' at ', ' '))
                  .toBe('Friday June 8 2018 12:00 AM ' + formatPrettyTimeZoneOffset(new Date(2018, 5, 8)));
          });
          it('can output a timezone only', () => {
              let marker = env.createMarker('2018-06-08');
              let formatter = createFormatter({ timeZoneName: 'short' });
              let s = env.format(marker, formatter);
              expect(s).toBe(formatPrettyTimeZoneOffset(new Date(2018, 5, 8)));
          });
          // because `new Date(year)` is error-prone
          it('startOfYear', () => {
              let d0 = env.createMarker(new Date(2018, 5, 5, 12));
              let d1 = env.toDate(env.startOfYear(d0));
              expect(d1).toEqual(new Date(2018, 0, 1));
          });
      });
      describe('when named timezone with coercion', () => {
          let env;
          beforeEach(() => {
              env = new DateEnv({
                  timeZone: 'America/Chicago',
                  calendarSystem: 'gregory',
                  locale: enLocale,
              });
          });
          describe('ISO8601 parsing', () => {
              it('parses non-tz as UTC with no forcedTzo', () => {
                  let res = env.createMarkerMeta('2018-06-08');
                  let date = env.toDate(res.marker);
                  expect(date).toEqual(new Date(Date.UTC(2018, 5, 8)));
                  expect(res.forcedTzo).toBeNull();
              });
              it('parses as UTC after stripping and with a forcedTzo', () => {
                  let res = env.createMarkerMeta('2018-06-08T00:00:00+12:00');
                  let date = env.toDate(res.marker);
                  expect(date).toEqual(new Date(Date.UTC(2018, 5, 8)));
                  expect(res.forcedTzo).toBe(12 * 60);
              });
              it('parses as UTC after stripping and with a forcedTzo, alt format', () => {
                  let res = env.createMarkerMeta('2018-06-08T01:01:01.100+1200');
                  let date = env.toDate(res.marker);
                  expect(date).toEqual(new Date(Date.UTC(2018, 5, 8, 1, 1, 1, 100)));
                  expect(res.forcedTzo).toBe(12 * 60);
              });
          });
          it('outputs UTC timezone when no timezone specified', () => {
              let marker = env.createMarker('2018-06-08');
              let formatter = createFormatter({
                  weekday: 'long',
                  day: 'numeric',
                  month: 'long',
                  year: 'numeric',
                  timeZoneName: 'short',
                  omitCommas: true, // for cross-browser
              });
              let s = env.format(marker, formatter);
              expect(s.replace(' at ', ' '))
                  .toBe('Friday June 8 2018 12:00 AM UTC');
          });
          it('outputs UTC short timezone when no timezone specified, when requested as long', () => {
              let marker = env.createMarker('2018-06-08');
              let formatter = createFormatter({
                  weekday: 'long',
                  day: 'numeric',
                  month: 'long',
                  year: 'numeric',
                  timeZoneName: 'long',
                  omitCommas: true, // for cross-browser
              });
              let s = env.format(marker, formatter);
              expect(s.replace(' at ', ' '))
                  .toBe('Friday June 8 2018 12:00 AM UTC');
          });
          it('computes current date as local values', () => {
              let marker = env.createNowMarker();
              let localDate = new Date();
              expect(marker.getUTCFullYear()).toBe(localDate.getFullYear());
              expect(marker.getUTCMonth()).toBe(localDate.getMonth());
              expect(marker.getUTCDate()).toBe(localDate.getDate());
              expect(marker.getUTCHours()).toBe(localDate.getHours());
              expect(marker.getUTCMinutes()).toBe(localDate.getMinutes());
              expect(marker.getUTCSeconds()).toBe(localDate.getSeconds());
          });
      });
      describe('duration parsing', () => {
          it('accepts whole day in string', () => {
              let dur = createDuration('2.00:00:00');
              expect(dur).toEqual({
                  years: 0,
                  months: 0,
                  days: 2,
                  milliseconds: 0,
              });
          });
          it('accepts hours, minutes, seconds, and milliseconds', () => {
              let dur = createDuration('01:02:03.500');
              expect(dur).toEqual({
                  years: 0,
                  months: 0,
                  days: 0,
                  milliseconds: 1 * 60 * 60 * 1000 +
                      2 * 60 * 1000 +
                      3 * 1000 +
                      500,
              });
          });
          it('accepts just hours and minutes', () => {
              let dur = createDuration('01:02');
              expect(dur).toEqual({
                  years: 0,
                  months: 0,
                  days: 0,
                  milliseconds: 1 * 60 * 60 * 1000 +
                      2 * 60 * 1000,
              });
          });
      });
  });

  // =============================================================================
  // Weekday
  // =============================================================================
  var ALL_WEEKDAYS = [
      'MO',
      'TU',
      'WE',
      'TH',
      'FR',
      'SA',
      'SU',
  ];
  var Weekday = /** @class */ (function () {
      function Weekday(weekday, n) {
          if (n === 0)
              throw new Error("Can't create weekday with n == 0");
          this.weekday = weekday;
          this.n = n;
      }
      Weekday.fromStr = function (str) {
          return new Weekday(ALL_WEEKDAYS.indexOf(str));
      };
      // __call__ - Cannot call the object directly, do it through
      // e.g. RRule.TH.nth(-1) instead,
      Weekday.prototype.nth = function (n) {
          return this.n === n ? this : new Weekday(this.weekday, n);
      };
      // __eq__
      Weekday.prototype.equals = function (other) {
          return this.weekday === other.weekday && this.n === other.n;
      };
      // __repr__
      Weekday.prototype.toString = function () {
          var s = ALL_WEEKDAYS[this.weekday];
          if (this.n)
              s = (this.n > 0 ? '+' : '') + String(this.n) + s;
          return s;
      };
      Weekday.prototype.getJsWeekday = function () {
          return this.weekday === 6 ? 0 : this.weekday + 1;
      };
      return Weekday;
  }());

  // =============================================================================
  var isPresent = function (value) {
      return value !== null && value !== undefined;
  };
  var isNumber = function (value) {
      return typeof value === 'number';
  };
  var isWeekdayStr = function (value) {
      return typeof value === 'string' && ALL_WEEKDAYS.includes(value);
  };
  var isArray = Array.isArray;
  /**
   * Simplified version of python's range()
   */
  var range = function (start, end) {
      if (end === void 0) { end = start; }
      if (arguments.length === 1) {
          end = start;
          start = 0;
      }
      var rang = [];
      for (var i = start; i < end; i++)
          rang.push(i);
      return rang;
  };
  var repeat = function (value, times) {
      var i = 0;
      var array = [];
      if (isArray(value)) {
          for (; i < times; i++)
              array[i] = [].concat(value);
      }
      else {
          for (; i < times; i++)
              array[i] = value;
      }
      return array;
  };
  var toArray = function (item) {
      if (isArray(item)) {
          return item;
      }
      return [item];
  };
  function padStart(item, targetLength, padString) {
      if (padString === void 0) { padString = ' '; }
      var str = String(item);
      targetLength = targetLength >> 0;
      if (str.length > targetLength) {
          return String(str);
      }
      targetLength = targetLength - str.length;
      if (targetLength > padString.length) {
          padString += repeat(padString, targetLength / padString.length);
      }
      return padString.slice(0, targetLength) + String(str);
  }
  /**
   * Python like split
   */
  var split = function (str, sep, num) {
      var splits = str.split(sep);
      return num
          ? splits.slice(0, num).concat([splits.slice(num).join(sep)])
          : splits;
  };
  /**
   * closure/goog/math/math.js:modulo
   * Copyright 2006 The Closure Library Authors.
   * The % operator in JavaScript returns the remainder of a / b, but differs from
   * some other languages in that the result will have the same sign as the
   * dividend. For example, -1 % 8 == -1, whereas in some other languages
   * (such as Python) the result would be 7. This function emulates the more
   * correct modulo behavior, which is useful for certain applications such as
   * calculating an offset index in a circular list.
   *
   * @param {number} a The dividend.
   * @param {number} b The divisor.
   * @return {number} a % b where the result is between 0 and b (either 0 <= x < b
   * or b < x <= 0, depending on the sign of b).
   */
  var pymod = function (a, b) {
      var r = a % b;
      // If r and b differ in sign, add b to wrap the result to the correct sign.
      return r * b < 0 ? r + b : r;
  };
  /**
   * @see: <http://docs.python.org/library/functions.html#divmod>
   */
  var divmod = function (a, b) {
      return { div: Math.floor(a / b), mod: pymod(a, b) };
  };
  var empty = function (obj) {
      return !isPresent(obj) || obj.length === 0;
  };
  /**
   * Python-like boolean
   *
   * @return {Boolean} value of an object/primitive, taking into account
   * the fact that in Python an empty list's/tuple's
   * boolean value is False, whereas in JS it's true
   */
  var notEmpty = function (obj) {
      return !empty(obj);
  };
  /**
   * Return true if a value is in an array
   */
  var includes = function (arr, val) {
      return notEmpty(arr) && arr.indexOf(val) !== -1;
  };

  /* eslint-disable @typescript-eslint/no-namespace */
  /**
   * General date-related utilities.
   * Also handles several incompatibilities between JavaScript and Python
   *
   */
  var dateutil;
  (function (dateutil) {
      dateutil.MONTH_DAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      /**
       * Number of milliseconds of one day
       */
      dateutil.ONE_DAY = 1000 * 60 * 60 * 24;
      /**
       * @see: <http://docs.python.org/library/datetime.html#datetime.MAXYEAR>
       */
      dateutil.MAXYEAR = 9999;
      /**
       * Python uses 1-Jan-1 as the base for calculating ordinals but we don't
       * want to confuse the JS engine with milliseconds > Number.MAX_NUMBER,
       * therefore we use 1-Jan-1970 instead
       */
      dateutil.ORDINAL_BASE = new Date(Date.UTC(1970, 0, 1));
      /**
       * Python: MO-SU: 0 - 6
       * JS: SU-SAT 0 - 6
       */
      dateutil.PY_WEEKDAYS = [6, 0, 1, 2, 3, 4, 5];
      /**
       * py_date.timetuple()[7]
       */
      dateutil.getYearDay = function (date) {
          var dateNoTime = new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
          return (Math.ceil((dateNoTime.valueOf() -
              new Date(date.getUTCFullYear(), 0, 1).valueOf()) /
              dateutil.ONE_DAY) + 1);
      };
      dateutil.isLeapYear = function (year) {
          return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
      };
      dateutil.isDate = function (value) {
          return value instanceof Date;
      };
      dateutil.isValidDate = function (value) {
          return dateutil.isDate(value) && !isNaN(value.getTime());
      };
      /**
       * @return {Number} the date's timezone offset in ms
       */
      dateutil.tzOffset = function (date) {
          return date.getTimezoneOffset() * 60 * 1000;
      };
      /**
       * @see: <http://www.mcfedries.com/JavaScript/DaysBetween.asp>
       */
      dateutil.daysBetween = function (date1, date2) {
          // The number of milliseconds in one day
          // Convert both dates to milliseconds
          var date1ms = date1.getTime() - dateutil.tzOffset(date1);
          var date2ms = date2.getTime() - dateutil.tzOffset(date2);
          // Calculate the difference in milliseconds
          var differencems = date1ms - date2ms;
          // Convert back to days and return
          return Math.round(differencems / dateutil.ONE_DAY);
      };
      /**
       * @see: <http://docs.python.org/library/datetime.html#datetime.date.toordinal>
       */
      dateutil.toOrdinal = function (date) {
          return dateutil.daysBetween(date, dateutil.ORDINAL_BASE);
      };
      /**
       * @see - <http://docs.python.org/library/datetime.html#datetime.date.fromordinal>
       */
      dateutil.fromOrdinal = function (ordinal) {
          return new Date(dateutil.ORDINAL_BASE.getTime() + ordinal * dateutil.ONE_DAY);
      };
      dateutil.getMonthDays = function (date) {
          var month = date.getUTCMonth();
          return month === 1 && dateutil.isLeapYear(date.getUTCFullYear())
              ? 29
              : dateutil.MONTH_DAYS[month];
      };
      /**
       * @return {Number} python-like weekday
       */
      dateutil.getWeekday = function (date) {
          return dateutil.PY_WEEKDAYS[date.getUTCDay()];
      };
      /**
       * @see: <http://docs.python.org/library/calendar.html#calendar.monthrange>
       */
      dateutil.monthRange = function (year, month) {
          var date = new Date(Date.UTC(year, month, 1));
          return [dateutil.getWeekday(date), dateutil.getMonthDays(date)];
      };
      /**
       * @see: <http://docs.python.org/library/datetime.html#datetime.datetime.combine>
       */
      dateutil.combine = function (date, time) {
          time = time || date;
          return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds()));
      };
      dateutil.clone = function (date) {
          var dolly = new Date(date.getTime());
          return dolly;
      };
      dateutil.cloneDates = function (dates) {
          var clones = [];
          for (var i = 0; i < dates.length; i++) {
              clones.push(dateutil.clone(dates[i]));
          }
          return clones;
      };
      /**
       * Sorts an array of Date or dateutil.Time objects
       */
      dateutil.sort = function (dates) {
          dates.sort(function (a, b) {
              return a.getTime() - b.getTime();
          });
      };
      dateutil.timeToUntilString = function (time, utc) {
          if (utc === void 0) { utc = true; }
          var date = new Date(time);
          return [
              padStart(date.getUTCFullYear().toString(), 4, '0'),
              padStart(date.getUTCMonth() + 1, 2, '0'),
              padStart(date.getUTCDate(), 2, '0'),
              'T',
              padStart(date.getUTCHours(), 2, '0'),
              padStart(date.getUTCMinutes(), 2, '0'),
              padStart(date.getUTCSeconds(), 2, '0'),
              utc ? 'Z' : '',
          ].join('');
      };
      dateutil.untilStringToDate = function (until) {
          var re = /^(\d{4})(\d{2})(\d{2})(T(\d{2})(\d{2})(\d{2})Z?)?$/;
          var bits = re.exec(until);
          if (!bits)
              throw new Error("Invalid UNTIL value: ".concat(until));
          return new Date(Date.UTC(parseInt(bits[1], 10), parseInt(bits[2], 10) - 1, parseInt(bits[3], 10), parseInt(bits[5], 10) || 0, parseInt(bits[6], 10) || 0, parseInt(bits[7], 10) || 0));
      };
  })(dateutil || (dateutil = {}));
  var dateutil$1 = dateutil;

  /**
   * This class helps us to emulate python's generators, sorta.
   */
  var IterResult = /** @class */ (function () {
      function IterResult(method, args) {
          this.minDate = null;
          this.maxDate = null;
          this._result = [];
          this.total = 0;
          this.method = method;
          this.args = args;
          if (method === 'between') {
              this.maxDate = args.inc
                  ? args.before
                  : new Date(args.before.getTime() - 1);
              this.minDate = args.inc ? args.after : new Date(args.after.getTime() + 1);
          }
          else if (method === 'before') {
              this.maxDate = args.inc ? args.dt : new Date(args.dt.getTime() - 1);
          }
          else if (method === 'after') {
              this.minDate = args.inc ? args.dt : new Date(args.dt.getTime() + 1);
          }
      }
      /**
       * Possibly adds a date into the result.
       *
       * @param {Date} date - the date isn't necessarly added to the result
       * list (if it is too late/too early)
       * @return {Boolean} true if it makes sense to continue the iteration
       * false if we're done.
       */
      IterResult.prototype.accept = function (date) {
          ++this.total;
          var tooEarly = this.minDate && date < this.minDate;
          var tooLate = this.maxDate && date > this.maxDate;
          if (this.method === 'between') {
              if (tooEarly)
                  return true;
              if (tooLate)
                  return false;
          }
          else if (this.method === 'before') {
              if (tooLate)
                  return false;
          }
          else if (this.method === 'after') {
              if (tooEarly)
                  return true;
              this.add(date);
              return false;
          }
          return this.add(date);
      };
      /**
       *
       * @param {Date} date that is part of the result.
       * @return {Boolean} whether we are interested in more values.
       */
      IterResult.prototype.add = function (date) {
          this._result.push(date);
          return true;
      };
      /**
       * 'before' and 'after' return only one date, whereas 'all'
       * and 'between' an array.
       *
       * @return {Date,Array?}
       */
      IterResult.prototype.getValue = function () {
          var res = this._result;
          switch (this.method) {
              case 'all':
              case 'between':
                  return res;
              case 'before':
              case 'after':
              default:
                  return (res.length ? res[res.length - 1] : null);
          }
      };
      IterResult.prototype.clone = function () {
          return new IterResult(this.method, this.args);
      };
      return IterResult;
  }());

  /******************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  /* global Reflect, Promise */

  var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
          function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
      return extendStatics(d, b);
  };

  function __extends(d, b) {
      if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  var __assign = function() {
      __assign = Object.assign || function __assign(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
      };
      return __assign.apply(this, arguments);
  };

  function __spreadArray(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
              if (!ar) ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
          }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
  }

  /**
   * IterResult subclass that calls a callback function on each add,
   * and stops iterating when the callback returns false.
   */
  var CallbackIterResult = /** @class */ (function (_super) {
      __extends(CallbackIterResult, _super);
      function CallbackIterResult(method, args, iterator) {
          var _this = _super.call(this, method, args) || this;
          _this.iterator = iterator;
          return _this;
      }
      CallbackIterResult.prototype.add = function (date) {
          if (this.iterator(date, this._result.length)) {
              this._result.push(date);
              return true;
          }
          return false;
      };
      return CallbackIterResult;
  }(IterResult));

  // =============================================================================
  // i18n
  // =============================================================================
  var ENGLISH = {
      dayNames: [
          'Sunday',
          'Monday',
          'Tuesday',
          'Wednesday',
          'Thursday',
          'Friday',
          'Saturday',
      ],
      monthNames: [
          'January',
          'February',
          'March',
          'April',
          'May',
          'June',
          'July',
          'August',
          'September',
          'October',
          'November',
          'December',
      ],
      tokens: {
          SKIP: /^[ \r\n\t]+|^\.$/,
          number: /^[1-9][0-9]*/,
          numberAsText: /^(one|two|three)/i,
          every: /^every/i,
          'day(s)': /^days?/i,
          'weekday(s)': /^weekdays?/i,
          'week(s)': /^weeks?/i,
          'hour(s)': /^hours?/i,
          'minute(s)': /^minutes?/i,
          'month(s)': /^months?/i,
          'year(s)': /^years?/i,
          on: /^(on|in)/i,
          at: /^(at)/i,
          the: /^the/i,
          first: /^first/i,
          second: /^second/i,
          third: /^third/i,
          nth: /^([1-9][0-9]*)(\.|th|nd|rd|st)/i,
          last: /^last/i,
          for: /^for/i,
          'time(s)': /^times?/i,
          until: /^(un)?til/i,
          monday: /^mo(n(day)?)?/i,
          tuesday: /^tu(e(s(day)?)?)?/i,
          wednesday: /^we(d(n(esday)?)?)?/i,
          thursday: /^th(u(r(sday)?)?)?/i,
          friday: /^fr(i(day)?)?/i,
          saturday: /^sa(t(urday)?)?/i,
          sunday: /^su(n(day)?)?/i,
          january: /^jan(uary)?/i,
          february: /^feb(ruary)?/i,
          march: /^mar(ch)?/i,
          april: /^apr(il)?/i,
          may: /^may/i,
          june: /^june?/i,
          july: /^july?/i,
          august: /^aug(ust)?/i,
          september: /^sep(t(ember)?)?/i,
          october: /^oct(ober)?/i,
          november: /^nov(ember)?/i,
          december: /^dec(ember)?/i,
          comma: /^(,\s*|(and|or)\s*)+/i,
      },
  };

  // =============================================================================
  // Helper functions
  // =============================================================================
  /**
   * Return true if a value is in an array
   */
  var contains = function (arr, val) {
      return arr.indexOf(val) !== -1;
  };
  var defaultGetText = function (id) { return id.toString(); };
  var defaultDateFormatter = function (year, month, day) { return "".concat(month, " ").concat(day, ", ").concat(year); };
  /**
   *
   * @param {RRule} rrule
   * Optional:
   * @param {Function} gettext function
   * @param {Object} language definition
   * @constructor
   */
  var ToText = /** @class */ (function () {
      function ToText(rrule, gettext, language, dateFormatter) {
          if (gettext === void 0) { gettext = defaultGetText; }
          if (language === void 0) { language = ENGLISH; }
          if (dateFormatter === void 0) { dateFormatter = defaultDateFormatter; }
          this.text = [];
          this.language = language || ENGLISH;
          this.gettext = gettext;
          this.dateFormatter = dateFormatter;
          this.rrule = rrule;
          this.options = rrule.options;
          this.origOptions = rrule.origOptions;
          if (this.origOptions.bymonthday) {
              var bymonthday = [].concat(this.options.bymonthday);
              var bynmonthday = [].concat(this.options.bynmonthday);
              bymonthday.sort(function (a, b) { return a - b; });
              bynmonthday.sort(function (a, b) { return b - a; });
              // 1, 2, 3, .., -5, -4, -3, ..
              this.bymonthday = bymonthday.concat(bynmonthday);
              if (!this.bymonthday.length)
                  this.bymonthday = null;
          }
          if (isPresent(this.origOptions.byweekday)) {
              var byweekday = !isArray(this.origOptions.byweekday)
                  ? [this.origOptions.byweekday]
                  : this.origOptions.byweekday;
              var days = String(byweekday);
              this.byweekday = {
                  allWeeks: byweekday.filter(function (weekday) {
                      return !weekday.n;
                  }),
                  someWeeks: byweekday.filter(function (weekday) {
                      return Boolean(weekday.n);
                  }),
                  isWeekdays: days.indexOf('MO') !== -1 &&
                      days.indexOf('TU') !== -1 &&
                      days.indexOf('WE') !== -1 &&
                      days.indexOf('TH') !== -1 &&
                      days.indexOf('FR') !== -1 &&
                      days.indexOf('SA') === -1 &&
                      days.indexOf('SU') === -1,
                  isEveryDay: days.indexOf('MO') !== -1 &&
                      days.indexOf('TU') !== -1 &&
                      days.indexOf('WE') !== -1 &&
                      days.indexOf('TH') !== -1 &&
                      days.indexOf('FR') !== -1 &&
                      days.indexOf('SA') !== -1 &&
                      days.indexOf('SU') !== -1,
              };
              var sortWeekDays = function (a, b) {
                  return a.weekday - b.weekday;
              };
              this.byweekday.allWeeks.sort(sortWeekDays);
              this.byweekday.someWeeks.sort(sortWeekDays);
              if (!this.byweekday.allWeeks.length)
                  this.byweekday.allWeeks = null;
              if (!this.byweekday.someWeeks.length)
                  this.byweekday.someWeeks = null;
          }
          else {
              this.byweekday = null;
          }
      }
      /**
       * Test whether the rrule can be fully converted to text.
       *
       * @param {RRule} rrule
       * @return {Boolean}
       */
      ToText.isFullyConvertible = function (rrule) {
          var canConvert = true;
          if (!(rrule.options.freq in ToText.IMPLEMENTED))
              return false;
          if (rrule.origOptions.until && rrule.origOptions.count)
              return false;
          for (var key in rrule.origOptions) {
              if (contains(['dtstart', 'wkst', 'freq'], key))
                  return true;
              if (!contains(ToText.IMPLEMENTED[rrule.options.freq], key))
                  return false;
          }
          return canConvert;
      };
      ToText.prototype.isFullyConvertible = function () {
          return ToText.isFullyConvertible(this.rrule);
      };
      /**
       * Perform the conversion. Only some of the frequencies are supported.
       * If some of the rrule's options aren't supported, they'll
       * be omitted from the output an "(~ approximate)" will be appended.
       *
       * @return {*}
       */
      ToText.prototype.toString = function () {
          var gettext = this.gettext;
          if (!(this.options.freq in ToText.IMPLEMENTED)) {
              return gettext('RRule error: Unable to fully convert this rrule to text');
          }
          this.text = [gettext('every')];
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          this[RRule.FREQUENCIES[this.options.freq]]();
          if (this.options.until) {
              this.add(gettext('until'));
              var until = this.options.until;
              this.add(this.dateFormatter(until.getUTCFullYear(), this.language.monthNames[until.getUTCMonth()], until.getUTCDate()));
          }
          else if (this.options.count) {
              this.add(gettext('for'))
                  .add(this.options.count.toString())
                  .add(this.plural(this.options.count) ? gettext('times') : gettext('time'));
          }
          if (!this.isFullyConvertible())
              this.add(gettext('(~ approximate)'));
          return this.text.join('');
      };
      ToText.prototype.HOURLY = function () {
          var gettext = this.gettext;
          if (this.options.interval !== 1)
              this.add(this.options.interval.toString());
          this.add(this.plural(this.options.interval) ? gettext('hours') : gettext('hour'));
      };
      ToText.prototype.MINUTELY = function () {
          var gettext = this.gettext;
          if (this.options.interval !== 1)
              this.add(this.options.interval.toString());
          this.add(this.plural(this.options.interval)
              ? gettext('minutes')
              : gettext('minute'));
      };
      ToText.prototype.DAILY = function () {
          var gettext = this.gettext;
          if (this.options.interval !== 1)
              this.add(this.options.interval.toString());
          if (this.byweekday && this.byweekday.isWeekdays) {
              this.add(this.plural(this.options.interval)
                  ? gettext('weekdays')
                  : gettext('weekday'));
          }
          else {
              this.add(this.plural(this.options.interval) ? gettext('days') : gettext('day'));
          }
          if (this.origOptions.bymonth) {
              this.add(gettext('in'));
              this._bymonth();
          }
          if (this.bymonthday) {
              this._bymonthday();
          }
          else if (this.byweekday) {
              this._byweekday();
          }
          else if (this.origOptions.byhour) {
              this._byhour();
          }
      };
      ToText.prototype.WEEKLY = function () {
          var gettext = this.gettext;
          if (this.options.interval !== 1) {
              this.add(this.options.interval.toString()).add(this.plural(this.options.interval) ? gettext('weeks') : gettext('week'));
          }
          if (this.byweekday && this.byweekday.isWeekdays) {
              if (this.options.interval === 1) {
                  this.add(this.plural(this.options.interval)
                      ? gettext('weekdays')
                      : gettext('weekday'));
              }
              else {
                  this.add(gettext('on')).add(gettext('weekdays'));
              }
          }
          else if (this.byweekday && this.byweekday.isEveryDay) {
              this.add(this.plural(this.options.interval) ? gettext('days') : gettext('day'));
          }
          else {
              if (this.options.interval === 1)
                  this.add(gettext('week'));
              if (this.origOptions.bymonth) {
                  this.add(gettext('in'));
                  this._bymonth();
              }
              if (this.bymonthday) {
                  this._bymonthday();
              }
              else if (this.byweekday) {
                  this._byweekday();
              }
          }
      };
      ToText.prototype.MONTHLY = function () {
          var gettext = this.gettext;
          if (this.origOptions.bymonth) {
              if (this.options.interval !== 1) {
                  this.add(this.options.interval.toString()).add(gettext('months'));
                  if (this.plural(this.options.interval))
                      this.add(gettext('in'));
              }
              this._bymonth();
          }
          else {
              if (this.options.interval !== 1) {
                  this.add(this.options.interval.toString());
              }
              this.add(this.plural(this.options.interval)
                  ? gettext('months')
                  : gettext('month'));
          }
          if (this.bymonthday) {
              this._bymonthday();
          }
          else if (this.byweekday && this.byweekday.isWeekdays) {
              this.add(gettext('on')).add(gettext('weekdays'));
          }
          else if (this.byweekday) {
              this._byweekday();
          }
      };
      ToText.prototype.YEARLY = function () {
          var gettext = this.gettext;
          if (this.origOptions.bymonth) {
              if (this.options.interval !== 1) {
                  this.add(this.options.interval.toString());
                  this.add(gettext('years'));
              }
              this._bymonth();
          }
          else {
              if (this.options.interval !== 1) {
                  this.add(this.options.interval.toString());
              }
              this.add(this.plural(this.options.interval) ? gettext('years') : gettext('year'));
          }
          if (this.bymonthday) {
              this._bymonthday();
          }
          else if (this.byweekday) {
              this._byweekday();
          }
          if (this.options.byyearday) {
              this.add(gettext('on the'))
                  .add(this.list(this.options.byyearday, this.nth, gettext('and')))
                  .add(gettext('day'));
          }
          if (this.options.byweekno) {
              this.add(gettext('in'))
                  .add(this.plural(this.options.byweekno.length)
                  ? gettext('weeks')
                  : gettext('week'))
                  .add(this.list(this.options.byweekno, undefined, gettext('and')));
          }
      };
      ToText.prototype._bymonthday = function () {
          var gettext = this.gettext;
          if (this.byweekday && this.byweekday.allWeeks) {
              this.add(gettext('on'))
                  .add(this.list(this.byweekday.allWeeks, this.weekdaytext, gettext('or')))
                  .add(gettext('the'))
                  .add(this.list(this.bymonthday, this.nth, gettext('or')));
          }
          else {
              this.add(gettext('on the')).add(this.list(this.bymonthday, this.nth, gettext('and')));
          }
          // this.add(gettext('DAY'))
      };
      ToText.prototype._byweekday = function () {
          var gettext = this.gettext;
          if (this.byweekday.allWeeks && !this.byweekday.isWeekdays) {
              this.add(gettext('on')).add(this.list(this.byweekday.allWeeks, this.weekdaytext));
          }
          if (this.byweekday.someWeeks) {
              if (this.byweekday.allWeeks)
                  this.add(gettext('and'));
              this.add(gettext('on the')).add(this.list(this.byweekday.someWeeks, this.weekdaytext, gettext('and')));
          }
      };
      ToText.prototype._byhour = function () {
          var gettext = this.gettext;
          this.add(gettext('at')).add(this.list(this.origOptions.byhour, undefined, gettext('and')));
      };
      ToText.prototype._bymonth = function () {
          this.add(this.list(this.options.bymonth, this.monthtext, this.gettext('and')));
      };
      ToText.prototype.nth = function (n) {
          n = parseInt(n.toString(), 10);
          var nth;
          var gettext = this.gettext;
          if (n === -1)
              return gettext('last');
          var npos = Math.abs(n);
          switch (npos) {
              case 1:
              case 21:
              case 31:
                  nth = npos + gettext('st');
                  break;
              case 2:
              case 22:
                  nth = npos + gettext('nd');
                  break;
              case 3:
              case 23:
                  nth = npos + gettext('rd');
                  break;
              default:
                  nth = npos + gettext('th');
          }
          return n < 0 ? nth + ' ' + gettext('last') : nth;
      };
      ToText.prototype.monthtext = function (m) {
          return this.language.monthNames[m - 1];
      };
      ToText.prototype.weekdaytext = function (wday) {
          var weekday = isNumber(wday) ? (wday + 1) % 7 : wday.getJsWeekday();
          return ((wday.n ? this.nth(wday.n) + ' ' : '') +
              this.language.dayNames[weekday]);
      };
      ToText.prototype.plural = function (n) {
          return n % 100 !== 1;
      };
      ToText.prototype.add = function (s) {
          this.text.push(' ');
          this.text.push(s);
          return this;
      };
      ToText.prototype.list = function (arr, callback, finalDelim, delim) {
          var _this = this;
          if (delim === void 0) { delim = ','; }
          if (!isArray(arr)) {
              arr = [arr];
          }
          var delimJoin = function (array, delimiter, finalDelimiter) {
              var list = '';
              for (var i = 0; i < array.length; i++) {
                  if (i !== 0) {
                      if (i === array.length - 1) {
                          list += ' ' + finalDelimiter + ' ';
                      }
                      else {
                          list += delimiter + ' ';
                      }
                  }
                  list += array[i];
              }
              return list;
          };
          callback =
              callback ||
                  function (o) {
                      return o.toString();
                  };
          var realCallback = function (arg) {
              return callback && callback.call(_this, arg);
          };
          if (finalDelim) {
              return delimJoin(arr.map(realCallback), delim, finalDelim);
          }
          else {
              return arr.map(realCallback).join(delim + ' ');
          }
      };
      return ToText;
  }());

  // =============================================================================
  // Parser
  // =============================================================================
  var Parser = /** @class */ (function () {
      function Parser(rules) {
          this.done = true;
          this.rules = rules;
      }
      Parser.prototype.start = function (text) {
          this.text = text;
          this.done = false;
          return this.nextSymbol();
      };
      Parser.prototype.isDone = function () {
          return this.done && this.symbol === null;
      };
      Parser.prototype.nextSymbol = function () {
          var best;
          var bestSymbol;
          this.symbol = null;
          this.value = null;
          do {
              if (this.done)
                  return false;
              var rule = void 0;
              best = null;
              for (var name_1 in this.rules) {
                  rule = this.rules[name_1];
                  var match = rule.exec(this.text);
                  if (match) {
                      if (best === null || match[0].length > best[0].length) {
                          best = match;
                          bestSymbol = name_1;
                      }
                  }
              }
              if (best != null) {
                  this.text = this.text.substr(best[0].length);
                  if (this.text === '')
                      this.done = true;
              }
              if (best == null) {
                  this.done = true;
                  this.symbol = null;
                  this.value = null;
                  return;
              }
          } while (bestSymbol === 'SKIP');
          this.symbol = bestSymbol;
          this.value = best;
          return true;
      };
      Parser.prototype.accept = function (name) {
          if (this.symbol === name) {
              if (this.value) {
                  var v = this.value;
                  this.nextSymbol();
                  return v;
              }
              this.nextSymbol();
              return true;
          }
          return false;
      };
      Parser.prototype.acceptNumber = function () {
          return this.accept('number');
      };
      Parser.prototype.expect = function (name) {
          if (this.accept(name))
              return true;
          throw new Error('expected ' + name + ' but found ' + this.symbol);
      };
      return Parser;
  }());
  function parseText(text, language) {
      if (language === void 0) { language = ENGLISH; }
      var options = {};
      var ttr = new Parser(language.tokens);
      if (!ttr.start(text))
          return null;
      S();
      return options;
      function S() {
          // every [n]
          ttr.expect('every');
          var n = ttr.acceptNumber();
          if (n)
              options.interval = parseInt(n[0], 10);
          if (ttr.isDone())
              throw new Error('Unexpected end');
          switch (ttr.symbol) {
              case 'day(s)':
                  options.freq = RRule.DAILY;
                  if (ttr.nextSymbol()) {
                      AT();
                      F();
                  }
                  break;
              // FIXME Note: every 2 weekdays != every two weeks on weekdays.
              // DAILY on weekdays is not a valid rule
              case 'weekday(s)':
                  options.freq = RRule.WEEKLY;
                  options.byweekday = [RRule.MO, RRule.TU, RRule.WE, RRule.TH, RRule.FR];
                  ttr.nextSymbol();
                  F();
                  break;
              case 'week(s)':
                  options.freq = RRule.WEEKLY;
                  if (ttr.nextSymbol()) {
                      ON();
                      F();
                  }
                  break;
              case 'hour(s)':
                  options.freq = RRule.HOURLY;
                  if (ttr.nextSymbol()) {
                      ON();
                      F();
                  }
                  break;
              case 'minute(s)':
                  options.freq = RRule.MINUTELY;
                  if (ttr.nextSymbol()) {
                      ON();
                      F();
                  }
                  break;
              case 'month(s)':
                  options.freq = RRule.MONTHLY;
                  if (ttr.nextSymbol()) {
                      ON();
                      F();
                  }
                  break;
              case 'year(s)':
                  options.freq = RRule.YEARLY;
                  if (ttr.nextSymbol()) {
                      ON();
                      F();
                  }
                  break;
              case 'monday':
              case 'tuesday':
              case 'wednesday':
              case 'thursday':
              case 'friday':
              case 'saturday':
              case 'sunday':
                  options.freq = RRule.WEEKLY;
                  var key = ttr.symbol
                      .substr(0, 2)
                      .toUpperCase();
                  options.byweekday = [RRule[key]];
                  if (!ttr.nextSymbol())
                      return;
                  // TODO check for duplicates
                  while (ttr.accept('comma')) {
                      if (ttr.isDone())
                          throw new Error('Unexpected end');
                      var wkd = decodeWKD();
                      if (!wkd) {
                          throw new Error('Unexpected symbol ' + ttr.symbol + ', expected weekday');
                      }
                      options.byweekday.push(RRule[wkd]);
                      ttr.nextSymbol();
                  }
                  MDAYs();
                  F();
                  break;
              case 'january':
              case 'february':
              case 'march':
              case 'april':
              case 'may':
              case 'june':
              case 'july':
              case 'august':
              case 'september':
              case 'october':
              case 'november':
              case 'december':
                  options.freq = RRule.YEARLY;
                  options.bymonth = [decodeM()];
                  if (!ttr.nextSymbol())
                      return;
                  // TODO check for duplicates
                  while (ttr.accept('comma')) {
                      if (ttr.isDone())
                          throw new Error('Unexpected end');
                      var m = decodeM();
                      if (!m) {
                          throw new Error('Unexpected symbol ' + ttr.symbol + ', expected month');
                      }
                      options.bymonth.push(m);
                      ttr.nextSymbol();
                  }
                  ON();
                  F();
                  break;
              default:
                  throw new Error('Unknown symbol');
          }
      }
      function ON() {
          var on = ttr.accept('on');
          var the = ttr.accept('the');
          if (!(on || the))
              return;
          do {
              var nth = decodeNTH();
              var wkd = decodeWKD();
              var m = decodeM();
              // nth <weekday> | <weekday>
              if (nth) {
                  // ttr.nextSymbol()
                  if (wkd) {
                      ttr.nextSymbol();
                      if (!options.byweekday)
                          options.byweekday = [];
                      options.byweekday.push(RRule[wkd].nth(nth));
                  }
                  else {
                      if (!options.bymonthday)
                          options.bymonthday = [];
                      options.bymonthday.push(nth);
                      ttr.accept('day(s)');
                  }
                  // <weekday>
              }
              else if (wkd) {
                  ttr.nextSymbol();
                  if (!options.byweekday)
                      options.byweekday = [];
                  options.byweekday.push(RRule[wkd]);
              }
              else if (ttr.symbol === 'weekday(s)') {
                  ttr.nextSymbol();
                  if (!options.byweekday) {
                      options.byweekday = [RRule.MO, RRule.TU, RRule.WE, RRule.TH, RRule.FR];
                  }
              }
              else if (ttr.symbol === 'week(s)') {
                  ttr.nextSymbol();
                  var n = ttr.acceptNumber();
                  if (!n) {
                      throw new Error('Unexpected symbol ' + ttr.symbol + ', expected week number');
                  }
                  options.byweekno = [parseInt(n[0], 10)];
                  while (ttr.accept('comma')) {
                      n = ttr.acceptNumber();
                      if (!n) {
                          throw new Error('Unexpected symbol ' + ttr.symbol + '; expected monthday');
                      }
                      options.byweekno.push(parseInt(n[0], 10));
                  }
              }
              else if (m) {
                  ttr.nextSymbol();
                  if (!options.bymonth)
                      options.bymonth = [];
                  options.bymonth.push(m);
              }
              else {
                  return;
              }
          } while (ttr.accept('comma') || ttr.accept('the') || ttr.accept('on'));
      }
      function AT() {
          var at = ttr.accept('at');
          if (!at)
              return;
          do {
              var n = ttr.acceptNumber();
              if (!n) {
                  throw new Error('Unexpected symbol ' + ttr.symbol + ', expected hour');
              }
              options.byhour = [parseInt(n[0], 10)];
              while (ttr.accept('comma')) {
                  n = ttr.acceptNumber();
                  if (!n) {
                      throw new Error('Unexpected symbol ' + ttr.symbol + '; expected hour');
                  }
                  options.byhour.push(parseInt(n[0], 10));
              }
          } while (ttr.accept('comma') || ttr.accept('at'));
      }
      function decodeM() {
          switch (ttr.symbol) {
              case 'january':
                  return 1;
              case 'february':
                  return 2;
              case 'march':
                  return 3;
              case 'april':
                  return 4;
              case 'may':
                  return 5;
              case 'june':
                  return 6;
              case 'july':
                  return 7;
              case 'august':
                  return 8;
              case 'september':
                  return 9;
              case 'october':
                  return 10;
              case 'november':
                  return 11;
              case 'december':
                  return 12;
              default:
                  return false;
          }
      }
      function decodeWKD() {
          switch (ttr.symbol) {
              case 'monday':
              case 'tuesday':
              case 'wednesday':
              case 'thursday':
              case 'friday':
              case 'saturday':
              case 'sunday':
                  return ttr.symbol.substr(0, 2).toUpperCase();
              default:
                  return false;
          }
      }
      function decodeNTH() {
          switch (ttr.symbol) {
              case 'last':
                  ttr.nextSymbol();
                  return -1;
              case 'first':
                  ttr.nextSymbol();
                  return 1;
              case 'second':
                  ttr.nextSymbol();
                  return ttr.accept('last') ? -2 : 2;
              case 'third':
                  ttr.nextSymbol();
                  return ttr.accept('last') ? -3 : 3;
              case 'nth':
                  var v = parseInt(ttr.value[1], 10);
                  if (v < -366 || v > 366)
                      throw new Error('Nth out of range: ' + v);
                  ttr.nextSymbol();
                  return ttr.accept('last') ? -v : v;
              default:
                  return false;
          }
      }
      function MDAYs() {
          ttr.accept('on');
          ttr.accept('the');
          var nth = decodeNTH();
          if (!nth)
              return;
          options.bymonthday = [nth];
          ttr.nextSymbol();
          while (ttr.accept('comma')) {
              nth = decodeNTH();
              if (!nth) {
                  throw new Error('Unexpected symbol ' + ttr.symbol + '; expected monthday');
              }
              options.bymonthday.push(nth);
              ttr.nextSymbol();
          }
      }
      function F() {
          if (ttr.symbol === 'until') {
              var date = Date.parse(ttr.text);
              if (!date)
                  throw new Error('Cannot parse until date:' + ttr.text);
              options.until = new Date(date);
          }
          else if (ttr.accept('for')) {
              options.count = parseInt(ttr.value[0], 10);
              ttr.expect('number');
              // ttr.expect('times')
          }
      }
  }

  var Frequency;
  (function (Frequency) {
      Frequency[Frequency["YEARLY"] = 0] = "YEARLY";
      Frequency[Frequency["MONTHLY"] = 1] = "MONTHLY";
      Frequency[Frequency["WEEKLY"] = 2] = "WEEKLY";
      Frequency[Frequency["DAILY"] = 3] = "DAILY";
      Frequency[Frequency["HOURLY"] = 4] = "HOURLY";
      Frequency[Frequency["MINUTELY"] = 5] = "MINUTELY";
      Frequency[Frequency["SECONDLY"] = 6] = "SECONDLY";
  })(Frequency || (Frequency = {}));
  function freqIsDailyOrGreater(freq) {
      return freq < Frequency.HOURLY;
  }

  /* !
   * rrule.js - Library for working with recurrence rules for calendar dates.
   * https://github.com/jakubroztocil/rrule
   *
   * Copyright 2010, Jakub Roztocil and Lars Schoning
   * Licenced under the BSD licence.
   * https://github.com/jakubroztocil/rrule/blob/master/LICENCE
   *
   */
  /**
   *
   * Implementation of RRule.fromText() and RRule::toText().
   *
   *
   * On the client side, this file needs to be included
   * when those functions are used.
   *
   */
  // =============================================================================
  // fromText
  // =============================================================================
  /**
   * Will be able to convert some of the below described rules from
   * text format to a rule object.
   *
   *
   * RULES
   *
   * Every ([n])
   * day(s)
   * | [weekday], ..., (and) [weekday]
   * | weekday(s)
   * | week(s)
   * | month(s)
   * | [month], ..., (and) [month]
   * | year(s)
   *
   *
   * Plus 0, 1, or multiple of these:
   *
   * on [weekday], ..., (or) [weekday] the [monthday], [monthday], ... (or) [monthday]
   *
   * on [weekday], ..., (and) [weekday]
   *
   * on the [monthday], [monthday], ... (and) [monthday] (day of the month)
   *
   * on the [nth-weekday], ..., (and) [nth-weekday] (of the month/year)
   *
   *
   * Plus 0 or 1 of these:
   *
   * for [n] time(s)
   *
   * until [date]
   *
   * Plus (.)
   *
   *
   * Definitely no supported for parsing:
   *
   * (for year):
   * in week(s) [n], ..., (and) [n]
   *
   * on the [yearday], ..., (and) [n] day of the year
   * on day [yearday], ..., (and) [n]
   *
   *
   * NON-TERMINALS
   *
   * [n]: 1, 2 ..., one, two, three ..
   * [month]: January, February, March, April, May, ... December
   * [weekday]: Monday, ... Sunday
   * [nth-weekday]: first [weekday], 2nd [weekday], ... last [weekday], ...
   * [monthday]: first, 1., 2., 1st, 2nd, second, ... 31st, last day, 2nd last day, ..
   * [date]:
   * - [month] (0-31(,) ([year])),
   * - (the) 0-31.(1-12.([year])),
   * - (the) 0-31/(1-12/([year])),
   * - [weekday]
   *
   * [year]: 0000, 0001, ... 01, 02, ..
   *
   * Definitely not supported for parsing:
   *
   * [yearday]: first, 1., 2., 1st, 2nd, second, ... 366th, last day, 2nd last day, ..
   *
   * @param {String} text
   * @return {Object, Boolean} the rule, or null.
   */
  var fromText = function (text, language) {
      if (language === void 0) { language = ENGLISH; }
      return new RRule(parseText(text, language) || undefined);
  };
  var common$1 = [
      'count',
      'until',
      'interval',
      'byweekday',
      'bymonthday',
      'bymonth',
  ];
  ToText.IMPLEMENTED = [];
  ToText.IMPLEMENTED[Frequency.HOURLY] = common$1;
  ToText.IMPLEMENTED[Frequency.MINUTELY] = common$1;
  ToText.IMPLEMENTED[Frequency.DAILY] = ['byhour'].concat(common$1);
  ToText.IMPLEMENTED[Frequency.WEEKLY] = common$1;
  ToText.IMPLEMENTED[Frequency.MONTHLY] = common$1;
  ToText.IMPLEMENTED[Frequency.YEARLY] = ['byweekno', 'byyearday'].concat(common$1);
  // =============================================================================
  // Export
  // =============================================================================
  var toText = function (rrule, gettext, language, dateFormatter) {
      return new ToText(rrule, gettext, language, dateFormatter).toString();
  };
  var isFullyConvertible = ToText.isFullyConvertible;

  var Time = /** @class */ (function () {
      function Time(hour, minute, second, millisecond) {
          this.hour = hour;
          this.minute = minute;
          this.second = second;
          this.millisecond = millisecond || 0;
      }
      Time.prototype.getHours = function () {
          return this.hour;
      };
      Time.prototype.getMinutes = function () {
          return this.minute;
      };
      Time.prototype.getSeconds = function () {
          return this.second;
      };
      Time.prototype.getMilliseconds = function () {
          return this.millisecond;
      };
      Time.prototype.getTime = function () {
          return ((this.hour * 60 * 60 + this.minute * 60 + this.second) * 1000 +
              this.millisecond);
      };
      return Time;
  }());
  var DateTime = /** @class */ (function (_super) {
      __extends(DateTime, _super);
      function DateTime(year, month, day, hour, minute, second, millisecond) {
          var _this = _super.call(this, hour, minute, second, millisecond) || this;
          _this.year = year;
          _this.month = month;
          _this.day = day;
          return _this;
      }
      DateTime.fromDate = function (date) {
          return new this(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.valueOf() % 1000);
      };
      DateTime.prototype.getWeekday = function () {
          return dateutil.getWeekday(new Date(this.getTime()));
      };
      DateTime.prototype.getTime = function () {
          return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond)).getTime();
      };
      DateTime.prototype.getDay = function () {
          return this.day;
      };
      DateTime.prototype.getMonth = function () {
          return this.month;
      };
      DateTime.prototype.getYear = function () {
          return this.year;
      };
      DateTime.prototype.addYears = function (years) {
          this.year += years;
      };
      DateTime.prototype.addMonths = function (months) {
          this.month += months;
          if (this.month > 12) {
              var yearDiv = Math.floor(this.month / 12);
              var monthMod = pymod(this.month, 12);
              this.month = monthMod;
              this.year += yearDiv;
              if (this.month === 0) {
                  this.month = 12;
                  --this.year;
              }
          }
      };
      DateTime.prototype.addWeekly = function (days, wkst) {
          if (wkst > this.getWeekday()) {
              this.day += -(this.getWeekday() + 1 + (6 - wkst)) + days * 7;
          }
          else {
              this.day += -(this.getWeekday() - wkst) + days * 7;
          }
          this.fixDay();
      };
      DateTime.prototype.addDaily = function (days) {
          this.day += days;
          this.fixDay();
      };
      DateTime.prototype.addHours = function (hours, filtered, byhour) {
          if (filtered) {
              // Jump to one iteration before next day
              this.hour += Math.floor((23 - this.hour) / hours) * hours;
          }
          for (;;) {
              this.hour += hours;
              var _a = divmod(this.hour, 24), dayDiv = _a.div, hourMod = _a.mod;
              if (dayDiv) {
                  this.hour = hourMod;
                  this.addDaily(dayDiv);
              }
              if (empty(byhour) || includes(byhour, this.hour))
                  break;
          }
      };
      DateTime.prototype.addMinutes = function (minutes, filtered, byhour, byminute) {
          if (filtered) {
              // Jump to one iteration before next day
              this.minute +=
                  Math.floor((1439 - (this.hour * 60 + this.minute)) / minutes) * minutes;
          }
          for (;;) {
              this.minute += minutes;
              var _a = divmod(this.minute, 60), hourDiv = _a.div, minuteMod = _a.mod;
              if (hourDiv) {
                  this.minute = minuteMod;
                  this.addHours(hourDiv, false, byhour);
              }
              if ((empty(byhour) || includes(byhour, this.hour)) &&
                  (empty(byminute) || includes(byminute, this.minute))) {
                  break;
              }
          }
      };
      DateTime.prototype.addSeconds = function (seconds, filtered, byhour, byminute, bysecond) {
          if (filtered) {
              // Jump to one iteration before next day
              this.second +=
                  Math.floor((86399 - (this.hour * 3600 + this.minute * 60 + this.second)) /
                      seconds) * seconds;
          }
          for (;;) {
              this.second += seconds;
              var _a = divmod(this.second, 60), minuteDiv = _a.div, secondMod = _a.mod;
              if (minuteDiv) {
                  this.second = secondMod;
                  this.addMinutes(minuteDiv, false, byhour, byminute);
              }
              if ((empty(byhour) || includes(byhour, this.hour)) &&
                  (empty(byminute) || includes(byminute, this.minute)) &&
                  (empty(bysecond) || includes(bysecond, this.second))) {
                  break;
              }
          }
      };
      DateTime.prototype.fixDay = function () {
          if (this.day <= 28) {
              return;
          }
          var daysinmonth = dateutil.monthRange(this.year, this.month - 1)[1];
          if (this.day <= daysinmonth) {
              return;
          }
          while (this.day > daysinmonth) {
              this.day -= daysinmonth;
              ++this.month;
              if (this.month === 13) {
                  this.month = 1;
                  ++this.year;
                  if (this.year > dateutil.MAXYEAR) {
                      return;
                  }
              }
              daysinmonth = dateutil.monthRange(this.year, this.month - 1)[1];
          }
      };
      DateTime.prototype.add = function (options, filtered) {
          var freq = options.freq, interval = options.interval, wkst = options.wkst, byhour = options.byhour, byminute = options.byminute, bysecond = options.bysecond;
          switch (freq) {
              case Frequency.YEARLY:
                  return this.addYears(interval);
              case Frequency.MONTHLY:
                  return this.addMonths(interval);
              case Frequency.WEEKLY:
                  return this.addWeekly(interval, wkst);
              case Frequency.DAILY:
                  return this.addDaily(interval);
              case Frequency.HOURLY:
                  return this.addHours(interval, filtered, byhour);
              case Frequency.MINUTELY:
                  return this.addMinutes(interval, filtered, byhour, byminute);
              case Frequency.SECONDLY:
                  return this.addSeconds(interval, filtered, byhour, byminute, bysecond);
          }
      };
      return DateTime;
  }(Time));

  function initializeOptions$1(options) {
      var invalid = [];
      var keys = Object.keys(options);
      // Shallow copy for options and origOptions and check for invalid
      for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
          var key = keys_1[_i];
          if (!includes(defaultKeys, key))
              invalid.push(key);
          if (dateutil$1.isDate(options[key]) && !dateutil$1.isValidDate(options[key])) {
              invalid.push(key);
          }
      }
      if (invalid.length) {
          throw new Error('Invalid options: ' + invalid.join(', '));
      }
      return __assign({}, options);
  }
  function parseOptions(options) {
      var opts = __assign(__assign({}, DEFAULT_OPTIONS$1), initializeOptions$1(options));
      if (isPresent(opts.byeaster))
          opts.freq = RRule.YEARLY;
      if (!(isPresent(opts.freq) && RRule.FREQUENCIES[opts.freq])) {
          throw new Error("Invalid frequency: ".concat(opts.freq, " ").concat(options.freq));
      }
      if (!opts.dtstart)
          opts.dtstart = new Date(new Date().setMilliseconds(0));
      if (!isPresent(opts.wkst)) {
          opts.wkst = RRule.MO.weekday;
      }
      else if (isNumber(opts.wkst)) ;
      else {
          opts.wkst = opts.wkst.weekday;
      }
      if (isPresent(opts.bysetpos)) {
          if (isNumber(opts.bysetpos))
              opts.bysetpos = [opts.bysetpos];
          for (var i = 0; i < opts.bysetpos.length; i++) {
              var v = opts.bysetpos[i];
              if (v === 0 || !(v >= -366 && v <= 366)) {
                  throw new Error('bysetpos must be between 1 and 366,' + ' or between -366 and -1');
              }
          }
      }
      if (!(Boolean(opts.byweekno) ||
          notEmpty(opts.byweekno) ||
          notEmpty(opts.byyearday) ||
          Boolean(opts.bymonthday) ||
          notEmpty(opts.bymonthday) ||
          isPresent(opts.byweekday) ||
          isPresent(opts.byeaster))) {
          switch (opts.freq) {
              case RRule.YEARLY:
                  if (!opts.bymonth)
                      opts.bymonth = opts.dtstart.getUTCMonth() + 1;
                  opts.bymonthday = opts.dtstart.getUTCDate();
                  break;
              case RRule.MONTHLY:
                  opts.bymonthday = opts.dtstart.getUTCDate();
                  break;
              case RRule.WEEKLY:
                  opts.byweekday = [dateutil$1.getWeekday(opts.dtstart)];
                  break;
          }
      }
      // bymonth
      if (isPresent(opts.bymonth) && !isArray(opts.bymonth)) {
          opts.bymonth = [opts.bymonth];
      }
      // byyearday
      if (isPresent(opts.byyearday) &&
          !isArray(opts.byyearday) &&
          isNumber(opts.byyearday)) {
          opts.byyearday = [opts.byyearday];
      }
      // bymonthday
      if (!isPresent(opts.bymonthday)) {
          opts.bymonthday = [];
          opts.bynmonthday = [];
      }
      else if (isArray(opts.bymonthday)) {
          var bymonthday = [];
          var bynmonthday = [];
          for (var i = 0; i < opts.bymonthday.length; i++) {
              var v = opts.bymonthday[i];
              if (v > 0) {
                  bymonthday.push(v);
              }
              else if (v < 0) {
                  bynmonthday.push(v);
              }
          }
          opts.bymonthday = bymonthday;
          opts.bynmonthday = bynmonthday;
      }
      else if (opts.bymonthday < 0) {
          opts.bynmonthday = [opts.bymonthday];
          opts.bymonthday = [];
      }
      else {
          opts.bynmonthday = [];
          opts.bymonthday = [opts.bymonthday];
      }
      // byweekno
      if (isPresent(opts.byweekno) && !isArray(opts.byweekno)) {
          opts.byweekno = [opts.byweekno];
      }
      // byweekday / bynweekday
      if (!isPresent(opts.byweekday)) {
          opts.bynweekday = null;
      }
      else if (isNumber(opts.byweekday)) {
          opts.byweekday = [opts.byweekday];
          opts.bynweekday = null;
      }
      else if (isWeekdayStr(opts.byweekday)) {
          opts.byweekday = [Weekday.fromStr(opts.byweekday).weekday];
          opts.bynweekday = null;
      }
      else if (opts.byweekday instanceof Weekday) {
          if (!opts.byweekday.n || opts.freq > RRule.MONTHLY) {
              opts.byweekday = [opts.byweekday.weekday];
              opts.bynweekday = null;
          }
          else {
              opts.bynweekday = [[opts.byweekday.weekday, opts.byweekday.n]];
              opts.byweekday = null;
          }
      }
      else {
          var byweekday = [];
          var bynweekday = [];
          for (var i = 0; i < opts.byweekday.length; i++) {
              var wday = opts.byweekday[i];
              if (isNumber(wday)) {
                  byweekday.push(wday);
                  continue;
              }
              else if (isWeekdayStr(wday)) {
                  byweekday.push(Weekday.fromStr(wday).weekday);
                  continue;
              }
              if (!wday.n || opts.freq > RRule.MONTHLY) {
                  byweekday.push(wday.weekday);
              }
              else {
                  bynweekday.push([wday.weekday, wday.n]);
              }
          }
          opts.byweekday = notEmpty(byweekday) ? byweekday : null;
          opts.bynweekday = notEmpty(bynweekday) ? bynweekday : null;
      }
      // byhour
      if (!isPresent(opts.byhour)) {
          opts.byhour = opts.freq < RRule.HOURLY ? [opts.dtstart.getUTCHours()] : null;
      }
      else if (isNumber(opts.byhour)) {
          opts.byhour = [opts.byhour];
      }
      // byminute
      if (!isPresent(opts.byminute)) {
          opts.byminute =
              opts.freq < RRule.MINUTELY ? [opts.dtstart.getUTCMinutes()] : null;
      }
      else if (isNumber(opts.byminute)) {
          opts.byminute = [opts.byminute];
      }
      // bysecond
      if (!isPresent(opts.bysecond)) {
          opts.bysecond =
              opts.freq < RRule.SECONDLY ? [opts.dtstart.getUTCSeconds()] : null;
      }
      else if (isNumber(opts.bysecond)) {
          opts.bysecond = [opts.bysecond];
      }
      return { parsedOptions: opts };
  }
  function buildTimeset(opts) {
      var millisecondModulo = opts.dtstart.getTime() % 1000;
      if (!freqIsDailyOrGreater(opts.freq)) {
          return [];
      }
      var timeset = [];
      opts.byhour.forEach(function (hour) {
          opts.byminute.forEach(function (minute) {
              opts.bysecond.forEach(function (second) {
                  timeset.push(new Time(hour, minute, second, millisecondModulo));
              });
          });
      });
      return timeset;
  }

  function parseString(rfcString) {
      var options = rfcString
          .split('\n')
          .map(parseLine)
          .filter(function (x) { return x !== null; });
      return __assign(__assign({}, options[0]), options[1]);
  }
  function parseDtstart(line) {
      var options = {};
      var dtstartWithZone = /DTSTART(?:;TZID=([^:=]+?))?(?::|=)([^;\s]+)/i.exec(line);
      if (!dtstartWithZone) {
          return options;
      }
      var tzid = dtstartWithZone[1], dtstart = dtstartWithZone[2];
      if (tzid) {
          options.tzid = tzid;
      }
      options.dtstart = dateutil$1.untilStringToDate(dtstart);
      return options;
  }
  function parseLine(rfcString) {
      rfcString = rfcString.replace(/^\s+|\s+$/, '');
      if (!rfcString.length)
          return null;
      var header = /^([A-Z]+?)[:;]/.exec(rfcString.toUpperCase());
      if (!header) {
          return parseRrule(rfcString);
      }
      var key = header[1];
      switch (key.toUpperCase()) {
          case 'RRULE':
          case 'EXRULE':
              return parseRrule(rfcString);
          case 'DTSTART':
              return parseDtstart(rfcString);
          default:
              throw new Error("Unsupported RFC prop ".concat(key, " in ").concat(rfcString));
      }
  }
  function parseRrule(line) {
      var strippedLine = line.replace(/^RRULE:/i, '');
      var options = parseDtstart(strippedLine);
      var attrs = line.replace(/^(?:RRULE|EXRULE):/i, '').split(';');
      attrs.forEach(function (attr) {
          var _a = attr.split('='), key = _a[0], value = _a[1];
          switch (key.toUpperCase()) {
              case 'FREQ':
                  options.freq = Frequency[value.toUpperCase()];
                  break;
              case 'WKST':
                  options.wkst = Days[value.toUpperCase()];
                  break;
              case 'COUNT':
              case 'INTERVAL':
              case 'BYSETPOS':
              case 'BYMONTH':
              case 'BYMONTHDAY':
              case 'BYYEARDAY':
              case 'BYWEEKNO':
              case 'BYHOUR':
              case 'BYMINUTE':
              case 'BYSECOND':
                  var num = parseNumber(value);
                  var optionKey = key.toLowerCase();
                  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                  // @ts-ignore
                  options[optionKey] = num;
                  break;
              case 'BYWEEKDAY':
              case 'BYDAY':
                  options.byweekday = parseWeekday(value);
                  break;
              case 'DTSTART':
              case 'TZID':
                  // for backwards compatibility
                  var dtstart = parseDtstart(line);
                  options.tzid = dtstart.tzid;
                  options.dtstart = dtstart.dtstart;
                  break;
              case 'UNTIL':
                  options.until = dateutil$1.untilStringToDate(value);
                  break;
              case 'BYEASTER':
                  options.byeaster = Number(value);
                  break;
              default:
                  throw new Error("Unknown RRULE property '" + key + "'");
          }
      });
      return options;
  }
  function parseNumber(value) {
      if (value.indexOf(',') !== -1) {
          var values = value.split(',');
          return values.map(parseIndividualNumber);
      }
      return parseIndividualNumber(value);
  }
  function parseIndividualNumber(value) {
      if (/^[+-]?\d+$/.test(value)) {
          return Number(value);
      }
      return value;
  }
  function parseWeekday(value) {
      var days = value.split(',');
      return days.map(function (day) {
          if (day.length === 2) {
              // MO, TU, ...
              return Days[day]; // wday instanceof Weekday
          }
          // -1MO, +3FR, 1SO, 13TU ...
          var parts = day.match(/^([+-]?\d{1,2})([A-Z]{2})$/);
          if (!parts || parts.length < 3) {
              throw new SyntaxError("Invalid weekday string: ".concat(day));
          }
          var n = Number(parts[1]);
          var wdaypart = parts[2];
          var wday = Days[wdaypart].weekday;
          return new Weekday(wday, n);
      });
  }

  var DateWithZone = /** @class */ (function () {
      function DateWithZone(date, tzid) {
          if (isNaN(date.getTime())) {
              throw new RangeError('Invalid date passed to DateWithZone');
          }
          this.date = date;
          this.tzid = tzid;
      }
      Object.defineProperty(DateWithZone.prototype, "isUTC", {
          get: function () {
              return !this.tzid || this.tzid.toUpperCase() === 'UTC';
          },
          enumerable: false,
          configurable: true
      });
      DateWithZone.prototype.toString = function () {
          var datestr = dateutil$1.timeToUntilString(this.date.getTime(), this.isUTC);
          if (!this.isUTC) {
              return ";TZID=".concat(this.tzid, ":").concat(datestr);
          }
          return ":".concat(datestr);
      };
      DateWithZone.prototype.getTime = function () {
          return this.date.getTime();
      };
      DateWithZone.prototype.rezonedDate = function () {
          var _a;
          if (this.isUTC) {
              return this.date;
          }
          var localTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
          var dateInLocalTZ = new Date(this.date.toLocaleString(undefined, { timeZone: localTimeZone }));
          var dateInTargetTZ = new Date(this.date.toLocaleString(undefined, { timeZone: (_a = this.tzid) !== null && _a !== void 0 ? _a : 'UTC' }));
          var tzOffset = dateInTargetTZ.getTime() - dateInLocalTZ.getTime();
          return new Date(this.date.getTime() - tzOffset);
      };
      return DateWithZone;
  }());

  function optionsToString(options) {
      var rrule = [];
      var dtstart = '';
      var keys = Object.keys(options);
      var defaultKeys = Object.keys(DEFAULT_OPTIONS$1);
      for (var i = 0; i < keys.length; i++) {
          if (keys[i] === 'tzid')
              continue;
          if (!includes(defaultKeys, keys[i]))
              continue;
          var key = keys[i].toUpperCase();
          var value = options[keys[i]];
          var outValue = '';
          if (!isPresent(value) || (isArray(value) && !value.length))
              continue;
          switch (key) {
              case 'FREQ':
                  outValue = RRule.FREQUENCIES[options.freq];
                  break;
              case 'WKST':
                  if (isNumber(value)) {
                      outValue = new Weekday(value).toString();
                  }
                  else {
                      outValue = value.toString();
                  }
                  break;
              case 'BYWEEKDAY':
                  /*
                    NOTE: BYWEEKDAY is a special case.
                    RRule() deconstructs the rule.options.byweekday array
                    into an array of Weekday arguments.
                    On the other hand, rule.origOptions is an array of Weekdays.
                    We need to handle both cases here.
                    It might be worth change RRule to keep the Weekdays.
          
                    Also, BYWEEKDAY (used by RRule) vs. BYDAY (RFC)
          
                    */
                  key = 'BYDAY';
                  outValue = toArray(value)
                      .map(function (wday) {
                      if (wday instanceof Weekday) {
                          return wday;
                      }
                      if (isArray(wday)) {
                          return new Weekday(wday[0], wday[1]);
                      }
                      return new Weekday(wday);
                  })
                      .toString();
                  break;
              case 'DTSTART':
                  dtstart = buildDtstart(value, options.tzid);
                  break;
              case 'UNTIL':
                  outValue = dateutil$1.timeToUntilString(value, !options.tzid);
                  break;
              default:
                  if (isArray(value)) {
                      var strValues = [];
                      for (var j = 0; j < value.length; j++) {
                          strValues[j] = String(value[j]);
                      }
                      outValue = strValues.toString();
                  }
                  else {
                      outValue = String(value);
                  }
          }
          if (outValue) {
              rrule.push([key, outValue]);
          }
      }
      var rules = rrule
          .map(function (_a) {
          var key = _a[0], value = _a[1];
          return "".concat(key, "=").concat(value.toString());
      })
          .join(';');
      var ruleString = '';
      if (rules !== '') {
          ruleString = "RRULE:".concat(rules);
      }
      return [dtstart, ruleString].filter(function (x) { return !!x; }).join('\n');
  }
  function buildDtstart(dtstart, tzid) {
      if (!dtstart) {
          return '';
      }
      return 'DTSTART' + new DateWithZone(new Date(dtstart), tzid).toString();
  }

  function argsMatch(left, right) {
      if (Array.isArray(left)) {
          if (!Array.isArray(right))
              return false;
          if (left.length !== right.length)
              return false;
          return left.every(function (date, i) { return date.getTime() === right[i].getTime(); });
      }
      if (left instanceof Date) {
          return right instanceof Date && left.getTime() === right.getTime();
      }
      return left === right;
  }
  var Cache = /** @class */ (function () {
      function Cache() {
          this.all = false;
          this.before = [];
          this.after = [];
          this.between = [];
      }
      /**
       * @param {String} what - all/before/after/between
       * @param {Array,Date} value - an array of dates, one date, or null
       * @param {Object?} args - _iter arguments
       */
      Cache.prototype._cacheAdd = function (what, value, args) {
          if (value) {
              value =
                  value instanceof Date
                      ? dateutil$1.clone(value)
                      : dateutil$1.cloneDates(value);
          }
          if (what === 'all') {
              this.all = value;
          }
          else {
              args._value = value;
              this[what].push(args);
          }
      };
      /**
       * @return false - not in the cache
       * @return null  - cached, but zero occurrences (before/after)
       * @return Date  - cached (before/after)
       * @return []    - cached, but zero occurrences (all/between)
       * @return [Date1, DateN] - cached (all/between)
       */
      Cache.prototype._cacheGet = function (what, args) {
          var cached = false;
          var argsKeys = args ? Object.keys(args) : [];
          var findCacheDiff = function (item) {
              for (var i = 0; i < argsKeys.length; i++) {
                  var key = argsKeys[i];
                  if (!argsMatch(args[key], item[key])) {
                      return true;
                  }
              }
              return false;
          };
          var cachedObject = this[what];
          if (what === 'all') {
              cached = this.all;
          }
          else if (isArray(cachedObject)) {
              // Let's see whether we've already called the
              // 'what' method with the same 'args'
              for (var i = 0; i < cachedObject.length; i++) {
                  var item = cachedObject[i];
                  if (argsKeys.length && findCacheDiff(item))
                      continue;
                  cached = item._value;
                  break;
              }
          }
          if (!cached && this.all) {
              // Not in the cache, but we already know all the occurrences,
              // so we can find the correct dates from the cached ones.
              var iterResult = new IterResult(what, args);
              for (var i = 0; i < this.all.length; i++) {
                  if (!iterResult.accept(this.all[i]))
                      break;
              }
              cached = iterResult.getValue();
              this._cacheAdd(what, cached, args);
          }
          return isArray(cached)
              ? dateutil$1.cloneDates(cached)
              : cached instanceof Date
                  ? dateutil$1.clone(cached)
                  : cached;
      };
      return Cache;
  }());

  // =============================================================================
  // Date masks
  // =============================================================================
  // Every mask is 7 days longer to handle cross-year weekly periods.
  var M365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], repeat(1, 31), true), repeat(2, 28), true), repeat(3, 31), true), repeat(4, 30), true), repeat(5, 31), true), repeat(6, 30), true), repeat(7, 31), true), repeat(8, 31), true), repeat(9, 30), true), repeat(10, 31), true), repeat(11, 30), true), repeat(12, 31), true), repeat(1, 7), true);
  var M366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], repeat(1, 31), true), repeat(2, 29), true), repeat(3, 31), true), repeat(4, 30), true), repeat(5, 31), true), repeat(6, 30), true), repeat(7, 31), true), repeat(8, 31), true), repeat(9, 30), true), repeat(10, 31), true), repeat(11, 30), true), repeat(12, 31), true), repeat(1, 7), true);
  var M28 = range(1, 29);
  var M29 = range(1, 30);
  var M30 = range(1, 31);
  var M31 = range(1, 32);
  var MDAY366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], M31, true), M29, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31.slice(0, 7), true);
  var MDAY365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], M31, true), M28, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31.slice(0, 7), true);
  var NM28 = range(-28, 0);
  var NM29 = range(-29, 0);
  var NM30 = range(-30, 0);
  var NM31 = range(-31, 0);
  var NMDAY366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], NM31, true), NM29, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31.slice(0, 7), true);
  var NMDAY365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], NM31, true), NM28, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31.slice(0, 7), true);
  var M366RANGE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366];
  var M365RANGE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];
  var WDAYMASK = (function () {
      var wdaymask = [];
      for (var i = 0; i < 55; i++)
          wdaymask = wdaymask.concat(range(7));
      return wdaymask;
  })();

  function rebuildYear(year, options) {
      var firstyday = new Date(Date.UTC(year, 0, 1));
      var yearlen = dateutil$1.isLeapYear(year) ? 366 : 365;
      var nextyearlen = dateutil$1.isLeapYear(year + 1) ? 366 : 365;
      var yearordinal = dateutil$1.toOrdinal(firstyday);
      var yearweekday = dateutil$1.getWeekday(firstyday);
      var result = __assign(__assign({ yearlen: yearlen, nextyearlen: nextyearlen, yearordinal: yearordinal, yearweekday: yearweekday }, baseYearMasks(year)), { wnomask: null });
      if (empty(options.byweekno)) {
          return result;
      }
      result.wnomask = repeat(0, yearlen + 7);
      var firstwkst;
      var wyearlen;
      var no1wkst = (firstwkst = pymod(7 - yearweekday + options.wkst, 7));
      if (no1wkst >= 4) {
          no1wkst = 0;
          // Number of days in the year, plus the days we got
          // from last year.
          wyearlen = result.yearlen + pymod(yearweekday - options.wkst, 7);
      }
      else {
          // Number of days in the year, minus the days we
          // left in last year.
          wyearlen = yearlen - no1wkst;
      }
      var div = Math.floor(wyearlen / 7);
      var mod = pymod(wyearlen, 7);
      var numweeks = Math.floor(div + mod / 4);
      for (var j = 0; j < options.byweekno.length; j++) {
          var n = options.byweekno[j];
          if (n < 0) {
              n += numweeks + 1;
          }
          if (!(n > 0 && n <= numweeks)) {
              continue;
          }
          var i = void 0;
          if (n > 1) {
              i = no1wkst + (n - 1) * 7;
              if (no1wkst !== firstwkst) {
                  i -= 7 - firstwkst;
              }
          }
          else {
              i = no1wkst;
          }
          for (var k = 0; k < 7; k++) {
              result.wnomask[i] = 1;
              i++;
              if (result.wdaymask[i] === options.wkst)
                  break;
          }
      }
      if (includes(options.byweekno, 1)) {
          // Check week number 1 of next year as well
          // orig-TODO : Check -numweeks for next year.
          var i = no1wkst + numweeks * 7;
          if (no1wkst !== firstwkst)
              i -= 7 - firstwkst;
          if (i < yearlen) {
              // If week starts in next year, we
              // don't care about it.
              for (var j = 0; j < 7; j++) {
                  result.wnomask[i] = 1;
                  i += 1;
                  if (result.wdaymask[i] === options.wkst)
                      break;
              }
          }
      }
      if (no1wkst) {
          // Check last week number of last year as
          // well. If no1wkst is 0, either the year
          // started on week start, or week number 1
          // got days from last year, so there are no
          // days from last year's last week number in
          // this year.
          var lnumweeks = void 0;
          if (!includes(options.byweekno, -1)) {
              var lyearweekday = dateutil$1.getWeekday(new Date(Date.UTC(year - 1, 0, 1)));
              var lno1wkst = pymod(7 - lyearweekday.valueOf() + options.wkst, 7);
              var lyearlen = dateutil$1.isLeapYear(year - 1) ? 366 : 365;
              var weekst = void 0;
              if (lno1wkst >= 4) {
                  lno1wkst = 0;
                  weekst = lyearlen + pymod(lyearweekday - options.wkst, 7);
              }
              else {
                  weekst = yearlen - no1wkst;
              }
              lnumweeks = Math.floor(52 + pymod(weekst, 7) / 4);
          }
          else {
              lnumweeks = -1;
          }
          if (includes(options.byweekno, lnumweeks)) {
              for (var i = 0; i < no1wkst; i++)
                  result.wnomask[i] = 1;
          }
      }
      return result;
  }
  function baseYearMasks(year) {
      var yearlen = dateutil$1.isLeapYear(year) ? 366 : 365;
      var firstyday = new Date(Date.UTC(year, 0, 1));
      var wday = dateutil$1.getWeekday(firstyday);
      if (yearlen === 365) {
          return {
              mmask: M365MASK,
              mdaymask: MDAY365MASK,
              nmdaymask: NMDAY365MASK,
              wdaymask: WDAYMASK.slice(wday),
              mrange: M365RANGE,
          };
      }
      return {
          mmask: M366MASK,
          mdaymask: MDAY366MASK,
          nmdaymask: NMDAY366MASK,
          wdaymask: WDAYMASK.slice(wday),
          mrange: M366RANGE,
      };
  }

  function rebuildMonth(year, month, yearlen, mrange, wdaymask, options) {
      var result = {
          lastyear: year,
          lastmonth: month,
          nwdaymask: [],
      };
      var ranges = [];
      if (options.freq === RRule.YEARLY) {
          if (empty(options.bymonth)) {
              ranges = [[0, yearlen]];
          }
          else {
              for (var j = 0; j < options.bymonth.length; j++) {
                  month = options.bymonth[j];
                  ranges.push(mrange.slice(month - 1, month + 1));
              }
          }
      }
      else if (options.freq === RRule.MONTHLY) {
          ranges = [mrange.slice(month - 1, month + 1)];
      }
      if (empty(ranges)) {
          return result;
      }
      // Weekly frequency won't get here, so we may not
      // care about cross-year weekly periods.
      result.nwdaymask = repeat(0, yearlen);
      for (var j = 0; j < ranges.length; j++) {
          var rang = ranges[j];
          var first = rang[0];
          var last = rang[1] - 1;
          for (var k = 0; k < options.bynweekday.length; k++) {
              var i = void 0;
              var _a = options.bynweekday[k], wday = _a[0], n = _a[1];
              if (n < 0) {
                  i = last + (n + 1) * 7;
                  i -= pymod(wdaymask[i] - wday, 7);
              }
              else {
                  i = first + (n - 1) * 7;
                  i += pymod(7 - wdaymask[i] + wday, 7);
              }
              if (first <= i && i <= last)
                  result.nwdaymask[i] = 1;
          }
      }
      return result;
  }

  function easter(y, offset) {
      if (offset === void 0) { offset = 0; }
      var a = y % 19;
      var b = Math.floor(y / 100);
      var c = y % 100;
      var d = Math.floor(b / 4);
      var e = b % 4;
      var f = Math.floor((b + 8) / 25);
      var g = Math.floor((b - f + 1) / 3);
      var h = Math.floor(19 * a + b - d - g + 15) % 30;
      var i = Math.floor(c / 4);
      var k = c % 4;
      var l = Math.floor(32 + 2 * e + 2 * i - h - k) % 7;
      var m = Math.floor((a + 11 * h + 22 * l) / 451);
      var month = Math.floor((h + l - 7 * m + 114) / 31);
      var day = ((h + l - 7 * m + 114) % 31) + 1;
      var date = Date.UTC(y, month - 1, day + offset);
      var yearStart = Date.UTC(y, 0, 1);
      return [Math.ceil((date - yearStart) / (1000 * 60 * 60 * 24))];
  }

  // =============================================================================
  // Iterinfo
  // =============================================================================
  var Iterinfo = /** @class */ (function () {
      // eslint-disable-next-line no-empty-function
      function Iterinfo(options) {
          this.options = options;
      }
      Iterinfo.prototype.rebuild = function (year, month) {
          var options = this.options;
          if (year !== this.lastyear) {
              this.yearinfo = rebuildYear(year, options);
          }
          if (notEmpty(options.bynweekday) &&
              (month !== this.lastmonth || year !== this.lastyear)) {
              var _a = this.yearinfo, yearlen = _a.yearlen, mrange = _a.mrange, wdaymask = _a.wdaymask;
              this.monthinfo = rebuildMonth(year, month, yearlen, mrange, wdaymask, options);
          }
          if (isPresent(options.byeaster)) {
              this.eastermask = easter(year, options.byeaster);
          }
      };
      Object.defineProperty(Iterinfo.prototype, "lastyear", {
          get: function () {
              return this.monthinfo ? this.monthinfo.lastyear : null;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Iterinfo.prototype, "lastmonth", {
          get: function () {
              return this.monthinfo ? this.monthinfo.lastmonth : null;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Iterinfo.prototype, "yearlen", {
          get: function () {
              return this.yearinfo.yearlen;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Iterinfo.prototype, "yearordinal", {
          get: function () {
              return this.yearinfo.yearordinal;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Iterinfo.prototype, "mrange", {
          get: function () {
              return this.yearinfo.mrange;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Iterinfo.prototype, "wdaymask", {
          get: function () {
              return this.yearinfo.wdaymask;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Iterinfo.prototype, "mmask", {
          get: function () {
              return this.yearinfo.mmask;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Iterinfo.prototype, "wnomask", {
          get: function () {
              return this.yearinfo.wnomask;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Iterinfo.prototype, "nwdaymask", {
          get: function () {
              return this.monthinfo ? this.monthinfo.nwdaymask : [];
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Iterinfo.prototype, "nextyearlen", {
          get: function () {
              return this.yearinfo.nextyearlen;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Iterinfo.prototype, "mdaymask", {
          get: function () {
              return this.yearinfo.mdaymask;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Iterinfo.prototype, "nmdaymask", {
          get: function () {
              return this.yearinfo.nmdaymask;
          },
          enumerable: false,
          configurable: true
      });
      Iterinfo.prototype.ydayset = function () {
          return [range(this.yearlen), 0, this.yearlen];
      };
      Iterinfo.prototype.mdayset = function (_, month) {
          var start = this.mrange[month - 1];
          var end = this.mrange[month];
          var set = repeat(null, this.yearlen);
          for (var i = start; i < end; i++)
              set[i] = i;
          return [set, start, end];
      };
      Iterinfo.prototype.wdayset = function (year, month, day) {
          // We need to handle cross-year weeks here.
          var set = repeat(null, this.yearlen + 7);
          var i = dateutil$1.toOrdinal(new Date(Date.UTC(year, month - 1, day))) -
              this.yearordinal;
          var start = i;
          for (var j = 0; j < 7; j++) {
              set[i] = i;
              ++i;
              if (this.wdaymask[i] === this.options.wkst)
                  break;
          }
          return [set, start, i];
      };
      Iterinfo.prototype.ddayset = function (year, month, day) {
          var set = repeat(null, this.yearlen);
          var i = dateutil$1.toOrdinal(new Date(Date.UTC(year, month - 1, day))) -
              this.yearordinal;
          set[i] = i;
          return [set, i, i + 1];
      };
      Iterinfo.prototype.htimeset = function (hour, _, second, millisecond) {
          var _this = this;
          var set = [];
          this.options.byminute.forEach(function (minute) {
              set = set.concat(_this.mtimeset(hour, minute, second, millisecond));
          });
          dateutil$1.sort(set);
          return set;
      };
      Iterinfo.prototype.mtimeset = function (hour, minute, _, millisecond) {
          var set = this.options.bysecond.map(function (second) { return new Time(hour, minute, second, millisecond); });
          dateutil$1.sort(set);
          return set;
      };
      Iterinfo.prototype.stimeset = function (hour, minute, second, millisecond) {
          return [new Time(hour, minute, second, millisecond)];
      };
      Iterinfo.prototype.getdayset = function (freq) {
          switch (freq) {
              case Frequency.YEARLY:
                  return this.ydayset.bind(this);
              case Frequency.MONTHLY:
                  return this.mdayset.bind(this);
              case Frequency.WEEKLY:
                  return this.wdayset.bind(this);
              case Frequency.DAILY:
                  return this.ddayset.bind(this);
              default:
                  return this.ddayset.bind(this);
          }
      };
      Iterinfo.prototype.gettimeset = function (freq) {
          switch (freq) {
              case Frequency.HOURLY:
                  return this.htimeset.bind(this);
              case Frequency.MINUTELY:
                  return this.mtimeset.bind(this);
              case Frequency.SECONDLY:
                  return this.stimeset.bind(this);
          }
      };
      return Iterinfo;
  }());

  function buildPoslist(bysetpos, timeset, start, end, ii, dayset) {
      var poslist = [];
      for (var j = 0; j < bysetpos.length; j++) {
          var daypos = void 0;
          var timepos = void 0;
          var pos = bysetpos[j];
          if (pos < 0) {
              daypos = Math.floor(pos / timeset.length);
              timepos = pymod(pos, timeset.length);
          }
          else {
              daypos = Math.floor((pos - 1) / timeset.length);
              timepos = pymod(pos - 1, timeset.length);
          }
          var tmp = [];
          for (var k = start; k < end; k++) {
              var val = dayset[k];
              if (!isPresent(val))
                  continue;
              tmp.push(val);
          }
          var i = void 0;
          if (daypos < 0) {
              i = tmp.slice(daypos)[0];
          }
          else {
              i = tmp[daypos];
          }
          var time = timeset[timepos];
          var date = dateutil$1.fromOrdinal(ii.yearordinal + i);
          var res = dateutil$1.combine(date, time);
          // XXX: can this ever be in the array?
          // - compare the actual date instead?
          if (!includes(poslist, res))
              poslist.push(res);
      }
      dateutil$1.sort(poslist);
      return poslist;
  }

  function iter(iterResult, options) {
      var dtstart = options.dtstart, freq = options.freq, interval = options.interval, until = options.until, bysetpos = options.bysetpos;
      var count = options.count;
      if (count === 0 || interval === 0) {
          return emitResult(iterResult);
      }
      var counterDate = DateTime.fromDate(dtstart);
      var ii = new Iterinfo(options);
      ii.rebuild(counterDate.year, counterDate.month);
      var timeset = makeTimeset(ii, counterDate, options);
      for (;;) {
          var _a = ii.getdayset(freq)(counterDate.year, counterDate.month, counterDate.day), dayset = _a[0], start = _a[1], end = _a[2];
          var filtered = removeFilteredDays(dayset, start, end, ii, options);
          if (notEmpty(bysetpos)) {
              var poslist = buildPoslist(bysetpos, timeset, start, end, ii, dayset);
              for (var j = 0; j < poslist.length; j++) {
                  var res = poslist[j];
                  if (until && res > until) {
                      return emitResult(iterResult);
                  }
                  if (res >= dtstart) {
                      var rezonedDate = rezoneIfNeeded(res, options);
                      if (!iterResult.accept(rezonedDate)) {
                          return emitResult(iterResult);
                      }
                      if (count) {
                          --count;
                          if (!count) {
                              return emitResult(iterResult);
                          }
                      }
                  }
              }
          }
          else {
              for (var j = start; j < end; j++) {
                  var currentDay = dayset[j];
                  if (!isPresent(currentDay)) {
                      continue;
                  }
                  var date = dateutil$1.fromOrdinal(ii.yearordinal + currentDay);
                  for (var k = 0; k < timeset.length; k++) {
                      var time = timeset[k];
                      var res = dateutil$1.combine(date, time);
                      if (until && res > until) {
                          return emitResult(iterResult);
                      }
                      if (res >= dtstart) {
                          var rezonedDate = rezoneIfNeeded(res, options);
                          if (!iterResult.accept(rezonedDate)) {
                              return emitResult(iterResult);
                          }
                          if (count) {
                              --count;
                              if (!count) {
                                  return emitResult(iterResult);
                              }
                          }
                      }
                  }
              }
          }
          if (options.interval === 0) {
              return emitResult(iterResult);
          }
          // Handle frequency and interval
          counterDate.add(options, filtered);
          if (counterDate.year > dateutil$1.MAXYEAR) {
              return emitResult(iterResult);
          }
          if (!freqIsDailyOrGreater(freq)) {
              timeset = ii.gettimeset(freq)(counterDate.hour, counterDate.minute, counterDate.second, 0);
          }
          ii.rebuild(counterDate.year, counterDate.month);
      }
  }
  function isFiltered(ii, currentDay, options) {
      var bymonth = options.bymonth, byweekno = options.byweekno, byweekday = options.byweekday, byeaster = options.byeaster, bymonthday = options.bymonthday, bynmonthday = options.bynmonthday, byyearday = options.byyearday;
      return ((notEmpty(bymonth) && !includes(bymonth, ii.mmask[currentDay])) ||
          (notEmpty(byweekno) && !ii.wnomask[currentDay]) ||
          (notEmpty(byweekday) && !includes(byweekday, ii.wdaymask[currentDay])) ||
          (notEmpty(ii.nwdaymask) && !ii.nwdaymask[currentDay]) ||
          (byeaster !== null && !includes(ii.eastermask, currentDay)) ||
          ((notEmpty(bymonthday) || notEmpty(bynmonthday)) &&
              !includes(bymonthday, ii.mdaymask[currentDay]) &&
              !includes(bynmonthday, ii.nmdaymask[currentDay])) ||
          (notEmpty(byyearday) &&
              ((currentDay < ii.yearlen &&
                  !includes(byyearday, currentDay + 1) &&
                  !includes(byyearday, -ii.yearlen + currentDay)) ||
                  (currentDay >= ii.yearlen &&
                      !includes(byyearday, currentDay + 1 - ii.yearlen) &&
                      !includes(byyearday, -ii.nextyearlen + currentDay - ii.yearlen)))));
  }
  function rezoneIfNeeded(date, options) {
      return new DateWithZone(date, options.tzid).rezonedDate();
  }
  function emitResult(iterResult) {
      return iterResult.getValue();
  }
  function removeFilteredDays(dayset, start, end, ii, options) {
      var filtered = false;
      for (var dayCounter = start; dayCounter < end; dayCounter++) {
          var currentDay = dayset[dayCounter];
          filtered = isFiltered(ii, currentDay, options);
          if (filtered)
              dayset[currentDay] = null;
      }
      return filtered;
  }
  function makeTimeset(ii, counterDate, options) {
      var freq = options.freq, byhour = options.byhour, byminute = options.byminute, bysecond = options.bysecond;
      if (freqIsDailyOrGreater(freq)) {
          return buildTimeset(options);
      }
      if ((freq >= RRule.HOURLY &&
          notEmpty(byhour) &&
          !includes(byhour, counterDate.hour)) ||
          (freq >= RRule.MINUTELY &&
              notEmpty(byminute) &&
              !includes(byminute, counterDate.minute)) ||
          (freq >= RRule.SECONDLY &&
              notEmpty(bysecond) &&
              !includes(bysecond, counterDate.second))) {
          return [];
      }
      return ii.gettimeset(freq)(counterDate.hour, counterDate.minute, counterDate.second, counterDate.millisecond);
  }

  // =============================================================================
  // RRule
  // =============================================================================
  var Days = {
      MO: new Weekday(0),
      TU: new Weekday(1),
      WE: new Weekday(2),
      TH: new Weekday(3),
      FR: new Weekday(4),
      SA: new Weekday(5),
      SU: new Weekday(6),
  };
  var DEFAULT_OPTIONS$1 = {
      freq: Frequency.YEARLY,
      dtstart: null,
      interval: 1,
      wkst: Days.MO,
      count: null,
      until: null,
      tzid: null,
      bysetpos: null,
      bymonth: null,
      bymonthday: null,
      bynmonthday: null,
      byyearday: null,
      byweekno: null,
      byweekday: null,
      bynweekday: null,
      byhour: null,
      byminute: null,
      bysecond: null,
      byeaster: null,
  };
  var defaultKeys = Object.keys(DEFAULT_OPTIONS$1);
  /**
   *
   * @param {Options?} options - see <http://labix.org/python-dateutil/#head-cf004ee9a75592797e076752b2a889c10f445418>
   * - The only required option is `freq`, one of RRule.YEARLY, RRule.MONTHLY, ...
   * @constructor
   */
  var RRule = /** @class */ (function () {
      function RRule(options, noCache) {
          if (options === void 0) { options = {}; }
          if (noCache === void 0) { noCache = false; }
          // RFC string
          this._cache = noCache ? null : new Cache();
          // used by toString()
          this.origOptions = initializeOptions$1(options);
          var parsedOptions = parseOptions(options).parsedOptions;
          this.options = parsedOptions;
      }
      RRule.parseText = function (text, language) {
          return parseText(text, language);
      };
      RRule.fromText = function (text, language) {
          return fromText(text, language);
      };
      RRule.fromString = function (str) {
          return new RRule(RRule.parseString(str) || undefined);
      };
      RRule.prototype._iter = function (iterResult) {
          return iter(iterResult, this.options);
      };
      RRule.prototype._cacheGet = function (what, args) {
          if (!this._cache)
              return false;
          return this._cache._cacheGet(what, args);
      };
      RRule.prototype._cacheAdd = function (what, value, args) {
          if (!this._cache)
              return;
          return this._cache._cacheAdd(what, value, args);
      };
      /**
       * @param {Function} iterator - optional function that will be called
       * on each date that is added. It can return false
       * to stop the iteration.
       * @return Array containing all recurrences.
       */
      RRule.prototype.all = function (iterator) {
          if (iterator) {
              return this._iter(new CallbackIterResult('all', {}, iterator));
          }
          var result = this._cacheGet('all');
          if (result === false) {
              result = this._iter(new IterResult('all', {}));
              this._cacheAdd('all', result);
          }
          return result;
      };
      /**
       * Returns all the occurrences of the rrule between after and before.
       * The inc keyword defines what happens if after and/or before are
       * themselves occurrences. With inc == True, they will be included in the
       * list, if they are found in the recurrence set.
       *
       * @return Array
       */
      RRule.prototype.between = function (after, before, inc, iterator) {
          if (inc === void 0) { inc = false; }
          if (!dateutil$1.isValidDate(after) || !dateutil$1.isValidDate(before)) {
              throw new Error('Invalid date passed in to RRule.between');
          }
          var args = {
              before: before,
              after: after,
              inc: inc,
          };
          if (iterator) {
              return this._iter(new CallbackIterResult('between', args, iterator));
          }
          var result = this._cacheGet('between', args);
          if (result === false) {
              result = this._iter(new IterResult('between', args));
              this._cacheAdd('between', result, args);
          }
          return result;
      };
      /**
       * Returns the last recurrence before the given datetime instance.
       * The inc keyword defines what happens if dt is an occurrence.
       * With inc == True, if dt itself is an occurrence, it will be returned.
       *
       * @return Date or null
       */
      RRule.prototype.before = function (dt, inc) {
          if (inc === void 0) { inc = false; }
          if (!dateutil$1.isValidDate(dt)) {
              throw new Error('Invalid date passed in to RRule.before');
          }
          var args = { dt: dt, inc: inc };
          var result = this._cacheGet('before', args);
          if (result === false) {
              result = this._iter(new IterResult('before', args));
              this._cacheAdd('before', result, args);
          }
          return result;
      };
      /**
       * Returns the first recurrence after the given datetime instance.
       * The inc keyword defines what happens if dt is an occurrence.
       * With inc == True, if dt itself is an occurrence, it will be returned.
       *
       * @return Date or null
       */
      RRule.prototype.after = function (dt, inc) {
          if (inc === void 0) { inc = false; }
          if (!dateutil$1.isValidDate(dt)) {
              throw new Error('Invalid date passed in to RRule.after');
          }
          var args = { dt: dt, inc: inc };
          var result = this._cacheGet('after', args);
          if (result === false) {
              result = this._iter(new IterResult('after', args));
              this._cacheAdd('after', result, args);
          }
          return result;
      };
      /**
       * Returns the number of recurrences in this set. It will have go trough
       * the whole recurrence, if this hasn't been done before.
       */
      RRule.prototype.count = function () {
          return this.all().length;
      };
      /**
       * Converts the rrule into its string representation
       *
       * @see <http://www.ietf.org/rfc/rfc2445.txt>
       * @return String
       */
      RRule.prototype.toString = function () {
          return optionsToString(this.origOptions);
      };
      /**
       * Will convert all rules described in nlp:ToText
       * to text.
       */
      RRule.prototype.toText = function (gettext, language, dateFormatter) {
          return toText(this, gettext, language, dateFormatter);
      };
      RRule.prototype.isFullyConvertibleToText = function () {
          return isFullyConvertible(this);
      };
      /**
       * @return a RRule instance with the same freq and options
       * as this one (cache is not cloned)
       */
      RRule.prototype.clone = function () {
          return new RRule(this.origOptions);
      };
      // RRule class 'constants'
      RRule.FREQUENCIES = [
          'YEARLY',
          'MONTHLY',
          'WEEKLY',
          'DAILY',
          'HOURLY',
          'MINUTELY',
          'SECONDLY',
      ];
      RRule.YEARLY = Frequency.YEARLY;
      RRule.MONTHLY = Frequency.MONTHLY;
      RRule.WEEKLY = Frequency.WEEKLY;
      RRule.DAILY = Frequency.DAILY;
      RRule.HOURLY = Frequency.HOURLY;
      RRule.MINUTELY = Frequency.MINUTELY;
      RRule.SECONDLY = Frequency.SECONDLY;
      RRule.MO = Days.MO;
      RRule.TU = Days.TU;
      RRule.WE = Days.WE;
      RRule.TH = Days.TH;
      RRule.FR = Days.FR;
      RRule.SA = Days.SA;
      RRule.SU = Days.SU;
      RRule.parseString = parseString;
      RRule.optionsToString = optionsToString;
      return RRule;
  }());

  function iterSet(iterResult, _rrule, _exrule, _rdate, _exdate, tzid) {
      var _exdateHash = {};
      var _accept = iterResult.accept;
      function evalExdate(after, before) {
          _exrule.forEach(function (rrule) {
              rrule.between(after, before, true).forEach(function (date) {
                  _exdateHash[Number(date)] = true;
              });
          });
      }
      _exdate.forEach(function (date) {
          var zonedDate = new DateWithZone(date, tzid).rezonedDate();
          _exdateHash[Number(zonedDate)] = true;
      });
      iterResult.accept = function (date) {
          var dt = Number(date);
          if (isNaN(dt))
              return _accept.call(this, date);
          if (!_exdateHash[dt]) {
              evalExdate(new Date(dt - 1), new Date(dt + 1));
              if (!_exdateHash[dt]) {
                  _exdateHash[dt] = true;
                  return _accept.call(this, date);
              }
          }
          return true;
      };
      if (iterResult.method === 'between') {
          evalExdate(iterResult.args.after, iterResult.args.before);
          iterResult.accept = function (date) {
              var dt = Number(date);
              if (!_exdateHash[dt]) {
                  _exdateHash[dt] = true;
                  return _accept.call(this, date);
              }
              return true;
          };
      }
      for (var i = 0; i < _rdate.length; i++) {
          var zonedDate = new DateWithZone(_rdate[i], tzid).rezonedDate();
          if (!iterResult.accept(new Date(zonedDate.getTime())))
              break;
      }
      _rrule.forEach(function (rrule) {
          iter(iterResult, rrule.options);
      });
      var res = iterResult._result;
      dateutil$1.sort(res);
      switch (iterResult.method) {
          case 'all':
          case 'between':
              return res;
          case 'before':
              return ((res.length && res[res.length - 1]) || null);
          case 'after':
          default:
              return ((res.length && res[0]) || null);
      }
  }

  /**
   * RRuleStr
   * To parse a set of rrule strings
   */
  var DEFAULT_OPTIONS = {
      dtstart: null,
      cache: false,
      unfold: false,
      forceset: false,
      compatible: false,
      tzid: null,
  };
  function parseInput(s, options) {
      var rrulevals = [];
      var rdatevals = [];
      var exrulevals = [];
      var exdatevals = [];
      var parsedDtstart = parseDtstart(s);
      var dtstart = parsedDtstart.dtstart;
      var tzid = parsedDtstart.tzid;
      var lines = splitIntoLines(s, options.unfold);
      lines.forEach(function (line) {
          var _a;
          if (!line)
              return;
          var _b = breakDownLine(line), name = _b.name, parms = _b.parms, value = _b.value;
          switch (name.toUpperCase()) {
              case 'RRULE':
                  if (parms.length) {
                      throw new Error("unsupported RRULE parm: ".concat(parms.join(',')));
                  }
                  rrulevals.push(parseString(line));
                  break;
              case 'RDATE':
                  var _c = (_a = /RDATE(?:;TZID=([^:=]+))?/i.exec(line)) !== null && _a !== void 0 ? _a : [], rdateTzid = _c[1];
                  if (rdateTzid && !tzid) {
                      tzid = rdateTzid;
                  }
                  rdatevals = rdatevals.concat(parseRDate(value, parms));
                  break;
              case 'EXRULE':
                  if (parms.length) {
                      throw new Error("unsupported EXRULE parm: ".concat(parms.join(',')));
                  }
                  exrulevals.push(parseString(value));
                  break;
              case 'EXDATE':
                  exdatevals = exdatevals.concat(parseRDate(value, parms));
                  break;
              case 'DTSTART':
                  break;
              default:
                  throw new Error('unsupported property: ' + name);
          }
      });
      return {
          dtstart: dtstart,
          tzid: tzid,
          rrulevals: rrulevals,
          rdatevals: rdatevals,
          exrulevals: exrulevals,
          exdatevals: exdatevals,
      };
  }
  function buildRule(s, options) {
      var _a = parseInput(s, options), rrulevals = _a.rrulevals, rdatevals = _a.rdatevals, exrulevals = _a.exrulevals, exdatevals = _a.exdatevals, dtstart = _a.dtstart, tzid = _a.tzid;
      var noCache = options.cache === false;
      if (options.compatible) {
          options.forceset = true;
          options.unfold = true;
      }
      if (options.forceset ||
          rrulevals.length > 1 ||
          rdatevals.length ||
          exrulevals.length ||
          exdatevals.length) {
          var rset_1 = new RRuleSet(noCache);
          rset_1.dtstart(dtstart);
          rset_1.tzid(tzid || undefined);
          rrulevals.forEach(function (val) {
              rset_1.rrule(new RRule(groomRruleOptions(val, dtstart, tzid), noCache));
          });
          rdatevals.forEach(function (date) {
              rset_1.rdate(date);
          });
          exrulevals.forEach(function (val) {
              rset_1.exrule(new RRule(groomRruleOptions(val, dtstart, tzid), noCache));
          });
          exdatevals.forEach(function (date) {
              rset_1.exdate(date);
          });
          if (options.compatible && options.dtstart)
              rset_1.rdate(dtstart);
          return rset_1;
      }
      var val = rrulevals[0] || {};
      return new RRule(groomRruleOptions(val, val.dtstart || options.dtstart || dtstart, val.tzid || options.tzid || tzid), noCache);
  }
  function rrulestr(s, options) {
      if (options === void 0) { options = {}; }
      return buildRule(s, initializeOptions(options));
  }
  function groomRruleOptions(val, dtstart, tzid) {
      return __assign(__assign({}, val), { dtstart: dtstart, tzid: tzid });
  }
  function initializeOptions(options) {
      var invalid = [];
      var keys = Object.keys(options);
      var defaultKeys = Object.keys(DEFAULT_OPTIONS);
      keys.forEach(function (key) {
          if (!includes(defaultKeys, key))
              invalid.push(key);
      });
      if (invalid.length) {
          throw new Error('Invalid options: ' + invalid.join(', '));
      }
      return __assign(__assign({}, DEFAULT_OPTIONS), options);
  }
  function extractName(line) {
      if (line.indexOf(':') === -1) {
          return {
              name: 'RRULE',
              value: line,
          };
      }
      var _a = split(line, ':', 1), name = _a[0], value = _a[1];
      return {
          name: name,
          value: value,
      };
  }
  function breakDownLine(line) {
      var _a = extractName(line), name = _a.name, value = _a.value;
      var parms = name.split(';');
      if (!parms)
          throw new Error('empty property name');
      return {
          name: parms[0].toUpperCase(),
          parms: parms.slice(1),
          value: value,
      };
  }
  function splitIntoLines(s, unfold) {
      if (unfold === void 0) { unfold = false; }
      s = s && s.trim();
      if (!s)
          throw new Error('Invalid empty string');
      // More info about 'unfold' option
      // Go head to http://www.ietf.org/rfc/rfc2445.txt
      if (!unfold) {
          return s.split(/\s/);
      }
      var lines = s.split('\n');
      var i = 0;
      while (i < lines.length) {
          // TODO
          var line = (lines[i] = lines[i].replace(/\s+$/g, ''));
          if (!line) {
              lines.splice(i, 1);
          }
          else if (i > 0 && line[0] === ' ') {
              lines[i - 1] += line.slice(1);
              lines.splice(i, 1);
          }
          else {
              i += 1;
          }
      }
      return lines;
  }
  function validateDateParm(parms) {
      parms.forEach(function (parm) {
          if (!/(VALUE=DATE(-TIME)?)|(TZID=)/.test(parm)) {
              throw new Error('unsupported RDATE/EXDATE parm: ' + parm);
          }
      });
  }
  function parseRDate(rdateval, parms) {
      validateDateParm(parms);
      return rdateval
          .split(',')
          .map(function (datestr) { return dateutil$1.untilStringToDate(datestr); });
  }

  function createGetterSetter(fieldName) {
      var _this = this;
      return function (field) {
          if (field !== undefined) {
              _this["_".concat(fieldName)] = field;
          }
          if (_this["_".concat(fieldName)] !== undefined) {
              return _this["_".concat(fieldName)];
          }
          for (var i = 0; i < _this._rrule.length; i++) {
              var field_1 = _this._rrule[i].origOptions[fieldName];
              if (field_1) {
                  return field_1;
              }
          }
      };
  }
  var RRuleSet = /** @class */ (function (_super) {
      __extends(RRuleSet, _super);
      /**
       *
       * @param {Boolean?} noCache
       * The same stratagy as RRule on cache, default to false
       * @constructor
       */
      function RRuleSet(noCache) {
          if (noCache === void 0) { noCache = false; }
          var _this = _super.call(this, {}, noCache) || this;
          _this.dtstart = createGetterSetter.apply(_this, ['dtstart']);
          _this.tzid = createGetterSetter.apply(_this, ['tzid']);
          _this._rrule = [];
          _this._rdate = [];
          _this._exrule = [];
          _this._exdate = [];
          return _this;
      }
      RRuleSet.prototype._iter = function (iterResult) {
          return iterSet(iterResult, this._rrule, this._exrule, this._rdate, this._exdate, this.tzid());
      };
      /**
       * Adds an RRule to the set
       *
       * @param {RRule}
       */
      RRuleSet.prototype.rrule = function (rrule) {
          _addRule(rrule, this._rrule);
      };
      /**
       * Adds an EXRULE to the set
       *
       * @param {RRule}
       */
      RRuleSet.prototype.exrule = function (rrule) {
          _addRule(rrule, this._exrule);
      };
      /**
       * Adds an RDate to the set
       *
       * @param {Date}
       */
      RRuleSet.prototype.rdate = function (date) {
          _addDate(date, this._rdate);
      };
      /**
       * Adds an EXDATE to the set
       *
       * @param {Date}
       */
      RRuleSet.prototype.exdate = function (date) {
          _addDate(date, this._exdate);
      };
      /**
       * Get list of included rrules in this recurrence set.
       *
       * @return List of rrules
       */
      RRuleSet.prototype.rrules = function () {
          return this._rrule.map(function (e) { return rrulestr(e.toString()); });
      };
      /**
       * Get list of excluded rrules in this recurrence set.
       *
       * @return List of exrules
       */
      RRuleSet.prototype.exrules = function () {
          return this._exrule.map(function (e) { return rrulestr(e.toString()); });
      };
      /**
       * Get list of included datetimes in this recurrence set.
       *
       * @return List of rdates
       */
      RRuleSet.prototype.rdates = function () {
          return this._rdate.map(function (e) { return new Date(e.getTime()); });
      };
      /**
       * Get list of included datetimes in this recurrence set.
       *
       * @return List of exdates
       */
      RRuleSet.prototype.exdates = function () {
          return this._exdate.map(function (e) { return new Date(e.getTime()); });
      };
      RRuleSet.prototype.valueOf = function () {
          var result = [];
          if (!this._rrule.length && this._dtstart) {
              result = result.concat(optionsToString({ dtstart: this._dtstart }));
          }
          this._rrule.forEach(function (rrule) {
              result = result.concat(rrule.toString().split('\n'));
          });
          this._exrule.forEach(function (exrule) {
              result = result.concat(exrule
                  .toString()
                  .split('\n')
                  .map(function (line) { return line.replace(/^RRULE:/, 'EXRULE:'); })
                  .filter(function (line) { return !/^DTSTART/.test(line); }));
          });
          if (this._rdate.length) {
              result.push(rdatesToString('RDATE', this._rdate, this.tzid()));
          }
          if (this._exdate.length) {
              result.push(rdatesToString('EXDATE', this._exdate, this.tzid()));
          }
          return result;
      };
      /**
       * to generate recurrence field such as:
       * DTSTART:19970902T010000Z
       * RRULE:FREQ=YEARLY;COUNT=2;BYDAY=TU
       * RRULE:FREQ=YEARLY;COUNT=1;BYDAY=TH
       */
      RRuleSet.prototype.toString = function () {
          return this.valueOf().join('\n');
      };
      /**
       * Create a new RRuleSet Object completely base on current instance
       */
      RRuleSet.prototype.clone = function () {
          var rrs = new RRuleSet(!!this._cache);
          this._rrule.forEach(function (rule) { return rrs.rrule(rule.clone()); });
          this._exrule.forEach(function (rule) { return rrs.exrule(rule.clone()); });
          this._rdate.forEach(function (date) { return rrs.rdate(new Date(date.getTime())); });
          this._exdate.forEach(function (date) { return rrs.exdate(new Date(date.getTime())); });
          return rrs;
      };
      return RRuleSet;
  }(RRule));
  function _addRule(rrule, collection) {
      if (!(rrule instanceof RRule)) {
          throw new TypeError(String(rrule) + ' is not RRule instance');
      }
      if (!includes(collection.map(String), String(rrule))) {
          collection.push(rrule);
      }
  }
  function _addDate(date, collection) {
      if (!(date instanceof Date)) {
          throw new TypeError(String(date) + ' is not Date instance');
      }
      if (!includes(collection.map(Number), Number(date))) {
          collection.push(date);
          dateutil$1.sort(collection);
      }
  }
  function rdatesToString(param, rdates, tzid) {
      var isUTC = !tzid || tzid.toUpperCase() === 'UTC';
      var header = isUTC ? "".concat(param, ":") : "".concat(param, ";TZID=").concat(tzid, ":");
      var dateString = rdates
          .map(function (rdate) { return dateutil$1.timeToUntilString(rdate.valueOf(), isUTC); })
          .join(',');
      return "".concat(header).concat(dateString);
  }

  const recurringType = {
      parse(eventProps, dateEnv) {
          if (eventProps.rrule != null) {
              let eventRRuleData = parseEventRRule(eventProps, dateEnv);
              if (eventRRuleData) {
                  return {
                      typeData: { rruleSet: eventRRuleData.rruleSet, isTimeZoneSpecified: eventRRuleData.isTimeZoneSpecified },
                      allDayGuess: !eventRRuleData.isTimeSpecified,
                      duration: eventProps.duration,
                  };
              }
          }
          return null;
      },
      expand(eventRRuleData, framingRange, dateEnv) {
          let dates;
          if (eventRRuleData.isTimeZoneSpecified) {
              dates = eventRRuleData.rruleSet.between(dateEnv.toDate(framingRange.start), // rrule lib will treat as UTC-zoned
              dateEnv.toDate(framingRange.end), // (same)
              true).map((date) => dateEnv.createMarker(date)); // convert UTC-zoned-date to locale datemarker
          }
          else {
              // when no timezone in given start/end, the rrule lib will assume UTC,
              // which is same as our DateMarkers. no need to manipulate
              dates = eventRRuleData.rruleSet.between(framingRange.start, framingRange.end, true);
          }
          return dates;
      },
  };
  function parseEventRRule(eventProps, dateEnv) {
      let rruleSet;
      let isTimeSpecified = false;
      let isTimeZoneSpecified = false;
      if (typeof eventProps.rrule === 'string') {
          let res = parseRRuleString(eventProps.rrule);
          rruleSet = res.rruleSet;
          isTimeSpecified = res.isTimeSpecified;
          isTimeZoneSpecified = res.isTimeZoneSpecified;
      }
      if (typeof eventProps.rrule === 'object' && eventProps.rrule) { // non-null object
          let res = parseRRuleObject(eventProps.rrule, dateEnv);
          rruleSet = new RRuleSet();
          rruleSet.rrule(res.rrule);
          isTimeSpecified = res.isTimeSpecified;
          isTimeZoneSpecified = res.isTimeZoneSpecified;
      }
      // convery to arrays. TODO: general util?
      let exdateInputs = [].concat(eventProps.exdate || []);
      let exruleInputs = [].concat(eventProps.exrule || []);
      for (let exdateInput of exdateInputs) {
          let res = parse$3(exdateInput);
          isTimeSpecified = isTimeSpecified || !res.isTimeUnspecified;
          isTimeZoneSpecified = isTimeZoneSpecified || res.timeZoneOffset !== null;
          rruleSet.exdate(new Date(res.marker.valueOf() - (res.timeZoneOffset || 0) * 60 * 1000));
      }
      // TODO: exrule is deprecated. what to do? (https://icalendar.org/iCalendar-RFC-5545/a-3-deprecated-features.html)
      for (let exruleInput of exruleInputs) {
          let res = parseRRuleObject(exruleInput, dateEnv);
          isTimeSpecified = isTimeSpecified || res.isTimeSpecified;
          isTimeZoneSpecified = isTimeZoneSpecified || res.isTimeZoneSpecified;
          rruleSet.exrule(res.rrule);
      }
      return { rruleSet, isTimeSpecified, isTimeZoneSpecified };
  }
  function parseRRuleObject(rruleInput, dateEnv) {
      let isTimeSpecified = false;
      let isTimeZoneSpecified = false;
      function processDateInput(dateInput) {
          if (typeof dateInput === 'string') {
              let markerData = parse$3(dateInput);
              if (markerData) {
                  isTimeSpecified = isTimeSpecified || !markerData.isTimeUnspecified;
                  isTimeZoneSpecified = isTimeZoneSpecified || markerData.timeZoneOffset !== null;
                  return new Date(markerData.marker.valueOf() - (markerData.timeZoneOffset || 0) * 60 * 1000); // NOT DRY
              }
              return null;
          }
          return dateInput; // TODO: what about number timestamps?
      }
      let rruleOptions = Object.assign(Object.assign({}, rruleInput), { dtstart: processDateInput(rruleInput.dtstart), until: processDateInput(rruleInput.until), freq: convertConstant(rruleInput.freq), wkst: rruleInput.wkst == null
              ? (dateEnv.weekDow - 1 + 7) % 7 // convert Sunday-first to Monday-first
              : convertConstant(rruleInput.wkst), byweekday: convertConstants(rruleInput.byweekday) });
      return { rrule: new RRule(rruleOptions), isTimeSpecified, isTimeZoneSpecified };
  }
  function parseRRuleString(str) {
      let rruleSet = rrulestr(str, { forceset: true });
      let analysis = analyzeRRuleString(str);
      return Object.assign({ rruleSet }, analysis);
  }
  function analyzeRRuleString(str) {
      let isTimeSpecified = false;
      let isTimeZoneSpecified = false;
      function processMatch(whole, introPart, datePart) {
          let result = parse$3(datePart);
          isTimeSpecified = isTimeSpecified || !result.isTimeUnspecified;
          isTimeZoneSpecified = isTimeZoneSpecified || result.timeZoneOffset !== null;
      }
      str.replace(/\b(DTSTART:)([^\n]*)/, processMatch);
      str.replace(/\b(EXDATE:)([^\n]*)/, processMatch);
      str.replace(/\b(UNTIL=)([^;\n]*)/, processMatch);
      return { isTimeSpecified, isTimeZoneSpecified };
  }
  function convertConstants(input) {
      if (Array.isArray(input)) {
          return input.map(convertConstant);
      }
      return convertConstant(input);
  }
  function convertConstant(input) {
      if (typeof input === 'string') {
          return RRule[input.toUpperCase()];
      }
      return input;
  }

  const RRULE_EVENT_REFINERS = {
      rrule: identity,
      exrule: identity,
      exdate: identity,
      duration: createDuration,
  };

  var index$5 = createPlugin({
      name: '@fullcalendar/rrule',
      recurringTypes: [recurringType],
      eventRefiners: RRULE_EVENT_REFINERS,
  });

  describe('rrule plugin', () => {
      pushOptions({
          plugins: [index$5, index$a],
          initialView: 'dayGridMonth',
          now: '2018-09-07',
          timeZone: 'UTC',
      });
      it('expands events when given an rrule object', () => {
          initCalendar({
              events: [
                  {
                      rrule: {
                          dtstart: '2018-09-04T13:00:00',
                          freq: 'weekly',
                      },
                  },
              ],
          });
          let events = getSortedEvents();
          expect(events.length).toBe(5);
          expect(events[0].start).toEqualDate('2018-09-04T13:00:00Z');
          expect(events[0].end).toBe(null);
          expect(events[1].start).toEqualDate('2018-09-11T13:00:00Z');
          expect(events[2].start).toEqualDate('2018-09-18T13:00:00Z');
          expect(events[3].start).toEqualDate('2018-09-25T13:00:00Z');
          expect(events[4].start).toEqualDate('2018-10-02T13:00:00Z');
      });
      it('can expand monthly recurrence when given an rrule object', () => {
          initCalendar({
              initialView: 'dayGridMonth',
              now: '2018-12-25T12:00:00',
              events: [{
                      rrule: {
                          dtstart: '2018-11-01',
                          freq: 'monthly',
                          count: 13,
                          bymonthday: [13],
                      },
                  }],
          });
          let events = currentCalendar.getEvents();
          expect(events.length).toBe(1);
          expect(events[0].start).toEqualDate('2018-12-13');
      });
      // https://github.com/fullcalendar/fullcalendar/issues/6059
      it('can specify strings in byweekday', () => {
          initCalendar({
              initialView: 'dayGridMonth',
              initialDate: '2021-01-01',
              events: [{
                      allDay: true,
                      rrule: {
                          freq: 'weekly',
                          byweekday: ['mo', 'tu'],
                          dtstart: '2021-01-01',
                      },
                  }],
          });
          let events = currentCalendar.getEvents();
          expect(events.length).toBe(10);
          expect(events[0].start).toEqualDate('2021-01-04');
      });
      it('can exclude a recurrence with exdate', () => {
          let calendar = initCalendar({
              initialView: 'dayGridMonth',
              now: '2020-12-01',
              events: [{
                      rrule: {
                          dtstart: '2020-12-01',
                          freq: 'weekly',
                      },
                      exdate: '2020-12-08',
                  }],
          });
          let events = calendar.getEvents();
          expect(events.length).toBe(5);
          expect(events[0].start).toEqualDate('2020-12-01');
          expect(events[1].start).toEqualDate('2020-12-15');
          expect(events[2].start).toEqualDate('2020-12-22');
          expect(events[3].start).toEqualDate('2020-12-29');
          expect(events[4].start).toEqualDate('2021-01-05');
      });
      it('can exclude multiple recurrences with exdate', () => {
          let calendar = initCalendar({
              initialView: 'dayGridMonth',
              now: '2020-12-01',
              events: [{
                      rrule: {
                          dtstart: '2020-12-01',
                          freq: 'weekly',
                      },
                      exdate: ['2020-12-08', '2020-12-15'],
                  }],
          });
          let events = calendar.getEvents();
          expect(events.length).toBe(4);
          expect(events[0].start).toEqualDate('2020-12-01');
          expect(events[1].start).toEqualDate('2020-12-22');
          expect(events[2].start).toEqualDate('2020-12-29');
          expect(events[3].start).toEqualDate('2021-01-05');
      });
      it('can exclude recurrences with an exrule', () => {
          let calendar = initCalendar({
              initialView: 'dayGridMonth',
              now: '2020-12-01',
              events: [{
                      rrule: {
                          dtstart: '2020-12-01',
                          freq: 'weekly',
                      },
                      exrule: {
                          dtstart: '2020-12-08',
                          until: '2020-12-15',
                          freq: 'weekly',
                      },
                  }],
          });
          let events = calendar.getEvents();
          expect(events.length).toBe(4);
          expect(events[0].start).toEqualDate('2020-12-01');
          expect(events[1].start).toEqualDate('2020-12-22');
          expect(events[2].start).toEqualDate('2020-12-29');
          expect(events[3].start).toEqualDate('2021-01-05');
      });
      it('can exclude recurrences with multiple exrules', () => {
          let calendar = initCalendar({
              initialView: 'dayGridMonth',
              now: '2020-12-01',
              events: [{
                      rrule: {
                          dtstart: '2020-12-01',
                          freq: 'weekly',
                      },
                      exrule: [
                          {
                              dtstart: '2020-12-08',
                              until: '2020-12-15',
                              freq: 'weekly',
                          },
                          {
                              dtstart: '2020-12-22',
                              until: '2020-12-29',
                              freq: 'weekly',
                          },
                      ],
                  }],
          });
          let events = calendar.getEvents();
          expect(events.length).toBe(2);
          expect(events[0].start).toEqualDate('2020-12-01');
          expect(events[1].start).toEqualDate('2021-01-05');
      });
      it('expands events until a date', () => {
          initCalendar({
              events: [
                  {
                      rrule: {
                          dtstart: '2018-09-04T13:00:00',
                          until: '2018-10-01',
                          freq: 'weekly',
                      },
                  },
              ],
          });
          let events = getSortedEvents();
          expect(events.length).toBe(4);
          expect(events[0].start).toEqualDate('2018-09-04T13:00:00Z');
          expect(events[0].end).toBe(null);
          expect(events[1].start).toEqualDate('2018-09-11T13:00:00Z');
          expect(events[2].start).toEqualDate('2018-09-18T13:00:00Z');
          expect(events[3].start).toEqualDate('2018-09-25T13:00:00Z');
      });
      it('expands a range that starts exactly at the current view\'s start', () => {
          initCalendar({
              initialDate: '2019-04-02',
              initialView: 'dayGridDay',
              events: [
                  {
                      title: 'event with everyday with range',
                      allDay: true,
                      rrule: {
                          freq: 'daily',
                          dtstart: '2019-04-02',
                          until: '2019-04-09',
                      },
                  },
              ],
          });
          let events = getSortedEvents();
          expect(events.length).toBeGreaterThanOrEqual(1);
          expect(events[0].start).toEqualDate('2019-04-02');
      });
      it('expands events with a duration', () => {
          initCalendar({
              events: [
                  {
                      rrule: {
                          dtstart: '2018-09-04T13:00:00',
                          freq: 'weekly',
                      },
                      duration: '03:00',
                  },
              ],
          });
          let events = getSortedEvents();
          expect(events.length).toBe(5);
          expect(events[0].start).toEqualDate('2018-09-04T13:00:00Z');
          expect(events[0].end).toEqualDate('2018-09-04T16:00:00Z');
      });
      it('expands events with guessed allDay', () => {
          initCalendar({
              events: [
                  {
                      rrule: {
                          dtstart: '2018-09-04',
                          freq: 'weekly',
                      },
                  },
              ],
          });
          let events = getSortedEvents();
          expect(events.length).toBe(5);
          expect(events[0].start).toEqualDate('2018-09-04');
          expect(events[0].end).toBe(null);
          expect(events[0].allDay).toBe(true);
      });
      it('inherits defaultAllDay from source', () => {
          initCalendar({
              defaultAllDay: false,
              events: [
                  {
                      rrule: {
                          dtstart: parseUtcDate('2018-09-04'),
                          freq: 'weekly',
                      },
                  },
              ],
          });
          let events = getSortedEvents();
          expect(events.length).toBe(5);
          expect(events[0].start).toEqualDate('2018-09-04');
          expect(events[0].end).toBe(null);
          expect(events[0].allDay).toBe(false);
      });
      it('inherits defaultAllDay from source setting', () => {
          initCalendar({
              eventSources: [{
                      defaultAllDay: false,
                      events: [
                          {
                              rrule: {
                                  dtstart: parseUtcDate('2018-09-04'),
                                  freq: 'weekly',
                              },
                          },
                      ],
                  }],
          });
          let events = getSortedEvents();
          expect(events.length).toBe(5);
          expect(events[0].start).toEqualDate('2018-09-04');
          expect(events[0].end).toBe(null);
          expect(events[0].allDay).toBe(false);
      });
      it('can generate local dates when given an rrule object', () => {
          initCalendar({
              timeZone: 'local',
              events: [
                  {
                      rrule: {
                          dtstart: parseLocalDate('2018-09-04T05:00:00').toISOString(),
                          freq: 'weekly',
                      },
                  },
              ],
          });
          let events = getSortedEvents();
          expect(events.length).toBe(5);
          expect(events[0].start).toEqualLocalDate('2018-09-04T05:00:00');
          expect(events[0].end).toBe(null);
          expect(events[0].allDay).toBe(false);
      });
      describe('when given an rrule string', () => {
          it('expands', () => {
              initCalendar({
                  events: [
                      {
                          rrule: 'DTSTART:20180904T130000\n' +
                              'RRULE:FREQ=WEEKLY',
                      },
                  ],
              });
              let events = getSortedEvents();
              expect(events.length).toBe(5);
              expect(events[0].start).toEqualDate('2018-09-04T13:00:00Z');
              expect(events[0].end).toBe(null);
              expect(events[1].start).toEqualDate('2018-09-11T13:00:00Z');
              expect(events[2].start).toEqualDate('2018-09-18T13:00:00Z');
              expect(events[3].start).toEqualDate('2018-09-25T13:00:00Z');
              expect(events[4].start).toEqualDate('2018-10-02T13:00:00Z');
          });
          // https://github.com/fullcalendar/fullcalendar/issues/6126
          it('expands correctly with UNTIL followed by newline', () => {
              initCalendar({
                  events: [
                      {
                          rrule: 'DTSTART:20180904T130000\n' +
                              'RRULE:FREQ=WEEKLY;UNTIL=20180925T130000\n' +
                              'RDATE:20180904T130000',
                      },
                  ],
              });
              let events = getSortedEvents();
              expect(events.length).toBe(4);
          });
          it('respects allDay', () => {
              initCalendar({
                  events: [
                      {
                          allDay: true,
                          rrule: 'DTSTART:20180904T130000\nRRULE:FREQ=WEEKLY',
                      },
                  ],
              });
              let events = getSortedEvents();
              expect(events[0].start).toEqualDate('2018-09-04'); // should round down
              expect(events[0].allDay).toBe(true);
              expect(events[0].extendedProps).toEqual({}); // didnt accumulate allDay or rrule props
          });
          it('can expand monthly recurrence in UTC', () => {
              initCalendar({
                  initialView: 'dayGridMonth',
                  now: '2018-12-25T12:00:00',
                  timeZone: 'UTC',
                  events: [{
                          rrule: 'DTSTART:20181101\nRRULE:FREQ=MONTHLY;COUNT=13;BYMONTHDAY=13',
                      }],
              });
              let events = currentCalendar.getEvents();
              expect(events.length).toBe(1);
              expect(events[0].start).toEqualDate('2018-12-13');
          });
          it('can expand monthly recurrence in local timeZone', () => {
              initCalendar({
                  initialView: 'dayGridMonth',
                  now: '2018-12-25T12:00:00',
                  timeZone: 'local',
                  events: [{
                          rrule: 'DTSTART:20181101\nRRULE:FREQ=MONTHLY;COUNT=13;BYMONTHDAY=13',
                      }],
              });
              let events = currentCalendar.getEvents();
              expect(events.length).toBe(1);
              expect(events[0].start).toEqualLocalDate('2018-12-13');
          });
          it('can expand weekly timed recurrence in local timeZone', () => {
              initCalendar({
                  initialView: 'dayGridMonth',
                  now: '2018-12-25T12:00:00',
                  timeZone: 'local',
                  events: [{
                          rrule: 'DTSTART:20181201T000000\nRRULE:FREQ=WEEKLY',
                      }],
              });
              let events = currentCalendar.getEvents();
              expect(events.length).toBe(6);
              expect(events[0].start).toEqualLocalDate('2018-12-01');
          });
          it('can expand weekly UTC-timed recurrence in local timeZone', () => {
              initCalendar({
                  initialView: 'dayGridMonth',
                  now: '2018-12-25T12:00:00',
                  timeZone: 'local',
                  events: [{
                          rrule: 'DTSTART:20181201T000000Z\nRRULE:FREQ=WEEKLY',
                      }],
              });
              let events = currentCalendar.getEvents();
              expect(events.length).toBe(6);
              expect(events[0].start).toEqualDate('2018-12-01');
          });
          it('can expand weekly UTC-timed recurrence in local timeZone, with exclusion', () => {
              initCalendar({
                  initialView: 'dayGridMonth',
                  now: '2018-12-25T12:00:00',
                  timeZone: 'local',
                  events: [{
                          rrule: 'DTSTART:20181201T000000Z\nRRULE:FREQ=WEEKLY\nEXDATE:20181208T000000Z',
                      }],
              });
              let events = currentCalendar.getEvents();
              expect(events.length).toBe(5);
              expect(events[0].start).toEqualDate('2018-12-01');
          });
          it('can generate local dates', () => {
              let localStart = buildLocalRRuleDateStr('2018-09-04T05:00:00');
              initCalendar({
                  timeZone: 'local',
                  events: [
                      {
                          rrule: `DTSTART:${localStart}\nRRULE:FREQ=WEEKLY`,
                      },
                  ],
              });
              let events = getSortedEvents();
              expect(events.length).toBe(5);
              expect(events[0].start).toEqualLocalDate('2018-09-04T05:00:00');
              expect(events[0].end).toBe(null);
              expect(events[0].allDay).toBe(false);
          });
          it('can generate local dates, including EXDATE', () => {
              let localStart = buildLocalRRuleDateStr('2018-09-04T05:00:00');
              let localExdate = buildLocalRRuleDateStr('2018-09-05T05:00:00');
              initCalendar({
                  timeZone: 'local',
                  events: [
                      {
                          rrule: `DTSTART:${localStart}\nRRULE:FREQ=WEEKLY\nEXDATE:${localExdate}`,
                      },
                  ],
              });
              let events = getSortedEvents();
              expect(events.length).toBe(5);
              expect(events[0].start).toEqualLocalDate('2018-09-04T05:00:00');
              expect(events[0].end).toBe(null);
              expect(events[0].allDay).toBe(false);
          });
          // https://github.com/fullcalendar/fullcalendar/issues/5726
          it('can generate local dates, including EXDATE, when BYDAY and TZ shifting', () => {
              initCalendar({
                  timeZone: 'local',
                  initialDate: '2020-09-10',
                  events: [
                      {
                          rrule: 'DTSTART:20200915T030000Z\nRRULE:FREQ=WEEKLY;BYDAY=SA\nEXDATE:20201003T030000Z',
                      },
                  ],
              });
              let events = getSortedEvents();
              expect(events.length).toBe(3);
              expect(events[0].start).toEqualDate('2020-09-19T03:00:00');
              expect(events[1].start).toEqualDate('2020-09-26T03:00:00');
              expect(events[2].start).toEqualDate('2020-10-10T03:00:00');
          });
          // https://github.com/fullcalendar/fullcalendar/issues/5993
          it('won\'t accidentally clip dates when calendar has non-UTC timezone', () => {
              let calendar = initCalendar({
                  plugins: [index$5, index$a, index$6],
                  initialDate: '2020-11-01',
                  timeZone: 'Asia/Manila',
                  events: [
                      {
                          duration: '01:00',
                          rrule: {
                              freq: 'daily',
                              dtstart: '2020-10-24T16:00:00Z', // will be 00:00 in Manila
                          },
                      },
                  ],
              });
              let events = calendar.getEvents();
              expect(events[0].start).toEqualDate(calendar.view.activeStart);
          });
          // https://github.com/fullcalendar/fullcalendar/issues/7230
          it('updating the rrule dynamically renders correct number of events', () => {
              const recurringEventDef = {
                  id: '4',
                  groupId: '4',
                  allDay: true,
                  rrule: {
                      freq: 'weekly',
                      dtstart: '2023-03-10',
                  },
              };
              let calendar = initCalendar({
                  plugins: [index$5, index$a],
                  initialDate: '2023-03-10',
                  initialView: 'dayGridMonth',
                  events: [recurringEventDef],
              });
              const dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
              expect(dayGridWrapper.getEventEls().length).toBe(5);
              calendar.next();
              expect(dayGridWrapper.getEventEls().length).toBe(6);
              calendar.resetOptions({
                  events: [Object.assign(Object.assign({}, recurringEventDef), { duration: { days: 2 } })],
              }, ['events']);
              expect(dayGridWrapper.getEventEls().length).toBe(6);
          });
      });
      // https://github.com/fullcalendar/fullcalendar/issues/5273
      it('updates rrule timed events when timeZone changes', () => {
          const timeTexts = [];
          const calendar = initCalendar({
              plugins: [index$5, index$a, index$6],
              timeZone: 'America/New_York',
              initialDate: '2023-02-10',
              initialView: 'dayGridMonth',
              events: [{
                      id: '4',
                      groupId: '4',
                      allDay: false,
                      rrule: {
                          freq: 'weekly',
                          dtstart: '2023-02-10T12:00:00',
                          until: '2023-02-11', // only one instance
                      },
                  }],
              eventContent(arg) {
                  timeTexts.push(arg.timeText);
                  return true;
              },
          });
          let events = calendar.getEvents();
          expect(events[0].allDay).toBe(false);
          expect(events[0].start).toEqualDate('2023-02-10T17:00:00Z');
          expect(timeTexts.length).toBe(1);
          expect(timeTexts[0]).toBe('12p');
          calendar.setOption('timeZone', 'America/Chicago');
          events = calendar.getEvents();
          expect(events[0].allDay).toBe(false);
          expect(events[0].start).toEqualDate('2023-02-10T17:00:00Z');
          expect(timeTexts.length).toBe(2);
          expect(timeTexts[1]).toBe('11a');
      });
      // utils
      function buildLocalRRuleDateStr(inputStr) {
          return parseLocalDate(inputStr).toISOString().replace('.000', '').replace(/[-:]/g, '');
      }
      function getSortedEvents() {
          let events = currentCalendar.getEvents();
          events.sort((eventA, eventB) => eventA.start.valueOf() - eventB.start.valueOf());
          return events;
      }
  });

  describe('formatDate', () => {
      it('works with no timezone offset', () => {
          let str = formatDate('2018-09-04', {
              month: 'long',
              day: 'numeric',
              year: 'numeric',
          });
          expect(str).toBe('September 4, 2018');
      });
      it('works with timezone offset', () => {
          let str = formatDate('2018-09-04T00:00:00-05:00', {
              month: 'long',
              day: 'numeric',
              year: 'numeric',
              timeZoneName: 'short',
              timeZone: 'America/New_York',
              omitCommas: true, // for cross-browser
          });
          expect(str.replace(' at ', ' '))
              .toBe('September 4 2018 12:00 AM GMT-5');
      });
  });
  describe('formatRange', () => {
      it('works with no timezone offset', () => {
          let str = formatRange$2('2018-09-04', '2018-10-04', {
              month: 'long',
              day: 'numeric',
              year: 'numeric',
          });
          expect(str).toBe('September 4 - October 4, 2018');
      });
      it('works with custom separator', () => {
          let str = formatRange$2('2018-09-04', '2018-10-04', {
              month: 'long',
              day: 'numeric',
              year: 'numeric',
              separator: ' ... ',
          });
          expect(str).toBe('September 4 ... October 4, 2018');
      });
      it('works with timezone offset', () => {
          let str = formatRange$2('2018-09-04T00:00:00-05:00', '2018-10-04T00:00:00-05:00', {
              month: 'long',
              day: 'numeric',
              year: 'numeric',
              timeZoneName: 'short',
              timeZone: 'America/New_York',
              omitCommas: true, // for cross-browser
          });
          expect(str.replace(' at ', ' '))
              .toBe('September 4 - October 4 2018 12:00 AM GMT-5');
      });
  });

  var commonjsGlobal$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule$1(fn, basedir, module) {
  	return module = {
  	  path: basedir,
  	  exports: {},
  	  require: function (path, base) {
        return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
      }
  	}, fn(module, module.exports), module.exports;
  }

  function getCjsExportFromNamespace (n) {
  	return n && n['default'] || n;
  }

  function commonjsRequire () {
  	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
  }

  var moment = createCommonjsModule$1(function (module, exports) {
  (function (global, factory) {
      module.exports = factory() ;
  }(commonjsGlobal$1, (function () {
      var hookCallback;

      function hooks() {
          return hookCallback.apply(null, arguments);
      }

      // This is done to register the method called with moment()
      // without creating circular dependencies.
      function setHookCallback(callback) {
          hookCallback = callback;
      }

      function isArray(input) {
          return (
              input instanceof Array ||
              Object.prototype.toString.call(input) === '[object Array]'
          );
      }

      function isObject(input) {
          // IE8 will treat undefined and null as object if it wasn't for
          // input != null
          return (
              input != null &&
              Object.prototype.toString.call(input) === '[object Object]'
          );
      }

      function hasOwnProp(a, b) {
          return Object.prototype.hasOwnProperty.call(a, b);
      }

      function isObjectEmpty(obj) {
          if (Object.getOwnPropertyNames) {
              return Object.getOwnPropertyNames(obj).length === 0;
          } else {
              var k;
              for (k in obj) {
                  if (hasOwnProp(obj, k)) {
                      return false;
                  }
              }
              return true;
          }
      }

      function isUndefined(input) {
          return input === void 0;
      }

      function isNumber(input) {
          return (
              typeof input === 'number' ||
              Object.prototype.toString.call(input) === '[object Number]'
          );
      }

      function isDate(input) {
          return (
              input instanceof Date ||
              Object.prototype.toString.call(input) === '[object Date]'
          );
      }

      function map(arr, fn) {
          var res = [],
              i,
              arrLen = arr.length;
          for (i = 0; i < arrLen; ++i) {
              res.push(fn(arr[i], i));
          }
          return res;
      }

      function extend(a, b) {
          for (var i in b) {
              if (hasOwnProp(b, i)) {
                  a[i] = b[i];
              }
          }

          if (hasOwnProp(b, 'toString')) {
              a.toString = b.toString;
          }

          if (hasOwnProp(b, 'valueOf')) {
              a.valueOf = b.valueOf;
          }

          return a;
      }

      function createUTC(input, format, locale, strict) {
          return createLocalOrUTC(input, format, locale, strict, true).utc();
      }

      function defaultParsingFlags() {
          // We need to deep clone this object.
          return {
              empty: false,
              unusedTokens: [],
              unusedInput: [],
              overflow: -2,
              charsLeftOver: 0,
              nullInput: false,
              invalidEra: null,
              invalidMonth: null,
              invalidFormat: false,
              userInvalidated: false,
              iso: false,
              parsedDateParts: [],
              era: null,
              meridiem: null,
              rfc2822: false,
              weekdayMismatch: false,
          };
      }

      function getParsingFlags(m) {
          if (m._pf == null) {
              m._pf = defaultParsingFlags();
          }
          return m._pf;
      }

      var some;
      if (Array.prototype.some) {
          some = Array.prototype.some;
      } else {
          some = function (fun) {
              var t = Object(this),
                  len = t.length >>> 0,
                  i;

              for (i = 0; i < len; i++) {
                  if (i in t && fun.call(this, t[i], i, t)) {
                      return true;
                  }
              }

              return false;
          };
      }

      function isValid(m) {
          if (m._isValid == null) {
              var flags = getParsingFlags(m),
                  parsedParts = some.call(flags.parsedDateParts, function (i) {
                      return i != null;
                  }),
                  isNowValid =
                      !isNaN(m._d.getTime()) &&
                      flags.overflow < 0 &&
                      !flags.empty &&
                      !flags.invalidEra &&
                      !flags.invalidMonth &&
                      !flags.invalidWeekday &&
                      !flags.weekdayMismatch &&
                      !flags.nullInput &&
                      !flags.invalidFormat &&
                      !flags.userInvalidated &&
                      (!flags.meridiem || (flags.meridiem && parsedParts));

              if (m._strict) {
                  isNowValid =
                      isNowValid &&
                      flags.charsLeftOver === 0 &&
                      flags.unusedTokens.length === 0 &&
                      flags.bigHour === undefined;
              }

              if (Object.isFrozen == null || !Object.isFrozen(m)) {
                  m._isValid = isNowValid;
              } else {
                  return isNowValid;
              }
          }
          return m._isValid;
      }

      function createInvalid(flags) {
          var m = createUTC(NaN);
          if (flags != null) {
              extend(getParsingFlags(m), flags);
          } else {
              getParsingFlags(m).userInvalidated = true;
          }

          return m;
      }

      // Plugins that add properties should also add the key here (null value),
      // so we can properly clone ourselves.
      var momentProperties = (hooks.momentProperties = []),
          updateInProgress = false;

      function copyConfig(to, from) {
          var i,
              prop,
              val,
              momentPropertiesLen = momentProperties.length;

          if (!isUndefined(from._isAMomentObject)) {
              to._isAMomentObject = from._isAMomentObject;
          }
          if (!isUndefined(from._i)) {
              to._i = from._i;
          }
          if (!isUndefined(from._f)) {
              to._f = from._f;
          }
          if (!isUndefined(from._l)) {
              to._l = from._l;
          }
          if (!isUndefined(from._strict)) {
              to._strict = from._strict;
          }
          if (!isUndefined(from._tzm)) {
              to._tzm = from._tzm;
          }
          if (!isUndefined(from._isUTC)) {
              to._isUTC = from._isUTC;
          }
          if (!isUndefined(from._offset)) {
              to._offset = from._offset;
          }
          if (!isUndefined(from._pf)) {
              to._pf = getParsingFlags(from);
          }
          if (!isUndefined(from._locale)) {
              to._locale = from._locale;
          }

          if (momentPropertiesLen > 0) {
              for (i = 0; i < momentPropertiesLen; i++) {
                  prop = momentProperties[i];
                  val = from[prop];
                  if (!isUndefined(val)) {
                      to[prop] = val;
                  }
              }
          }

          return to;
      }

      // Moment prototype object
      function Moment(config) {
          copyConfig(this, config);
          this._d = new Date(config._d != null ? config._d.getTime() : NaN);
          if (!this.isValid()) {
              this._d = new Date(NaN);
          }
          // Prevent infinite loop in case updateOffset creates new moment
          // objects.
          if (updateInProgress === false) {
              updateInProgress = true;
              hooks.updateOffset(this);
              updateInProgress = false;
          }
      }

      function isMoment(obj) {
          return (
              obj instanceof Moment || (obj != null && obj._isAMomentObject != null)
          );
      }

      function warn(msg) {
          if (
              hooks.suppressDeprecationWarnings === false &&
              typeof console !== 'undefined' &&
              console.warn
          ) {
              console.warn('Deprecation warning: ' + msg);
          }
      }

      function deprecate(msg, fn) {
          var firstTime = true;

          return extend(function () {
              if (hooks.deprecationHandler != null) {
                  hooks.deprecationHandler(null, msg);
              }
              if (firstTime) {
                  var args = [],
                      arg,
                      i,
                      key,
                      argLen = arguments.length;
                  for (i = 0; i < argLen; i++) {
                      arg = '';
                      if (typeof arguments[i] === 'object') {
                          arg += '\n[' + i + '] ';
                          for (key in arguments[0]) {
                              if (hasOwnProp(arguments[0], key)) {
                                  arg += key + ': ' + arguments[0][key] + ', ';
                              }
                          }
                          arg = arg.slice(0, -2); // Remove trailing comma and space
                      } else {
                          arg = arguments[i];
                      }
                      args.push(arg);
                  }
                  warn(
                      msg +
                          '\nArguments: ' +
                          Array.prototype.slice.call(args).join('') +
                          '\n' +
                          new Error().stack
                  );
                  firstTime = false;
              }
              return fn.apply(this, arguments);
          }, fn);
      }

      var deprecations = {};

      function deprecateSimple(name, msg) {
          if (hooks.deprecationHandler != null) {
              hooks.deprecationHandler(name, msg);
          }
          if (!deprecations[name]) {
              warn(msg);
              deprecations[name] = true;
          }
      }

      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;

      function isFunction(input) {
          return (
              (typeof Function !== 'undefined' && input instanceof Function) ||
              Object.prototype.toString.call(input) === '[object Function]'
          );
      }

      function set(config) {
          var prop, i;
          for (i in config) {
              if (hasOwnProp(config, i)) {
                  prop = config[i];
                  if (isFunction(prop)) {
                      this[i] = prop;
                  } else {
                      this['_' + i] = prop;
                  }
              }
          }
          this._config = config;
          // Lenient ordinal parsing accepts just a number in addition to
          // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
          // TODO: Remove "ordinalParse" fallback in next major release.
          this._dayOfMonthOrdinalParseLenient = new RegExp(
              (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                  '|' +
                  /\d{1,2}/.source
          );
      }

      function mergeConfigs(parentConfig, childConfig) {
          var res = extend({}, parentConfig),
              prop;
          for (prop in childConfig) {
              if (hasOwnProp(childConfig, prop)) {
                  if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                      res[prop] = {};
                      extend(res[prop], parentConfig[prop]);
                      extend(res[prop], childConfig[prop]);
                  } else if (childConfig[prop] != null) {
                      res[prop] = childConfig[prop];
                  } else {
                      delete res[prop];
                  }
              }
          }
          for (prop in parentConfig) {
              if (
                  hasOwnProp(parentConfig, prop) &&
                  !hasOwnProp(childConfig, prop) &&
                  isObject(parentConfig[prop])
              ) {
                  // make sure changes to properties don't modify parent config
                  res[prop] = extend({}, res[prop]);
              }
          }
          return res;
      }

      function Locale(config) {
          if (config != null) {
              this.set(config);
          }
      }

      var keys;

      if (Object.keys) {
          keys = Object.keys;
      } else {
          keys = function (obj) {
              var i,
                  res = [];
              for (i in obj) {
                  if (hasOwnProp(obj, i)) {
                      res.push(i);
                  }
              }
              return res;
          };
      }

      var defaultCalendar = {
          sameDay: '[Today at] LT',
          nextDay: '[Tomorrow at] LT',
          nextWeek: 'dddd [at] LT',
          lastDay: '[Yesterday at] LT',
          lastWeek: '[Last] dddd [at] LT',
          sameElse: 'L',
      };

      function calendar(key, mom, now) {
          var output = this._calendar[key] || this._calendar['sameElse'];
          return isFunction(output) ? output.call(mom, now) : output;
      }

      function zeroFill(number, targetLength, forceSign) {
          var absNumber = '' + Math.abs(number),
              zerosToFill = targetLength - absNumber.length,
              sign = number >= 0;
          return (
              (sign ? (forceSign ? '+' : '') : '-') +
              Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
              absNumber
          );
      }

      var formattingTokens =
              /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
          localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
          formatFunctions = {},
          formatTokenFunctions = {};

      // token:    'M'
      // padded:   ['MM', 2]
      // ordinal:  'Mo'
      // callback: function () { this.month() + 1 }
      function addFormatToken(token, padded, ordinal, callback) {
          var func = callback;
          if (typeof callback === 'string') {
              func = function () {
                  return this[callback]();
              };
          }
          if (token) {
              formatTokenFunctions[token] = func;
          }
          if (padded) {
              formatTokenFunctions[padded[0]] = function () {
                  return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
              };
          }
          if (ordinal) {
              formatTokenFunctions[ordinal] = function () {
                  return this.localeData().ordinal(
                      func.apply(this, arguments),
                      token
                  );
              };
          }
      }

      function removeFormattingTokens(input) {
          if (input.match(/\[[\s\S]/)) {
              return input.replace(/^\[|\]$/g, '');
          }
          return input.replace(/\\/g, '');
      }

      function makeFormatFunction(format) {
          var array = format.match(formattingTokens),
              i,
              length;

          for (i = 0, length = array.length; i < length; i++) {
              if (formatTokenFunctions[array[i]]) {
                  array[i] = formatTokenFunctions[array[i]];
              } else {
                  array[i] = removeFormattingTokens(array[i]);
              }
          }

          return function (mom) {
              var output = '',
                  i;
              for (i = 0; i < length; i++) {
                  output += isFunction(array[i])
                      ? array[i].call(mom, format)
                      : array[i];
              }
              return output;
          };
      }

      // format date using native date object
      function formatMoment(m, format) {
          if (!m.isValid()) {
              return m.localeData().invalidDate();
          }

          format = expandFormat(format, m.localeData());
          formatFunctions[format] =
              formatFunctions[format] || makeFormatFunction(format);

          return formatFunctions[format](m);
      }

      function expandFormat(format, locale) {
          var i = 5;

          function replaceLongDateFormatTokens(input) {
              return locale.longDateFormat(input) || input;
          }

          localFormattingTokens.lastIndex = 0;
          while (i >= 0 && localFormattingTokens.test(format)) {
              format = format.replace(
                  localFormattingTokens,
                  replaceLongDateFormatTokens
              );
              localFormattingTokens.lastIndex = 0;
              i -= 1;
          }

          return format;
      }

      var defaultLongDateFormat = {
          LTS: 'h:mm:ss A',
          LT: 'h:mm A',
          L: 'MM/DD/YYYY',
          LL: 'MMMM D, YYYY',
          LLL: 'MMMM D, YYYY h:mm A',
          LLLL: 'dddd, MMMM D, YYYY h:mm A',
      };

      function longDateFormat(key) {
          var format = this._longDateFormat[key],
              formatUpper = this._longDateFormat[key.toUpperCase()];

          if (format || !formatUpper) {
              return format;
          }

          this._longDateFormat[key] = formatUpper
              .match(formattingTokens)
              .map(function (tok) {
                  if (
                      tok === 'MMMM' ||
                      tok === 'MM' ||
                      tok === 'DD' ||
                      tok === 'dddd'
                  ) {
                      return tok.slice(1);
                  }
                  return tok;
              })
              .join('');

          return this._longDateFormat[key];
      }

      var defaultInvalidDate = 'Invalid date';

      function invalidDate() {
          return this._invalidDate;
      }

      var defaultOrdinal = '%d',
          defaultDayOfMonthOrdinalParse = /\d{1,2}/;

      function ordinal(number) {
          return this._ordinal.replace('%d', number);
      }

      var defaultRelativeTime = {
          future: 'in %s',
          past: '%s ago',
          s: 'a few seconds',
          ss: '%d seconds',
          m: 'a minute',
          mm: '%d minutes',
          h: 'an hour',
          hh: '%d hours',
          d: 'a day',
          dd: '%d days',
          w: 'a week',
          ww: '%d weeks',
          M: 'a month',
          MM: '%d months',
          y: 'a year',
          yy: '%d years',
      };

      function relativeTime(number, withoutSuffix, string, isFuture) {
          var output = this._relativeTime[string];
          return isFunction(output)
              ? output(number, withoutSuffix, string, isFuture)
              : output.replace(/%d/i, number);
      }

      function pastFuture(diff, output) {
          var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
          return isFunction(format) ? format(output) : format.replace(/%s/i, output);
      }

      var aliases = {};

      function addUnitAlias(unit, shorthand) {
          var lowerCase = unit.toLowerCase();
          aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
      }

      function normalizeUnits(units) {
          return typeof units === 'string'
              ? aliases[units] || aliases[units.toLowerCase()]
              : undefined;
      }

      function normalizeObjectUnits(inputObject) {
          var normalizedInput = {},
              normalizedProp,
              prop;

          for (prop in inputObject) {
              if (hasOwnProp(inputObject, prop)) {
                  normalizedProp = normalizeUnits(prop);
                  if (normalizedProp) {
                      normalizedInput[normalizedProp] = inputObject[prop];
                  }
              }
          }

          return normalizedInput;
      }

      var priorities = {};

      function addUnitPriority(unit, priority) {
          priorities[unit] = priority;
      }

      function getPrioritizedUnits(unitsObj) {
          var units = [],
              u;
          for (u in unitsObj) {
              if (hasOwnProp(unitsObj, u)) {
                  units.push({ unit: u, priority: priorities[u] });
              }
          }
          units.sort(function (a, b) {
              return a.priority - b.priority;
          });
          return units;
      }

      function isLeapYear(year) {
          return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
      }

      function absFloor(number) {
          if (number < 0) {
              // -0 -> 0
              return Math.ceil(number) || 0;
          } else {
              return Math.floor(number);
          }
      }

      function toInt(argumentForCoercion) {
          var coercedNumber = +argumentForCoercion,
              value = 0;

          if (coercedNumber !== 0 && isFinite(coercedNumber)) {
              value = absFloor(coercedNumber);
          }

          return value;
      }

      function makeGetSet(unit, keepTime) {
          return function (value) {
              if (value != null) {
                  set$1(this, unit, value);
                  hooks.updateOffset(this, keepTime);
                  return this;
              } else {
                  return get(this, unit);
              }
          };
      }

      function get(mom, unit) {
          return mom.isValid()
              ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]()
              : NaN;
      }

      function set$1(mom, unit, value) {
          if (mom.isValid() && !isNaN(value)) {
              if (
                  unit === 'FullYear' &&
                  isLeapYear(mom.year()) &&
                  mom.month() === 1 &&
                  mom.date() === 29
              ) {
                  value = toInt(value);
                  mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](
                      value,
                      mom.month(),
                      daysInMonth(value, mom.month())
                  );
              } else {
                  mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
              }
          }
      }

      // MOMENTS

      function stringGet(units) {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
              return this[units]();
          }
          return this;
      }

      function stringSet(units, value) {
          if (typeof units === 'object') {
              units = normalizeObjectUnits(units);
              var prioritized = getPrioritizedUnits(units),
                  i,
                  prioritizedLen = prioritized.length;
              for (i = 0; i < prioritizedLen; i++) {
                  this[prioritized[i].unit](units[prioritized[i].unit]);
              }
          } else {
              units = normalizeUnits(units);
              if (isFunction(this[units])) {
                  return this[units](value);
              }
          }
          return this;
      }

      var match1 = /\d/, //       0 - 9
          match2 = /\d\d/, //      00 - 99
          match3 = /\d{3}/, //     000 - 999
          match4 = /\d{4}/, //    0000 - 9999
          match6 = /[+-]?\d{6}/, // -999999 - 999999
          match1to2 = /\d\d?/, //       0 - 99
          match3to4 = /\d\d\d\d?/, //     999 - 9999
          match5to6 = /\d\d\d\d\d\d?/, //   99999 - 999999
          match1to3 = /\d{1,3}/, //       0 - 999
          match1to4 = /\d{1,4}/, //       0 - 9999
          match1to6 = /[+-]?\d{1,6}/, // -999999 - 999999
          matchUnsigned = /\d+/, //       0 - inf
          matchSigned = /[+-]?\d+/, //    -inf - inf
          matchOffset = /Z|[+-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
          matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, // +00 -00 +00:00 -00:00 +0000 -0000 or Z
          matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
          // any word (or two) characters or numbers including two/three word month in arabic.
          // includes scottish gaelic two word and hyphenated months
          matchWord =
              /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
          regexes;

      regexes = {};

      function addRegexToken(token, regex, strictRegex) {
          regexes[token] = isFunction(regex)
              ? regex
              : function (isStrict, localeData) {
                    return isStrict && strictRegex ? strictRegex : regex;
                };
      }

      function getParseRegexForToken(token, config) {
          if (!hasOwnProp(regexes, token)) {
              return new RegExp(unescapeFormat(token));
          }

          return regexes[token](config._strict, config._locale);
      }

      // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
      function unescapeFormat(s) {
          return regexEscape(
              s
                  .replace('\\', '')
                  .replace(
                      /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
                      function (matched, p1, p2, p3, p4) {
                          return p1 || p2 || p3 || p4;
                      }
                  )
          );
      }

      function regexEscape(s) {
          return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
      }

      var tokens = {};

      function addParseToken(token, callback) {
          var i,
              func = callback,
              tokenLen;
          if (typeof token === 'string') {
              token = [token];
          }
          if (isNumber(callback)) {
              func = function (input, array) {
                  array[callback] = toInt(input);
              };
          }
          tokenLen = token.length;
          for (i = 0; i < tokenLen; i++) {
              tokens[token[i]] = func;
          }
      }

      function addWeekParseToken(token, callback) {
          addParseToken(token, function (input, array, config, token) {
              config._w = config._w || {};
              callback(input, config._w, config, token);
          });
      }

      function addTimeToArrayFromToken(token, input, config) {
          if (input != null && hasOwnProp(tokens, token)) {
              tokens[token](input, config._a, config, token);
          }
      }

      var YEAR = 0,
          MONTH = 1,
          DATE = 2,
          HOUR = 3,
          MINUTE = 4,
          SECOND = 5,
          MILLISECOND = 6,
          WEEK = 7,
          WEEKDAY = 8;

      function mod(n, x) {
          return ((n % x) + x) % x;
      }

      var indexOf;

      if (Array.prototype.indexOf) {
          indexOf = Array.prototype.indexOf;
      } else {
          indexOf = function (o) {
              // I know
              var i;
              for (i = 0; i < this.length; ++i) {
                  if (this[i] === o) {
                      return i;
                  }
              }
              return -1;
          };
      }

      function daysInMonth(year, month) {
          if (isNaN(year) || isNaN(month)) {
              return NaN;
          }
          var modMonth = mod(month, 12);
          year += (month - modMonth) / 12;
          return modMonth === 1
              ? isLeapYear(year)
                  ? 29
                  : 28
              : 31 - ((modMonth % 7) % 2);
      }

      // FORMATTING

      addFormatToken('M', ['MM', 2], 'Mo', function () {
          return this.month() + 1;
      });

      addFormatToken('MMM', 0, 0, function (format) {
          return this.localeData().monthsShort(this, format);
      });

      addFormatToken('MMMM', 0, 0, function (format) {
          return this.localeData().months(this, format);
      });

      // ALIASES

      addUnitAlias('month', 'M');

      // PRIORITY

      addUnitPriority('month', 8);

      // PARSING

      addRegexToken('M', match1to2);
      addRegexToken('MM', match1to2, match2);
      addRegexToken('MMM', function (isStrict, locale) {
          return locale.monthsShortRegex(isStrict);
      });
      addRegexToken('MMMM', function (isStrict, locale) {
          return locale.monthsRegex(isStrict);
      });

      addParseToken(['M', 'MM'], function (input, array) {
          array[MONTH] = toInt(input) - 1;
      });

      addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
          var month = config._locale.monthsParse(input, token, config._strict);
          // if we didn't find a month name, mark the date as invalid.
          if (month != null) {
              array[MONTH] = month;
          } else {
              getParsingFlags(config).invalidMonth = input;
          }
      });

      // LOCALES

      var defaultLocaleMonths =
              'January_February_March_April_May_June_July_August_September_October_November_December'.split(
                  '_'
              ),
          defaultLocaleMonthsShort =
              'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
          MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
          defaultMonthsShortRegex = matchWord,
          defaultMonthsRegex = matchWord;

      function localeMonths(m, format) {
          if (!m) {
              return isArray(this._months)
                  ? this._months
                  : this._months['standalone'];
          }
          return isArray(this._months)
              ? this._months[m.month()]
              : this._months[
                    (this._months.isFormat || MONTHS_IN_FORMAT).test(format)
                        ? 'format'
                        : 'standalone'
                ][m.month()];
      }

      function localeMonthsShort(m, format) {
          if (!m) {
              return isArray(this._monthsShort)
                  ? this._monthsShort
                  : this._monthsShort['standalone'];
          }
          return isArray(this._monthsShort)
              ? this._monthsShort[m.month()]
              : this._monthsShort[
                    MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'
                ][m.month()];
      }

      function handleStrictParse(monthName, format, strict) {
          var i,
              ii,
              mom,
              llc = monthName.toLocaleLowerCase();
          if (!this._monthsParse) {
              // this is not used
              this._monthsParse = [];
              this._longMonthsParse = [];
              this._shortMonthsParse = [];
              for (i = 0; i < 12; ++i) {
                  mom = createUTC([2000, i]);
                  this._shortMonthsParse[i] = this.monthsShort(
                      mom,
                      ''
                  ).toLocaleLowerCase();
                  this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
              }
          }

          if (strict) {
              if (format === 'MMM') {
                  ii = indexOf.call(this._shortMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._longMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              }
          } else {
              if (format === 'MMM') {
                  ii = indexOf.call(this._shortMonthsParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._longMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._longMonthsParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._shortMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              }
          }
      }

      function localeMonthsParse(monthName, format, strict) {
          var i, mom, regex;

          if (this._monthsParseExact) {
              return handleStrictParse.call(this, monthName, format, strict);
          }

          if (!this._monthsParse) {
              this._monthsParse = [];
              this._longMonthsParse = [];
              this._shortMonthsParse = [];
          }

          // TODO: add sorting
          // Sorting makes sure if one month (or abbr) is a prefix of another
          // see sorting in computeMonthsParse
          for (i = 0; i < 12; i++) {
              // make the regex if we don't have it already
              mom = createUTC([2000, i]);
              if (strict && !this._longMonthsParse[i]) {
                  this._longMonthsParse[i] = new RegExp(
                      '^' + this.months(mom, '').replace('.', '') + '$',
                      'i'
                  );
                  this._shortMonthsParse[i] = new RegExp(
                      '^' + this.monthsShort(mom, '').replace('.', '') + '$',
                      'i'
                  );
              }
              if (!strict && !this._monthsParse[i]) {
                  regex =
                      '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                  this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
              }
              // test the regex
              if (
                  strict &&
                  format === 'MMMM' &&
                  this._longMonthsParse[i].test(monthName)
              ) {
                  return i;
              } else if (
                  strict &&
                  format === 'MMM' &&
                  this._shortMonthsParse[i].test(monthName)
              ) {
                  return i;
              } else if (!strict && this._monthsParse[i].test(monthName)) {
                  return i;
              }
          }
      }

      // MOMENTS

      function setMonth(mom, value) {
          var dayOfMonth;

          if (!mom.isValid()) {
              // No op
              return mom;
          }

          if (typeof value === 'string') {
              if (/^\d+$/.test(value)) {
                  value = toInt(value);
              } else {
                  value = mom.localeData().monthsParse(value);
                  // TODO: Another silent failure?
                  if (!isNumber(value)) {
                      return mom;
                  }
              }
          }

          dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
          mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
          return mom;
      }

      function getSetMonth(value) {
          if (value != null) {
              setMonth(this, value);
              hooks.updateOffset(this, true);
              return this;
          } else {
              return get(this, 'Month');
          }
      }

      function getDaysInMonth() {
          return daysInMonth(this.year(), this.month());
      }

      function monthsShortRegex(isStrict) {
          if (this._monthsParseExact) {
              if (!hasOwnProp(this, '_monthsRegex')) {
                  computeMonthsParse.call(this);
              }
              if (isStrict) {
                  return this._monthsShortStrictRegex;
              } else {
                  return this._monthsShortRegex;
              }
          } else {
              if (!hasOwnProp(this, '_monthsShortRegex')) {
                  this._monthsShortRegex = defaultMonthsShortRegex;
              }
              return this._monthsShortStrictRegex && isStrict
                  ? this._monthsShortStrictRegex
                  : this._monthsShortRegex;
          }
      }

      function monthsRegex(isStrict) {
          if (this._monthsParseExact) {
              if (!hasOwnProp(this, '_monthsRegex')) {
                  computeMonthsParse.call(this);
              }
              if (isStrict) {
                  return this._monthsStrictRegex;
              } else {
                  return this._monthsRegex;
              }
          } else {
              if (!hasOwnProp(this, '_monthsRegex')) {
                  this._monthsRegex = defaultMonthsRegex;
              }
              return this._monthsStrictRegex && isStrict
                  ? this._monthsStrictRegex
                  : this._monthsRegex;
          }
      }

      function computeMonthsParse() {
          function cmpLenRev(a, b) {
              return b.length - a.length;
          }

          var shortPieces = [],
              longPieces = [],
              mixedPieces = [],
              i,
              mom;
          for (i = 0; i < 12; i++) {
              // make the regex if we don't have it already
              mom = createUTC([2000, i]);
              shortPieces.push(this.monthsShort(mom, ''));
              longPieces.push(this.months(mom, ''));
              mixedPieces.push(this.months(mom, ''));
              mixedPieces.push(this.monthsShort(mom, ''));
          }
          // Sorting makes sure if one month (or abbr) is a prefix of another it
          // will match the longer piece.
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          for (i = 0; i < 12; i++) {
              shortPieces[i] = regexEscape(shortPieces[i]);
              longPieces[i] = regexEscape(longPieces[i]);
          }
          for (i = 0; i < 24; i++) {
              mixedPieces[i] = regexEscape(mixedPieces[i]);
          }

          this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._monthsShortRegex = this._monthsRegex;
          this._monthsStrictRegex = new RegExp(
              '^(' + longPieces.join('|') + ')',
              'i'
          );
          this._monthsShortStrictRegex = new RegExp(
              '^(' + shortPieces.join('|') + ')',
              'i'
          );
      }

      // FORMATTING

      addFormatToken('Y', 0, 0, function () {
          var y = this.year();
          return y <= 9999 ? zeroFill(y, 4) : '+' + y;
      });

      addFormatToken(0, ['YY', 2], 0, function () {
          return this.year() % 100;
      });

      addFormatToken(0, ['YYYY', 4], 0, 'year');
      addFormatToken(0, ['YYYYY', 5], 0, 'year');
      addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

      // ALIASES

      addUnitAlias('year', 'y');

      // PRIORITIES

      addUnitPriority('year', 1);

      // PARSING

      addRegexToken('Y', matchSigned);
      addRegexToken('YY', match1to2, match2);
      addRegexToken('YYYY', match1to4, match4);
      addRegexToken('YYYYY', match1to6, match6);
      addRegexToken('YYYYYY', match1to6, match6);

      addParseToken(['YYYYY', 'YYYYYY'], YEAR);
      addParseToken('YYYY', function (input, array) {
          array[YEAR] =
              input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken('YY', function (input, array) {
          array[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken('Y', function (input, array) {
          array[YEAR] = parseInt(input, 10);
      });

      // HELPERS

      function daysInYear(year) {
          return isLeapYear(year) ? 366 : 365;
      }

      // HOOKS

      hooks.parseTwoDigitYear = function (input) {
          return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
      };

      // MOMENTS

      var getSetYear = makeGetSet('FullYear', true);

      function getIsLeapYear() {
          return isLeapYear(this.year());
      }

      function createDate(y, m, d, h, M, s, ms) {
          // can't just apply() to create a date:
          // https://stackoverflow.com/q/181348
          var date;
          // the date constructor remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
              // preserve leap years using a full 400 year cycle, then reset
              date = new Date(y + 400, m, d, h, M, s, ms);
              if (isFinite(date.getFullYear())) {
                  date.setFullYear(y);
              }
          } else {
              date = new Date(y, m, d, h, M, s, ms);
          }

          return date;
      }

      function createUTCDate(y) {
          var date, args;
          // the Date.UTC function remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
              args = Array.prototype.slice.call(arguments);
              // preserve leap years using a full 400 year cycle, then reset
              args[0] = y + 400;
              date = new Date(Date.UTC.apply(null, args));
              if (isFinite(date.getUTCFullYear())) {
                  date.setUTCFullYear(y);
              }
          } else {
              date = new Date(Date.UTC.apply(null, arguments));
          }

          return date;
      }

      // start-of-first-week - start-of-year
      function firstWeekOffset(year, dow, doy) {
          var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
              fwd = 7 + dow - doy,
              // first-week day local weekday -- which local weekday is fwd
              fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

          return -fwdlw + fwd - 1;
      }

      // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
          var localWeekday = (7 + weekday - dow) % 7,
              weekOffset = firstWeekOffset(year, dow, doy),
              dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
              resYear,
              resDayOfYear;

          if (dayOfYear <= 0) {
              resYear = year - 1;
              resDayOfYear = daysInYear(resYear) + dayOfYear;
          } else if (dayOfYear > daysInYear(year)) {
              resYear = year + 1;
              resDayOfYear = dayOfYear - daysInYear(year);
          } else {
              resYear = year;
              resDayOfYear = dayOfYear;
          }

          return {
              year: resYear,
              dayOfYear: resDayOfYear,
          };
      }

      function weekOfYear(mom, dow, doy) {
          var weekOffset = firstWeekOffset(mom.year(), dow, doy),
              week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
              resWeek,
              resYear;

          if (week < 1) {
              resYear = mom.year() - 1;
              resWeek = week + weeksInYear(resYear, dow, doy);
          } else if (week > weeksInYear(mom.year(), dow, doy)) {
              resWeek = week - weeksInYear(mom.year(), dow, doy);
              resYear = mom.year() + 1;
          } else {
              resYear = mom.year();
              resWeek = week;
          }

          return {
              week: resWeek,
              year: resYear,
          };
      }

      function weeksInYear(year, dow, doy) {
          var weekOffset = firstWeekOffset(year, dow, doy),
              weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
          return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }

      // FORMATTING

      addFormatToken('w', ['ww', 2], 'wo', 'week');
      addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

      // ALIASES

      addUnitAlias('week', 'w');
      addUnitAlias('isoWeek', 'W');

      // PRIORITIES

      addUnitPriority('week', 5);
      addUnitPriority('isoWeek', 5);

      // PARSING

      addRegexToken('w', match1to2);
      addRegexToken('ww', match1to2, match2);
      addRegexToken('W', match1to2);
      addRegexToken('WW', match1to2, match2);

      addWeekParseToken(
          ['w', 'ww', 'W', 'WW'],
          function (input, week, config, token) {
              week[token.substr(0, 1)] = toInt(input);
          }
      );

      // HELPERS

      // LOCALES

      function localeWeek(mom) {
          return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }

      var defaultLocaleWeek = {
          dow: 0, // Sunday is the first day of the week.
          doy: 6, // The week that contains Jan 6th is the first week of the year.
      };

      function localeFirstDayOfWeek() {
          return this._week.dow;
      }

      function localeFirstDayOfYear() {
          return this._week.doy;
      }

      // MOMENTS

      function getSetWeek(input) {
          var week = this.localeData().week(this);
          return input == null ? week : this.add((input - week) * 7, 'd');
      }

      function getSetISOWeek(input) {
          var week = weekOfYear(this, 1, 4).week;
          return input == null ? week : this.add((input - week) * 7, 'd');
      }

      // FORMATTING

      addFormatToken('d', 0, 'do', 'day');

      addFormatToken('dd', 0, 0, function (format) {
          return this.localeData().weekdaysMin(this, format);
      });

      addFormatToken('ddd', 0, 0, function (format) {
          return this.localeData().weekdaysShort(this, format);
      });

      addFormatToken('dddd', 0, 0, function (format) {
          return this.localeData().weekdays(this, format);
      });

      addFormatToken('e', 0, 0, 'weekday');
      addFormatToken('E', 0, 0, 'isoWeekday');

      // ALIASES

      addUnitAlias('day', 'd');
      addUnitAlias('weekday', 'e');
      addUnitAlias('isoWeekday', 'E');

      // PRIORITY
      addUnitPriority('day', 11);
      addUnitPriority('weekday', 11);
      addUnitPriority('isoWeekday', 11);

      // PARSING

      addRegexToken('d', match1to2);
      addRegexToken('e', match1to2);
      addRegexToken('E', match1to2);
      addRegexToken('dd', function (isStrict, locale) {
          return locale.weekdaysMinRegex(isStrict);
      });
      addRegexToken('ddd', function (isStrict, locale) {
          return locale.weekdaysShortRegex(isStrict);
      });
      addRegexToken('dddd', function (isStrict, locale) {
          return locale.weekdaysRegex(isStrict);
      });

      addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
          var weekday = config._locale.weekdaysParse(input, token, config._strict);
          // if we didn't get a weekday name, mark the date as invalid
          if (weekday != null) {
              week.d = weekday;
          } else {
              getParsingFlags(config).invalidWeekday = input;
          }
      });

      addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
          week[token] = toInt(input);
      });

      // HELPERS

      function parseWeekday(input, locale) {
          if (typeof input !== 'string') {
              return input;
          }

          if (!isNaN(input)) {
              return parseInt(input, 10);
          }

          input = locale.weekdaysParse(input);
          if (typeof input === 'number') {
              return input;
          }

          return null;
      }

      function parseIsoWeekday(input, locale) {
          if (typeof input === 'string') {
              return locale.weekdaysParse(input) % 7 || 7;
          }
          return isNaN(input) ? null : input;
      }

      // LOCALES
      function shiftWeekdays(ws, n) {
          return ws.slice(n, 7).concat(ws.slice(0, n));
      }

      var defaultLocaleWeekdays =
              'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
          defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
          defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
          defaultWeekdaysRegex = matchWord,
          defaultWeekdaysShortRegex = matchWord,
          defaultWeekdaysMinRegex = matchWord;

      function localeWeekdays(m, format) {
          var weekdays = isArray(this._weekdays)
              ? this._weekdays
              : this._weekdays[
                    m && m !== true && this._weekdays.isFormat.test(format)
                        ? 'format'
                        : 'standalone'
                ];
          return m === true
              ? shiftWeekdays(weekdays, this._week.dow)
              : m
              ? weekdays[m.day()]
              : weekdays;
      }

      function localeWeekdaysShort(m) {
          return m === true
              ? shiftWeekdays(this._weekdaysShort, this._week.dow)
              : m
              ? this._weekdaysShort[m.day()]
              : this._weekdaysShort;
      }

      function localeWeekdaysMin(m) {
          return m === true
              ? shiftWeekdays(this._weekdaysMin, this._week.dow)
              : m
              ? this._weekdaysMin[m.day()]
              : this._weekdaysMin;
      }

      function handleStrictParse$1(weekdayName, format, strict) {
          var i,
              ii,
              mom,
              llc = weekdayName.toLocaleLowerCase();
          if (!this._weekdaysParse) {
              this._weekdaysParse = [];
              this._shortWeekdaysParse = [];
              this._minWeekdaysParse = [];

              for (i = 0; i < 7; ++i) {
                  mom = createUTC([2000, 1]).day(i);
                  this._minWeekdaysParse[i] = this.weekdaysMin(
                      mom,
                      ''
                  ).toLocaleLowerCase();
                  this._shortWeekdaysParse[i] = this.weekdaysShort(
                      mom,
                      ''
                  ).toLocaleLowerCase();
                  this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
              }
          }

          if (strict) {
              if (format === 'dddd') {
                  ii = indexOf.call(this._weekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else if (format === 'ddd') {
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              }
          } else {
              if (format === 'dddd') {
                  ii = indexOf.call(this._weekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else if (format === 'ddd') {
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._weekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._weekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              }
          }
      }

      function localeWeekdaysParse(weekdayName, format, strict) {
          var i, mom, regex;

          if (this._weekdaysParseExact) {
              return handleStrictParse$1.call(this, weekdayName, format, strict);
          }

          if (!this._weekdaysParse) {
              this._weekdaysParse = [];
              this._minWeekdaysParse = [];
              this._shortWeekdaysParse = [];
              this._fullWeekdaysParse = [];
          }

          for (i = 0; i < 7; i++) {
              // make the regex if we don't have it already

              mom = createUTC([2000, 1]).day(i);
              if (strict && !this._fullWeekdaysParse[i]) {
                  this._fullWeekdaysParse[i] = new RegExp(
                      '^' + this.weekdays(mom, '').replace('.', '\\.?') + '$',
                      'i'
                  );
                  this._shortWeekdaysParse[i] = new RegExp(
                      '^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$',
                      'i'
                  );
                  this._minWeekdaysParse[i] = new RegExp(
                      '^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$',
                      'i'
                  );
              }
              if (!this._weekdaysParse[i]) {
                  regex =
                      '^' +
                      this.weekdays(mom, '') +
                      '|^' +
                      this.weekdaysShort(mom, '') +
                      '|^' +
                      this.weekdaysMin(mom, '');
                  this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
              }
              // test the regex
              if (
                  strict &&
                  format === 'dddd' &&
                  this._fullWeekdaysParse[i].test(weekdayName)
              ) {
                  return i;
              } else if (
                  strict &&
                  format === 'ddd' &&
                  this._shortWeekdaysParse[i].test(weekdayName)
              ) {
                  return i;
              } else if (
                  strict &&
                  format === 'dd' &&
                  this._minWeekdaysParse[i].test(weekdayName)
              ) {
                  return i;
              } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                  return i;
              }
          }
      }

      // MOMENTS

      function getSetDayOfWeek(input) {
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }
          var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
          if (input != null) {
              input = parseWeekday(input, this.localeData());
              return this.add(input - day, 'd');
          } else {
              return day;
          }
      }

      function getSetLocaleDayOfWeek(input) {
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }
          var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
          return input == null ? weekday : this.add(input - weekday, 'd');
      }

      function getSetISODayOfWeek(input) {
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }

          // behaves the same as moment#day except
          // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
          // as a setter, sunday should belong to the previous week.

          if (input != null) {
              var weekday = parseIsoWeekday(input, this.localeData());
              return this.day(this.day() % 7 ? weekday : weekday - 7);
          } else {
              return this.day() || 7;
          }
      }

      function weekdaysRegex(isStrict) {
          if (this._weekdaysParseExact) {
              if (!hasOwnProp(this, '_weekdaysRegex')) {
                  computeWeekdaysParse.call(this);
              }
              if (isStrict) {
                  return this._weekdaysStrictRegex;
              } else {
                  return this._weekdaysRegex;
              }
          } else {
              if (!hasOwnProp(this, '_weekdaysRegex')) {
                  this._weekdaysRegex = defaultWeekdaysRegex;
              }
              return this._weekdaysStrictRegex && isStrict
                  ? this._weekdaysStrictRegex
                  : this._weekdaysRegex;
          }
      }

      function weekdaysShortRegex(isStrict) {
          if (this._weekdaysParseExact) {
              if (!hasOwnProp(this, '_weekdaysRegex')) {
                  computeWeekdaysParse.call(this);
              }
              if (isStrict) {
                  return this._weekdaysShortStrictRegex;
              } else {
                  return this._weekdaysShortRegex;
              }
          } else {
              if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                  this._weekdaysShortRegex = defaultWeekdaysShortRegex;
              }
              return this._weekdaysShortStrictRegex && isStrict
                  ? this._weekdaysShortStrictRegex
                  : this._weekdaysShortRegex;
          }
      }

      function weekdaysMinRegex(isStrict) {
          if (this._weekdaysParseExact) {
              if (!hasOwnProp(this, '_weekdaysRegex')) {
                  computeWeekdaysParse.call(this);
              }
              if (isStrict) {
                  return this._weekdaysMinStrictRegex;
              } else {
                  return this._weekdaysMinRegex;
              }
          } else {
              if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                  this._weekdaysMinRegex = defaultWeekdaysMinRegex;
              }
              return this._weekdaysMinStrictRegex && isStrict
                  ? this._weekdaysMinStrictRegex
                  : this._weekdaysMinRegex;
          }
      }

      function computeWeekdaysParse() {
          function cmpLenRev(a, b) {
              return b.length - a.length;
          }

          var minPieces = [],
              shortPieces = [],
              longPieces = [],
              mixedPieces = [],
              i,
              mom,
              minp,
              shortp,
              longp;
          for (i = 0; i < 7; i++) {
              // make the regex if we don't have it already
              mom = createUTC([2000, 1]).day(i);
              minp = regexEscape(this.weekdaysMin(mom, ''));
              shortp = regexEscape(this.weekdaysShort(mom, ''));
              longp = regexEscape(this.weekdays(mom, ''));
              minPieces.push(minp);
              shortPieces.push(shortp);
              longPieces.push(longp);
              mixedPieces.push(minp);
              mixedPieces.push(shortp);
              mixedPieces.push(longp);
          }
          // Sorting makes sure if one weekday (or abbr) is a prefix of another it
          // will match the longer piece.
          minPieces.sort(cmpLenRev);
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);

          this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._weekdaysShortRegex = this._weekdaysRegex;
          this._weekdaysMinRegex = this._weekdaysRegex;

          this._weekdaysStrictRegex = new RegExp(
              '^(' + longPieces.join('|') + ')',
              'i'
          );
          this._weekdaysShortStrictRegex = new RegExp(
              '^(' + shortPieces.join('|') + ')',
              'i'
          );
          this._weekdaysMinStrictRegex = new RegExp(
              '^(' + minPieces.join('|') + ')',
              'i'
          );
      }

      // FORMATTING

      function hFormat() {
          return this.hours() % 12 || 12;
      }

      function kFormat() {
          return this.hours() || 24;
      }

      addFormatToken('H', ['HH', 2], 0, 'hour');
      addFormatToken('h', ['hh', 2], 0, hFormat);
      addFormatToken('k', ['kk', 2], 0, kFormat);

      addFormatToken('hmm', 0, 0, function () {
          return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });

      addFormatToken('hmmss', 0, 0, function () {
          return (
              '' +
              hFormat.apply(this) +
              zeroFill(this.minutes(), 2) +
              zeroFill(this.seconds(), 2)
          );
      });

      addFormatToken('Hmm', 0, 0, function () {
          return '' + this.hours() + zeroFill(this.minutes(), 2);
      });

      addFormatToken('Hmmss', 0, 0, function () {
          return (
              '' +
              this.hours() +
              zeroFill(this.minutes(), 2) +
              zeroFill(this.seconds(), 2)
          );
      });

      function meridiem(token, lowercase) {
          addFormatToken(token, 0, 0, function () {
              return this.localeData().meridiem(
                  this.hours(),
                  this.minutes(),
                  lowercase
              );
          });
      }

      meridiem('a', true);
      meridiem('A', false);

      // ALIASES

      addUnitAlias('hour', 'h');

      // PRIORITY
      addUnitPriority('hour', 13);

      // PARSING

      function matchMeridiem(isStrict, locale) {
          return locale._meridiemParse;
      }

      addRegexToken('a', matchMeridiem);
      addRegexToken('A', matchMeridiem);
      addRegexToken('H', match1to2);
      addRegexToken('h', match1to2);
      addRegexToken('k', match1to2);
      addRegexToken('HH', match1to2, match2);
      addRegexToken('hh', match1to2, match2);
      addRegexToken('kk', match1to2, match2);

      addRegexToken('hmm', match3to4);
      addRegexToken('hmmss', match5to6);
      addRegexToken('Hmm', match3to4);
      addRegexToken('Hmmss', match5to6);

      addParseToken(['H', 'HH'], HOUR);
      addParseToken(['k', 'kk'], function (input, array, config) {
          var kInput = toInt(input);
          array[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(['a', 'A'], function (input, array, config) {
          config._isPm = config._locale.isPM(input);
          config._meridiem = input;
      });
      addParseToken(['h', 'hh'], function (input, array, config) {
          array[HOUR] = toInt(input);
          getParsingFlags(config).bigHour = true;
      });
      addParseToken('hmm', function (input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
          getParsingFlags(config).bigHour = true;
      });
      addParseToken('hmmss', function (input, array, config) {
          var pos1 = input.length - 4,
              pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
          getParsingFlags(config).bigHour = true;
      });
      addParseToken('Hmm', function (input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken('Hmmss', function (input, array, config) {
          var pos1 = input.length - 4,
              pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
      });

      // LOCALES

      function localeIsPM(input) {
          // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
          // Using charAt should be more compatible.
          return (input + '').toLowerCase().charAt(0) === 'p';
      }

      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
          // Setting the hour should keep the time, because the user explicitly
          // specified which hour they want. So trying to maintain the same hour (in
          // a new timezone) makes sense. Adding/subtracting hours does not follow
          // this rule.
          getSetHour = makeGetSet('Hours', true);

      function localeMeridiem(hours, minutes, isLower) {
          if (hours > 11) {
              return isLower ? 'pm' : 'PM';
          } else {
              return isLower ? 'am' : 'AM';
          }
      }

      var baseConfig = {
          calendar: defaultCalendar,
          longDateFormat: defaultLongDateFormat,
          invalidDate: defaultInvalidDate,
          ordinal: defaultOrdinal,
          dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
          relativeTime: defaultRelativeTime,

          months: defaultLocaleMonths,
          monthsShort: defaultLocaleMonthsShort,

          week: defaultLocaleWeek,

          weekdays: defaultLocaleWeekdays,
          weekdaysMin: defaultLocaleWeekdaysMin,
          weekdaysShort: defaultLocaleWeekdaysShort,

          meridiemParse: defaultLocaleMeridiemParse,
      };

      // internal storage for locale config files
      var locales = {},
          localeFamilies = {},
          globalLocale;

      function commonPrefix(arr1, arr2) {
          var i,
              minl = Math.min(arr1.length, arr2.length);
          for (i = 0; i < minl; i += 1) {
              if (arr1[i] !== arr2[i]) {
                  return i;
              }
          }
          return minl;
      }

      function normalizeLocale(key) {
          return key ? key.toLowerCase().replace('_', '-') : key;
      }

      // pick the locale from the array
      // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
      // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
      function chooseLocale(names) {
          var i = 0,
              j,
              next,
              locale,
              split;

          while (i < names.length) {
              split = normalizeLocale(names[i]).split('-');
              j = split.length;
              next = normalizeLocale(names[i + 1]);
              next = next ? next.split('-') : null;
              while (j > 0) {
                  locale = loadLocale(split.slice(0, j).join('-'));
                  if (locale) {
                      return locale;
                  }
                  if (
                      next &&
                      next.length >= j &&
                      commonPrefix(split, next) >= j - 1
                  ) {
                      //the next array item is better than a shallower substring of this one
                      break;
                  }
                  j--;
              }
              i++;
          }
          return globalLocale;
      }

      function isLocaleNameSane(name) {
          // Prevent names that look like filesystem paths, i.e contain '/' or '\'
          return name.match('^[^/\\\\]*$') != null;
      }

      function loadLocale(name) {
          var oldLocale = null,
              aliasedRequire;
          // TODO: Find a better way to register and load all the locales in Node
          if (
              locales[name] === undefined &&
              'object' !== 'undefined' &&
              module &&
              module.exports &&
              isLocaleNameSane(name)
          ) {
              try {
                  oldLocale = globalLocale._abbr;
                  aliasedRequire = commonjsRequire;
                  aliasedRequire('./locale/' + name);
                  getSetGlobalLocale(oldLocale);
              } catch (e) {
                  // mark as not found to avoid repeating expensive file require call causing high CPU
                  // when trying to find en-US, en_US, en-us for every format call
                  locales[name] = null; // null means not found
              }
          }
          return locales[name];
      }

      // This function will load locale and then set the global locale.  If
      // no arguments are passed in, it will simply return the current global
      // locale key.
      function getSetGlobalLocale(key, values) {
          var data;
          if (key) {
              if (isUndefined(values)) {
                  data = getLocale(key);
              } else {
                  data = defineLocale(key, values);
              }

              if (data) {
                  // moment.duration._locale = moment._locale = data;
                  globalLocale = data;
              } else {
                  if (typeof console !== 'undefined' && console.warn) {
                      //warn user if arguments are passed but the locale could not be set
                      console.warn(
                          'Locale ' + key + ' not found. Did you forget to load it?'
                      );
                  }
              }
          }

          return globalLocale._abbr;
      }

      function defineLocale(name, config) {
          if (config !== null) {
              var locale,
                  parentConfig = baseConfig;
              config.abbr = name;
              if (locales[name] != null) {
                  deprecateSimple(
                      'defineLocaleOverride',
                      'use moment.updateLocale(localeName, config) to change ' +
                          'an existing locale. moment.defineLocale(localeName, ' +
                          'config) should only be used for creating a new locale ' +
                          'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'
                  );
                  parentConfig = locales[name]._config;
              } else if (config.parentLocale != null) {
                  if (locales[config.parentLocale] != null) {
                      parentConfig = locales[config.parentLocale]._config;
                  } else {
                      locale = loadLocale(config.parentLocale);
                      if (locale != null) {
                          parentConfig = locale._config;
                      } else {
                          if (!localeFamilies[config.parentLocale]) {
                              localeFamilies[config.parentLocale] = [];
                          }
                          localeFamilies[config.parentLocale].push({
                              name: name,
                              config: config,
                          });
                          return null;
                      }
                  }
              }
              locales[name] = new Locale(mergeConfigs(parentConfig, config));

              if (localeFamilies[name]) {
                  localeFamilies[name].forEach(function (x) {
                      defineLocale(x.name, x.config);
                  });
              }

              // backwards compat for now: also set the locale
              // make sure we set the locale AFTER all child locales have been
              // created, so we won't end up with the child locale set.
              getSetGlobalLocale(name);

              return locales[name];
          } else {
              // useful for testing
              delete locales[name];
              return null;
          }
      }

      function updateLocale(name, config) {
          if (config != null) {
              var locale,
                  tmpLocale,
                  parentConfig = baseConfig;

              if (locales[name] != null && locales[name].parentLocale != null) {
                  // Update existing child locale in-place to avoid memory-leaks
                  locales[name].set(mergeConfigs(locales[name]._config, config));
              } else {
                  // MERGE
                  tmpLocale = loadLocale(name);
                  if (tmpLocale != null) {
                      parentConfig = tmpLocale._config;
                  }
                  config = mergeConfigs(parentConfig, config);
                  if (tmpLocale == null) {
                      // updateLocale is called for creating a new locale
                      // Set abbr so it will have a name (getters return
                      // undefined otherwise).
                      config.abbr = name;
                  }
                  locale = new Locale(config);
                  locale.parentLocale = locales[name];
                  locales[name] = locale;
              }

              // backwards compat for now: also set the locale
              getSetGlobalLocale(name);
          } else {
              // pass null for config to unupdate, useful for tests
              if (locales[name] != null) {
                  if (locales[name].parentLocale != null) {
                      locales[name] = locales[name].parentLocale;
                      if (name === getSetGlobalLocale()) {
                          getSetGlobalLocale(name);
                      }
                  } else if (locales[name] != null) {
                      delete locales[name];
                  }
              }
          }
          return locales[name];
      }

      // returns locale data
      function getLocale(key) {
          var locale;

          if (key && key._locale && key._locale._abbr) {
              key = key._locale._abbr;
          }

          if (!key) {
              return globalLocale;
          }

          if (!isArray(key)) {
              //short-circuit everything else
              locale = loadLocale(key);
              if (locale) {
                  return locale;
              }
              key = [key];
          }

          return chooseLocale(key);
      }

      function listLocales() {
          return keys(locales);
      }

      function checkOverflow(m) {
          var overflow,
              a = m._a;

          if (a && getParsingFlags(m).overflow === -2) {
              overflow =
                  a[MONTH] < 0 || a[MONTH] > 11
                      ? MONTH
                      : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])
                      ? DATE
                      : a[HOUR] < 0 ||
                        a[HOUR] > 24 ||
                        (a[HOUR] === 24 &&
                            (a[MINUTE] !== 0 ||
                                a[SECOND] !== 0 ||
                                a[MILLISECOND] !== 0))
                      ? HOUR
                      : a[MINUTE] < 0 || a[MINUTE] > 59
                      ? MINUTE
                      : a[SECOND] < 0 || a[SECOND] > 59
                      ? SECOND
                      : a[MILLISECOND] < 0 || a[MILLISECOND] > 999
                      ? MILLISECOND
                      : -1;

              if (
                  getParsingFlags(m)._overflowDayOfYear &&
                  (overflow < YEAR || overflow > DATE)
              ) {
                  overflow = DATE;
              }
              if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                  overflow = WEEK;
              }
              if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                  overflow = WEEKDAY;
              }

              getParsingFlags(m).overflow = overflow;
          }

          return m;
      }

      // iso 8601 regex
      // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
      var extendedIsoRegex =
              /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
          basicIsoRegex =
              /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
          tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
          isoDates = [
              ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
              ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
              ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
              ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
              ['YYYY-DDD', /\d{4}-\d{3}/],
              ['YYYY-MM', /\d{4}-\d\d/, false],
              ['YYYYYYMMDD', /[+-]\d{10}/],
              ['YYYYMMDD', /\d{8}/],
              ['GGGG[W]WWE', /\d{4}W\d{3}/],
              ['GGGG[W]WW', /\d{4}W\d{2}/, false],
              ['YYYYDDD', /\d{7}/],
              ['YYYYMM', /\d{6}/, false],
              ['YYYY', /\d{4}/, false],
          ],
          // iso time formats and regexes
          isoTimes = [
              ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
              ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
              ['HH:mm:ss', /\d\d:\d\d:\d\d/],
              ['HH:mm', /\d\d:\d\d/],
              ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
              ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
              ['HHmmss', /\d\d\d\d\d\d/],
              ['HHmm', /\d\d\d\d/],
              ['HH', /\d\d/],
          ],
          aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
          // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
          rfc2822 =
              /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
          obsOffsets = {
              UT: 0,
              GMT: 0,
              EDT: -4 * 60,
              EST: -5 * 60,
              CDT: -5 * 60,
              CST: -6 * 60,
              MDT: -6 * 60,
              MST: -7 * 60,
              PDT: -7 * 60,
              PST: -8 * 60,
          };

      // date from iso format
      function configFromISO(config) {
          var i,
              l,
              string = config._i,
              match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
              allowTime,
              dateFormat,
              timeFormat,
              tzFormat,
              isoDatesLen = isoDates.length,
              isoTimesLen = isoTimes.length;

          if (match) {
              getParsingFlags(config).iso = true;
              for (i = 0, l = isoDatesLen; i < l; i++) {
                  if (isoDates[i][1].exec(match[1])) {
                      dateFormat = isoDates[i][0];
                      allowTime = isoDates[i][2] !== false;
                      break;
                  }
              }
              if (dateFormat == null) {
                  config._isValid = false;
                  return;
              }
              if (match[3]) {
                  for (i = 0, l = isoTimesLen; i < l; i++) {
                      if (isoTimes[i][1].exec(match[3])) {
                          // match[2] should be 'T' or space
                          timeFormat = (match[2] || ' ') + isoTimes[i][0];
                          break;
                      }
                  }
                  if (timeFormat == null) {
                      config._isValid = false;
                      return;
                  }
              }
              if (!allowTime && timeFormat != null) {
                  config._isValid = false;
                  return;
              }
              if (match[4]) {
                  if (tzRegex.exec(match[4])) {
                      tzFormat = 'Z';
                  } else {
                      config._isValid = false;
                      return;
                  }
              }
              config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
              configFromStringAndFormat(config);
          } else {
              config._isValid = false;
          }
      }

      function extractFromRFC2822Strings(
          yearStr,
          monthStr,
          dayStr,
          hourStr,
          minuteStr,
          secondStr
      ) {
          var result = [
              untruncateYear(yearStr),
              defaultLocaleMonthsShort.indexOf(monthStr),
              parseInt(dayStr, 10),
              parseInt(hourStr, 10),
              parseInt(minuteStr, 10),
          ];

          if (secondStr) {
              result.push(parseInt(secondStr, 10));
          }

          return result;
      }

      function untruncateYear(yearStr) {
          var year = parseInt(yearStr, 10);
          if (year <= 49) {
              return 2000 + year;
          } else if (year <= 999) {
              return 1900 + year;
          }
          return year;
      }

      function preprocessRFC2822(s) {
          // Remove comments and folding whitespace and replace multiple-spaces with a single space
          return s
              .replace(/\([^()]*\)|[\n\t]/g, ' ')
              .replace(/(\s\s+)/g, ' ')
              .replace(/^\s\s*/, '')
              .replace(/\s\s*$/, '');
      }

      function checkWeekday(weekdayStr, parsedInput, config) {
          if (weekdayStr) {
              // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
              var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                  weekdayActual = new Date(
                      parsedInput[0],
                      parsedInput[1],
                      parsedInput[2]
                  ).getDay();
              if (weekdayProvided !== weekdayActual) {
                  getParsingFlags(config).weekdayMismatch = true;
                  config._isValid = false;
                  return false;
              }
          }
          return true;
      }

      function calculateOffset(obsOffset, militaryOffset, numOffset) {
          if (obsOffset) {
              return obsOffsets[obsOffset];
          } else if (militaryOffset) {
              // the only allowed military tz is Z
              return 0;
          } else {
              var hm = parseInt(numOffset, 10),
                  m = hm % 100,
                  h = (hm - m) / 100;
              return h * 60 + m;
          }
      }

      // date and time from ref 2822 format
      function configFromRFC2822(config) {
          var match = rfc2822.exec(preprocessRFC2822(config._i)),
              parsedArray;
          if (match) {
              parsedArray = extractFromRFC2822Strings(
                  match[4],
                  match[3],
                  match[2],
                  match[5],
                  match[6],
                  match[7]
              );
              if (!checkWeekday(match[1], parsedArray, config)) {
                  return;
              }

              config._a = parsedArray;
              config._tzm = calculateOffset(match[8], match[9], match[10]);

              config._d = createUTCDate.apply(null, config._a);
              config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

              getParsingFlags(config).rfc2822 = true;
          } else {
              config._isValid = false;
          }
      }

      // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict
      function configFromString(config) {
          var matched = aspNetJsonRegex.exec(config._i);
          if (matched !== null) {
              config._d = new Date(+matched[1]);
              return;
          }

          configFromISO(config);
          if (config._isValid === false) {
              delete config._isValid;
          } else {
              return;
          }

          configFromRFC2822(config);
          if (config._isValid === false) {
              delete config._isValid;
          } else {
              return;
          }

          if (config._strict) {
              config._isValid = false;
          } else {
              // Final attempt, use Input Fallback
              hooks.createFromInputFallback(config);
          }
      }

      hooks.createFromInputFallback = deprecate(
          'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
              'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
              'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.',
          function (config) {
              config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
          }
      );

      // Pick the first defined of two or three arguments.
      function defaults(a, b, c) {
          if (a != null) {
              return a;
          }
          if (b != null) {
              return b;
          }
          return c;
      }

      function currentDateArray(config) {
          // hooks is actually the exported moment object
          var nowValue = new Date(hooks.now());
          if (config._useUTC) {
              return [
                  nowValue.getUTCFullYear(),
                  nowValue.getUTCMonth(),
                  nowValue.getUTCDate(),
              ];
          }
          return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }

      // convert an array to a date.
      // the array should mirror the parameters below
      // note: all values past the year are optional and will default to the lowest possible value.
      // [year, month, day , hour, minute, second, millisecond]
      function configFromArray(config) {
          var i,
              date,
              input = [],
              currentDate,
              expectedWeekday,
              yearToUse;

          if (config._d) {
              return;
          }

          currentDate = currentDateArray(config);

          //compute day of the year from weeks and weekdays
          if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
              dayOfYearFromWeekInfo(config);
          }

          //if the day of the year is set, figure out what it is
          if (config._dayOfYear != null) {
              yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

              if (
                  config._dayOfYear > daysInYear(yearToUse) ||
                  config._dayOfYear === 0
              ) {
                  getParsingFlags(config)._overflowDayOfYear = true;
              }

              date = createUTCDate(yearToUse, 0, config._dayOfYear);
              config._a[MONTH] = date.getUTCMonth();
              config._a[DATE] = date.getUTCDate();
          }

          // Default to current date.
          // * if no year, month, day of month are given, default to today
          // * if day of month is given, default month and year
          // * if month is given, default only year
          // * if year is given, don't default anything
          for (i = 0; i < 3 && config._a[i] == null; ++i) {
              config._a[i] = input[i] = currentDate[i];
          }

          // Zero out whatever was not defaulted, including time
          for (; i < 7; i++) {
              config._a[i] = input[i] =
                  config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];
          }

          // Check for 24:00:00.000
          if (
              config._a[HOUR] === 24 &&
              config._a[MINUTE] === 0 &&
              config._a[SECOND] === 0 &&
              config._a[MILLISECOND] === 0
          ) {
              config._nextDay = true;
              config._a[HOUR] = 0;
          }

          config._d = (config._useUTC ? createUTCDate : createDate).apply(
              null,
              input
          );
          expectedWeekday = config._useUTC
              ? config._d.getUTCDay()
              : config._d.getDay();

          // Apply timezone offset from input. The actual utcOffset can be changed
          // with parseZone.
          if (config._tzm != null) {
              config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          }

          if (config._nextDay) {
              config._a[HOUR] = 24;
          }

          // check for mismatching day of week
          if (
              config._w &&
              typeof config._w.d !== 'undefined' &&
              config._w.d !== expectedWeekday
          ) {
              getParsingFlags(config).weekdayMismatch = true;
          }
      }

      function dayOfYearFromWeekInfo(config) {
          var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;

          w = config._w;
          if (w.GG != null || w.W != null || w.E != null) {
              dow = 1;
              doy = 4;

              // TODO: We need to take the current isoWeekYear, but that depends on
              // how we interpret now (local, utc, fixed offset). So create
              // a now version of current config (take local/utc/offset flags, and
              // create now).
              weekYear = defaults(
                  w.GG,
                  config._a[YEAR],
                  weekOfYear(createLocal(), 1, 4).year
              );
              week = defaults(w.W, 1);
              weekday = defaults(w.E, 1);
              if (weekday < 1 || weekday > 7) {
                  weekdayOverflow = true;
              }
          } else {
              dow = config._locale._week.dow;
              doy = config._locale._week.doy;

              curWeek = weekOfYear(createLocal(), dow, doy);

              weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

              // Default to current week.
              week = defaults(w.w, curWeek.week);

              if (w.d != null) {
                  // weekday -- low day numbers are considered next week
                  weekday = w.d;
                  if (weekday < 0 || weekday > 6) {
                      weekdayOverflow = true;
                  }
              } else if (w.e != null) {
                  // local weekday -- counting starts from beginning of week
                  weekday = w.e + dow;
                  if (w.e < 0 || w.e > 6) {
                      weekdayOverflow = true;
                  }
              } else {
                  // default to beginning of week
                  weekday = dow;
              }
          }
          if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
              getParsingFlags(config)._overflowWeeks = true;
          } else if (weekdayOverflow != null) {
              getParsingFlags(config)._overflowWeekday = true;
          } else {
              temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
              config._a[YEAR] = temp.year;
              config._dayOfYear = temp.dayOfYear;
          }
      }

      // constant that refers to the ISO standard
      hooks.ISO_8601 = function () {};

      // constant that refers to the RFC 2822 form
      hooks.RFC_2822 = function () {};

      // date from string and format string
      function configFromStringAndFormat(config) {
          // TODO: Move this to another part of the creation flow to prevent circular deps
          if (config._f === hooks.ISO_8601) {
              configFromISO(config);
              return;
          }
          if (config._f === hooks.RFC_2822) {
              configFromRFC2822(config);
              return;
          }
          config._a = [];
          getParsingFlags(config).empty = true;

          // This array is used to make a Date, either with `new Date` or `Date.UTC`
          var string = '' + config._i,
              i,
              parsedInput,
              tokens,
              token,
              skipped,
              stringLength = string.length,
              totalParsedInputLength = 0,
              era,
              tokenLen;

          tokens =
              expandFormat(config._f, config._locale).match(formattingTokens) || [];
          tokenLen = tokens.length;
          for (i = 0; i < tokenLen; i++) {
              token = tokens[i];
              parsedInput = (string.match(getParseRegexForToken(token, config)) ||
                  [])[0];
              if (parsedInput) {
                  skipped = string.substr(0, string.indexOf(parsedInput));
                  if (skipped.length > 0) {
                      getParsingFlags(config).unusedInput.push(skipped);
                  }
                  string = string.slice(
                      string.indexOf(parsedInput) + parsedInput.length
                  );
                  totalParsedInputLength += parsedInput.length;
              }
              // don't parse if it's not a known token
              if (formatTokenFunctions[token]) {
                  if (parsedInput) {
                      getParsingFlags(config).empty = false;
                  } else {
                      getParsingFlags(config).unusedTokens.push(token);
                  }
                  addTimeToArrayFromToken(token, parsedInput, config);
              } else if (config._strict && !parsedInput) {
                  getParsingFlags(config).unusedTokens.push(token);
              }
          }

          // add remaining unparsed input length to the string
          getParsingFlags(config).charsLeftOver =
              stringLength - totalParsedInputLength;
          if (string.length > 0) {
              getParsingFlags(config).unusedInput.push(string);
          }

          // clear _12h flag if hour is <= 12
          if (
              config._a[HOUR] <= 12 &&
              getParsingFlags(config).bigHour === true &&
              config._a[HOUR] > 0
          ) {
              getParsingFlags(config).bigHour = undefined;
          }

          getParsingFlags(config).parsedDateParts = config._a.slice(0);
          getParsingFlags(config).meridiem = config._meridiem;
          // handle meridiem
          config._a[HOUR] = meridiemFixWrap(
              config._locale,
              config._a[HOUR],
              config._meridiem
          );

          // handle era
          era = getParsingFlags(config).era;
          if (era !== null) {
              config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
          }

          configFromArray(config);
          checkOverflow(config);
      }

      function meridiemFixWrap(locale, hour, meridiem) {
          var isPm;

          if (meridiem == null) {
              // nothing to do
              return hour;
          }
          if (locale.meridiemHour != null) {
              return locale.meridiemHour(hour, meridiem);
          } else if (locale.isPM != null) {
              // Fallback
              isPm = locale.isPM(meridiem);
              if (isPm && hour < 12) {
                  hour += 12;
              }
              if (!isPm && hour === 12) {
                  hour = 0;
              }
              return hour;
          } else {
              // this is not supposed to happen
              return hour;
          }
      }

      // date from string and array of format strings
      function configFromStringAndArray(config) {
          var tempConfig,
              bestMoment,
              scoreToBeat,
              i,
              currentScore,
              validFormatFound,
              bestFormatIsValid = false,
              configfLen = config._f.length;

          if (configfLen === 0) {
              getParsingFlags(config).invalidFormat = true;
              config._d = new Date(NaN);
              return;
          }

          for (i = 0; i < configfLen; i++) {
              currentScore = 0;
              validFormatFound = false;
              tempConfig = copyConfig({}, config);
              if (config._useUTC != null) {
                  tempConfig._useUTC = config._useUTC;
              }
              tempConfig._f = config._f[i];
              configFromStringAndFormat(tempConfig);

              if (isValid(tempConfig)) {
                  validFormatFound = true;
              }

              // if there is any input that was not parsed add a penalty for that format
              currentScore += getParsingFlags(tempConfig).charsLeftOver;

              //or tokens
              currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

              getParsingFlags(tempConfig).score = currentScore;

              if (!bestFormatIsValid) {
                  if (
                      scoreToBeat == null ||
                      currentScore < scoreToBeat ||
                      validFormatFound
                  ) {
                      scoreToBeat = currentScore;
                      bestMoment = tempConfig;
                      if (validFormatFound) {
                          bestFormatIsValid = true;
                      }
                  }
              } else {
                  if (currentScore < scoreToBeat) {
                      scoreToBeat = currentScore;
                      bestMoment = tempConfig;
                  }
              }
          }

          extend(config, bestMoment || tempConfig);
      }

      function configFromObject(config) {
          if (config._d) {
              return;
          }

          var i = normalizeObjectUnits(config._i),
              dayOrDate = i.day === undefined ? i.date : i.day;
          config._a = map(
              [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
              function (obj) {
                  return obj && parseInt(obj, 10);
              }
          );

          configFromArray(config);
      }

      function createFromConfig(config) {
          var res = new Moment(checkOverflow(prepareConfig(config)));
          if (res._nextDay) {
              // Adding is smart enough around DST
              res.add(1, 'd');
              res._nextDay = undefined;
          }

          return res;
      }

      function prepareConfig(config) {
          var input = config._i,
              format = config._f;

          config._locale = config._locale || getLocale(config._l);

          if (input === null || (format === undefined && input === '')) {
              return createInvalid({ nullInput: true });
          }

          if (typeof input === 'string') {
              config._i = input = config._locale.preparse(input);
          }

          if (isMoment(input)) {
              return new Moment(checkOverflow(input));
          } else if (isDate(input)) {
              config._d = input;
          } else if (isArray(format)) {
              configFromStringAndArray(config);
          } else if (format) {
              configFromStringAndFormat(config);
          } else {
              configFromInput(config);
          }

          if (!isValid(config)) {
              config._d = null;
          }

          return config;
      }

      function configFromInput(config) {
          var input = config._i;
          if (isUndefined(input)) {
              config._d = new Date(hooks.now());
          } else if (isDate(input)) {
              config._d = new Date(input.valueOf());
          } else if (typeof input === 'string') {
              configFromString(config);
          } else if (isArray(input)) {
              config._a = map(input.slice(0), function (obj) {
                  return parseInt(obj, 10);
              });
              configFromArray(config);
          } else if (isObject(input)) {
              configFromObject(config);
          } else if (isNumber(input)) {
              // from milliseconds
              config._d = new Date(input);
          } else {
              hooks.createFromInputFallback(config);
          }
      }

      function createLocalOrUTC(input, format, locale, strict, isUTC) {
          var c = {};

          if (format === true || format === false) {
              strict = format;
              format = undefined;
          }

          if (locale === true || locale === false) {
              strict = locale;
              locale = undefined;
          }

          if (
              (isObject(input) && isObjectEmpty(input)) ||
              (isArray(input) && input.length === 0)
          ) {
              input = undefined;
          }
          // object construction must be done this way.
          // https://github.com/moment/moment/issues/1423
          c._isAMomentObject = true;
          c._useUTC = c._isUTC = isUTC;
          c._l = locale;
          c._i = input;
          c._f = format;
          c._strict = strict;

          return createFromConfig(c);
      }

      function createLocal(input, format, locale, strict) {
          return createLocalOrUTC(input, format, locale, strict, false);
      }

      var prototypeMin = deprecate(
              'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
              function () {
                  var other = createLocal.apply(null, arguments);
                  if (this.isValid() && other.isValid()) {
                      return other < this ? this : other;
                  } else {
                      return createInvalid();
                  }
              }
          ),
          prototypeMax = deprecate(
              'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
              function () {
                  var other = createLocal.apply(null, arguments);
                  if (this.isValid() && other.isValid()) {
                      return other > this ? this : other;
                  } else {
                      return createInvalid();
                  }
              }
          );

      // Pick a moment m from moments so that m[fn](other) is true for all
      // other. This relies on the function fn to be transitive.
      //
      // moments should either be an array of moment objects or an array, whose
      // first element is an array of moment objects.
      function pickBy(fn, moments) {
          var res, i;
          if (moments.length === 1 && isArray(moments[0])) {
              moments = moments[0];
          }
          if (!moments.length) {
              return createLocal();
          }
          res = moments[0];
          for (i = 1; i < moments.length; ++i) {
              if (!moments[i].isValid() || moments[i][fn](res)) {
                  res = moments[i];
              }
          }
          return res;
      }

      // TODO: Use [].sort instead?
      function min() {
          var args = [].slice.call(arguments, 0);

          return pickBy('isBefore', args);
      }

      function max() {
          var args = [].slice.call(arguments, 0);

          return pickBy('isAfter', args);
      }

      var now = function () {
          return Date.now ? Date.now() : +new Date();
      };

      var ordering = [
          'year',
          'quarter',
          'month',
          'week',
          'day',
          'hour',
          'minute',
          'second',
          'millisecond',
      ];

      function isDurationValid(m) {
          var key,
              unitHasDecimal = false,
              i,
              orderLen = ordering.length;
          for (key in m) {
              if (
                  hasOwnProp(m, key) &&
                  !(
                      indexOf.call(ordering, key) !== -1 &&
                      (m[key] == null || !isNaN(m[key]))
                  )
              ) {
                  return false;
              }
          }

          for (i = 0; i < orderLen; ++i) {
              if (m[ordering[i]]) {
                  if (unitHasDecimal) {
                      return false; // only allow non-integers for smallest unit
                  }
                  if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                      unitHasDecimal = true;
                  }
              }
          }

          return true;
      }

      function isValid$1() {
          return this._isValid;
      }

      function createInvalid$1() {
          return createDuration(NaN);
      }

      function Duration(duration) {
          var normalizedInput = normalizeObjectUnits(duration),
              years = normalizedInput.year || 0,
              quarters = normalizedInput.quarter || 0,
              months = normalizedInput.month || 0,
              weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
              days = normalizedInput.day || 0,
              hours = normalizedInput.hour || 0,
              minutes = normalizedInput.minute || 0,
              seconds = normalizedInput.second || 0,
              milliseconds = normalizedInput.millisecond || 0;

          this._isValid = isDurationValid(normalizedInput);

          // representation for dateAddRemove
          this._milliseconds =
              +milliseconds +
              seconds * 1e3 + // 1000
              minutes * 6e4 + // 1000 * 60
              hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
          // Because of dateAddRemove treats 24 hours as different from a
          // day when working around DST, we need to store them separately
          this._days = +days + weeks * 7;
          // It is impossible to translate months into days without knowing
          // which months you are are talking about, so we have to store
          // it separately.
          this._months = +months + quarters * 3 + years * 12;

          this._data = {};

          this._locale = getLocale();

          this._bubble();
      }

      function isDuration(obj) {
          return obj instanceof Duration;
      }

      function absRound(number) {
          if (number < 0) {
              return Math.round(-1 * number) * -1;
          } else {
              return Math.round(number);
          }
      }

      // compare two arrays, return the number of differences
      function compareArrays(array1, array2, dontConvert) {
          var len = Math.min(array1.length, array2.length),
              lengthDiff = Math.abs(array1.length - array2.length),
              diffs = 0,
              i;
          for (i = 0; i < len; i++) {
              if (
                  (dontConvert && array1[i] !== array2[i]) ||
                  (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))
              ) {
                  diffs++;
              }
          }
          return diffs + lengthDiff;
      }

      // FORMATTING

      function offset(token, separator) {
          addFormatToken(token, 0, 0, function () {
              var offset = this.utcOffset(),
                  sign = '+';
              if (offset < 0) {
                  offset = -offset;
                  sign = '-';
              }
              return (
                  sign +
                  zeroFill(~~(offset / 60), 2) +
                  separator +
                  zeroFill(~~offset % 60, 2)
              );
          });
      }

      offset('Z', ':');
      offset('ZZ', '');

      // PARSING

      addRegexToken('Z', matchShortOffset);
      addRegexToken('ZZ', matchShortOffset);
      addParseToken(['Z', 'ZZ'], function (input, array, config) {
          config._useUTC = true;
          config._tzm = offsetFromString(matchShortOffset, input);
      });

      // HELPERS

      // timezone chunker
      // '+10:00' > ['10',  '00']
      // '-1530'  > ['-15', '30']
      var chunkOffset = /([\+\-]|\d\d)/gi;

      function offsetFromString(matcher, string) {
          var matches = (string || '').match(matcher),
              chunk,
              parts,
              minutes;

          if (matches === null) {
              return null;
          }

          chunk = matches[matches.length - 1] || [];
          parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
          minutes = +(parts[1] * 60) + toInt(parts[2]);

          return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
      }

      // Return a moment from input, that is local/utc/zone equivalent to model.
      function cloneWithOffset(input, model) {
          var res, diff;
          if (model._isUTC) {
              res = model.clone();
              diff =
                  (isMoment(input) || isDate(input)
                      ? input.valueOf()
                      : createLocal(input).valueOf()) - res.valueOf();
              // Use low-level api, because this fn is low-level api.
              res._d.setTime(res._d.valueOf() + diff);
              hooks.updateOffset(res, false);
              return res;
          } else {
              return createLocal(input).local();
          }
      }

      function getDateOffset(m) {
          // On Firefox.24 Date#getTimezoneOffset returns a floating point.
          // https://github.com/moment/moment/pull/1871
          return -Math.round(m._d.getTimezoneOffset());
      }

      // HOOKS

      // This function will be called whenever a moment is mutated.
      // It is intended to keep the offset in sync with the timezone.
      hooks.updateOffset = function () {};

      // MOMENTS

      // keepLocalTime = true means only change the timezone, without
      // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
      // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
      // +0200, so we adjust the time as needed, to be valid.
      //
      // Keeping the time actually adds/subtracts (one hour)
      // from the actual represented time. That is why we call updateOffset
      // a second time. In case it wants us to change the offset again
      // _changeInProgress == true case, then we have to adjust, because
      // there is no such time in the given timezone.
      function getSetOffset(input, keepLocalTime, keepMinutes) {
          var offset = this._offset || 0,
              localAdjust;
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }
          if (input != null) {
              if (typeof input === 'string') {
                  input = offsetFromString(matchShortOffset, input);
                  if (input === null) {
                      return this;
                  }
              } else if (Math.abs(input) < 16 && !keepMinutes) {
                  input = input * 60;
              }
              if (!this._isUTC && keepLocalTime) {
                  localAdjust = getDateOffset(this);
              }
              this._offset = input;
              this._isUTC = true;
              if (localAdjust != null) {
                  this.add(localAdjust, 'm');
              }
              if (offset !== input) {
                  if (!keepLocalTime || this._changeInProgress) {
                      addSubtract(
                          this,
                          createDuration(input - offset, 'm'),
                          1,
                          false
                      );
                  } else if (!this._changeInProgress) {
                      this._changeInProgress = true;
                      hooks.updateOffset(this, true);
                      this._changeInProgress = null;
                  }
              }
              return this;
          } else {
              return this._isUTC ? offset : getDateOffset(this);
          }
      }

      function getSetZone(input, keepLocalTime) {
          if (input != null) {
              if (typeof input !== 'string') {
                  input = -input;
              }

              this.utcOffset(input, keepLocalTime);

              return this;
          } else {
              return -this.utcOffset();
          }
      }

      function setOffsetToUTC(keepLocalTime) {
          return this.utcOffset(0, keepLocalTime);
      }

      function setOffsetToLocal(keepLocalTime) {
          if (this._isUTC) {
              this.utcOffset(0, keepLocalTime);
              this._isUTC = false;

              if (keepLocalTime) {
                  this.subtract(getDateOffset(this), 'm');
              }
          }
          return this;
      }

      function setOffsetToParsedOffset() {
          if (this._tzm != null) {
              this.utcOffset(this._tzm, false, true);
          } else if (typeof this._i === 'string') {
              var tZone = offsetFromString(matchOffset, this._i);
              if (tZone != null) {
                  this.utcOffset(tZone);
              } else {
                  this.utcOffset(0, true);
              }
          }
          return this;
      }

      function hasAlignedHourOffset(input) {
          if (!this.isValid()) {
              return false;
          }
          input = input ? createLocal(input).utcOffset() : 0;

          return (this.utcOffset() - input) % 60 === 0;
      }

      function isDaylightSavingTime() {
          return (
              this.utcOffset() > this.clone().month(0).utcOffset() ||
              this.utcOffset() > this.clone().month(5).utcOffset()
          );
      }

      function isDaylightSavingTimeShifted() {
          if (!isUndefined(this._isDSTShifted)) {
              return this._isDSTShifted;
          }

          var c = {},
              other;

          copyConfig(c, this);
          c = prepareConfig(c);

          if (c._a) {
              other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
              this._isDSTShifted =
                  this.isValid() && compareArrays(c._a, other.toArray()) > 0;
          } else {
              this._isDSTShifted = false;
          }

          return this._isDSTShifted;
      }

      function isLocal() {
          return this.isValid() ? !this._isUTC : false;
      }

      function isUtcOffset() {
          return this.isValid() ? this._isUTC : false;
      }

      function isUtc() {
          return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }

      // ASP.NET json date format regex
      var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
          // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
          // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
          // and further modified to allow for strings containing both week and day
          isoRegex =
              /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

      function createDuration(input, key) {
          var duration = input,
              // matching against regexp is expensive, do it on demand
              match = null,
              sign,
              ret,
              diffRes;

          if (isDuration(input)) {
              duration = {
                  ms: input._milliseconds,
                  d: input._days,
                  M: input._months,
              };
          } else if (isNumber(input) || !isNaN(+input)) {
              duration = {};
              if (key) {
                  duration[key] = +input;
              } else {
                  duration.milliseconds = +input;
              }
          } else if ((match = aspNetRegex.exec(input))) {
              sign = match[1] === '-' ? -1 : 1;
              duration = {
                  y: 0,
                  d: toInt(match[DATE]) * sign,
                  h: toInt(match[HOUR]) * sign,
                  m: toInt(match[MINUTE]) * sign,
                  s: toInt(match[SECOND]) * sign,
                  ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // the millisecond decimal point is included in the match
              };
          } else if ((match = isoRegex.exec(input))) {
              sign = match[1] === '-' ? -1 : 1;
              duration = {
                  y: parseIso(match[2], sign),
                  M: parseIso(match[3], sign),
                  w: parseIso(match[4], sign),
                  d: parseIso(match[5], sign),
                  h: parseIso(match[6], sign),
                  m: parseIso(match[7], sign),
                  s: parseIso(match[8], sign),
              };
          } else if (duration == null) {
              // checks for null or undefined
              duration = {};
          } else if (
              typeof duration === 'object' &&
              ('from' in duration || 'to' in duration)
          ) {
              diffRes = momentsDifference(
                  createLocal(duration.from),
                  createLocal(duration.to)
              );

              duration = {};
              duration.ms = diffRes.milliseconds;
              duration.M = diffRes.months;
          }

          ret = new Duration(duration);

          if (isDuration(input) && hasOwnProp(input, '_locale')) {
              ret._locale = input._locale;
          }

          if (isDuration(input) && hasOwnProp(input, '_isValid')) {
              ret._isValid = input._isValid;
          }

          return ret;
      }

      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;

      function parseIso(inp, sign) {
          // We'd normally use ~~inp for this, but unfortunately it also
          // converts floats to ints.
          // inp may be undefined, so careful calling replace on it.
          var res = inp && parseFloat(inp.replace(',', '.'));
          // apply sign while we're at it
          return (isNaN(res) ? 0 : res) * sign;
      }

      function positiveMomentsDifference(base, other) {
          var res = {};

          res.months =
              other.month() - base.month() + (other.year() - base.year()) * 12;
          if (base.clone().add(res.months, 'M').isAfter(other)) {
              --res.months;
          }

          res.milliseconds = +other - +base.clone().add(res.months, 'M');

          return res;
      }

      function momentsDifference(base, other) {
          var res;
          if (!(base.isValid() && other.isValid())) {
              return { milliseconds: 0, months: 0 };
          }

          other = cloneWithOffset(other, base);
          if (base.isBefore(other)) {
              res = positiveMomentsDifference(base, other);
          } else {
              res = positiveMomentsDifference(other, base);
              res.milliseconds = -res.milliseconds;
              res.months = -res.months;
          }

          return res;
      }

      // TODO: remove 'name' arg after deprecation is removed
      function createAdder(direction, name) {
          return function (val, period) {
              var dur, tmp;
              //invert the arguments, but complain about it
              if (period !== null && !isNaN(+period)) {
                  deprecateSimple(
                      name,
                      'moment().' +
                          name +
                          '(period, number) is deprecated. Please use moment().' +
                          name +
                          '(number, period). ' +
                          'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.'
                  );
                  tmp = val;
                  val = period;
                  period = tmp;
              }

              dur = createDuration(val, period);
              addSubtract(this, dur, direction);
              return this;
          };
      }

      function addSubtract(mom, duration, isAdding, updateOffset) {
          var milliseconds = duration._milliseconds,
              days = absRound(duration._days),
              months = absRound(duration._months);

          if (!mom.isValid()) {
              // No op
              return;
          }

          updateOffset = updateOffset == null ? true : updateOffset;

          if (months) {
              setMonth(mom, get(mom, 'Month') + months * isAdding);
          }
          if (days) {
              set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
          }
          if (milliseconds) {
              mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
          }
          if (updateOffset) {
              hooks.updateOffset(mom, days || months);
          }
      }

      var add = createAdder(1, 'add'),
          subtract = createAdder(-1, 'subtract');

      function isString(input) {
          return typeof input === 'string' || input instanceof String;
      }

      // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
      function isMomentInput(input) {
          return (
              isMoment(input) ||
              isDate(input) ||
              isString(input) ||
              isNumber(input) ||
              isNumberOrStringArray(input) ||
              isMomentInputObject(input) ||
              input === null ||
              input === undefined
          );
      }

      function isMomentInputObject(input) {
          var objectTest = isObject(input) && !isObjectEmpty(input),
              propertyTest = false,
              properties = [
                  'years',
                  'year',
                  'y',
                  'months',
                  'month',
                  'M',
                  'days',
                  'day',
                  'd',
                  'dates',
                  'date',
                  'D',
                  'hours',
                  'hour',
                  'h',
                  'minutes',
                  'minute',
                  'm',
                  'seconds',
                  'second',
                  's',
                  'milliseconds',
                  'millisecond',
                  'ms',
              ],
              i,
              property,
              propertyLen = properties.length;

          for (i = 0; i < propertyLen; i += 1) {
              property = properties[i];
              propertyTest = propertyTest || hasOwnProp(input, property);
          }

          return objectTest && propertyTest;
      }

      function isNumberOrStringArray(input) {
          var arrayTest = isArray(input),
              dataTypeTest = false;
          if (arrayTest) {
              dataTypeTest =
                  input.filter(function (item) {
                      return !isNumber(item) && isString(input);
                  }).length === 0;
          }
          return arrayTest && dataTypeTest;
      }

      function isCalendarSpec(input) {
          var objectTest = isObject(input) && !isObjectEmpty(input),
              propertyTest = false,
              properties = [
                  'sameDay',
                  'nextDay',
                  'lastDay',
                  'nextWeek',
                  'lastWeek',
                  'sameElse',
              ],
              i,
              property;

          for (i = 0; i < properties.length; i += 1) {
              property = properties[i];
              propertyTest = propertyTest || hasOwnProp(input, property);
          }

          return objectTest && propertyTest;
      }

      function getCalendarFormat(myMoment, now) {
          var diff = myMoment.diff(now, 'days', true);
          return diff < -6
              ? 'sameElse'
              : diff < -1
              ? 'lastWeek'
              : diff < 0
              ? 'lastDay'
              : diff < 1
              ? 'sameDay'
              : diff < 2
              ? 'nextDay'
              : diff < 7
              ? 'nextWeek'
              : 'sameElse';
      }

      function calendar$1(time, formats) {
          // Support for single parameter, formats only overload to the calendar function
          if (arguments.length === 1) {
              if (!arguments[0]) {
                  time = undefined;
                  formats = undefined;
              } else if (isMomentInput(arguments[0])) {
                  time = arguments[0];
                  formats = undefined;
              } else if (isCalendarSpec(arguments[0])) {
                  formats = arguments[0];
                  time = undefined;
              }
          }
          // We want to compare the start of today, vs this.
          // Getting start-of-today depends on whether we're local/utc/offset or not.
          var now = time || createLocal(),
              sod = cloneWithOffset(now, this).startOf('day'),
              format = hooks.calendarFormat(this, sod) || 'sameElse',
              output =
                  formats &&
                  (isFunction(formats[format])
                      ? formats[format].call(this, now)
                      : formats[format]);

          return this.format(
              output || this.localeData().calendar(format, this, createLocal(now))
          );
      }

      function clone() {
          return new Moment(this);
      }

      function isAfter(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
              return false;
          }
          units = normalizeUnits(units) || 'millisecond';
          if (units === 'millisecond') {
              return this.valueOf() > localInput.valueOf();
          } else {
              return localInput.valueOf() < this.clone().startOf(units).valueOf();
          }
      }

      function isBefore(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
              return false;
          }
          units = normalizeUnits(units) || 'millisecond';
          if (units === 'millisecond') {
              return this.valueOf() < localInput.valueOf();
          } else {
              return this.clone().endOf(units).valueOf() < localInput.valueOf();
          }
      }

      function isBetween(from, to, units, inclusivity) {
          var localFrom = isMoment(from) ? from : createLocal(from),
              localTo = isMoment(to) ? to : createLocal(to);
          if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
              return false;
          }
          inclusivity = inclusivity || '()';
          return (
              (inclusivity[0] === '('
                  ? this.isAfter(localFrom, units)
                  : !this.isBefore(localFrom, units)) &&
              (inclusivity[1] === ')'
                  ? this.isBefore(localTo, units)
                  : !this.isAfter(localTo, units))
          );
      }

      function isSame(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input),
              inputMs;
          if (!(this.isValid() && localInput.isValid())) {
              return false;
          }
          units = normalizeUnits(units) || 'millisecond';
          if (units === 'millisecond') {
              return this.valueOf() === localInput.valueOf();
          } else {
              inputMs = localInput.valueOf();
              return (
                  this.clone().startOf(units).valueOf() <= inputMs &&
                  inputMs <= this.clone().endOf(units).valueOf()
              );
          }
      }

      function isSameOrAfter(input, units) {
          return this.isSame(input, units) || this.isAfter(input, units);
      }

      function isSameOrBefore(input, units) {
          return this.isSame(input, units) || this.isBefore(input, units);
      }

      function diff(input, units, asFloat) {
          var that, zoneDelta, output;

          if (!this.isValid()) {
              return NaN;
          }

          that = cloneWithOffset(input, this);

          if (!that.isValid()) {
              return NaN;
          }

          zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

          units = normalizeUnits(units);

          switch (units) {
              case 'year':
                  output = monthDiff(this, that) / 12;
                  break;
              case 'month':
                  output = monthDiff(this, that);
                  break;
              case 'quarter':
                  output = monthDiff(this, that) / 3;
                  break;
              case 'second':
                  output = (this - that) / 1e3;
                  break; // 1000
              case 'minute':
                  output = (this - that) / 6e4;
                  break; // 1000 * 60
              case 'hour':
                  output = (this - that) / 36e5;
                  break; // 1000 * 60 * 60
              case 'day':
                  output = (this - that - zoneDelta) / 864e5;
                  break; // 1000 * 60 * 60 * 24, negate dst
              case 'week':
                  output = (this - that - zoneDelta) / 6048e5;
                  break; // 1000 * 60 * 60 * 24 * 7, negate dst
              default:
                  output = this - that;
          }

          return asFloat ? output : absFloor(output);
      }

      function monthDiff(a, b) {
          if (a.date() < b.date()) {
              // end-of-month calculations work correct when the start month has more
              // days than the end month.
              return -monthDiff(b, a);
          }
          // difference in months
          var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
              // b is in (anchor - 1 month, anchor + 1 month)
              anchor = a.clone().add(wholeMonthDiff, 'months'),
              anchor2,
              adjust;

          if (b - anchor < 0) {
              anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
              // linear across the month
              adjust = (b - anchor) / (anchor - anchor2);
          } else {
              anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
              // linear across the month
              adjust = (b - anchor) / (anchor2 - anchor);
          }

          //check for negative zero, return zero if negative zero
          return -(wholeMonthDiff + adjust) || 0;
      }

      hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
      hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

      function toString() {
          return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
      }

      function toISOString(keepOffset) {
          if (!this.isValid()) {
              return null;
          }
          var utc = keepOffset !== true,
              m = utc ? this.clone().utc() : this;
          if (m.year() < 0 || m.year() > 9999) {
              return formatMoment(
                  m,
                  utc
                      ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]'
                      : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ'
              );
          }
          if (isFunction(Date.prototype.toISOString)) {
              // native implementation is ~50x faster, use it when we can
              if (utc) {
                  return this.toDate().toISOString();
              } else {
                  return new Date(this.valueOf() + this.utcOffset() * 60 * 1000)
                      .toISOString()
                      .replace('Z', formatMoment(m, 'Z'));
              }
          }
          return formatMoment(
              m,
              utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ'
          );
      }

      /**
       * Return a human readable representation of a moment that can
       * also be evaluated to get a new moment which is the same
       *
       * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
       */
      function inspect() {
          if (!this.isValid()) {
              return 'moment.invalid(/* ' + this._i + ' */)';
          }
          var func = 'moment',
              zone = '',
              prefix,
              year,
              datetime,
              suffix;
          if (!this.isLocal()) {
              func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
              zone = 'Z';
          }
          prefix = '[' + func + '("]';
          year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
          datetime = '-MM-DD[T]HH:mm:ss.SSS';
          suffix = zone + '[")]';

          return this.format(prefix + year + datetime + suffix);
      }

      function format(inputString) {
          if (!inputString) {
              inputString = this.isUtc()
                  ? hooks.defaultFormatUtc
                  : hooks.defaultFormat;
          }
          var output = formatMoment(this, inputString);
          return this.localeData().postformat(output);
      }

      function from(time, withoutSuffix) {
          if (
              this.isValid() &&
              ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
          ) {
              return createDuration({ to: this, from: time })
                  .locale(this.locale())
                  .humanize(!withoutSuffix);
          } else {
              return this.localeData().invalidDate();
          }
      }

      function fromNow(withoutSuffix) {
          return this.from(createLocal(), withoutSuffix);
      }

      function to(time, withoutSuffix) {
          if (
              this.isValid() &&
              ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
          ) {
              return createDuration({ from: this, to: time })
                  .locale(this.locale())
                  .humanize(!withoutSuffix);
          } else {
              return this.localeData().invalidDate();
          }
      }

      function toNow(withoutSuffix) {
          return this.to(createLocal(), withoutSuffix);
      }

      // If passed a locale key, it will set the locale for this
      // instance.  Otherwise, it will return the locale configuration
      // variables for this instance.
      function locale(key) {
          var newLocaleData;

          if (key === undefined) {
              return this._locale._abbr;
          } else {
              newLocaleData = getLocale(key);
              if (newLocaleData != null) {
                  this._locale = newLocaleData;
              }
              return this;
          }
      }

      var lang = deprecate(
          'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
          function (key) {
              if (key === undefined) {
                  return this.localeData();
              } else {
                  return this.locale(key);
              }
          }
      );

      function localeData() {
          return this._locale;
      }

      var MS_PER_SECOND = 1000,
          MS_PER_MINUTE = 60 * MS_PER_SECOND,
          MS_PER_HOUR = 60 * MS_PER_MINUTE,
          MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

      // actual modulo - handles negative numbers (for dates before 1970):
      function mod$1(dividend, divisor) {
          return ((dividend % divisor) + divisor) % divisor;
      }

      function localStartOfDate(y, m, d) {
          // the date constructor remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
              // preserve leap years using a full 400 year cycle, then reset
              return new Date(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
              return new Date(y, m, d).valueOf();
          }
      }

      function utcStartOfDate(y, m, d) {
          // Date.UTC remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
              // preserve leap years using a full 400 year cycle, then reset
              return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
              return Date.UTC(y, m, d);
          }
      }

      function startOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === undefined || units === 'millisecond' || !this.isValid()) {
              return this;
          }

          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

          switch (units) {
              case 'year':
                  time = startOfDate(this.year(), 0, 1);
                  break;
              case 'quarter':
                  time = startOfDate(
                      this.year(),
                      this.month() - (this.month() % 3),
                      1
                  );
                  break;
              case 'month':
                  time = startOfDate(this.year(), this.month(), 1);
                  break;
              case 'week':
                  time = startOfDate(
                      this.year(),
                      this.month(),
                      this.date() - this.weekday()
                  );
                  break;
              case 'isoWeek':
                  time = startOfDate(
                      this.year(),
                      this.month(),
                      this.date() - (this.isoWeekday() - 1)
                  );
                  break;
              case 'day':
              case 'date':
                  time = startOfDate(this.year(), this.month(), this.date());
                  break;
              case 'hour':
                  time = this._d.valueOf();
                  time -= mod$1(
                      time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                      MS_PER_HOUR
                  );
                  break;
              case 'minute':
                  time = this._d.valueOf();
                  time -= mod$1(time, MS_PER_MINUTE);
                  break;
              case 'second':
                  time = this._d.valueOf();
                  time -= mod$1(time, MS_PER_SECOND);
                  break;
          }

          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
      }

      function endOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === undefined || units === 'millisecond' || !this.isValid()) {
              return this;
          }

          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

          switch (units) {
              case 'year':
                  time = startOfDate(this.year() + 1, 0, 1) - 1;
                  break;
              case 'quarter':
                  time =
                      startOfDate(
                          this.year(),
                          this.month() - (this.month() % 3) + 3,
                          1
                      ) - 1;
                  break;
              case 'month':
                  time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                  break;
              case 'week':
                  time =
                      startOfDate(
                          this.year(),
                          this.month(),
                          this.date() - this.weekday() + 7
                      ) - 1;
                  break;
              case 'isoWeek':
                  time =
                      startOfDate(
                          this.year(),
                          this.month(),
                          this.date() - (this.isoWeekday() - 1) + 7
                      ) - 1;
                  break;
              case 'day':
              case 'date':
                  time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                  break;
              case 'hour':
                  time = this._d.valueOf();
                  time +=
                      MS_PER_HOUR -
                      mod$1(
                          time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                          MS_PER_HOUR
                      ) -
                      1;
                  break;
              case 'minute':
                  time = this._d.valueOf();
                  time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                  break;
              case 'second':
                  time = this._d.valueOf();
                  time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                  break;
          }

          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
      }

      function valueOf() {
          return this._d.valueOf() - (this._offset || 0) * 60000;
      }

      function unix() {
          return Math.floor(this.valueOf() / 1000);
      }

      function toDate() {
          return new Date(this.valueOf());
      }

      function toArray() {
          var m = this;
          return [
              m.year(),
              m.month(),
              m.date(),
              m.hour(),
              m.minute(),
              m.second(),
              m.millisecond(),
          ];
      }

      function toObject() {
          var m = this;
          return {
              years: m.year(),
              months: m.month(),
              date: m.date(),
              hours: m.hours(),
              minutes: m.minutes(),
              seconds: m.seconds(),
              milliseconds: m.milliseconds(),
          };
      }

      function toJSON() {
          // new Date(NaN).toJSON() === null
          return this.isValid() ? this.toISOString() : null;
      }

      function isValid$2() {
          return isValid(this);
      }

      function parsingFlags() {
          return extend({}, getParsingFlags(this));
      }

      function invalidAt() {
          return getParsingFlags(this).overflow;
      }

      function creationData() {
          return {
              input: this._i,
              format: this._f,
              locale: this._locale,
              isUTC: this._isUTC,
              strict: this._strict,
          };
      }

      addFormatToken('N', 0, 0, 'eraAbbr');
      addFormatToken('NN', 0, 0, 'eraAbbr');
      addFormatToken('NNN', 0, 0, 'eraAbbr');
      addFormatToken('NNNN', 0, 0, 'eraName');
      addFormatToken('NNNNN', 0, 0, 'eraNarrow');

      addFormatToken('y', ['y', 1], 'yo', 'eraYear');
      addFormatToken('y', ['yy', 2], 0, 'eraYear');
      addFormatToken('y', ['yyy', 3], 0, 'eraYear');
      addFormatToken('y', ['yyyy', 4], 0, 'eraYear');

      addRegexToken('N', matchEraAbbr);
      addRegexToken('NN', matchEraAbbr);
      addRegexToken('NNN', matchEraAbbr);
      addRegexToken('NNNN', matchEraName);
      addRegexToken('NNNNN', matchEraNarrow);

      addParseToken(
          ['N', 'NN', 'NNN', 'NNNN', 'NNNNN'],
          function (input, array, config, token) {
              var era = config._locale.erasParse(input, token, config._strict);
              if (era) {
                  getParsingFlags(config).era = era;
              } else {
                  getParsingFlags(config).invalidEra = input;
              }
          }
      );

      addRegexToken('y', matchUnsigned);
      addRegexToken('yy', matchUnsigned);
      addRegexToken('yyy', matchUnsigned);
      addRegexToken('yyyy', matchUnsigned);
      addRegexToken('yo', matchEraYearOrdinal);

      addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
      addParseToken(['yo'], function (input, array, config, token) {
          var match;
          if (config._locale._eraYearOrdinalRegex) {
              match = input.match(config._locale._eraYearOrdinalRegex);
          }

          if (config._locale.eraYearOrdinalParse) {
              array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
          } else {
              array[YEAR] = parseInt(input, 10);
          }
      });

      function localeEras(m, format) {
          var i,
              l,
              date,
              eras = this._eras || getLocale('en')._eras;
          for (i = 0, l = eras.length; i < l; ++i) {
              switch (typeof eras[i].since) {
                  case 'string':
                      // truncate time
                      date = hooks(eras[i].since).startOf('day');
                      eras[i].since = date.valueOf();
                      break;
              }

              switch (typeof eras[i].until) {
                  case 'undefined':
                      eras[i].until = +Infinity;
                      break;
                  case 'string':
                      // truncate time
                      date = hooks(eras[i].until).startOf('day').valueOf();
                      eras[i].until = date.valueOf();
                      break;
              }
          }
          return eras;
      }

      function localeErasParse(eraName, format, strict) {
          var i,
              l,
              eras = this.eras(),
              name,
              abbr,
              narrow;
          eraName = eraName.toUpperCase();

          for (i = 0, l = eras.length; i < l; ++i) {
              name = eras[i].name.toUpperCase();
              abbr = eras[i].abbr.toUpperCase();
              narrow = eras[i].narrow.toUpperCase();

              if (strict) {
                  switch (format) {
                      case 'N':
                      case 'NN':
                      case 'NNN':
                          if (abbr === eraName) {
                              return eras[i];
                          }
                          break;

                      case 'NNNN':
                          if (name === eraName) {
                              return eras[i];
                          }
                          break;

                      case 'NNNNN':
                          if (narrow === eraName) {
                              return eras[i];
                          }
                          break;
                  }
              } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
                  return eras[i];
              }
          }
      }

      function localeErasConvertYear(era, year) {
          var dir = era.since <= era.until ? +1 : -1;
          if (year === undefined) {
              return hooks(era.since).year();
          } else {
              return hooks(era.since).year() + (year - era.offset) * dir;
          }
      }

      function getEraName() {
          var i,
              l,
              val,
              eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
              // truncate time
              val = this.clone().startOf('day').valueOf();

              if (eras[i].since <= val && val <= eras[i].until) {
                  return eras[i].name;
              }
              if (eras[i].until <= val && val <= eras[i].since) {
                  return eras[i].name;
              }
          }

          return '';
      }

      function getEraNarrow() {
          var i,
              l,
              val,
              eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
              // truncate time
              val = this.clone().startOf('day').valueOf();

              if (eras[i].since <= val && val <= eras[i].until) {
                  return eras[i].narrow;
              }
              if (eras[i].until <= val && val <= eras[i].since) {
                  return eras[i].narrow;
              }
          }

          return '';
      }

      function getEraAbbr() {
          var i,
              l,
              val,
              eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
              // truncate time
              val = this.clone().startOf('day').valueOf();

              if (eras[i].since <= val && val <= eras[i].until) {
                  return eras[i].abbr;
              }
              if (eras[i].until <= val && val <= eras[i].since) {
                  return eras[i].abbr;
              }
          }

          return '';
      }

      function getEraYear() {
          var i,
              l,
              dir,
              val,
              eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
              dir = eras[i].since <= eras[i].until ? +1 : -1;

              // truncate time
              val = this.clone().startOf('day').valueOf();

              if (
                  (eras[i].since <= val && val <= eras[i].until) ||
                  (eras[i].until <= val && val <= eras[i].since)
              ) {
                  return (
                      (this.year() - hooks(eras[i].since).year()) * dir +
                      eras[i].offset
                  );
              }
          }

          return this.year();
      }

      function erasNameRegex(isStrict) {
          if (!hasOwnProp(this, '_erasNameRegex')) {
              computeErasParse.call(this);
          }
          return isStrict ? this._erasNameRegex : this._erasRegex;
      }

      function erasAbbrRegex(isStrict) {
          if (!hasOwnProp(this, '_erasAbbrRegex')) {
              computeErasParse.call(this);
          }
          return isStrict ? this._erasAbbrRegex : this._erasRegex;
      }

      function erasNarrowRegex(isStrict) {
          if (!hasOwnProp(this, '_erasNarrowRegex')) {
              computeErasParse.call(this);
          }
          return isStrict ? this._erasNarrowRegex : this._erasRegex;
      }

      function matchEraAbbr(isStrict, locale) {
          return locale.erasAbbrRegex(isStrict);
      }

      function matchEraName(isStrict, locale) {
          return locale.erasNameRegex(isStrict);
      }

      function matchEraNarrow(isStrict, locale) {
          return locale.erasNarrowRegex(isStrict);
      }

      function matchEraYearOrdinal(isStrict, locale) {
          return locale._eraYearOrdinalRegex || matchUnsigned;
      }

      function computeErasParse() {
          var abbrPieces = [],
              namePieces = [],
              narrowPieces = [],
              mixedPieces = [],
              i,
              l,
              eras = this.eras();

          for (i = 0, l = eras.length; i < l; ++i) {
              namePieces.push(regexEscape(eras[i].name));
              abbrPieces.push(regexEscape(eras[i].abbr));
              narrowPieces.push(regexEscape(eras[i].narrow));

              mixedPieces.push(regexEscape(eras[i].name));
              mixedPieces.push(regexEscape(eras[i].abbr));
              mixedPieces.push(regexEscape(eras[i].narrow));
          }

          this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
          this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
          this._erasNarrowRegex = new RegExp(
              '^(' + narrowPieces.join('|') + ')',
              'i'
          );
      }

      // FORMATTING

      addFormatToken(0, ['gg', 2], 0, function () {
          return this.weekYear() % 100;
      });

      addFormatToken(0, ['GG', 2], 0, function () {
          return this.isoWeekYear() % 100;
      });

      function addWeekYearFormatToken(token, getter) {
          addFormatToken(0, [token, token.length], 0, getter);
      }

      addWeekYearFormatToken('gggg', 'weekYear');
      addWeekYearFormatToken('ggggg', 'weekYear');
      addWeekYearFormatToken('GGGG', 'isoWeekYear');
      addWeekYearFormatToken('GGGGG', 'isoWeekYear');

      // ALIASES

      addUnitAlias('weekYear', 'gg');
      addUnitAlias('isoWeekYear', 'GG');

      // PRIORITY

      addUnitPriority('weekYear', 1);
      addUnitPriority('isoWeekYear', 1);

      // PARSING

      addRegexToken('G', matchSigned);
      addRegexToken('g', matchSigned);
      addRegexToken('GG', match1to2, match2);
      addRegexToken('gg', match1to2, match2);
      addRegexToken('GGGG', match1to4, match4);
      addRegexToken('gggg', match1to4, match4);
      addRegexToken('GGGGG', match1to6, match6);
      addRegexToken('ggggg', match1to6, match6);

      addWeekParseToken(
          ['gggg', 'ggggg', 'GGGG', 'GGGGG'],
          function (input, week, config, token) {
              week[token.substr(0, 2)] = toInt(input);
          }
      );

      addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
          week[token] = hooks.parseTwoDigitYear(input);
      });

      // MOMENTS

      function getSetWeekYear(input) {
          return getSetWeekYearHelper.call(
              this,
              input,
              this.week(),
              this.weekday(),
              this.localeData()._week.dow,
              this.localeData()._week.doy
          );
      }

      function getSetISOWeekYear(input) {
          return getSetWeekYearHelper.call(
              this,
              input,
              this.isoWeek(),
              this.isoWeekday(),
              1,
              4
          );
      }

      function getISOWeeksInYear() {
          return weeksInYear(this.year(), 1, 4);
      }

      function getISOWeeksInISOWeekYear() {
          return weeksInYear(this.isoWeekYear(), 1, 4);
      }

      function getWeeksInYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }

      function getWeeksInWeekYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
      }

      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
          var weeksTarget;
          if (input == null) {
              return weekOfYear(this, dow, doy).year;
          } else {
              weeksTarget = weeksInYear(input, dow, doy);
              if (week > weeksTarget) {
                  week = weeksTarget;
              }
              return setWeekAll.call(this, input, week, weekday, dow, doy);
          }
      }

      function setWeekAll(weekYear, week, weekday, dow, doy) {
          var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
              date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

          this.year(date.getUTCFullYear());
          this.month(date.getUTCMonth());
          this.date(date.getUTCDate());
          return this;
      }

      // FORMATTING

      addFormatToken('Q', 0, 'Qo', 'quarter');

      // ALIASES

      addUnitAlias('quarter', 'Q');

      // PRIORITY

      addUnitPriority('quarter', 7);

      // PARSING

      addRegexToken('Q', match1);
      addParseToken('Q', function (input, array) {
          array[MONTH] = (toInt(input) - 1) * 3;
      });

      // MOMENTS

      function getSetQuarter(input) {
          return input == null
              ? Math.ceil((this.month() + 1) / 3)
              : this.month((input - 1) * 3 + (this.month() % 3));
      }

      // FORMATTING

      addFormatToken('D', ['DD', 2], 'Do', 'date');

      // ALIASES

      addUnitAlias('date', 'D');

      // PRIORITY
      addUnitPriority('date', 9);

      // PARSING

      addRegexToken('D', match1to2);
      addRegexToken('DD', match1to2, match2);
      addRegexToken('Do', function (isStrict, locale) {
          // TODO: Remove "ordinalParse" fallback in next major release.
          return isStrict
              ? locale._dayOfMonthOrdinalParse || locale._ordinalParse
              : locale._dayOfMonthOrdinalParseLenient;
      });

      addParseToken(['D', 'DD'], DATE);
      addParseToken('Do', function (input, array) {
          array[DATE] = toInt(input.match(match1to2)[0]);
      });

      // MOMENTS

      var getSetDayOfMonth = makeGetSet('Date', true);

      // FORMATTING

      addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

      // ALIASES

      addUnitAlias('dayOfYear', 'DDD');

      // PRIORITY
      addUnitPriority('dayOfYear', 4);

      // PARSING

      addRegexToken('DDD', match1to3);
      addRegexToken('DDDD', match3);
      addParseToken(['DDD', 'DDDD'], function (input, array, config) {
          config._dayOfYear = toInt(input);
      });

      // HELPERS

      // MOMENTS

      function getSetDayOfYear(input) {
          var dayOfYear =
              Math.round(
                  (this.clone().startOf('day') - this.clone().startOf('year')) / 864e5
              ) + 1;
          return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
      }

      // FORMATTING

      addFormatToken('m', ['mm', 2], 0, 'minute');

      // ALIASES

      addUnitAlias('minute', 'm');

      // PRIORITY

      addUnitPriority('minute', 14);

      // PARSING

      addRegexToken('m', match1to2);
      addRegexToken('mm', match1to2, match2);
      addParseToken(['m', 'mm'], MINUTE);

      // MOMENTS

      var getSetMinute = makeGetSet('Minutes', false);

      // FORMATTING

      addFormatToken('s', ['ss', 2], 0, 'second');

      // ALIASES

      addUnitAlias('second', 's');

      // PRIORITY

      addUnitPriority('second', 15);

      // PARSING

      addRegexToken('s', match1to2);
      addRegexToken('ss', match1to2, match2);
      addParseToken(['s', 'ss'], SECOND);

      // MOMENTS

      var getSetSecond = makeGetSet('Seconds', false);

      // FORMATTING

      addFormatToken('S', 0, 0, function () {
          return ~~(this.millisecond() / 100);
      });

      addFormatToken(0, ['SS', 2], 0, function () {
          return ~~(this.millisecond() / 10);
      });

      addFormatToken(0, ['SSS', 3], 0, 'millisecond');
      addFormatToken(0, ['SSSS', 4], 0, function () {
          return this.millisecond() * 10;
      });
      addFormatToken(0, ['SSSSS', 5], 0, function () {
          return this.millisecond() * 100;
      });
      addFormatToken(0, ['SSSSSS', 6], 0, function () {
          return this.millisecond() * 1000;
      });
      addFormatToken(0, ['SSSSSSS', 7], 0, function () {
          return this.millisecond() * 10000;
      });
      addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
          return this.millisecond() * 100000;
      });
      addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
          return this.millisecond() * 1000000;
      });

      // ALIASES

      addUnitAlias('millisecond', 'ms');

      // PRIORITY

      addUnitPriority('millisecond', 16);

      // PARSING

      addRegexToken('S', match1to3, match1);
      addRegexToken('SS', match1to3, match2);
      addRegexToken('SSS', match1to3, match3);

      var token, getSetMillisecond;
      for (token = 'SSSS'; token.length <= 9; token += 'S') {
          addRegexToken(token, matchUnsigned);
      }

      function parseMs(input, array) {
          array[MILLISECOND] = toInt(('0.' + input) * 1000);
      }

      for (token = 'S'; token.length <= 9; token += 'S') {
          addParseToken(token, parseMs);
      }

      getSetMillisecond = makeGetSet('Milliseconds', false);

      // FORMATTING

      addFormatToken('z', 0, 0, 'zoneAbbr');
      addFormatToken('zz', 0, 0, 'zoneName');

      // MOMENTS

      function getZoneAbbr() {
          return this._isUTC ? 'UTC' : '';
      }

      function getZoneName() {
          return this._isUTC ? 'Coordinated Universal Time' : '';
      }

      var proto = Moment.prototype;

      proto.add = add;
      proto.calendar = calendar$1;
      proto.clone = clone;
      proto.diff = diff;
      proto.endOf = endOf;
      proto.format = format;
      proto.from = from;
      proto.fromNow = fromNow;
      proto.to = to;
      proto.toNow = toNow;
      proto.get = stringGet;
      proto.invalidAt = invalidAt;
      proto.isAfter = isAfter;
      proto.isBefore = isBefore;
      proto.isBetween = isBetween;
      proto.isSame = isSame;
      proto.isSameOrAfter = isSameOrAfter;
      proto.isSameOrBefore = isSameOrBefore;
      proto.isValid = isValid$2;
      proto.lang = lang;
      proto.locale = locale;
      proto.localeData = localeData;
      proto.max = prototypeMax;
      proto.min = prototypeMin;
      proto.parsingFlags = parsingFlags;
      proto.set = stringSet;
      proto.startOf = startOf;
      proto.subtract = subtract;
      proto.toArray = toArray;
      proto.toObject = toObject;
      proto.toDate = toDate;
      proto.toISOString = toISOString;
      proto.inspect = inspect;
      if (typeof Symbol !== 'undefined' && Symbol.for != null) {
          proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
              return 'Moment<' + this.format() + '>';
          };
      }
      proto.toJSON = toJSON;
      proto.toString = toString;
      proto.unix = unix;
      proto.valueOf = valueOf;
      proto.creationData = creationData;
      proto.eraName = getEraName;
      proto.eraNarrow = getEraNarrow;
      proto.eraAbbr = getEraAbbr;
      proto.eraYear = getEraYear;
      proto.year = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week = proto.weeks = getSetWeek;
      proto.isoWeek = proto.isoWeeks = getSetISOWeek;
      proto.weeksInYear = getWeeksInYear;
      proto.weeksInWeekYear = getWeeksInWeekYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
      proto.date = getSetDayOfMonth;
      proto.day = proto.days = getSetDayOfWeek;
      proto.weekday = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset = getSetOffset;
      proto.utc = setOffsetToUTC;
      proto.local = setOffsetToLocal;
      proto.parseZone = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST = isDaylightSavingTime;
      proto.isLocal = isLocal;
      proto.isUtcOffset = isUtcOffset;
      proto.isUtc = isUtc;
      proto.isUTC = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates = deprecate(
          'dates accessor is deprecated. Use date instead.',
          getSetDayOfMonth
      );
      proto.months = deprecate(
          'months accessor is deprecated. Use month instead',
          getSetMonth
      );
      proto.years = deprecate(
          'years accessor is deprecated. Use year instead',
          getSetYear
      );
      proto.zone = deprecate(
          'moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',
          getSetZone
      );
      proto.isDSTShifted = deprecate(
          'isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',
          isDaylightSavingTimeShifted
      );

      function createUnix(input) {
          return createLocal(input * 1000);
      }

      function createInZone() {
          return createLocal.apply(null, arguments).parseZone();
      }

      function preParsePostFormat(string) {
          return string;
      }

      var proto$1 = Locale.prototype;

      proto$1.calendar = calendar;
      proto$1.longDateFormat = longDateFormat;
      proto$1.invalidDate = invalidDate;
      proto$1.ordinal = ordinal;
      proto$1.preparse = preParsePostFormat;
      proto$1.postformat = preParsePostFormat;
      proto$1.relativeTime = relativeTime;
      proto$1.pastFuture = pastFuture;
      proto$1.set = set;
      proto$1.eras = localeEras;
      proto$1.erasParse = localeErasParse;
      proto$1.erasConvertYear = localeErasConvertYear;
      proto$1.erasAbbrRegex = erasAbbrRegex;
      proto$1.erasNameRegex = erasNameRegex;
      proto$1.erasNarrowRegex = erasNarrowRegex;

      proto$1.months = localeMonths;
      proto$1.monthsShort = localeMonthsShort;
      proto$1.monthsParse = localeMonthsParse;
      proto$1.monthsRegex = monthsRegex;
      proto$1.monthsShortRegex = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;

      proto$1.weekdays = localeWeekdays;
      proto$1.weekdaysMin = localeWeekdaysMin;
      proto$1.weekdaysShort = localeWeekdaysShort;
      proto$1.weekdaysParse = localeWeekdaysParse;

      proto$1.weekdaysRegex = weekdaysRegex;
      proto$1.weekdaysShortRegex = weekdaysShortRegex;
      proto$1.weekdaysMinRegex = weekdaysMinRegex;

      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;

      function get$1(format, index, field, setter) {
          var locale = getLocale(),
              utc = createUTC().set(setter, index);
          return locale[field](utc, format);
      }

      function listMonthsImpl(format, index, field) {
          if (isNumber(format)) {
              index = format;
              format = undefined;
          }

          format = format || '';

          if (index != null) {
              return get$1(format, index, field, 'month');
          }

          var i,
              out = [];
          for (i = 0; i < 12; i++) {
              out[i] = get$1(format, i, field, 'month');
          }
          return out;
      }

      // ()
      // (5)
      // (fmt, 5)
      // (fmt)
      // (true)
      // (true, 5)
      // (true, fmt, 5)
      // (true, fmt)
      function listWeekdaysImpl(localeSorted, format, index, field) {
          if (typeof localeSorted === 'boolean') {
              if (isNumber(format)) {
                  index = format;
                  format = undefined;
              }

              format = format || '';
          } else {
              format = localeSorted;
              index = format;
              localeSorted = false;

              if (isNumber(format)) {
                  index = format;
                  format = undefined;
              }

              format = format || '';
          }

          var locale = getLocale(),
              shift = localeSorted ? locale._week.dow : 0,
              i,
              out = [];

          if (index != null) {
              return get$1(format, (index + shift) % 7, field, 'day');
          }

          for (i = 0; i < 7; i++) {
              out[i] = get$1(format, (i + shift) % 7, field, 'day');
          }
          return out;
      }

      function listMonths(format, index) {
          return listMonthsImpl(format, index, 'months');
      }

      function listMonthsShort(format, index) {
          return listMonthsImpl(format, index, 'monthsShort');
      }

      function listWeekdays(localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
      }

      function listWeekdaysShort(localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
      }

      function listWeekdaysMin(localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
      }

      getSetGlobalLocale('en', {
          eras: [
              {
                  since: '0001-01-01',
                  until: +Infinity,
                  offset: 1,
                  name: 'Anno Domini',
                  narrow: 'AD',
                  abbr: 'AD',
              },
              {
                  since: '0000-12-31',
                  until: -Infinity,
                  offset: 1,
                  name: 'Before Christ',
                  narrow: 'BC',
                  abbr: 'BC',
              },
          ],
          dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
          ordinal: function (number) {
              var b = number % 10,
                  output =
                      toInt((number % 100) / 10) === 1
                          ? 'th'
                          : b === 1
                          ? 'st'
                          : b === 2
                          ? 'nd'
                          : b === 3
                          ? 'rd'
                          : 'th';
              return number + output;
          },
      });

      // Side effect imports

      hooks.lang = deprecate(
          'moment.lang is deprecated. Use moment.locale instead.',
          getSetGlobalLocale
      );
      hooks.langData = deprecate(
          'moment.langData is deprecated. Use moment.localeData instead.',
          getLocale
      );

      var mathAbs = Math.abs;

      function abs() {
          var data = this._data;

          this._milliseconds = mathAbs(this._milliseconds);
          this._days = mathAbs(this._days);
          this._months = mathAbs(this._months);

          data.milliseconds = mathAbs(data.milliseconds);
          data.seconds = mathAbs(data.seconds);
          data.minutes = mathAbs(data.minutes);
          data.hours = mathAbs(data.hours);
          data.months = mathAbs(data.months);
          data.years = mathAbs(data.years);

          return this;
      }

      function addSubtract$1(duration, input, value, direction) {
          var other = createDuration(input, value);

          duration._milliseconds += direction * other._milliseconds;
          duration._days += direction * other._days;
          duration._months += direction * other._months;

          return duration._bubble();
      }

      // supports only 2.0-style add(1, 's') or add(duration)
      function add$1(input, value) {
          return addSubtract$1(this, input, value, 1);
      }

      // supports only 2.0-style subtract(1, 's') or subtract(duration)
      function subtract$1(input, value) {
          return addSubtract$1(this, input, value, -1);
      }

      function absCeil(number) {
          if (number < 0) {
              return Math.floor(number);
          } else {
              return Math.ceil(number);
          }
      }

      function bubble() {
          var milliseconds = this._milliseconds,
              days = this._days,
              months = this._months,
              data = this._data,
              seconds,
              minutes,
              hours,
              years,
              monthsFromDays;

          // if we have a mix of positive and negative values, bubble down first
          // check: https://github.com/moment/moment/issues/2166
          if (
              !(
                  (milliseconds >= 0 && days >= 0 && months >= 0) ||
                  (milliseconds <= 0 && days <= 0 && months <= 0)
              )
          ) {
              milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
              days = 0;
              months = 0;
          }

          // The following code bubbles up values, see the tests for
          // examples of what that means.
          data.milliseconds = milliseconds % 1000;

          seconds = absFloor(milliseconds / 1000);
          data.seconds = seconds % 60;

          minutes = absFloor(seconds / 60);
          data.minutes = minutes % 60;

          hours = absFloor(minutes / 60);
          data.hours = hours % 24;

          days += absFloor(hours / 24);

          // convert days to months
          monthsFromDays = absFloor(daysToMonths(days));
          months += monthsFromDays;
          days -= absCeil(monthsToDays(monthsFromDays));

          // 12 months -> 1 year
          years = absFloor(months / 12);
          months %= 12;

          data.days = days;
          data.months = months;
          data.years = years;

          return this;
      }

      function daysToMonths(days) {
          // 400 years have 146097 days (taking into account leap year rules)
          // 400 years have 12 months === 4800
          return (days * 4800) / 146097;
      }

      function monthsToDays(months) {
          // the reverse of daysToMonths
          return (months * 146097) / 4800;
      }

      function as(units) {
          if (!this.isValid()) {
              return NaN;
          }
          var days,
              months,
              milliseconds = this._milliseconds;

          units = normalizeUnits(units);

          if (units === 'month' || units === 'quarter' || units === 'year') {
              days = this._days + milliseconds / 864e5;
              months = this._months + daysToMonths(days);
              switch (units) {
                  case 'month':
                      return months;
                  case 'quarter':
                      return months / 3;
                  case 'year':
                      return months / 12;
              }
          } else {
              // handle milliseconds separately because of floating point math errors (issue #1867)
              days = this._days + Math.round(monthsToDays(this._months));
              switch (units) {
                  case 'week':
                      return days / 7 + milliseconds / 6048e5;
                  case 'day':
                      return days + milliseconds / 864e5;
                  case 'hour':
                      return days * 24 + milliseconds / 36e5;
                  case 'minute':
                      return days * 1440 + milliseconds / 6e4;
                  case 'second':
                      return days * 86400 + milliseconds / 1000;
                  // Math.floor prevents floating point math errors here
                  case 'millisecond':
                      return Math.floor(days * 864e5) + milliseconds;
                  default:
                      throw new Error('Unknown unit ' + units);
              }
          }
      }

      // TODO: Use this.as('ms')?
      function valueOf$1() {
          if (!this.isValid()) {
              return NaN;
          }
          return (
              this._milliseconds +
              this._days * 864e5 +
              (this._months % 12) * 2592e6 +
              toInt(this._months / 12) * 31536e6
          );
      }

      function makeAs(alias) {
          return function () {
              return this.as(alias);
          };
      }

      var asMilliseconds = makeAs('ms'),
          asSeconds = makeAs('s'),
          asMinutes = makeAs('m'),
          asHours = makeAs('h'),
          asDays = makeAs('d'),
          asWeeks = makeAs('w'),
          asMonths = makeAs('M'),
          asQuarters = makeAs('Q'),
          asYears = makeAs('y');

      function clone$1() {
          return createDuration(this);
      }

      function get$2(units) {
          units = normalizeUnits(units);
          return this.isValid() ? this[units + 's']() : NaN;
      }

      function makeGetter(name) {
          return function () {
              return this.isValid() ? this._data[name] : NaN;
          };
      }

      var milliseconds = makeGetter('milliseconds'),
          seconds = makeGetter('seconds'),
          minutes = makeGetter('minutes'),
          hours = makeGetter('hours'),
          days = makeGetter('days'),
          months = makeGetter('months'),
          years = makeGetter('years');

      function weeks() {
          return absFloor(this.days() / 7);
      }

      var round = Math.round,
          thresholds = {
              ss: 44, // a few seconds to seconds
              s: 45, // seconds to minute
              m: 45, // minutes to hour
              h: 22, // hours to day
              d: 26, // days to month/week
              w: null, // weeks to month
              M: 11, // months to year
          };

      // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
          return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
      }

      function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
          var duration = createDuration(posNegDuration).abs(),
              seconds = round(duration.as('s')),
              minutes = round(duration.as('m')),
              hours = round(duration.as('h')),
              days = round(duration.as('d')),
              months = round(duration.as('M')),
              weeks = round(duration.as('w')),
              years = round(duration.as('y')),
              a =
                  (seconds <= thresholds.ss && ['s', seconds]) ||
                  (seconds < thresholds.s && ['ss', seconds]) ||
                  (minutes <= 1 && ['m']) ||
                  (minutes < thresholds.m && ['mm', minutes]) ||
                  (hours <= 1 && ['h']) ||
                  (hours < thresholds.h && ['hh', hours]) ||
                  (days <= 1 && ['d']) ||
                  (days < thresholds.d && ['dd', days]);

          if (thresholds.w != null) {
              a =
                  a ||
                  (weeks <= 1 && ['w']) ||
                  (weeks < thresholds.w && ['ww', weeks]);
          }
          a = a ||
              (months <= 1 && ['M']) ||
              (months < thresholds.M && ['MM', months]) ||
              (years <= 1 && ['y']) || ['yy', years];

          a[2] = withoutSuffix;
          a[3] = +posNegDuration > 0;
          a[4] = locale;
          return substituteTimeAgo.apply(null, a);
      }

      // This function allows you to set the rounding function for relative time strings
      function getSetRelativeTimeRounding(roundingFunction) {
          if (roundingFunction === undefined) {
              return round;
          }
          if (typeof roundingFunction === 'function') {
              round = roundingFunction;
              return true;
          }
          return false;
      }

      // This function allows you to set a threshold for relative time strings
      function getSetRelativeTimeThreshold(threshold, limit) {
          if (thresholds[threshold] === undefined) {
              return false;
          }
          if (limit === undefined) {
              return thresholds[threshold];
          }
          thresholds[threshold] = limit;
          if (threshold === 's') {
              thresholds.ss = limit - 1;
          }
          return true;
      }

      function humanize(argWithSuffix, argThresholds) {
          if (!this.isValid()) {
              return this.localeData().invalidDate();
          }

          var withSuffix = false,
              th = thresholds,
              locale,
              output;

          if (typeof argWithSuffix === 'object') {
              argThresholds = argWithSuffix;
              argWithSuffix = false;
          }
          if (typeof argWithSuffix === 'boolean') {
              withSuffix = argWithSuffix;
          }
          if (typeof argThresholds === 'object') {
              th = Object.assign({}, thresholds, argThresholds);
              if (argThresholds.s != null && argThresholds.ss == null) {
                  th.ss = argThresholds.s - 1;
              }
          }

          locale = this.localeData();
          output = relativeTime$1(this, !withSuffix, th, locale);

          if (withSuffix) {
              output = locale.pastFuture(+this, output);
          }

          return locale.postformat(output);
      }

      var abs$1 = Math.abs;

      function sign(x) {
          return (x > 0) - (x < 0) || +x;
      }

      function toISOString$1() {
          // for ISO strings we do not use the normal bubbling rules:
          //  * milliseconds bubble up until they become hours
          //  * days do not bubble at all
          //  * months bubble up until they become years
          // This is because there is no context-free conversion between hours and days
          // (think of clock changes)
          // and also not between days and months (28-31 days per month)
          if (!this.isValid()) {
              return this.localeData().invalidDate();
          }

          var seconds = abs$1(this._milliseconds) / 1000,
              days = abs$1(this._days),
              months = abs$1(this._months),
              minutes,
              hours,
              years,
              s,
              total = this.asSeconds(),
              totalSign,
              ymSign,
              daysSign,
              hmsSign;

          if (!total) {
              // this is the same as C#'s (Noda) and python (isodate)...
              // but not other JS (goog.date)
              return 'P0D';
          }

          // 3600 seconds -> 60 minutes -> 1 hour
          minutes = absFloor(seconds / 60);
          hours = absFloor(minutes / 60);
          seconds %= 60;
          minutes %= 60;

          // 12 months -> 1 year
          years = absFloor(months / 12);
          months %= 12;

          // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
          s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';

          totalSign = total < 0 ? '-' : '';
          ymSign = sign(this._months) !== sign(total) ? '-' : '';
          daysSign = sign(this._days) !== sign(total) ? '-' : '';
          hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

          return (
              totalSign +
              'P' +
              (years ? ymSign + years + 'Y' : '') +
              (months ? ymSign + months + 'M' : '') +
              (days ? daysSign + days + 'D' : '') +
              (hours || minutes || seconds ? 'T' : '') +
              (hours ? hmsSign + hours + 'H' : '') +
              (minutes ? hmsSign + minutes + 'M' : '') +
              (seconds ? hmsSign + s + 'S' : '')
          );
      }

      var proto$2 = Duration.prototype;

      proto$2.isValid = isValid$1;
      proto$2.abs = abs;
      proto$2.add = add$1;
      proto$2.subtract = subtract$1;
      proto$2.as = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds = asSeconds;
      proto$2.asMinutes = asMinutes;
      proto$2.asHours = asHours;
      proto$2.asDays = asDays;
      proto$2.asWeeks = asWeeks;
      proto$2.asMonths = asMonths;
      proto$2.asQuarters = asQuarters;
      proto$2.asYears = asYears;
      proto$2.valueOf = valueOf$1;
      proto$2._bubble = bubble;
      proto$2.clone = clone$1;
      proto$2.get = get$2;
      proto$2.milliseconds = milliseconds;
      proto$2.seconds = seconds;
      proto$2.minutes = minutes;
      proto$2.hours = hours;
      proto$2.days = days;
      proto$2.weeks = weeks;
      proto$2.months = months;
      proto$2.years = years;
      proto$2.humanize = humanize;
      proto$2.toISOString = toISOString$1;
      proto$2.toString = toISOString$1;
      proto$2.toJSON = toISOString$1;
      proto$2.locale = locale;
      proto$2.localeData = localeData;

      proto$2.toIsoString = deprecate(
          'toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',
          toISOString$1
      );
      proto$2.lang = lang;

      // FORMATTING

      addFormatToken('X', 0, 0, 'unix');
      addFormatToken('x', 0, 0, 'valueOf');

      // PARSING

      addRegexToken('x', matchSigned);
      addRegexToken('X', matchTimestamp);
      addParseToken('X', function (input, array, config) {
          config._d = new Date(parseFloat(input) * 1000);
      });
      addParseToken('x', function (input, array, config) {
          config._d = new Date(toInt(input));
      });

      //! moment.js

      hooks.version = '2.29.4';

      setHookCallback(createLocal);

      hooks.fn = proto;
      hooks.min = min;
      hooks.max = max;
      hooks.now = now;
      hooks.utc = createUTC;
      hooks.unix = createUnix;
      hooks.months = listMonths;
      hooks.isDate = isDate;
      hooks.locale = getSetGlobalLocale;
      hooks.invalid = createInvalid;
      hooks.duration = createDuration;
      hooks.isMoment = isMoment;
      hooks.weekdays = listWeekdays;
      hooks.parseZone = createInZone;
      hooks.localeData = getLocale;
      hooks.isDuration = isDuration;
      hooks.monthsShort = listMonthsShort;
      hooks.weekdaysMin = listWeekdaysMin;
      hooks.defineLocale = defineLocale;
      hooks.updateLocale = updateLocale;
      hooks.locales = listLocales;
      hooks.weekdaysShort = listWeekdaysShort;
      hooks.normalizeUnits = normalizeUnits;
      hooks.relativeTimeRounding = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat = getCalendarFormat;
      hooks.prototype = proto;

      // currently HTML5 input type only supports 24-hour formats
      hooks.HTML5_FMT = {
          DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm', // <input type="datetime-local" />
          DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss', // <input type="datetime-local" step="1" />
          DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS', // <input type="datetime-local" step="0.001" />
          DATE: 'YYYY-MM-DD', // <input type="date" />
          TIME: 'HH:mm', // <input type="time" />
          TIME_SECONDS: 'HH:mm:ss', // <input type="time" step="1" />
          TIME_MS: 'HH:mm:ss.SSS', // <input type="time" step="0.001" />
          WEEK: 'GGGG-[W]WW', // <input type="week" />
          MONTH: 'YYYY-MM', // <input type="month" />
      };

      return hooks;

  })));
  });

  function toMoment(date, calendar) {
      if (!(calendar instanceof CalendarImpl)) {
          throw new Error('must supply a CalendarApi instance');
      }
      let { dateEnv } = calendar.getCurrentData();
      return convertToMoment(date, dateEnv.timeZone, null, dateEnv.locale.codes[0]);
  }
  function toMomentDuration(fcDuration) {
      return moment.duration(fcDuration); // moment accepts all the props that fc.Duration already has!
  }
  // Internal Utils
  function convertToMoment(input, timeZone, timeZoneOffset, locale) {
      let mom;
      if (timeZone === 'local') {
          mom = moment(input);
      }
      else if (timeZone === 'UTC') {
          mom = moment.utc(input);
      }
      else if (moment.tz) {
          mom = moment.tz(input, timeZone);
      }
      else {
          mom = moment.utc(input);
          if (timeZoneOffset != null) {
              mom.utcOffset(timeZoneOffset);
          }
      }
      mom.locale(locale);
      return mom;
  }

  function formatWithCmdStr(cmdStr, arg) {
      let cmd = parseCmdStr(cmdStr);
      if (arg.end) {
          let startMom = convertToMoment(arg.start.array, arg.timeZone, arg.start.timeZoneOffset, arg.localeCodes[0]);
          let endMom = convertToMoment(arg.end.array, arg.timeZone, arg.end.timeZoneOffset, arg.localeCodes[0]);
          return formatRange(cmd, createMomentFormatFunc(startMom), createMomentFormatFunc(endMom), arg.defaultSeparator);
      }
      return convertToMoment(arg.date.array, arg.timeZone, arg.date.timeZoneOffset, arg.localeCodes[0]).format(cmd.whole); // TODO: test for this
  }
  function createMomentFormatFunc(mom) {
      return (cmdStr) => (cmdStr ? mom.format(cmdStr) : '' // because calling with blank string results in ISO8601 :(
      );
  }
  function parseCmdStr(cmdStr) {
      let parts = cmdStr.match(/^(.*?)\{(.*)\}(.*)$/); // TODO: lookbehinds for escape characters
      if (parts) {
          let middle = parseCmdStr(parts[2]);
          return {
              head: parts[1],
              middle,
              tail: parts[3],
              whole: parts[1] + middle.whole + parts[3],
          };
      }
      return {
          head: null,
          middle: null,
          tail: null,
          whole: cmdStr,
      };
  }
  function formatRange(cmd, formatStart, formatEnd, separator) {
      if (cmd.middle) {
          let startHead = formatStart(cmd.head);
          let startMiddle = formatRange(cmd.middle, formatStart, formatEnd, separator);
          let startTail = formatStart(cmd.tail);
          let endHead = formatEnd(cmd.head);
          let endMiddle = formatRange(cmd.middle, formatStart, formatEnd, separator);
          let endTail = formatEnd(cmd.tail);
          if (startHead === endHead && startTail === endTail) {
              return startHead +
                  (startMiddle === endMiddle ? startMiddle : startMiddle + separator + endMiddle) +
                  startTail;
          }
      }
      let startWhole = formatStart(cmd.whole);
      let endWhole = formatEnd(cmd.whole);
      if (startWhole === endWhole) {
          return startWhole;
      }
      return startWhole + separator + endWhole;
  }

  var index$4 = createPlugin({
      name: '@fullcalendar/moment',
      cmdFormatter: formatWithCmdStr,
  });

  createCommonjsModule$1(function (module, exports) {
  (function (global, factory) {
     typeof commonjsRequire === 'function' ? factory(moment) :
     factory(global.moment);
  }(commonjsGlobal$1, (function (moment) {
      //! moment.js locale configuration

      var monthsShortDot =
              'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split(
                  '_'
              ),
          monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
          monthsParse = [
              /^ene/i,
              /^feb/i,
              /^mar/i,
              /^abr/i,
              /^may/i,
              /^jun/i,
              /^jul/i,
              /^ago/i,
              /^sep/i,
              /^oct/i,
              /^nov/i,
              /^dic/i,
          ],
          monthsRegex =
              /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

      var es = moment.defineLocale('es', {
          months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split(
              '_'
          ),
          monthsShort: function (m, format) {
              if (!m) {
                  return monthsShortDot;
              } else if (/-MMM-/.test(format)) {
                  return monthsShort[m.month()];
              } else {
                  return monthsShortDot[m.month()];
              }
          },
          monthsRegex: monthsRegex,
          monthsShortRegex: monthsRegex,
          monthsStrictRegex:
              /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
          monthsShortStrictRegex:
              /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
          monthsParse: monthsParse,
          longMonthsParse: monthsParse,
          shortMonthsParse: monthsParse,
          weekdays: 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
          weekdaysShort: 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
          weekdaysMin: 'do_lu_ma_mi_ju_vi_sá'.split('_'),
          weekdaysParseExact: true,
          longDateFormat: {
              LT: 'H:mm',
              LTS: 'H:mm:ss',
              L: 'DD/MM/YYYY',
              LL: 'D [de] MMMM [de] YYYY',
              LLL: 'D [de] MMMM [de] YYYY H:mm',
              LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm',
          },
          calendar: {
              sameDay: function () {
                  return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
              },
              nextDay: function () {
                  return '[mañana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
              },
              nextWeek: function () {
                  return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
              },
              lastDay: function () {
                  return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
              },
              lastWeek: function () {
                  return (
                      '[el] dddd [pasado a la' +
                      (this.hours() !== 1 ? 's' : '') +
                      '] LT'
                  );
              },
              sameElse: 'L',
          },
          relativeTime: {
              future: 'en %s',
              past: 'hace %s',
              s: 'unos segundos',
              ss: '%d segundos',
              m: 'un minuto',
              mm: '%d minutos',
              h: 'una hora',
              hh: '%d horas',
              d: 'un día',
              dd: '%d días',
              w: 'una semana',
              ww: '%d semanas',
              M: 'un mes',
              MM: '%d meses',
              y: 'un año',
              yy: '%d años',
          },
          dayOfMonthOrdinalParse: /\d{1,2}º/,
          ordinal: '%dº',
          week: {
              dow: 1, // Monday is the first day of the week.
              doy: 4, // The week that contains Jan 4th is the first week of the year.
          },
          invalidDate: 'Fecha inválida',
      });

      return es;

  })));
  });

  // fix bug with jQuery 3 returning 0 height for <td> elements in the IE's
  ['height', 'outerHeight'].forEach((methodName) => {
      let orig = $.fn[methodName];
      $.fn[methodName] = function () {
          if (!arguments.length && this.is('td')) { // eslint-disable-line prefer-rest-params
              return this[0].getBoundingClientRect().height;
          }
          return orig.apply(this, arguments); // eslint-disable-line prefer-rest-params
      };
  });
  function getBoundingRects(els) {
      return $(els).map((i, node) => getBoundingRect(node)).get();
  }
  function getBoundingRect(el) {
      el = $(el);
      return $.extend({}, el[0].getBoundingClientRect(), {
          node: el, // very useful for debugging
      });
  }
  function anyElsIntersect(els) {
      let rects = els.map((el) => el.getBoundingClientRect());
      for (let i = 0; i < rects.length; i += 1) {
          for (let j = i + 1; j < rects.length; j += 1) {
              if (rectsIntersect(rects[i], rects[j])) {
                  return [els[i], els[j]];
              }
          }
      }
      return false;
  }
  function anyElsObscured(els) {
      let rects = els.map((el) => el.getBoundingClientRect());
      for (let i = 0; i < rects.length; i += 1) {
          for (let j = 0; j < rects.length; j += 1) {
              if (i !== j && rectContainersOther(rects[i], rects[j])) {
                  return [els[i], els[j]];
              }
          }
      }
      return false;
  }
  // given an element, returns its bounding box. given a rect, returns the rect.
  function massageRect(input) {
      if (isRect(input)) {
          return input;
      }
      return getBoundingRect(input);
  }
  // Jasmine Adapters
  // --------------------------------------------------------------------------------------------------
  beforeEach(() => {
      jasmine.addMatchers({
          toBeMostlyAbove() {
              return {
                  compare(subject, other) {
                      const result = { pass: isRectMostlyAbove(massageRect(subject), massageRect(other)), message: '' };
                      if (!result.pass) {
                          result.message = 'first rect is not mostly above the second';
                      }
                      return result;
                  },
              };
          },
          toBeMostlyBelow() {
              return {
                  compare(subject, other) {
                      const result = { pass: !isRectMostlyAbove(massageRect(subject), massageRect(other)), message: '' };
                      if (!result.pass) {
                          result.message = 'first rect is not mostly below the second';
                      }
                      return result;
                  },
              };
          },
          toBeMostlyLeftOf() {
              return {
                  compare(subject, other) {
                      const result = { pass: isRectMostlyLeft(massageRect(subject), massageRect(other)), message: '' };
                      if (!result.pass) {
                          result.message = 'first rect is not mostly left of the second';
                      }
                      return result;
                  },
              };
          },
          toBeMostlyRightOf() {
              return {
                  compare(subject, other) {
                      const result = { pass: !isRectMostlyLeft(massageRect(subject), massageRect(other)), message: '' };
                      if (!result.pass) {
                          result.message = 'first rect is not mostly right of the second';
                      }
                      return result;
                  },
              };
          },
          toBeMostlyBoundedBy() {
              return {
                  compare(subject, other) {
                      const result = { pass: isRectMostlyBounded(massageRect(subject), massageRect(other)), message: '' };
                      if (!result.pass) {
                          result.message = 'first rect is not mostly bounded by the second';
                      }
                      return result;
                  },
              };
          },
          toBeMostlyHBoundedBy() {
              return {
                  compare(subject, other) {
                      const result = { pass: isRectMostlyHBounded(massageRect(subject), massageRect(other)), message: '' };
                      if (!result.pass) {
                          result.message = 'first rect does not mostly horizontally bound the second';
                      }
                      return result;
                  },
              };
          },
          toBeMostlyVBoundedBy() {
              return {
                  compare(subject, other) {
                      const result = { pass: isRectMostlyVBounded(massageRect(subject), massageRect(other)), message: '' };
                      if (!result.pass) {
                          result.message = 'first rect does not mostly vertically bound the second';
                      }
                      return result;
                  },
              };
          },
          toBeBoundedBy() {
              return {
                  compare(actual, expected) {
                      let outer = massageRect(expected);
                      let inner = massageRect(actual);
                      let result = {
                          message: '',
                          pass: outer && inner &&
                              inner.left >= outer.left &&
                              inner.right <= outer.right &&
                              inner.top >= outer.top &&
                              inner.bottom <= outer.bottom,
                      };
                      if (!result.pass) {
                          result.message = 'Element does not bound other element';
                      }
                      return result;
                  },
              };
          },
          toBeLeftOf() {
              return {
                  compare(actual, expected) {
                      let subjectBounds = massageRect(actual);
                      let otherBounds = massageRect(expected);
                      let result = {
                          message: '',
                          pass: subjectBounds && otherBounds &&
                              Math.round(subjectBounds.right) <= Math.round(otherBounds.left) + 2,
                          // need to round because IE was giving weird fractions
                      };
                      if (!result.pass) {
                          result.message = 'Element is not to the left of the other element';
                      }
                      return result;
                  },
              };
          },
          toBeRightOf() {
              return {
                  compare(actual, expected) {
                      let subjectBounds = massageRect(actual);
                      let otherBounds = massageRect(expected);
                      let result = {
                          message: '',
                          pass: subjectBounds && otherBounds &&
                              Math.round(subjectBounds.left) >= Math.round(otherBounds.right) - 2,
                          // need to round because IE was giving weird fractions
                      };
                      if (!result.pass) {
                          result.message = 'Element is not to the right of the other element';
                      }
                      return result;
                  },
              };
          },
          toBeAbove() {
              return {
                  compare(actual, expected) {
                      let subjectBounds = massageRect(actual);
                      let otherBounds = massageRect(expected);
                      let result = {
                          message: '',
                          pass: subjectBounds && otherBounds &&
                              Math.round(subjectBounds.bottom) <= Math.round(otherBounds.top) + 2,
                          // need to round because IE was giving weird fractions
                      };
                      if (!result.pass) {
                          result.message = 'Element is not above the other element';
                      }
                      return result;
                  },
              };
          },
          toBeBelow() {
              return {
                  compare(actual, expected) {
                      let subjectBounds = massageRect(actual);
                      let otherBounds = massageRect(expected);
                      let result = {
                          message: '',
                          pass: subjectBounds && otherBounds &&
                              Math.round(subjectBounds.top) >= Math.round(otherBounds.bottom) - 2,
                          // need to round because IE was giving weird fractions
                      };
                      if (!result.pass) {
                          result.message = 'Element is not below the other element';
                      }
                      return result;
                  },
              };
          },
          toIntersectWith() {
              return {
                  compare(actual, expected) {
                      let subjectBounds = massageRect(actual);
                      let otherBounds = massageRect(expected);
                      let result = {
                          message: '',
                          pass: subjectBounds && otherBounds &&
                              subjectBounds.right - 1 > otherBounds.left &&
                              subjectBounds.left + 1 < otherBounds.right &&
                              subjectBounds.bottom - 1 > otherBounds.top &&
                              subjectBounds.top + 1 < otherBounds.bottom,
                          // +/-1 because of zoom
                      };
                      if (!result.pass) {
                          result.message = 'Element does not intersect with other element';
                      }
                      return result;
                  },
              };
          },
      });
  });

  class TimeGridWrapper {
      constructor(el) {
          this.el = el;
      }
      getAllDayEls() {
          return findElements(this.el, '.fc-day[data-date]');
      }
      getMirrorEls() {
          return findElements(this.el, '.fc-event.fc-event-mirror');
      }
      getDayEls(date) {
          date = ensureDate(date);
          return findElements(this.el, '.fc-day[data-date="' + formatIsoDay(date) + '"]');
      }
      getSlotEls() {
          return findElements(this.el, '.fc-timegrid-slot-label[data-time]');
      }
      getAxisTexts() {
          return this.getSlotAxisEls().map((el) => $(el).text());
      }
      getSlotAxisEls() {
          return findElements(this.el, '.fc-timegrid-slot-label[data-time]');
      }
      getSlotLaneEls() {
          return findElements(this.el, '.fc-timegrid-slot-lane[data-time]');
      }
      getSlotElByIndex(index) {
          return $(`.fc-timegrid-slots tr:eq(${index})`, this.el).get();
      }
      getMainSlotTable() {
          return $('.fc-timegrid-slots > table')[0];
      }
      getSeparateSlotAxisTable() {
          return $('.fc-timegrid-axis-chunk > table')[0];
      }
      getSlotElByTime(timeMs) {
          let date = parseUtcDate('2016-01-01');
          date = new Date(date.valueOf() + timeMs);
          if (date.getUTCDate() === 1) { // ensure no time overflow/underflow
              return this.el.querySelector('.fc-timegrid-slot-label[data-time="' + formatIsoTime(date) + '"]');
          }
          return null;
      }
      getNonBusinessDayEls() {
          return findElements(this.el, '.fc-non-business');
      }
      getColEl(col) {
          return this.el.querySelectorAll('.fc-timegrid-col:not(.fc-timegrid-axis)')[col];
      }
      queryBgEventsInCol(col) {
          return findElements(this.getColEl(col), '.fc-bg-event');
      }
      queryNonBusinessSegsInCol(col) {
          return findElements(this.getColEl(col), '.fc-non-business');
      }
      getHighlightEls() {
          return findElements(this.el, '.fc-highlight');
      }
      // TODO: discourage use
      getDowEls(dayAbbrev) {
          return findElements(this.el, `.fc-day-${dayAbbrev}`);
      }
      // for https://github.com/fullcalendar/fullcalendar-scheduler/issues/363
      isStructureValid() {
          return Boolean(this.el.querySelector('.fc-timegrid-slots'));
      }
      getMoreEls() {
          return findElements(this.el, '.fc-timegrid-more-link');
      }
      openMorePopover(index) {
          $(this.getMoreEls()[index || 0]).simulate('click');
      }
      getMorePopoverEl() {
          let viewWrapperEl = this.el.closest('.fc-view-harness');
          return viewWrapperEl.querySelector('.fc-more-popover');
      }
      getMorePopoverEventEls() {
          return findElements(this.getMorePopoverEl(), '.fc-event');
      }
      hasNowIndicator() {
          let hasArrow = Boolean(this.getNowIndicatorArrowEl());
          let hasLine = Boolean(this.getNowIndicatorLineEl());
          if (hasArrow !== hasLine) {
              throw new Error('Inconsistent now-indicator rendering state');
          }
          else {
              return hasArrow;
          }
      }
      getNowIndicatorArrowEl() {
          return this.el.querySelector('.fc-timegrid-now-indicator-arrow');
      }
      getNowIndicatorLineEl() {
          return this.el.querySelector('.fc-timegrid-now-indicator-line');
      }
      getTimeAxisInfo() {
          return $('.fc-timegrid-slot-label[data-time]', this.el).map((i, td) => ({
              text: $(td).text(),
              isMajor: !$(td).hasClass('fc-timegrid-slot-minor'),
          })).get();
      }
      getLastMajorAxisInfo() {
          let cells = this.getTimeAxisInfo();
          for (let i = cells.length - 1; i >= 0; i -= 1) {
              if (cells[i].isMajor) {
                  return cells[i];
              }
          }
          return null;
      }
      dragEventToDate(eventEl, dropDate, onBeforeRelease) {
          return new Promise((resolve) => {
              $(eventEl).simulate('drag', {
                  localPoint: { left: '50%', top: 5 },
                  end: this.getPoint(dropDate),
                  onBeforeRelease,
                  onRelease: () => resolve(),
              });
          });
      }
      resizeEvent(eventEl, origEndDate, newEndDate, onBeforeRelease) {
          return new Promise((resolve) => {
              let resizerEl = $(eventEl).find('.' + CalendarWrapper.EVENT_RESIZER_CLASSNAME)
                  .css('display', 'block')[0]; // usually only displays on hover. force display
              let resizerPoint = getRectCenter$1(resizerEl.getBoundingClientRect());
              let origPoint = this.getPoint(origEndDate);
              let yCorrect = resizerPoint.top - origPoint.top;
              let destPoint = this.getPoint(newEndDate);
              destPoint = addPoints(destPoint, { left: 0, top: yCorrect });
              $(resizerEl).simulate('drag', {
                  end: destPoint,
                  onBeforeRelease,
                  onRelease: () => resolve(),
              });
          });
      }
      resizeEventTouch(eventEl, origEndDate, newEndDate) {
          return new Promise((resolve) => {
              setTimeout(() => {
                  $(eventEl).simulate('drag', {
                      isTouch: true,
                      localPoint: { left: '50%', top: '90%' },
                      delay: 200,
                      onRelease: () => {
                          let resizerEl = eventEl.querySelector('.' + CalendarWrapper.EVENT_RESIZER_CLASSNAME);
                          let resizerPoint = getRectCenter$1(resizerEl.getBoundingClientRect());
                          let origPoint = this.getPoint(origEndDate);
                          let yCorrect = resizerPoint.top - origPoint.top;
                          let destPoint = this.getPoint(newEndDate);
                          destPoint = addPoints(destPoint, { left: 0, top: yCorrect });
                          $(resizerEl).simulate('drag', {
                              isTouch: true,
                              end: destPoint,
                              onRelease: () => resolve(),
                          });
                      },
                  });
              }, 0);
          });
      }
      selectDates(start, end) {
          let startPoint = this.getPoint(start);
          let endPoint = this.getPoint(end, true);
          startPoint.top += 2;
          endPoint.top -= 2;
          return new Promise((resolve) => {
              $(this.getDayEls(start)).simulate('drag', {
                  point: startPoint,
                  end: endPoint,
                  onRelease: () => resolve(),
              });
          });
      }
      selectDatesTouch(start, end, debug = false) {
          let dayEls = this.getDayEls(start);
          let startPoint = this.getPoint(start);
          let endPoint = this.getPoint(end, true);
          startPoint.top += 2;
          endPoint.top -= 2;
          return new Promise((resolve) => {
              setTimeout(() => {
                  // QUESTION: why do we not need to do press-down first?
                  $(dayEls).simulate('drag', {
                      debug,
                      isTouch: true,
                      point: startPoint,
                      end: endPoint,
                      onRelease: () => resolve(),
                  });
              }, 0);
          });
      }
      clickDate(date) {
          return new Promise((resolve) => {
              $(this.getDayEls(date)).simulate('drag', {
                  point: this.getPoint(date),
                  onRelease: () => resolve(),
              });
          });
      }
      getRect(start, end) {
          let obj;
          if (typeof start === 'object') {
              obj = start;
              start = obj.start;
              end = obj.end;
          }
          start = ensureDate(start);
          end = ensureDate(end);
          let startDay = startOfDay(start);
          let endDay = startOfDay(end);
          let startTimeMs = start.valueOf() - startDay.valueOf();
          let endTimeMs = end.valueOf() - endDay.valueOf();
          if (startDay.valueOf() === endDay.valueOf()) {
              endTimeMs = end.valueOf() - endDay.valueOf();
          }
          else if (end < start) {
              endTimeMs = startTimeMs;
          }
          else {
              endTimeMs = 1000 * 60 * 60 * 24; // whole day
          }
          let dayEls = this.getDayEls(start);
          let dayRect = getBoundingRect(dayEls);
          return {
              left: dayRect.left,
              right: dayRect.right,
              top: this.getTimeTop(startTimeMs),
              bottom: this.getTimeTop(endTimeMs),
          };
      }
      getPoint(date, isEnd) {
          date = ensureDate(date);
          let day = startOfDay(date);
          let timeMs = date.valueOf() - day.valueOf();
          if (isEnd && !timeMs) {
              day = addDays(day, -1);
              timeMs = date.valueOf() - day.valueOf();
          }
          let top = this.getTimeTop(timeMs);
          let dayEls = this.getDayEls(day);
          let dayRect;
          expect(dayEls.length).toBe(1);
          dayRect = getBoundingRect(dayEls[0]);
          return {
              left: (dayRect.left + dayRect.right) / 2,
              top,
          };
      }
      getLine(date) {
          date = ensureDate(date);
          let day = startOfDay(date);
          let timeMs = date.valueOf() - day.valueOf();
          let top = this.getTimeTop(timeMs);
          let dayEls = this.getDayEls(date);
          let dayRect;
          expect(dayEls.length).toBe(1);
          dayRect = getBoundingRect(dayEls[0]);
          return {
              left: dayRect.left,
              right: dayRect.right,
              top,
              bottom: top,
          };
      }
      getTimeTop(targetTimeMs) {
          if (typeof targetTimeMs !== 'number') {
              targetTimeMs = asRoughMs(createDuration(targetTimeMs));
          }
          const topBorderWidth = 1; // TODO: kill
          let singleSlotEl = this.getSlotElByTime(targetTimeMs);
          if (singleSlotEl) { // exact slot match
              return $(singleSlotEl).offset().top + topBorderWidth;
          }
          let $slotEl; // used within loop, but we access last val
          let slotEls = this.getSlotEls(); // all slots
          let slotTimeMs = null;
          let prevSlotTimeMs = null;
          for (let i = 0; i < slotEls.length; i += 1) { // traverse earlier to later
              let slotEl = slotEls[i];
              $slotEl = $(slotEl);
              prevSlotTimeMs = slotTimeMs;
              slotTimeMs = createDuration(slotEl.getAttribute('data-time')).milliseconds;
              // is target time between start of previous slot but before this one?
              if (targetTimeMs < slotTimeMs) {
                  // before first slot
                  if (!prevSlotTimeMs) {
                      return $slotEl.offset().top + topBorderWidth;
                  }
                  let $prevSlotEl = $(slotEls[i - 1]);
                  return $prevSlotEl.offset().top + // previous slot top
                      topBorderWidth +
                      ($prevSlotEl.outerHeight() *
                          ((targetTimeMs - prevSlotTimeMs) / (slotTimeMs - prevSlotTimeMs)));
              }
          }
          // target time must be after the start time of the last slot.
          // `slotTimeMs` is set to the start time of the last slot.
          // guess the duration of the last slot, based on previous duration
          const slotMsDuration = slotTimeMs - prevSlotTimeMs;
          return $slotEl.offset().top + // last slot's top
              topBorderWidth +
              ($slotEl.outerHeight() *
                  Math.min(1, (targetTimeMs - slotTimeMs) / slotMsDuration)); // don't go past end of last slot
      }
      computeSpanRects(start, end) {
          start = ensureDate(start);
          end = ensureDate(end);
          let dayStructs = this.computeDayInfo();
          let slotStructs = this.computeSlotInfo();
          let dayI;
          let dayStruct;
          let slotI;
          let slotStruct;
          let slotDayStart;
          let slotStart;
          let slotEnd;
          let coverage;
          let startTop = null;
          let endTop = null;
          let rects = [];
          for (dayI = 0; dayI < dayStructs.length; dayI += 1) {
              dayStruct = dayStructs[dayI];
              for (slotI = 0; slotI < slotStructs.length; slotI += 1) {
                  slotStruct = slotStructs[slotI];
                  slotDayStart = addDays(dayStruct.date, slotStruct.dayOffset);
                  slotStart = addMs(slotDayStart, slotStruct.startTimeMs);
                  slotEnd = addMs(slotDayStart, slotStruct.endTimeMs);
                  if (startTop === null) { // looking for the start
                      coverage = (start - slotStart.valueOf()) / (slotEnd.valueOf() - slotStart.valueOf());
                      startTop = (coverage > 0 && coverage <= 1)
                          ? (slotStruct.top + slotStruct.height * coverage)
                          : null;
                  }
                  else { // looking for the end
                      coverage = (end - slotStart.valueOf()) / (slotEnd.valueOf() - slotStart.valueOf());
                      endTop = (coverage >= 0 && coverage < 1) // exclusive
                          ? (slotStruct.top + slotStruct.height * coverage)
                          : null;
                      if (endTop !== null) { // found end
                          rects.push({
                              left: dayStruct.left,
                              right: dayStruct.right,
                              top: startTop,
                              bottom: endTop,
                              width: dayStruct.right - dayStruct.left,
                              height: endTop - startTop,
                          });
                          startTop = null;
                      }
                  }
              }
              if (startTop !== null) { // could not find the start in this day
                  rects.push({
                      left: dayStruct.left,
                      right: dayStruct.right,
                      top: startTop,
                      bottom: slotStruct.bottom,
                      width: dayStruct.right - dayStruct.left,
                      height: slotStruct.bottom - startTop,
                  });
                  startTop = slotStructs[0].top; // top of next column
              }
          }
          return rects;
      }
      computeDayInfo() {
          let dayEls = this.getAllDayEls();
          let days = dayEls.map((node) => {
              let rect = node.getBoundingClientRect();
              return $.extend({}, rect, {
                  date: parse$3(node.getAttribute('data-date')).marker,
              });
          });
          return days;
      }
      computeSlotInfo() {
          let slotEls = this.getSlotEls();
          let slots = slotEls.map((node) => {
              let rect = node.getBoundingClientRect();
              return $.extend({}, rect, {
                  startTimeMs: createDuration(node.getAttribute('data-time')).milliseconds,
              });
          });
          let len = slots.length;
          if (len < 3) {
              console.log('need at least 3 slots'); // eslint-disable-line no-console
              return [];
          }
          let mid = Math.floor(len / 2);
          let i = mid - 1;
          let standardMs = slots[mid + 1].startTimeMs - slots[mid].startTimeMs;
          let ms;
          let dayOffset = 0;
          // iterate from one-before middle to beginning
          for (i = mid - 1; i >= 0; i -= 1) {
              ms = slots[i + 1].startTimeMs - slots[i].startTimeMs;
              // big deviation? assume moved to previous day (b/c of special slotMinTime)
              if (Math.abs(ms - standardMs) > standardMs * 2) {
                  dayOffset -= 1;
                  slots[i].endTimeMs = slots[i].startTimeMs + standardMs;
              }
              else { // otherwise, current slot's end is next slot's beginning
                  slots[i].endTimeMs = slots[i + 1].startTimeMs;
              }
              slots[i].dayOffset = dayOffset;
          }
          dayOffset = 0;
          // iterate from middle to one-before last
          for (i = mid; i < len - 1; i += 1) {
              ms = slots[i + 1].startTimeMs - slots[i].startTimeMs;
              slots[i].dayOffset = dayOffset;
              // big deviation? assume moved to next day (b/c of special slotMaxTime)
              if (Math.abs(ms - standardMs) > standardMs * 2) {
                  dayOffset += 1; // will apply to the next slotStruct
                  slots[i].endTimeMs = slots[i].startTimeMs + standardMs;
              }
              else { // otherwise, current slot's end is next slot's beginning
                  slots[i].endTimeMs = slots[i + 1].startTimeMs;
              }
          }
          // assume last slot has the standard duration
          slots[i].endTimeMs = slots[i].startTimeMs + standardMs;
          slots[i].dayOffset = dayOffset;
          // if last slot went over the day threshold
          if (slots[i].endTimeMs > 1000 * 60 * 60 * 24) {
              slots[i].endTimeMs -= 1000 * 60 * 60 * 24;
              slots[i].dayOffset += 1;
          }
          return slots;
      }
      getEventEls() {
          return findElements(this.el, '.fc-timegrid-event');
      }
      getFirstEventEl() {
          return this.el.querySelector('.fc-timegrid-event');
      }
      getBgEventEls() {
          return findElements(this.el, '.fc-bg-event');
      }
      getEventTimeTexts() {
          return this.getEventEls().map((eventEl) => $(eventEl.querySelector('.fc-event-time')).text());
      }
      static getEventElInfo(eventEl) {
          return {
              title: $(eventEl).find('.fc-event-title').text(),
              timeText: $(eventEl).find('.fc-event-time').text(),
          };
      }
      /*
      Returns a boolean.
      TODO: check isStart/isEnd.
      */
      checkEventRendering(start, end) {
          if (typeof start === 'string') {
              start = new Date(start);
          }
          if (typeof end === 'string') {
              end = new Date(end);
          }
          let expectedRects = this.computeSpanRects(start, end);
          let eventEls = this.getEventEls(); // sorted by DOM order. not good for RTL
          let isMatch = checkEventRenderingMatch(expectedRects, eventEls);
          return {
              rects: expectedRects,
              els: eventEls,
              length: eventEls.length,
              isMatch,
          };
      }
  }
  function checkEventRenderingMatch(expectedRects, eventEls) {
      let expectedLength = expectedRects.length;
      let i;
      let expectedRect;
      let elRect;
      if (eventEls.length !== expectedLength) {
          console.log('does not match element count'); // eslint-disable-line no-console
          return false;
      }
      for (i = 0; i < expectedLength; i += 1) {
          expectedRect = expectedRects[i];
          elRect = eventEls[i].getBoundingClientRect();
          // horizontally contained AND vertically really similar?
          if (!(elRect.left >= expectedRect.left &&
              elRect.right <= expectedRect.right &&
              Math.abs(elRect.top - expectedRect.top) < 1 &&
              Math.abs(elRect.bottom + 1 - expectedRect.bottom) < 1 // add 1 because of bottom margin!
          )) {
              console.log('rects do not match'); // eslint-disable-line no-console
              return false;
          }
      }
      return true;
  }
  function queryEventElInfo(eventEl) {
      return {
          timeText: $(eventEl.querySelector('.fc-event-time')).text(),
          isShort: eventEl.classList.contains('fc-timegrid-event-short'),
      };
  }

  class TimeGridViewWrapper extends ViewWrapper {
      constructor(calendar) {
          super(calendar, 'fc-timegrid');
      }
      get header() {
          let headerEl = this.el.querySelector('.fc-col-header');
          return headerEl ? new DayHeaderWrapper(headerEl) : null;
      }
      get timeGrid() {
          return new TimeGridWrapper(this.el.querySelector('.fc-timegrid-body'));
      }
      get dayGrid() {
          let dayGridEl = this.el.querySelector('.fc-daygrid-body');
          return dayGridEl ? new DayGridWrapper(dayGridEl) : null;
      }
      getScrollerEl() {
          return this.el.querySelector('.fc-timegrid-body').parentElement; // TODO: use closest
      }
      getHeaderAxisEl() {
          return this.el.querySelector('.fc-col-header .fc-timegrid-axis');
      }
      getHeaderWeekNumberLink() {
          return this.getHeaderAxisEl().querySelector('a');
      }
      getHeaderWeekText() {
          return $(this.getHeaderWeekNumberLink()).text();
      }
      getAllDayAxisEl() {
          return this.el.querySelector('.fc-daygrid-body .fc-timegrid-axis');
      }
      getAllDayAxisElText() {
          return $(this.getAllDayAxisEl()).text();
      }
  }

  describe('moment plugin', () => {
      const PLUGINS = [index$a, index$9, index$4];
      pushOptions({ plugins: PLUGINS });
      describe('toMoment', () => {
          describe('timezone handling', () => {
              it('transfers UTC', () => {
                  let calendar = new Calendar(document.createElement('div'), {
                      plugins: [index$a],
                      events: [{ start: '2018-09-05T12:00:00', end: '2018-09-05T18:00:00' }],
                      timeZone: 'UTC',
                  });
                  let event = calendar.getEvents()[0];
                  let startMom = toMoment(event.start, calendar);
                  let endMom = toMoment(event.end, calendar);
                  expect(startMom.format()).toEqual('2018-09-05T12:00:00Z');
                  expect(endMom.format()).toEqual('2018-09-05T18:00:00Z');
              });
              it('transfers local', () => {
                  let calendar = new Calendar(document.createElement('div'), {
                      plugins: [index$a],
                      events: [{ start: '2018-09-05T12:00:00', end: '2018-09-05T18:00:00' }],
                      timeZone: 'local',
                  });
                  let event = calendar.getEvents()[0];
                  let startMom = toMoment(event.start, calendar);
                  let endMom = toMoment(event.end, calendar);
                  expect(startMom.toDate()).toEqualLocalDate('2018-09-05T12:00:00');
                  expect(endMom.toDate()).toEqualLocalDate('2018-09-05T18:00:00');
              });
          });
          it('transfers locale', () => {
              let calendar = new Calendar(document.createElement('div'), {
                  plugins: [index$a],
                  events: [{ start: '2018-09-05T12:00:00', end: '2018-09-05T18:00:00' }],
                  locale: 'es',
              });
              let event = calendar.getEvents()[0];
              let mom = toMoment(event.start, calendar);
              expect(mom.locale()).toEqual('es');
          });
      });
      describe('toDuration', () => {
          it('converts correctly', () => {
              let calendar = new Calendar(document.createElement('div'), {
                  plugins: [index$a],
                  defaultTimedEventDuration: '05:00',
                  defaultAllDayEventDuration: { days: 3 },
              });
              // hacky way to have a duration parsed
              let timedDuration = toMomentDuration(calendar.getCurrentData().options.defaultTimedEventDuration);
              let allDayDuration = toMomentDuration(calendar.getCurrentData().options.defaultAllDayEventDuration);
              expect(timedDuration.asHours()).toBe(5);
              expect(allDayDuration.asDays()).toBe(3);
          });
      });
      describe('date formatting', () => {
          it('produces event time text', () => {
              let calendar = initCalendar({
                  initialView: 'dayGridMonth',
                  now: '2018-09-06',
                  displayEventEnd: false,
                  eventTimeFormat: 'HH:mm:ss[!]',
                  events: [
                      { title: 'my event', start: '2018-09-06T13:30:20' },
                  ],
              });
              let calendarWrapper = new CalendarWrapper(calendar);
              let eventEl = calendarWrapper.getFirstEventEl();
              let eventInfo = calendarWrapper.getEventElInfo(eventEl);
              expect(eventInfo.timeText).toBe('13:30:20!');
          });
      });
      describe('range formatting', () => {
          it('renders with same month', () => {
              let calendar = new Calendar(document.createElement('div'), {
                  plugins: PLUGINS,
              });
              let s;
              s = calendar.formatRange('2018-09-03', '2018-09-05', 'MMMM {D}, YYYY [nice]');
              expect(s).toEqual('September 3 - 5, 2018 nice');
              s = calendar.formatRange('2018-09-03', '2018-09-05', '{D} MMMM, YYYY [nice]');
              expect(s).toEqual('3 - 5 September, 2018 nice');
          });
          it('renders with same year but different month', () => {
              let calendar = new Calendar(document.createElement('div'), {
                  plugins: PLUGINS,
              });
              let s;
              s = calendar.formatRange('2018-09-03', '2018-10-05', '{MMMM {D}}, YYYY [nice]');
              expect(s).toEqual('September 3 - October 5, 2018 nice');
              s = calendar.formatRange('2018-09-03', '2018-10-05', '{{D} MMMM}, YYYY [nice]');
              expect(s).toEqual('3 September - 5 October, 2018 nice');
          });
          it('renders with different years', () => {
              let calendar = new Calendar(document.createElement('div'), {
                  plugins: PLUGINS,
              });
              let s;
              s = calendar.formatRange('2018-09-03', '2019-10-05', '{MMMM {D}}, YYYY [nice]');
              expect(s).toEqual('September 3, 2018 nice - October 5, 2019 nice');
              s = calendar.formatRange('2018-09-03', '2019-10-05', '{{D} MMMM}, YYYY [nice]');
              expect(s).toEqual('3 September, 2018 nice - 5 October, 2019 nice');
          });
          it('renders the same if same day', () => {
              let calendar = new Calendar(document.createElement('div'), {
                  plugins: PLUGINS,
              });
              let s;
              s = calendar.formatRange('2018-09-03T00:00:00', '2018-09-03T23:59:59', 'MMM Do YY');
              expect(s).toEqual('Sep 3rd 18');
          });
          it('inherits defaultRangeSeparator', () => {
              let calendar = new Calendar(document.createElement('div'), {
                  plugins: PLUGINS,
                  defaultRangeSeparator: ' to ',
              });
              let s = calendar.formatRange('2018-09-03', '2018-09-05', 'MMMM D, YYYY [nice]');
              expect(s).toEqual('September 3, 2018 nice to September 5, 2018 nice');
          });
          it('produces title with titleRangeSeparator', () => {
              initCalendar({
                  initialView: 'dayGridWeek',
                  now: '2018-09-06',
                  titleFormat: 'MMMM {D} YY [yup]',
                  titleRangeSeparator: ' to ',
              });
              expect(currentCalendar.view.title).toBe('September 2 to 8 18 yup');
          });
          // https://github.com/fullcalendar/fullcalendar/issues/5493
          it('displays correct rangeSeparator on events', () => {
              let calendar = initCalendar({
                  initialView: 'timeGridDay',
                  initialDate: '2020-06-26',
                  scrollTime: '00:00',
                  eventTimeFormat: 'HH:mm:ss',
                  events: [
                      { title: 'event', start: '2020-06-26T01:00:00', end: '2020-06-26T02:00:00' },
                  ],
              });
              let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
              let timeTexts = timeGridWrapper.getEventTimeTexts();
              expect(timeTexts[0]).toBe('01:00:00 - 02:00:00');
          });
      });
  });

  var momentTimezone$1 = createCommonjsModule$1(function (module) {
  //! moment-timezone.js
  //! version : 0.5.40
  //! Copyright (c) JS Foundation and other contributors
  //! license : MIT
  //! github.com/moment/moment-timezone

  (function (root, factory) {

  	/*global define*/
  	if (module.exports) {
  		module.exports = factory(moment); // Node
  	} else {
  		factory(root.moment);                        // Browser
  	}
  }(commonjsGlobal$1, function (moment) {

  	// Resolves es6 module loading issue
  	if (moment.version === undefined && moment.default) {
  		moment = moment.default;
  	}

  	// Do not load moment-timezone a second time.
  	// if (moment.tz !== undefined) {
  	// 	logError('Moment Timezone ' + moment.tz.version + ' was already loaded ' + (moment.tz.dataVersion ? 'with data from ' : 'without any data') + moment.tz.dataVersion);
  	// 	return moment;
  	// }

  	var VERSION = "0.5.40",
  		zones = {},
  		links = {},
  		countries = {},
  		names = {},
  		guesses = {},
  		cachedGuess;

  	if (!moment || typeof moment.version !== 'string') {
  		logError('Moment Timezone requires Moment.js. See https://momentjs.com/timezone/docs/#/use-it/browser/');
  	}

  	var momentVersion = moment.version.split('.'),
  		major = +momentVersion[0],
  		minor = +momentVersion[1];

  	// Moment.js version check
  	if (major < 2 || (major === 2 && minor < 6)) {
  		logError('Moment Timezone requires Moment.js >= 2.6.0. You are using Moment.js ' + moment.version + '. See momentjs.com');
  	}

  	/************************************
  		Unpacking
  	************************************/

  	function charCodeToInt(charCode) {
  		if (charCode > 96) {
  			return charCode - 87;
  		} else if (charCode > 64) {
  			return charCode - 29;
  		}
  		return charCode - 48;
  	}

  	function unpackBase60(string) {
  		var i = 0,
  			parts = string.split('.'),
  			whole = parts[0],
  			fractional = parts[1] || '',
  			multiplier = 1,
  			num,
  			out = 0,
  			sign = 1;

  		// handle negative numbers
  		if (string.charCodeAt(0) === 45) {
  			i = 1;
  			sign = -1;
  		}

  		// handle digits before the decimal
  		for (i; i < whole.length; i++) {
  			num = charCodeToInt(whole.charCodeAt(i));
  			out = 60 * out + num;
  		}

  		// handle digits after the decimal
  		for (i = 0; i < fractional.length; i++) {
  			multiplier = multiplier / 60;
  			num = charCodeToInt(fractional.charCodeAt(i));
  			out += num * multiplier;
  		}

  		return out * sign;
  	}

  	function arrayToInt (array) {
  		for (var i = 0; i < array.length; i++) {
  			array[i] = unpackBase60(array[i]);
  		}
  	}

  	function intToUntil (array, length) {
  		for (var i = 0; i < length; i++) {
  			array[i] = Math.round((array[i - 1] || 0) + (array[i] * 60000)); // minutes to milliseconds
  		}

  		array[length - 1] = Infinity;
  	}

  	function mapIndices (source, indices) {
  		var out = [], i;

  		for (i = 0; i < indices.length; i++) {
  			out[i] = source[indices[i]];
  		}

  		return out;
  	}

  	function unpack (string) {
  		var data = string.split('|'),
  			offsets = data[2].split(' '),
  			indices = data[3].split(''),
  			untils  = data[4].split(' ');

  		arrayToInt(offsets);
  		arrayToInt(indices);
  		arrayToInt(untils);

  		intToUntil(untils, indices.length);

  		return {
  			name       : data[0],
  			abbrs      : mapIndices(data[1].split(' '), indices),
  			offsets    : mapIndices(offsets, indices),
  			untils     : untils,
  			population : data[5] | 0
  		};
  	}

  	/************************************
  		Zone object
  	************************************/

  	function Zone (packedString) {
  		if (packedString) {
  			this._set(unpack(packedString));
  		}
  	}

  	Zone.prototype = {
  		_set : function (unpacked) {
  			this.name       = unpacked.name;
  			this.abbrs      = unpacked.abbrs;
  			this.untils     = unpacked.untils;
  			this.offsets    = unpacked.offsets;
  			this.population = unpacked.population;
  		},

  		_index : function (timestamp) {
  			var target = +timestamp,
  				untils = this.untils,
  				i;

  			for (i = 0; i < untils.length; i++) {
  				if (target < untils[i]) {
  					return i;
  				}
  			}
  		},

  		countries : function () {
  			var zone_name = this.name;
  			return Object.keys(countries).filter(function (country_code) {
  				return countries[country_code].zones.indexOf(zone_name) !== -1;
  			});
  		},

  		parse : function (timestamp) {
  			var target  = +timestamp,
  				offsets = this.offsets,
  				untils  = this.untils,
  				max     = untils.length - 1,
  				offset, offsetNext, offsetPrev, i;

  			for (i = 0; i < max; i++) {
  				offset     = offsets[i];
  				offsetNext = offsets[i + 1];
  				offsetPrev = offsets[i ? i - 1 : i];

  				if (offset < offsetNext && tz.moveAmbiguousForward) {
  					offset = offsetNext;
  				} else if (offset > offsetPrev && tz.moveInvalidForward) {
  					offset = offsetPrev;
  				}

  				if (target < untils[i] - (offset * 60000)) {
  					return offsets[i];
  				}
  			}

  			return offsets[max];
  		},

  		abbr : function (mom) {
  			return this.abbrs[this._index(mom)];
  		},

  		offset : function (mom) {
  			logError("zone.offset has been deprecated in favor of zone.utcOffset");
  			return this.offsets[this._index(mom)];
  		},

  		utcOffset : function (mom) {
  			return this.offsets[this._index(mom)];
  		}
  	};

  	/************************************
  		Country object
  	************************************/

  	function Country (country_name, zone_names) {
  		this.name = country_name;
  		this.zones = zone_names;
  	}

  	/************************************
  		Current Timezone
  	************************************/

  	function OffsetAt(at) {
  		var timeString = at.toTimeString();
  		var abbr = timeString.match(/\([a-z ]+\)/i);
  		if (abbr && abbr[0]) {
  			// 17:56:31 GMT-0600 (CST)
  			// 17:56:31 GMT-0600 (Central Standard Time)
  			abbr = abbr[0].match(/[A-Z]/g);
  			abbr = abbr ? abbr.join('') : undefined;
  		} else {
  			// 17:56:31 CST
  			// 17:56:31 GMT+0800 (台北標準時間)
  			abbr = timeString.match(/[A-Z]{3,5}/g);
  			abbr = abbr ? abbr[0] : undefined;
  		}

  		if (abbr === 'GMT') {
  			abbr = undefined;
  		}

  		this.at = +at;
  		this.abbr = abbr;
  		this.offset = at.getTimezoneOffset();
  	}

  	function ZoneScore(zone) {
  		this.zone = zone;
  		this.offsetScore = 0;
  		this.abbrScore = 0;
  	}

  	ZoneScore.prototype.scoreOffsetAt = function (offsetAt) {
  		this.offsetScore += Math.abs(this.zone.utcOffset(offsetAt.at) - offsetAt.offset);
  		if (this.zone.abbr(offsetAt.at).replace(/[^A-Z]/g, '') !== offsetAt.abbr) {
  			this.abbrScore++;
  		}
  	};

  	function findChange(low, high) {
  		var mid, diff;

  		while ((diff = ((high.at - low.at) / 12e4 | 0) * 6e4)) {
  			mid = new OffsetAt(new Date(low.at + diff));
  			if (mid.offset === low.offset) {
  				low = mid;
  			} else {
  				high = mid;
  			}
  		}

  		return low;
  	}

  	function userOffsets() {
  		var startYear = new Date().getFullYear() - 2,
  			last = new OffsetAt(new Date(startYear, 0, 1)),
  			offsets = [last],
  			change, next, i;

  		for (i = 1; i < 48; i++) {
  			next = new OffsetAt(new Date(startYear, i, 1));
  			if (next.offset !== last.offset) {
  				change = findChange(last, next);
  				offsets.push(change);
  				offsets.push(new OffsetAt(new Date(change.at + 6e4)));
  			}
  			last = next;
  		}

  		for (i = 0; i < 4; i++) {
  			offsets.push(new OffsetAt(new Date(startYear + i, 0, 1)));
  			offsets.push(new OffsetAt(new Date(startYear + i, 6, 1)));
  		}

  		return offsets;
  	}

  	function sortZoneScores (a, b) {
  		if (a.offsetScore !== b.offsetScore) {
  			return a.offsetScore - b.offsetScore;
  		}
  		if (a.abbrScore !== b.abbrScore) {
  			return a.abbrScore - b.abbrScore;
  		}
  		if (a.zone.population !== b.zone.population) {
  			return b.zone.population - a.zone.population;
  		}
  		return b.zone.name.localeCompare(a.zone.name);
  	}

  	function addToGuesses (name, offsets) {
  		var i, offset;
  		arrayToInt(offsets);
  		for (i = 0; i < offsets.length; i++) {
  			offset = offsets[i];
  			guesses[offset] = guesses[offset] || {};
  			guesses[offset][name] = true;
  		}
  	}

  	function guessesForUserOffsets (offsets) {
  		var offsetsLength = offsets.length,
  			filteredGuesses = {},
  			out = [],
  			i, j, guessesOffset;

  		for (i = 0; i < offsetsLength; i++) {
  			guessesOffset = guesses[offsets[i].offset] || {};
  			for (j in guessesOffset) {
  				if (guessesOffset.hasOwnProperty(j)) {
  					filteredGuesses[j] = true;
  				}
  			}
  		}

  		for (i in filteredGuesses) {
  			if (filteredGuesses.hasOwnProperty(i)) {
  				out.push(names[i]);
  			}
  		}

  		return out;
  	}

  	function rebuildGuess () {

  		// use Intl API when available and returning valid time zone
  		try {
  			var intlName = Intl.DateTimeFormat().resolvedOptions().timeZone;
  			if (intlName && intlName.length > 3) {
  				var name = names[normalizeName(intlName)];
  				if (name) {
  					return name;
  				}
  				logError("Moment Timezone found " + intlName + " from the Intl api, but did not have that data loaded.");
  			}
  		} catch (e) {
  			// Intl unavailable, fall back to manual guessing.
  		}

  		var offsets = userOffsets(),
  			offsetsLength = offsets.length,
  			guesses = guessesForUserOffsets(offsets),
  			zoneScores = [],
  			zoneScore, i, j;

  		for (i = 0; i < guesses.length; i++) {
  			zoneScore = new ZoneScore(getZone(guesses[i]));
  			for (j = 0; j < offsetsLength; j++) {
  				zoneScore.scoreOffsetAt(offsets[j]);
  			}
  			zoneScores.push(zoneScore);
  		}

  		zoneScores.sort(sortZoneScores);

  		return zoneScores.length > 0 ? zoneScores[0].zone.name : undefined;
  	}

  	function guess (ignoreCache) {
  		if (!cachedGuess || ignoreCache) {
  			cachedGuess = rebuildGuess();
  		}
  		return cachedGuess;
  	}

  	/************************************
  		Global Methods
  	************************************/

  	function normalizeName (name) {
  		return (name || '').toLowerCase().replace(/\//g, '_');
  	}

  	function addZone (packed) {
  		var i, name, split, normalized;

  		if (typeof packed === "string") {
  			packed = [packed];
  		}

  		for (i = 0; i < packed.length; i++) {
  			split = packed[i].split('|');
  			name = split[0];
  			normalized = normalizeName(name);
  			zones[normalized] = packed[i];
  			names[normalized] = name;
  			addToGuesses(normalized, split[2].split(' '));
  		}
  	}

  	function getZone (name, caller) {

  		name = normalizeName(name);

  		var zone = zones[name];
  		var link;

  		if (zone instanceof Zone) {
  			return zone;
  		}

  		if (typeof zone === 'string') {
  			zone = new Zone(zone);
  			zones[name] = zone;
  			return zone;
  		}

  		// Pass getZone to prevent recursion more than 1 level deep
  		if (links[name] && caller !== getZone && (link = getZone(links[name], getZone))) {
  			zone = zones[name] = new Zone();
  			zone._set(link);
  			zone.name = names[name];
  			return zone;
  		}

  		return null;
  	}

  	function getNames () {
  		var i, out = [];

  		for (i in names) {
  			if (names.hasOwnProperty(i) && (zones[i] || zones[links[i]]) && names[i]) {
  				out.push(names[i]);
  			}
  		}

  		return out.sort();
  	}

  	function getCountryNames () {
  		return Object.keys(countries);
  	}

  	function addLink (aliases) {
  		var i, alias, normal0, normal1;

  		if (typeof aliases === "string") {
  			aliases = [aliases];
  		}

  		for (i = 0; i < aliases.length; i++) {
  			alias = aliases[i].split('|');

  			normal0 = normalizeName(alias[0]);
  			normal1 = normalizeName(alias[1]);

  			links[normal0] = normal1;
  			names[normal0] = alias[0];

  			links[normal1] = normal0;
  			names[normal1] = alias[1];
  		}
  	}

  	function addCountries (data) {
  		var i, country_code, country_zones, split;
  		if (!data || !data.length) return;
  		for (i = 0; i < data.length; i++) {
  			split = data[i].split('|');
  			country_code = split[0].toUpperCase();
  			country_zones = split[1].split(' ');
  			countries[country_code] = new Country(
  				country_code,
  				country_zones
  			);
  		}
  	}

  	function getCountry (name) {
  		name = name.toUpperCase();
  		return countries[name] || null;
  	}

  	function zonesForCountry(country, with_offset) {
  		country = getCountry(country);

  		if (!country) return null;

  		var zones = country.zones.sort();

  		if (with_offset) {
  			return zones.map(function (zone_name) {
  				var zone = getZone(zone_name);
  				return {
  					name: zone_name,
  					offset: zone.utcOffset(new Date())
  				};
  			});
  		}

  		return zones;
  	}

  	function loadData (data) {
  		addZone(data.zones);
  		addLink(data.links);
  		addCountries(data.countries);
  		tz.dataVersion = data.version;
  	}

  	function zoneExists (name) {
  		if (!zoneExists.didShowError) {
  			zoneExists.didShowError = true;
  				logError("moment.tz.zoneExists('" + name + "') has been deprecated in favor of !moment.tz.zone('" + name + "')");
  		}
  		return !!getZone(name);
  	}

  	function needsOffset (m) {
  		var isUnixTimestamp = (m._f === 'X' || m._f === 'x');
  		return !!(m._a && (m._tzm === undefined) && !isUnixTimestamp);
  	}

  	function logError (message) {
  		if (typeof console !== 'undefined' && typeof console.error === 'function') {
  			console.error(message);
  		}
  	}

  	/************************************
  		moment.tz namespace
  	************************************/

  	function tz (input) {
  		var args = Array.prototype.slice.call(arguments, 0, -1),
  			name = arguments[arguments.length - 1],
  			zone = getZone(name),
  			out  = moment.utc.apply(null, args);

  		if (zone && !moment.isMoment(input) && needsOffset(out)) {
  			out.add(zone.parse(out), 'minutes');
  		}

  		out.tz(name);

  		return out;
  	}

  	tz.version      = VERSION;
  	tz.dataVersion  = '';
  	tz._zones       = zones;
  	tz._links       = links;
  	tz._names       = names;
  	tz._countries	= countries;
  	tz.add          = addZone;
  	tz.link         = addLink;
  	tz.load         = loadData;
  	tz.zone         = getZone;
  	tz.zoneExists   = zoneExists; // deprecated in 0.1.0
  	tz.guess        = guess;
  	tz.names        = getNames;
  	tz.Zone         = Zone;
  	tz.unpack       = unpack;
  	tz.unpackBase60 = unpackBase60;
  	tz.needsOffset  = needsOffset;
  	tz.moveInvalidForward   = true;
  	tz.moveAmbiguousForward = false;
  	tz.countries    = getCountryNames;
  	tz.zonesForCountry = zonesForCountry;

  	/************************************
  		Interface with Moment.js
  	************************************/

  	var fn = moment.fn;

  	moment.tz = tz;

  	moment.defaultZone = null;

  	moment.updateOffset = function (mom, keepTime) {
  		var zone = moment.defaultZone,
  			offset;

  		if (mom._z === undefined) {
  			if (zone && needsOffset(mom) && !mom._isUTC) {
  				mom._d = moment.utc(mom._a)._d;
  				mom.utc().add(zone.parse(mom), 'minutes');
  			}
  			mom._z = zone;
  		}
  		if (mom._z) {
  			offset = mom._z.utcOffset(mom);
  			if (Math.abs(offset) < 16) {
  				offset = offset / 60;
  			}
  			if (mom.utcOffset !== undefined) {
  				var z = mom._z;
  				mom.utcOffset(-offset, keepTime);
  				mom._z = z;
  			} else {
  				mom.zone(offset, keepTime);
  			}
  		}
  	};

  	fn.tz = function (name, keepTime) {
  		if (name) {
  			if (typeof name !== 'string') {
  				throw new Error('Time zone name must be a string, got ' + name + ' [' + typeof name + ']');
  			}
  			this._z = getZone(name);
  			if (this._z) {
  				moment.updateOffset(this, keepTime);
  			} else {
  				logError("Moment Timezone has no data for " + name + ". See http://momentjs.com/timezone/docs/#/data-loading/.");
  			}
  			return this;
  		}
  		if (this._z) { return this._z.name; }
  	};

  	function abbrWrap (old) {
  		return function () {
  			if (this._z) { return this._z.abbr(this); }
  			return old.call(this);
  		};
  	}

  	function resetZoneWrap (old) {
  		return function () {
  			this._z = null;
  			return old.apply(this, arguments);
  		};
  	}

  	function resetZoneWrap2 (old) {
  		return function () {
  			if (arguments.length > 0) this._z = null;
  			return old.apply(this, arguments);
  		};
  	}

  	fn.zoneName  = abbrWrap(fn.zoneName);
  	fn.zoneAbbr  = abbrWrap(fn.zoneAbbr);
  	fn.utc       = resetZoneWrap(fn.utc);
  	fn.local     = resetZoneWrap(fn.local);
  	fn.utcOffset = resetZoneWrap2(fn.utcOffset);

  	moment.tz.setDefault = function(name) {
  		if (major < 2 || (major === 2 && minor < 9)) {
  			logError('Moment Timezone setDefault() requires Moment.js >= 2.9.0. You are using Moment.js ' + moment.version + '.');
  		}
  		moment.defaultZone = name ? getZone(name) : null;
  		return moment;
  	};

  	// Cloning a moment should include the _z property.
  	var momentProperties = moment.momentProperties;
  	if (Object.prototype.toString.call(momentProperties) === '[object Array]') {
  		// moment 2.8.1+
  		momentProperties.push('_z');
  		momentProperties.push('_a');
  	} else if (momentProperties) {
  		// moment 2.7.0
  		momentProperties._z = null;
  	}

  	// INJECT DATA

  	return moment;
  }));
  });

  var version = "2022g";
  var zones = [
  	"Africa/Abidjan|LMT GMT|g.8 0|01|-2ldXH.Q|48e5",
  	"Africa/Nairobi|LMT +0230 EAT +0245|-2r.g -2u -30 -2J|012132|-2ua2r.g N6nV.g 3Fbu h1cu dzbJ|47e5",
  	"Africa/Algiers|LMT PMT WET WEST CET CEST|-c.c -9.l 0 -10 -10 -20|01232323232323232454542423234542324|-3bQ0c.c MDA2.P cNb9.l HA0 19A0 1iM0 11c0 1oo0 Wo0 1rc0 QM0 1EM0 UM0 DA0 Imo0 rd0 De0 9Xz0 1fb0 1ap0 16K0 2yo0 mEp0 hwL0 jxA0 11A0 dDd0 17b0 11B0 1cN0 2Dy0 1cN0 1fB0 1cL0|26e5",
  	"Africa/Lagos|LMT GMT +0030 WAT|-d.z 0 -u -10|01023|-2B40d.z 7iod.z dnXK.p dLzH.z|17e6",
  	"Africa/Bissau|LMT -01 GMT|12.k 10 0|012|-2ldX0 2xoo0|39e4",
  	"Africa/Maputo|LMT CAT|-2a.k -20|01|-2GJea.k|26e5",
  	"Africa/Cairo|LMT EET EEST|-25.9 -20 -30|01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2MBC5.9 1AQM5.9 vb0 1ip0 11z0 1iN0 1nz0 12p0 1pz0 10N0 1pz0 16p0 1jz0 s3d0 Vz0 1oN0 11b0 1oO0 10N0 1pz0 10N0 1pb0 10N0 1pb0 10N0 1pb0 10N0 1pz0 10N0 1pb0 10N0 1pb0 11d0 1oL0 11d0 1pb0 11d0 1oL0 11d0 1oL0 11d0 1oL0 11d0 1pb0 11d0 1oL0 11d0 1oL0 11d0 1oL0 11d0 1pb0 11d0 1oL0 11d0 1oL0 11d0 1oL0 11d0 1pb0 11d0 1oL0 11d0 1WL0 rd0 1Rz0 wp0 1pb0 11d0 1oL0 11d0 1oL0 11d0 1oL0 11d0 1pb0 11d0 1qL0 Xd0 1oL0 11d0 1oL0 11d0 1pb0 11d0 1oL0 11d0 1oL0 11d0 1ny0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 WL0 1qN0 Rb0 1wp0 On0 1zd0 Lz0 1EN0 Fb0 c10 8n0 8Nd0 gL0 e10 mn0|15e6",
  	"Africa/Casablanca|LMT +00 +01|u.k 0 -10|01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212|-2gMnt.E 130Lt.E rb0 Dd0 dVb0 b6p0 TX0 EoB0 LL0 gnd0 rz0 43d0 AL0 1Nd0 XX0 1Cp0 pz0 dEp0 4mn0 SyN0 AL0 1Nd0 wn0 1FB0 Db0 1zd0 Lz0 1Nf0 wM0 co0 go0 1o00 s00 dA0 vc0 11A0 A00 e00 y00 11A0 uM0 e00 Dc0 11A0 s00 e00 IM0 WM0 mo0 gM0 LA0 WM0 jA0 e00 28M0 e00 2600 gM0 2600 e00 2600 gM0 2600 gM0 2600 e00 2600 gM0 2600 e00 28M0 e00 2600 gM0 2600 e00 2600 gM0 2600 gM0 2600 e00 2600 gM0 2600 e00 2600 gM0 2600 gM0 2600 e00 2600 gM0 2600 gM0 2600 e00 2600 gM0 2600 e00 2600 gM0 2600 gM0 2600 e00 2600 gM0 2600 gM0 2600 e00 2600 gM0 2600 e00 2600 gM0 2600 gM0 2600 e00 2600 gM0 2600 gM0 2600 e00 2600 gM0 2600 e00 2600 gM0 2600 gM0 2600 e00 2600 gM0 2600 gM0 2600 e00 2600 gM0 2600 e00 2600 gM0 2600 gM0 2600 e00 2600 gM0 2600 gM0 2600 e00 2600 gM0 2600 e00 2600 gM0 2600 gM0 2600 e00 2600 gM0 2600 gM0 2600 e00 2600 gM0 2600 e00 2600 gM0 2600 gM0 2600 e00 2600 gM0 2600 gM0 2600 e00 2600 gM0|32e5",
  	"Africa/Ceuta|LMT WET WEST CET CEST|l.g 0 -10 -10 -20|0121212121212121212121343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343|-2M0M0 GdX0 11z0 drd0 18p0 3HX0 17d0 1fz0 1a10 1io0 1a00 1y7o0 LL0 gnd0 rz0 43d0 AL0 1Nd0 XX0 1Cp0 pz0 dEp0 4VB0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|85e3",
  	"Africa/El_Aaiun|LMT -01 +00 +01|Q.M 10 0 -10|012323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323|-1rDz7.c 1GVA7.c 6L0 AL0 1Nd0 XX0 1Cp0 pz0 1cBB0 AL0 1Nd0 wn0 1FB0 Db0 1zd0 Lz0 1Nf0 wM0 co0 go0 1o00 s00 dA0 vc0 11A0 A00 e00 y00 11A0 uM0 e00 Dc0 11A0 s00 e00 IM0 WM0 mo0 gM0 LA0 WM0 jA0 e00 28M0 e00 2600 gM0 2600 e00 2600 gM0 2600 gM0 2600 e00 2600 gM0 2600 e00 28M0 e00 2600 gM0 2600 e00 2600 gM0 2600 gM0 2600 e00 2600 gM0 2600 e00 2600 gM0 2600 gM0 2600 e00 2600 gM0 2600 gM0 2600 e00 2600 gM0 2600 e00 2600 gM0 2600 gM0 2600 e00 2600 gM0 2600 gM0 2600 e00 2600 gM0 2600 e00 2600 gM0 2600 gM0 2600 e00 2600 gM0 2600 gM0 2600 e00 2600 gM0 2600 e00 2600 gM0 2600 gM0 2600 e00 2600 gM0 2600 gM0 2600 e00 2600 gM0 2600 e00 2600 gM0 2600 gM0 2600 e00 2600 gM0 2600 gM0 2600 e00 2600 gM0 2600 e00 2600 gM0 2600 gM0 2600 e00 2600 gM0 2600 gM0 2600 e00 2600 gM0 2600 e00 2600 gM0 2600 gM0 2600 e00 2600 gM0 2600 gM0 2600 e00 2600 gM0|20e4",
  	"Africa/Johannesburg|LMT SAST SAST SAST|-1Q -1u -20 -30|0123232|-39EpQ qTcm 1Ajdu 1cL0 1cN0 1cL0|84e5",
  	"Africa/Juba|LMT CAT CAST EAT|-26.s -20 -30 -30|012121212121212121212121212121212131|-1yW26.s 1zK06.s 16L0 1iN0 17b0 1jd0 17b0 1ip0 17z0 1i10 17X0 1hB0 18n0 1hd0 19b0 1gp0 19z0 1iN0 17b0 1ip0 17z0 1i10 18n0 1hd0 18L0 1gN0 19b0 1gp0 19z0 1iN0 17z0 1i10 17X0 yGd0 PeX0|",
  	"Africa/Khartoum|LMT CAT CAST EAT|-2a.8 -20 -30 -30|012121212121212121212121212121212131|-1yW2a.8 1zK0a.8 16L0 1iN0 17b0 1jd0 17b0 1ip0 17z0 1i10 17X0 1hB0 18n0 1hd0 19b0 1gp0 19z0 1iN0 17b0 1ip0 17z0 1i10 18n0 1hd0 18L0 1gN0 19b0 1gp0 19z0 1iN0 17z0 1i10 17X0 yGd0 HjL0|51e5",
  	"Africa/Monrovia|LMT MMT MMT GMT|H.8 H.8 I.u 0|0123|-3ygng.Q 1usM0 28G01.m|11e5",
  	"Africa/Ndjamena|LMT WAT WAST|-10.c -10 -20|0121|-2le10.c 2J3c0.c Wn0|13e5",
  	"Africa/Sao_Tome|LMT LMT GMT WAT|-q.U A.J 0 -10|01232|-3tooq.U 18aoq.U 4i6N0 2q00|",
  	"Africa/Tripoli|LMT CET CEST EET|-Q.I -10 -20 -20|012121213121212121212121213123123|-21JcQ.I 1hnBQ.I vx0 4iP0 xx0 4eN0 Bb0 7ip0 U0n0 A10 1db0 1cN0 1db0 1dd0 1db0 1eN0 1bb0 1e10 1cL0 1c10 1db0 1dd0 1db0 1cN0 1db0 1q10 fAn0 1ep0 1db0 AKq0 TA0 1o00|11e5",
  	"Africa/Tunis|LMT PMT CET CEST|-E.I -9.l -10 -20|01232323232323232323232323232323232|-3zO0E.I 1cBAv.n 18pa9.l 1qM0 DA0 3Tc0 11B0 1ze0 WM0 7z0 3d0 14L0 1cN0 1f90 1ar0 16J0 1gXB0 WM0 1rA0 11c0 nwo0 Ko0 1cM0 1cM0 1rA0 10M0 zuM0 10N0 1aN0 1qM0 WM0 1qM0 11A0 1o00|20e5",
  	"Africa/Windhoek|LMT +0130 SAST SAST CAT WAT|-18.o -1u -20 -30 -20 -10|012324545454545454545454545454545454545454545454545454|-39Ep8.o qTbC.o 1Ajdu 1cL0 1SqL0 9Io0 16P0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0|32e4",
  	"America/Adak|LMT LMT NST NWT NPT BST BDT AHST HST HDT|-cd.m bK.C b0 a0 a0 b0 a0 a0 a0 90|01234256565656565656565656565656565678989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898|-48Pzs.L 1jVzf.p 1EX1d.m 8wW0 iB0 Qlb0 52O0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 cm0 10q0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|326",
  	"America/Anchorage|LMT LMT AST AWT APT AHST AHDT YST AKST AKDT|-e0.o 9X.A a0 90 90 a0 90 90 90 80|01234256565656565656565656565656565678989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898|-48Pzs.L 1jVxs.n 1EX20.o 8wX0 iA0 Qlb0 52O0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 cm0 10q0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|30e4",
  	"America/Puerto_Rico|LMT AST AWT APT|4o.p 40 30 30|01231|-2Qi7z.z 1IUbz.z 7XT0 iu0|24e5",
  	"America/Araguaina|LMT -03 -02|3c.M 30 20|0121212121212121212121212121212121212121212121212121|-2glwL.c HdKL.c 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 dMN0 Lz0 1zd0 Rb0 1wN0 Wn0 1tB0 Rb0 1tB0 WL0 1tB0 Rb0 1zd0 On0 1HB0 FX0 ny10 Lz0|14e4",
  	"America/Argentina/Buenos_Aires|LMT CMT -04 -03 -02|3R.M 4g.M 40 30 20|012323232323232323232323232323232323232323234343434343434343|-331U6.c 125cn pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Rb0 1wp0 Rb0 1wp0 TX0 A4p0 uL0 1qN0 WL0|",
  	"America/Argentina/Catamarca|LMT CMT -04 -03 -02|4n.8 4g.M 40 30 20|012323232323232323232323232323232323232323234343434243432343|-331TA.Q 125bR.E pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Rb0 1wq0 Ra0 1wp0 TX0 rlB0 7B0 8zb0 uL0|",
  	"America/Argentina/Cordoba|LMT CMT -04 -03 -02|4g.M 4g.M 40 30 20|012323232323232323232323232323232323232323234343434243434343|-331TH.c 125c0 pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Rb0 1wq0 Ra0 1wp0 TX0 A4p0 uL0 1qN0 WL0|",
  	"America/Argentina/Jujuy|LMT CMT -04 -03 -02|4l.c 4g.M 40 30 20|0123232323232323232323232323232323232323232343434232434343|-331TC.M 125bT.A pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1ze0 TX0 1ld0 WK0 1wp0 TX0 A4p0 uL0|",
  	"America/Argentina/La_Rioja|LMT CMT -04 -03 -02|4r.o 4g.M 40 30 20|0123232323232323232323232323232323232323232343434342343432343|-331Tw.A 125bN.o pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Qn0 qO0 16n0 Rb0 1wp0 TX0 rlB0 7B0 8zb0 uL0|",
  	"America/Argentina/Mendoza|LMT CMT -04 -03 -02|4z.g 4g.M 40 30 20|012323232323232323232323232323232323232323234343423232432343|-331To.I 125bF.w pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1u20 SL0 1vd0 Tb0 1wp0 TW0 ri10 Op0 7TX0 uL0|",
  	"America/Argentina/Rio_Gallegos|LMT CMT -04 -03 -02|4A.Q 4g.M 40 30 20|012323232323232323232323232323232323232323234343434343432343|-331Tn.8 125bD.U pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Rb0 1wp0 Rb0 1wp0 TX0 rlB0 7B0 8zb0 uL0|",
  	"America/Argentina/Salta|LMT CMT -04 -03 -02|4l.E 4g.M 40 30 20|0123232323232323232323232323232323232323232343434342434343|-331TC.k 125bT.8 pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Rb0 1wq0 Ra0 1wp0 TX0 A4p0 uL0|",
  	"America/Argentina/San_Juan|LMT CMT -04 -03 -02|4y.4 4g.M 40 30 20|0123232323232323232323232323232323232323232343434342343432343|-331Tp.U 125bG.I pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Qn0 qO0 16n0 Rb0 1wp0 TX0 rld0 m10 8lb0 uL0|",
  	"America/Argentina/San_Luis|LMT CMT -04 -03 -02|4p.o 4g.M 40 30 20|0123232323232323232323232323232323232323232343434232323432323|-331Ty.A 125bP.o pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 XX0 1q20 SL0 AN0 vDb0 m10 8lb0 8L0 jd0 1qN0 WL0 1qN0|",
  	"America/Argentina/Tucuman|LMT CMT -04 -03 -02|4k.Q 4g.M 40 30 20|01232323232323232323232323232323232323232323434343424343234343|-331TD.8 125bT.U pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Rb0 1wq0 Ra0 1wp0 TX0 rlB0 4N0 8BX0 uL0 1qN0 WL0|",
  	"America/Argentina/Ushuaia|LMT CMT -04 -03 -02|4x.c 4g.M 40 30 20|012323232323232323232323232323232323232323234343434343432343|-331Tq.M 125bH.A pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Rb0 1wp0 Rb0 1wp0 TX0 rkN0 8p0 8zb0 uL0|",
  	"America/Asuncion|LMT AMT -04 -03|3O.E 3O.E 40 30|0123232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323|-3eLw9.k 1FGo0 1DKM9.k 3CL0 3Dd0 10L0 1pB0 10n0 1pB0 10n0 1pB0 1cL0 1dd0 1db0 1dd0 1cL0 1dd0 1cL0 1dd0 1cL0 1dd0 1db0 1dd0 1cL0 1dd0 1cL0 1dd0 1cL0 1dd0 1db0 1dd0 1cL0 1lB0 14n0 1dd0 1cL0 1fd0 WL0 1rd0 1aL0 1dB0 Xz0 1qp0 Xb0 1qN0 10L0 1rB0 TX0 1tB0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1qN0 1cL0 WN0 1qL0 11B0 1nX0 1ip0 WL0 1qN0 WL0 1qN0 WL0 1tB0 TX0 1tB0 TX0 1tB0 19X0 1a10 1fz0 1a10 1fz0 1cN0 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 17b0 1ip0|28e5",
  	"America/Panama|LMT CMT EST|5i.8 5j.A 50|012|-3eLuF.Q Iy01.s|15e5",
  	"America/Bahia_Banderas|LMT MST CST MDT PST CDT|71 70 60 60 80 50|0121312141313131313131313131313131313152525252525252525252525252|-1UQF0 deL0 8lc0 17c0 10M0 1dd0 otX0 gmN0 P2N0 13Vd0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nW0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0|84e3",
  	"America/Bahia|LMT -03 -02|2y.4 30 20|01212121212121212121212121212121212121212121212121212121212121|-2glxp.U HdLp.U 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 1EN0 Lz0 1C10 IL0 1HB0 Db0 1HB0 On0 1zd0 On0 1zd0 Lz0 1zd0 Rb0 1wN0 Wn0 1tB0 Rb0 1tB0 WL0 1tB0 Rb0 1zd0 On0 1HB0 FX0 l5B0 Rb0|27e5",
  	"America/Barbados|LMT AST ADT -0330|3W.t 40 30 3u|0121213121212121|-2m4k1.v 1eAN1.v RB0 1Bz0 Op0 1rb0 11d0 1jJc0 IL0 1ip0 17b0 1ip0 17b0 1ld0 13b0|28e4",
  	"America/Belem|LMT -03 -02|3d.U 30 20|012121212121212121212121212121|-2glwK.4 HdKK.4 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0|20e5",
  	"America/Belize|LMT CST -0530 CWT CPT CDT|5Q.M 60 5u 50 50 50|012121212121212121212121212121212121212121212121213412121212121212121212121212121212121212121215151|-2kBu7.c fPA7.c Onu 1zcu Rbu 1wou Rbu 1wou Rbu 1zcu Onu 1zcu Onu 1zcu Rbu 1wou Rbu 1wou Rbu 1wou Rbu 1zcu Onu 1zcu Onu 1zcu Rbu 1wou Rbu 1wou Rbu 1zcu Onu 1zcu Onu 1zcu Onu 1zcu Rbu 1wou Rbu 1wou Rbu 1zcu Onu 1zcu Onu 1zcu Rbu Rcu 7Bt0 Ni0 4nd0 Rbu 1wou Rbu 1wou Rbu 1zcu Onu 1zcu Onu 1zcu Rbu 1wou Rbu 1wou Rbu 1wou Rbu 1zcu Onu 1zcu Onu 1zcu Rbu 1wou Rbu 1wou Rbu 1zcu Onu 1zcu Onu 1zcu Onu 1zcu Rbu 1wou Rbu 1wou Rbu 1zcu Onu e9Au qn0 lxB0 mn0|57e3",
  	"America/Boa_Vista|LMT -04 -03|42.E 40 30|0121212121212121212121212121212121|-2glvV.k HdKV.k 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 smp0 WL0 1tB0 2L0|62e2",
  	"America/Bogota|LMT BMT -05 -04|4U.g 4U.g 50 40|01232|-3sTv3.I 1eIo0 38yo3.I 1PX0|90e5",
  	"America/Boise|LMT PST PDT MST MWT MPT MDT|7I.N 80 70 70 60 60 60|01212134536363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363|-3tFE0 1nEe0 1nX0 11B0 1nX0 8C10 JCL0 8x20 ix0 QwN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 Dd0 1Kn0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|21e4",
  	"America/Cambridge_Bay|-00 MST MWT MPT MDT CST CDT EST|0 70 60 60 60 60 50 50|012314141414141414141414141414141414141414141414141414141414567541414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141|-21Jc0 RO90 8x20 ix0 14HB0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11A0 1nX0 2K0 WQ0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|15e2",
  	"America/Campo_Grande|LMT -04 -03|3C.s 40 30|01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2glwl.w HdLl.w 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 1EN0 Lz0 1C10 IL0 1HB0 Db0 1HB0 On0 1zd0 On0 1zd0 Lz0 1zd0 Rb0 1wN0 Wn0 1tB0 Rb0 1tB0 WL0 1tB0 Rb0 1zd0 On0 1HB0 FX0 1C10 Lz0 1Ip0 HX0 1zd0 On0 1HB0 IL0 1wp0 On0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 Rb0 1zd0 Lz0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 On0 1zd0 On0 1HB0 FX0|77e4",
  	"America/Cancun|LMT CST EST EDT CDT|5L.4 60 50 40 50|0123232341414141414141414141414141414141412|-1UQG0 2q2o0 yLB0 1lb0 14p0 1lb0 14p0 Lz0 xB0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 Dd0|63e4",
  	"America/Caracas|LMT CMT -0430 -04|4r.I 4r.E 4u 40|012323|-3eLvw.g ROnX.U 28KM2.k 1IwOu kqo0|29e5",
  	"America/Cayenne|LMT -04 -03|3t.k 40 30|012|-2mrwu.E 2gWou.E|58e3",
  	"America/Chicago|LMT CST CDT EST CWT CPT|5O.A 60 50 50 50 50|012121212121212121212121212121212121213121212121214512121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-3tFG0 1nEe0 1nX0 11B0 1nX0 1wp0 TX0 WN0 1qL0 1cN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 11B0 1Hz0 14p0 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 RB0 8x30 iw0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|92e5",
  	"America/Chihuahua|LMT MST CST MDT CDT|74.k 70 60 60 50|0121312424231313131313131313131313131313131313131313131313132|-1UQF0 deL0 8lc0 17c0 10M0 1dd0 2zQN0 1lb0 14p0 1lb0 14q0 1lb0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0|81e4",
  	"America/Ciudad_Juarez|LMT MST CST MDT CDT|75.U 70 60 60 50|0121312424231313131313131313131313131313131313131313131313132131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131|-1UQF0 deL0 8lc0 17c0 10M0 1dd0 2zQN0 1lb0 14p0 1lb0 14q0 1lb0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 U10 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1wn0 cm0 EP0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|",
  	"America/Costa_Rica|LMT SJMT CST CDT|5A.d 5A.d 60 50|01232323232|-3eLun.L 1fyo0 2lu0n.L Db0 1Kp0 Db0 pRB0 15b0 1kp0 mL0|12e5",
  	"America/Phoenix|LMT MST MDT MWT|7s.i 70 60 60|012121313121|-3tFF0 1nEe0 1nX0 11B0 1nX0 SgN0 4Al1 Ap0 1db0 SWqX 1cL0|42e5",
  	"America/Cuiaba|LMT -04 -03|3I.k 40 30|012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2glwf.E HdLf.E 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 1EN0 Lz0 1C10 IL0 1HB0 Db0 1HB0 On0 1zd0 On0 1zd0 Lz0 1zd0 Rb0 1wN0 Wn0 1tB0 Rb0 1tB0 WL0 1tB0 Rb0 1zd0 On0 1HB0 FX0 4a10 HX0 1zd0 On0 1HB0 IL0 1wp0 On0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 Rb0 1zd0 Lz0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 On0 1zd0 On0 1HB0 FX0|54e4",
  	"America/Danmarkshavn|LMT -03 -02 GMT|1e.E 30 20 0|01212121212121212121212121212121213|-2a5WJ.k 2z5fJ.k 19U0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 DC0|8",
  	"America/Dawson_Creek|LMT PST PDT PWT PPT MST|80.U 80 70 70 70 70|01213412121212121212121212121212121212121212121212121212125|-3tofX.4 1nspX.4 1in0 UGp0 8x10 iy0 3NB0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 ML0|12e3",
  	"America/Dawson|LMT YST YDT YWT YPT YDDT PST PDT MST|9h.E 90 80 80 80 70 80 70 70|0121213415167676767676767676767676767676767676767676767676767676767676767676767676767676767678|-2MSeG.k GWpG.k 1in0 1o10 13V0 Ser0 8x00 iz0 LCL0 1fA0 jrA0 fNd0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1z90|13e2",
  	"America/Denver|LMT MST MDT MWT MPT|6X.U 70 60 60 60|012121212134121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-3tFF0 1nEe0 1nX0 11B0 1nX0 11B0 1qL0 WN0 mn0 Ord0 8x20 ix0 LCN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|26e5",
  	"America/Detroit|LMT CST EST EWT EPT EDT|5w.b 60 50 40 40 40|0123425252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252|-2Cgir.N peqr.N 156L0 8x40 iv0 6fd0 11z0 JxX1 SMX 1cN0 1cL0 aW10 1cL0 s10 1Vz0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|37e5",
  	"America/Edmonton|LMT MST MDT MWT MPT|7x.Q 70 60 60 60|0121212121212134121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2yd4q.8 shdq.8 1in0 17d0 hz0 2dB0 1fz0 1a10 11z0 1qN0 WL0 1qN0 11z0 IGN0 8x20 ix0 3NB0 11z0 XQp0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|10e5",
  	"America/Eirunepe|LMT -05 -04|4D.s 50 40|0121212121212121212121212121212121|-2glvk.w HdLk.w 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 dPB0 On0 yTd0 d5X0|31e3",
  	"America/El_Salvador|LMT CST CDT|5U.M 60 50|012121|-1XiG3.c 2Fvc3.c WL0 1qN0 WL0|11e5",
  	"America/Tijuana|LMT MST PST PDT PWT PPT|7M.4 70 80 70 70 70|012123245232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-1UQF0 4Q00 8mM0 8lc0 SN0 1cL0 pHB0 83r0 zI0 5O10 1Rz0 cOO0 11A0 1o00 11A0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 BUp0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 U10 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|20e5",
  	"America/Fort_Nelson|LMT PST PDT PWT PPT MST|8a.L 80 70 70 70 70|012134121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121215|-3tofN.d 1nspN.d 1in0 UGp0 8x10 iy0 3NB0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0|39e2",
  	"America/Fort_Wayne|LMT CST CDT CWT CPT EST EDT|5I.C 60 50 50 50 50 40|0121212134121212121212121212151565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565|-3tFG0 1nEe0 1nX0 11B0 1nX0 QI10 Db0 RB0 8x30 iw0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 5Tz0 1o10 qLb0 1cL0 1cN0 1cL0 1qhd0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|",
  	"America/Fortaleza|LMT -03 -02|2y 30 20|0121212121212121212121212121212121212121|-2glxq HdLq 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 nsp0 WL0 1tB0 5z0 2mN0 On0|34e5",
  	"America/Glace_Bay|LMT AST ADT AWT APT|3X.M 40 30 30 30|012134121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2IsI0.c CwO0.c 1in0 UGp0 8x50 iu0 iq10 11z0 Jg10 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|19e3",
  	"America/Godthab|LMT -03 -02|3q.U 30 20|01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212|-2a5Ux.4 2z5dx.4 19U0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0|17e3",
  	"America/Goose_Bay|LMT NST NDT NST NDT NWT NPT AST ADT ADDT|41.E 3u.Q 2u.Q 3u 2u 2u 2u 40 30 20|0121343434343434356343434343434343434343434343434343434343437878787878787878787878787878787878787878787879787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787|-3tojW.k 1nspt.c 1in0 DXb0 2HbX.8 WL0 1qN0 WL0 1qN0 WL0 1tB0 TX0 1tB0 WL0 1qN0 WL0 1qN0 7UHu itu 1tB0 WL0 1qN0 WL0 1qN0 WL0 1qN0 WL0 1tB0 WL0 1ld0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 S10 g0u 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14n1 1lb0 14p0 1nW0 11C0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zcX Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|76e2",
  	"America/Grand_Turk|LMT KMT EST EDT AST|4I.w 57.a 50 40 40|01232323232323232323232323232323232323232323232323232323232323232323232323243232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-3eLvf.s RK0m.C 2HHBQ.O 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 7jA0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|37e2",
  	"America/Guatemala|LMT CST CDT|62.4 60 50|0121212121|-24KhV.U 2efXV.U An0 mtd0 Nz0 ifB0 17b0 zDB0 11z0|13e5",
  	"America/Guayaquil|LMT QMT -05 -04|5j.k 5e 50 40|01232|-3eLuE.E 1DNzS.E 2uILK rz0|27e5",
  	"America/Guyana|LMT -04 -0345 -03|3Q.D 40 3J 30|01231|-2mf87.l 8Hc7.l 2r7bJ Ey0f|80e4",
  	"America/Halifax|LMT AST ADT AWT APT|4e.o 40 30 30 30|0121212121212121212121212121212121212121212121212134121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2IsHJ.A xzzJ.A 1db0 3I30 1in0 3HX0 IL0 1E10 ML0 1yN0 Pb0 1Bd0 Mn0 1Bd0 Rz0 1w10 Xb0 1w10 LX0 1w10 Xb0 1w10 Lz0 1C10 Jz0 1E10 OL0 1yN0 Un0 1qp0 Xb0 1qp0 11X0 1w10 Lz0 1HB0 LX0 1C10 FX0 1w10 Xb0 1qp0 Xb0 1BB0 LX0 1td0 Xb0 1qp0 Xb0 Rf0 8x50 iu0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 3Qp0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 3Qp0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 6i10 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|39e4",
  	"America/Havana|LMT HMT CST CDT|5t.s 5t.A 50 40|0123232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-3eLuu.w 1qx00.8 72zu.o ML0 sld0 An0 1Nd0 Db0 1Nd0 An0 6Ep0 An0 1Nd0 An0 JDd0 Mn0 1Ap0 On0 1fd0 11X0 1qN0 WL0 1wp0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 14n0 1ld0 14L0 1kN0 15b0 1kp0 1cL0 1cN0 1fz0 1a10 1fz0 1fB0 11z0 14p0 1nX0 11B0 1nX0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 14n0 1ld0 14n0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 1a10 1in0 1a10 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 17c0 1o00 11A0 1qM0 11A0 1o00 11A0 1o00 14o0 1lc0 14o0 1lc0 11A0 6i00 Rc0 1wo0 U00 1tA0 Rc0 1wo0 U00 1wo0 U00 1zc0 U00 1qM0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0|21e5",
  	"America/Hermosillo|LMT MST CST MDT PST|7n.Q 70 60 60 80|0121312141313131|-1UQF0 deL0 8lc0 17c0 10M0 1dd0 otX0 gmN0 P2N0 13Vd0 1lb0 14p0 1lb0 14p0 1lb0|64e4",
  	"America/Indiana/Knox|LMT CST CDT CWT CPT EST|5K.u 60 50 50 50 50|01212134121212121212121212121212121212151212121212121212121212121212121212121212121212121252121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-3tFG0 1nEe0 1nX0 11B0 1nX0 SgN0 8x30 iw0 3NB0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 1fz0 1cN0 1cL0 1cN0 11z0 1o10 11z0 1o10 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 3Cn0 8wp0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 z8o0 1o00 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|",
  	"America/Indiana/Marengo|LMT CST CDT CWT CPT EST EDT|5J.n 60 50 50 50 50 40|01212134121212121212121215656565656525656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565|-3tFG0 1nEe0 1nX0 11B0 1nX0 SgN0 8x30 iw0 dyN0 11z0 6fd0 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 jrz0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1VA0 LA0 1BX0 1e6p0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|",
  	"America/Indiana/Petersburg|LMT CST CDT CWT CPT EST EDT|5N.7 60 50 50 50 50 40|01212134121212121212121212121512121212121212121212125212565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565|-3tFG0 1nEe0 1nX0 11B0 1nX0 SgN0 8x30 iw0 njX0 WN0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 3Fb0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 19co0 1o00 Rd0 1zb0 Oo0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|",
  	"America/Indiana/Tell_City|LMT CST CDT CWT CPT EST EDT|5L.3 60 50 50 50 50 40|012121341212121212121212121512165652121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-3tFG0 1nEe0 1nX0 11B0 1nX0 SgN0 8x30 iw0 njX0 WN0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 8wn0 1cN0 1cL0 1cN0 1cK0 1cN0 1cL0 1qhd0 1o00 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|",
  	"America/Indiana/Vevay|LMT CST CDT CWT CPT EST EDT|5E.g 60 50 50 50 50 40|0121213415656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565|-3tFG0 1nEe0 1nX0 11B0 1nX0 SgN0 8x30 iw0 kPB0 Awn0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1lnd0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|",
  	"America/Indiana/Vincennes|LMT CST CDT CWT CPT EST EDT|5O.7 60 50 50 50 50 40|01212134121212121212121212121212156565212565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565|-3tFG0 1nEe0 1nX0 11B0 1nX0 SgN0 8x30 iw0 1o10 11z0 g0p0 11z0 1o10 11z0 1qL0 WN0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 1fz0 1cN0 WL0 1qN0 1cL0 1cN0 1cL0 1cN0 caL0 1cL0 1cN0 1cL0 1qhd0 1o00 Rd0 1zb0 Oo0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|",
  	"America/Indiana/Winamac|LMT CST CDT CWT CPT EST EDT|5K.p 60 50 50 50 50 40|012121341212121212121212121212121212121565652165656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565|-3tFG0 1nEe0 1nX0 11B0 1nX0 SgN0 8x30 iw0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 1fz0 1cN0 1cL0 1cN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 jrz0 1cL0 1cN0 1cL0 1qhd0 1o00 Rd0 1za0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|",
  	"America/Inuvik|-00 PST PDT MDT MST|0 80 70 60 70|01212121212121213434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434|-FnA0 L3K0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cK0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|35e2",
  	"America/Iqaluit|-00 EWT EPT EST EDT CST CDT|0 40 40 50 40 60 50|0123434343434343434343434343434343434343434343434343434343456343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343|-16K00 7nX0 iv0 14HB0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11C0 1nX0 11A0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|67e2",
  	"America/Jamaica|LMT KMT EST EDT|57.a 57.a 50 40|01232323232323232323232|-3eLuQ.O RK00 2uM1Q.O 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0|94e4",
  	"America/Juneau|LMT LMT PST PWT PPT PDT YDT YST AKST AKDT|-f2.j 8V.F 80 70 70 70 80 90 90 80|0123425252525252525252525252625252578989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898|-48Pzs.L 1jVwq.s 1EX12.j 8x10 iy0 Vo10 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cM0 1cM0 1cL0 1cN0 1fz0 1a10 1fz0 co0 10q0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|33e3",
  	"America/Kentucky/Louisville|LMT CST CDT CWT CPT EST EDT|5H.2 60 50 50 50 50 40|01212121213412121212121212121212121212565656565656525656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565|-3tFG0 1nEe0 1nX0 11B0 1nX0 3Fd0 Nb0 LPd0 11z0 RB0 8x30 iw0 1nX1 e0X 9vd0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 xz0 gso0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1VA0 LA0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|",
  	"America/Kentucky/Monticello|LMT CST CDT CWT CPT EST EDT|5D.o 60 50 50 50 50 40|01212134121212121212121212121212121212121212121212121212121212121212121212565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565|-3tFG0 1nEe0 1nX0 11B0 1nX0 SgN0 8x30 iw0 SWp0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11A0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|",
  	"America/La_Paz|LMT CMT BST -04|4w.A 4w.A 3w.A 40|0123|-3eLvr.o 1FIo0 13b0|19e5",
  	"America/Lima|LMT LMT -05 -04|58.c 58.A 50 40|01232323232323232|-3eLuP.M JcM0.o 1bDzP.o zX0 1aN0 1cL0 1cN0 1cL0 1PrB0 zX0 1O10 zX0 6Gp0 zX0 98p0 zX0|11e6",
  	"America/Los_Angeles|LMT PST PDT PWT PPT|7Q.W 80 70 70 70|0121213412121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-3tFE0 1nEe0 1nX0 11B0 1nX0 SgN0 8x10 iy0 5Wp1 1VaX 3dA0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1a00 1fA0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|15e6",
  	"America/Maceio|LMT -03 -02|2m.Q 30 20|012121212121212121212121212121212121212121|-2glxB.8 HdLB.8 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 dMN0 Lz0 8Q10 WL0 1tB0 5z0 2mN0 On0|93e4",
  	"America/Managua|LMT MMT CST EST CDT|5J.8 5J.c 60 50 50|01232424232324242|-3eLue.Q 1Mhc0.4 1yAMe.M 4mn0 9Up0 Dz0 1K10 Dz0 s3F0 1KH0 DB0 9In0 k8p0 19X0 1o30 11y0|22e5",
  	"America/Manaus|LMT -04 -03|40.4 40 30|01212121212121212121212121212121|-2glvX.U HdKX.U 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 dPB0 On0|19e5",
  	"America/Martinique|LMT FFMT AST ADT|44.k 44.k 40 30|01232|-3eLvT.E PTA0 2LPbT.E 19X0|39e4",
  	"America/Matamoros|LMT CST CDT|6u 60 50|0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-1UQG0 2FjC0 1nX0 i6p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 U10 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|45e4",
  	"America/Mazatlan|LMT MST CST MDT PST|75.E 70 60 60 80|0121312141313131313131313131313131313131313131313131313131313131|-1UQF0 deL0 8lc0 17c0 10M0 1dd0 otX0 gmN0 P2N0 13Vd0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0|44e4",
  	"America/Menominee|LMT CST CDT CWT CPT EST|5O.r 60 50 50 50 50|012121341212152121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-3pdG9.x 1jce9.x 1nX0 11B0 1nX0 SgN0 8x30 iw0 1o10 11z0 LCN0 1fz0 6410 9Jb0 1cM0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|85e2",
  	"America/Merida|LMT CST EST CDT|5W.s 60 50 50|0121313131313131313131313131313131313131313131313131313131|-1UQG0 2q2o0 2hz0 wu30 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0|11e5",
  	"America/Metlakatla|LMT LMT PST PWT PPT PDT AKST AKDT|-fd.G 8K.i 80 70 70 70 90 80|0123425252525252525252525252525252526767672676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676|-48Pzs.L 1jVwf.5 1EX1d.G 8x10 iy0 Vo10 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1hU10 Rd0 1zb0 Op0 1zb0 Op0 1zb0 uM0 jB0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|14e2",
  	"America/Mexico_City|LMT MST CST MDT CDT CWT|6A.A 70 60 60 50 50|012131242425242424242424242424242424242424242424242424242424242424242|-1UQF0 deL0 8lc0 17c0 10M0 1dd0 gEn0 TX0 3xd0 Jb0 6zB0 SL0 e5d0 17b0 1Pff0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0|20e6",
  	"America/Miquelon|LMT AST -03 -02|3I.E 40 30 20|012323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-2mKkf.k 2LTAf.k gQ10 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|61e2",
  	"America/Moncton|LMT EST AST ADT AWT APT|4j.8 50 40 30 30 30|0123232323232323232323245232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-3txvE.Q J4ME.Q CwN0 1in0 zAo0 An0 1Nd0 An0 1Nd0 An0 1Nd0 An0 1Nd0 An0 1Nd0 An0 1K10 Lz0 1zB0 NX0 1u10 Wn0 S20 8x50 iu0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 3Cp0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14n1 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 ReX 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|64e3",
  	"America/Monterrey|LMT CST CDT|6F.g 60 50|0121212121212121212121212121212121212121212121212121212121|-1UQG0 2FjC0 1nX0 i6p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0|41e5",
  	"America/Montevideo|LMT MMT -04 -03 -0330 -0230 -02 -0130|3I.P 3I.P 40 30 3u 2u 20 1u|012343434343434343434343435353636353636375363636363636363636363636363636363636363636363|-2tRUf.9 sVc0 8jcf.9 1db0 1dcu 1cLu 1dcu 1cLu ircu 11zu 1o0u 11zu 1o0u 11zu 1o0u 11zu 1qMu WLu 1qMu WLu 1fAu 1cLu 1o0u 11zu NAu 3jXu zXu Dq0u 19Xu pcu jz0 cm10 19X0 6tB0 1fbu 3o0u jX0 4vB0 xz0 3Cp0 mmu 1a10 IMu Db0 4c10 uL0 1Nd0 An0 1SN0 uL0 mp0 28L0 iPB0 un0 1SN0 xz0 1zd0 Lz0 1zd0 Rb0 1zd0 On0 1wp0 Rb0 s8p0 1fB0 1ip0 11z0 1ld0 14n0 1o10 11z0 1o10 11z0 1o10 14n0 1ld0 14n0 1ld0 14n0 1o10 11z0 1o10 11z0 1o10 11z0|17e5",
  	"America/Toronto|LMT EST EDT EWT EPT|5h.w 50 40 40 40|012121212121212121212121212121212121212121212123412121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-32B6G.s UFdG.s 1in0 11Wu 1nzu 1fD0 WJ0 1wr0 Nb0 1Ap0 On0 1zd0 On0 1wp0 TX0 1tB0 TX0 1tB0 TX0 1tB0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 4kM0 8x40 iv0 1o10 11z0 1nX0 11z0 1o10 11z0 1o10 1qL0 11D0 1nX0 11B0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|65e5",
  	"America/New_York|LMT EST EDT EWT EPT|4U.2 50 40 40 40|012121212121212121212121212121212121212121212121213412121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-3tFH0 1nEe0 1nX0 11B0 1nX0 11B0 1qL0 1a10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 RB0 8x40 iv0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|21e6",
  	"America/Nome|LMT LMT NST NWT NPT BST BDT YST AKST AKDT|-cW.m b1.C b0 a0 a0 b0 a0 90 90 80|01234256565656565656565656565656565678989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898989898|-48Pzs.L 1jVyu.p 1EX1W.m 8wW0 iB0 Qlb0 52O0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 cl0 10q0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|38e2",
  	"America/Noronha|LMT -02 -01|29.E 20 10|0121212121212121212121212121212121212121|-2glxO.k HdKO.k 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 nsp0 WL0 1tB0 2L0 2pB0 On0|30e2",
  	"America/North_Dakota/Beulah|LMT MST MDT MWT MPT CST CDT|6L.7 70 60 60 60 60 50|012121341212121212121212121212121212121212121212121212121212121212121212121212121212121212121212565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565|-3tFF0 1nEe0 1nX0 11B0 1nX0 SgN0 8x20 ix0 QwN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Oo0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0|",
  	"America/North_Dakota/Center|LMT MST MDT MWT MPT CST CDT|6J.c 70 60 60 60 60 50|0121213412121212121212121212121212121212121212121212121212125656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565|-3tFF0 1nEe0 1nX0 11B0 1nX0 SgN0 8x20 ix0 QwN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14o0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|",
  	"America/North_Dakota/New_Salem|LMT MST MDT MWT MPT CST CDT|6J.D 70 60 60 60 60 50|0121213412121212121212121212121212121212121212121212121212121212121212121212121212565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565|-3tFF0 1nEe0 1nX0 11B0 1nX0 SgN0 8x20 ix0 QwN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14o0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|",
  	"America/Ojinaga|LMT MST CST MDT CDT|6V.E 70 60 60 50|0121312424231313131313131313131313131313131313131313131313132424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242|-1UQF0 deL0 8lc0 17c0 10M0 1dd0 2zQN0 1lb0 14p0 1lb0 14q0 1lb0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 U10 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1wn0 Rc0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|23e3",
  	"America/Paramaribo|LMT PMT PMT -0330 -03|3E.E 3E.Q 3E.A 3u 30|01234|-2nDUj.k Wqo0.c qanX.I 1yVXN.o|24e4",
  	"America/Port-au-Prince|LMT PPMT EST EDT|4N.k 4N 50 40|012323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-3eLva.E 15RLX.E 2FnMb 19X0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14q0 1o00 11A0 1o00 11A0 1o00 14o0 1lc0 14o0 1lc0 14o0 1o00 11A0 1o00 11A0 1o00 14o0 1lc0 14o0 1lc0 i6n0 1nX0 11B0 1nX0 d430 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 3iN0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|23e5",
  	"America/Rio_Branco|LMT -05 -04|4v.c 50 40|01212121212121212121212121212121|-2glvs.M HdLs.M 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 NBd0 d5X0|31e4",
  	"America/Porto_Velho|LMT -04 -03|4f.A 40 30|012121212121212121212121212121|-2glvI.o HdKI.o 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0|37e4",
  	"America/Punta_Arenas|LMT SMT -05 -04 -03|4H.E 4G.J 50 40 30|01213132323232323232343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434|-3eLvg.k MJbX.5 fJAh.f 5knG.J 1Vzh.f jRAG.J 1pbh.f 11d0 1oL0 11d0 1oL0 11d0 1oL0 11d0 1pb0 11d0 nHX0 op0 blz0 ko0 Qeo0 WL0 1zd0 On0 1ip0 11z0 1o10 11z0 1qN0 WL0 1ld0 14n0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 WL0 1qN0 1cL0 1cN0 11z0 1o10 11z0 1qN0 WL0 1fB0 19X0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 17b0 1ip0 11z0 1ip0 1fz0 1fB0 11z0 1qN0 WL0 1qN0 WL0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 17b0 1ip0 11z0 1o10 19X0 1fB0 1nX0 G10 1EL0 Op0 1zb0 Rd0 1wn0 Rd0 46n0 Ap0|",
  	"America/Winnipeg|LMT CST CDT CWT CPT|6s.A 60 50 50 50|0121212134121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-3kLtv.o 1a3bv.o WL0 3ND0 1in0 Jap0 Rb0 aCN0 8x30 iw0 1tB0 11z0 1ip0 11z0 1o10 11z0 1o10 11z0 1rd0 10L0 1op0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 1cL0 1cN0 11z0 6i10 WL0 6i10 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1a00 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1a00 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 14o0 1lc0 14o0 1o00 11A0 1o00 11A0 1o00 14o0 1lc0 14o0 1lc0 14o0 1o00 11A0 1o00 11A0 1o00 14o0 1lc0 14o0 1lc0 14o0 1lc0 14o0 1o00 11A0 1o00 11A0 1o00 14o0 1lc0 14o0 1lc0 14o0 1o00 11A0 1o00 11A0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|66e4",
  	"America/Rankin_Inlet|-00 CST CDT EST|0 60 50 50|01212121212121212121212121212121212121212121212121212121212321212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-vDc0 Bjk0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|26e2",
  	"America/Recife|LMT -03 -02|2j.A 30 20|0121212121212121212121212121212121212121|-2glxE.o HdLE.o 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 nsp0 WL0 1tB0 2L0 2pB0 On0|33e5",
  	"America/Regina|LMT MST MDT MWT MPT CST|6W.A 70 60 60 60 60|012121212121212121212121341212121212121212121212121215|-2AD51.o uHe1.o 1in0 s2L0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 66N0 1cL0 1cN0 19X0 1fB0 1cL0 1fB0 1cL0 1cN0 1cL0 M30 8x20 ix0 1ip0 1cL0 1ip0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 3NB0 1cL0 1cN0|19e4",
  	"America/Resolute|-00 CST CDT EST|0 60 50 50|01212121212121212121212121212121212121212121212121212121212321212121212321212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-SnA0 103I0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|229",
  	"America/Santarem|LMT -04 -03|3C.M 40 30|0121212121212121212121212121212|-2glwl.c HdLl.c 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 NBd0|21e4",
  	"America/Santiago|LMT SMT -05 -04 -03|4G.J 4G.J 50 40 30|0121313232323232323432343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434|-3eLvh.f MJc0 fJAh.f 5knG.J 1Vzh.f jRAG.J 1pbh.f 11d0 1oL0 11d0 1oL0 11d0 1oL0 11d0 1pb0 11d0 nHX0 op0 9Bz0 hX0 1q10 ko0 Qeo0 WL0 1zd0 On0 1ip0 11z0 1o10 11z0 1qN0 WL0 1ld0 14n0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 WL0 1qN0 1cL0 1cN0 11z0 1o10 11z0 1qN0 WL0 1fB0 19X0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 17b0 1ip0 11z0 1ip0 1fz0 1fB0 11z0 1qN0 WL0 1qN0 WL0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 17b0 1ip0 11z0 1o10 19X0 1fB0 1nX0 G10 1EL0 Op0 1zb0 Rd0 1wn0 Rd0 46n0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1zb0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0|62e5",
  	"America/Santo_Domingo|LMT SDMT EST EDT -0430 AST|4D.A 4E 50 40 4u 40|012324242424242525|-3eLvk.o 1Jic0.o 1lJMk Mn0 6sp0 Lbu 1Cou yLu 1RAu wLu 1QMu xzu 1Q0u xXu 1PAu 13jB0 e00|29e5",
  	"America/Sao_Paulo|LMT -03 -02|36.s 30 20|01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2glwR.w HdKR.w 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 pTd0 PX0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 1EN0 Lz0 1C10 IL0 1HB0 Db0 1HB0 On0 1zd0 On0 1zd0 Lz0 1zd0 Rb0 1wN0 Wn0 1tB0 Rb0 1tB0 WL0 1tB0 Rb0 1zd0 On0 1HB0 FX0 1C10 Lz0 1Ip0 HX0 1zd0 On0 1HB0 IL0 1wp0 On0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 Rb0 1zd0 Lz0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 On0 1zd0 On0 1HB0 FX0|20e6",
  	"America/Scoresbysund|LMT -02 -01 +00|1r.Q 20 10 0|0121323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-2a5Ww.8 2z5ew.8 1a00 1cK0 1cL0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|452",
  	"America/Sitka|LMT LMT PST PWT PPT PDT YST AKST AKDT|-eW.L 91.d 80 70 70 70 90 90 80|0123425252525252525252525252525252567878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787|-48Pzs.L 1jVwu 1EX0W.L 8x10 iy0 Vo10 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 co0 10q0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|90e2",
  	"America/St_Johns|LMT NST NDT NST NDT NWT NPT NDDT|3u.Q 3u.Q 2u.Q 3u 2u 2u 2u 1u|012121212121212121212121212121212121213434343434343435634343434343434343434343434343434343434343434343434343434343434343434343434343434343437343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343|-3tokt.8 1l020 14L0 1nB0 1in0 1gm0 Dz0 1JB0 1cL0 1cN0 1cL0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1fB0 1cL0 1cN0 1cL0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1fB0 1cL0 1fB0 19X0 1fB0 19X0 10O0 eKX.8 19X0 1iq0 WL0 1qN0 WL0 1qN0 WL0 1tB0 TX0 1tB0 WL0 1qN0 WL0 1qN0 7UHu itu 1tB0 WL0 1qN0 WL0 1qN0 WL0 1qN0 WL0 1tB0 WL0 1ld0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14n1 1lb0 14p0 1nW0 11C0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zcX Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|11e4",
  	"America/Swift_Current|LMT MST MDT MWT MPT CST|7b.k 70 60 60 60 60|012134121212121212121215|-2AD4M.E uHdM.E 1in0 UGp0 8x20 ix0 1o10 17b0 1ip0 11z0 1o10 11z0 1o10 11z0 isN0 1cL0 3Cp0 1cL0 1cN0 11z0 1qN0 WL0 pMp0|16e3",
  	"America/Tegucigalpa|LMT CST CDT|5M.Q 60 50|01212121|-1WGGb.8 2ETcb.8 WL0 1qN0 WL0 GRd0 AL0|11e5",
  	"America/Thule|LMT AST ADT|4z.8 40 30|012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2a5To.Q 31NBo.Q 1cL0 1cN0 1cL0 1fB0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|656",
  	"America/Vancouver|LMT PST PDT PWT PPT|8c.s 80 70 70 70|01213412121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-3tofL.w 1nspL.w 1in0 UGp0 8x10 iy0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|23e5",
  	"America/Whitehorse|LMT YST YDT YWT YPT YDDT PST PDT MST|90.c 90 80 80 80 70 80 70 70|0121213415167676767676767676767676767676767676767676767676767676767676767676767676767676767678|-2MSeX.M GWpX.M 1in0 1o10 13V0 Ser0 8x00 iz0 LCL0 1fA0 LA0 ytd0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1z90|23e3",
  	"America/Yakutat|LMT LMT YST YWT YPT YDT AKST AKDT|-eF.5 9i.T 90 80 80 80 90 80|0123425252525252525252525252525252526767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676|-48Pzs.L 1jVwL.G 1EX1F.5 8x00 iz0 Vo10 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 cn0 10q0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|642",
  	"America/Yellowknife|-00 MST MWT MPT MDT|0 70 60 60 60|01231414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141|-1pdA0 hix0 8x20 ix0 14HB0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|19e3",
  	"Antarctica/Casey|-00 +08 +11|0 -80 -b0|0121212121212|-2q00 1DjS0 T90 40P0 KL0 blz0 3m10 1o30 14k0 1kr0 12l0 1o01|10",
  	"Antarctica/Davis|-00 +07 +05|0 -70 -50|01012121|-vyo0 iXt0 alj0 1D7v0 VB0 3Wn0 KN0|70",
  	"Pacific/Port_Moresby|LMT PMMT +10|-9M.E -9M.w -a0|012|-3D8VM.E AvA0.8|25e4",
  	"Antarctica/Macquarie|-00 AEST AEDT|0 -a0 -b0|0121012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212|-2OPc0 Fb40 1a00 4SK0 1ayy0 Lvs0 1cM0 1o00 Rc0 1wo0 Rc0 1wo0 U00 1wo0 LA0 1C00 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 11A0 1qM0 WM0 1qM0 Oo0 1zc0 Oo0 1zc0 Oo0 1wo0 WM0 1tA0 WM0 1tA0 U00 1tA0 U00 1tA0 11A0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 11A0 1o00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1cM0 1a00 1io0 1cM0 1cM0 1cM0 1cM0 3Co0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0|1",
  	"Antarctica/Mawson|-00 +06 +05|0 -60 -50|012|-CEo0 2fyk0|60",
  	"Pacific/Auckland|LMT NZMT NZST NZST NZDT|-bD.4 -bu -cu -c0 -d0|012131313131313131313131313134343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434|-46jLD.4 2nEO9.4 Lz0 1tB0 11zu 1o0u 11zu 1o0u 11zu 1o0u 14nu 1lcu 14nu 1lcu 1lbu 11Au 1nXu 11Au 1nXu 11Au 1nXu 11Au 1nXu 11Au 1qLu WMu 1qLu 11Au 1n1bu IM0 1C00 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1qM0 14o0 1lc0 14o0 1lc0 14o0 1lc0 17c0 1io0 17c0 1io0 17c0 1io0 17c0 1lc0 14o0 1lc0 14o0 1lc0 17c0 1io0 17c0 1io0 17c0 1lc0 14o0 1lc0 14o0 1lc0 17c0 1io0 17c0 1io0 17c0 1io0 17c0 1io0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00|14e5",
  	"Antarctica/Palmer|-00 -03 -04 -02|0 30 40 20|0121212121213121212121212121212121212121212121212121212121212121212121212121212121|-cao0 nD0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 jsN0 14N0 11z0 1o10 11z0 1qN0 WL0 1qN0 WL0 1qN0 1cL0 1cN0 11z0 1o10 11z0 1qN0 WL0 1fB0 19X0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 17b0 1ip0 11z0 1ip0 1fz0 1fB0 11z0 1qN0 WL0 1qN0 WL0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 17b0 1ip0 11z0 1o10 19X0 1fB0 1nX0 G10 1EL0 Op0 1zb0 Rd0 1wn0 Rd0 46n0 Ap0|40",
  	"Antarctica/Rothera|-00 -03|0 30|01|gOo0|130",
  	"Asia/Riyadh|LMT +03|-36.Q -30|01|-TvD6.Q|57e5",
  	"Antarctica/Troll|-00 +00 +02|0 0 -20|01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|1puo0 hd0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|40",
  	"Asia/Urumqi|LMT +06|-5O.k -60|01|-1GgtO.k|32e5",
  	"Europe/Berlin|LMT CET CEST CEMT|-R.s -10 -20 -30|012121212121212321212321212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-36RcR.s UbWR.s 11d0 1iO0 11A0 1o00 11A0 Qrc0 6i00 WM0 1fA0 1cM0 1cM0 1cM0 kL0 Nc0 m10 WM0 1ao0 1cp0 dX0 jz0 Dd0 1io0 17c0 1fA0 1a00 1ehA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|41e5",
  	"Asia/Almaty|LMT +05 +06 +07|-57.M -50 -60 -70|012323232323232323232321232323232323232323232323232|-1Pc57.M eUo7.M 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0|15e5",
  	"Asia/Amman|LMT EET EEST +03|-2n.I -20 -30 -30|0121212121212121212121212121212121212121212121212121212121212121212121212121212121212123|-1yW2n.I 1HiMn.I KL0 1oN0 11b0 1oN0 11b0 1pd0 1dz0 1cp0 11b0 1op0 11b0 fO10 1db0 1e10 1cL0 1cN0 1cL0 1cN0 1fz0 1pd0 10n0 1ld0 14n0 1hB0 15b0 1ip0 19X0 1cN0 1cL0 1cN0 17b0 1ld0 14o0 1lc0 17c0 1io0 17c0 1io0 17c0 1So0 y00 1fc0 1dc0 1co0 1dc0 1cM0 1cM0 1cM0 1o00 11A0 1lc0 17c0 1cM0 1cM0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 4bX0 Dd0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 LA0 1C00|25e5",
  	"Asia/Anadyr|LMT +12 +13 +14 +11|-bN.U -c0 -d0 -e0 -b0|01232121212121212121214121212121212121212121212121212121212141|-1PcbN.U eUnN.U 23CL0 1db0 2q10 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 2sp0 WM0|13e3",
  	"Asia/Aqtau|LMT +04 +05 +06|-3l.4 -40 -50 -60|012323232323232323232123232312121212121212121212|-1Pc3l.4 eUnl.4 24PX0 2pX0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cN0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0|15e4",
  	"Asia/Aqtobe|LMT +04 +05 +06|-3M.E -40 -50 -60|0123232323232323232321232323232323232323232323232|-1Pc3M.E eUnM.E 23CL0 3Db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0|27e4",
  	"Asia/Ashgabat|LMT +04 +05 +06|-3R.w -40 -50 -60|0123232323232323232323212|-1Pc3R.w eUnR.w 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0|41e4",
  	"Asia/Atyrau|LMT +03 +05 +06 +04|-3r.I -30 -50 -60 -40|01232323232323232323242323232323232324242424242|-1Pc3r.I eUor.I 24PW0 2pX0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 2sp0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0|",
  	"Asia/Baghdad|LMT BMT +03 +04|-2V.E -2V.A -30 -40|0123232323232323232323232323232323232323232323232323232|-3eLCV.E 18ao0.4 2ACnV.A 11b0 1cp0 1dz0 1dd0 1db0 1cN0 1cp0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1de0 1dc0 1dc0 1dc0 1cM0 1dc0 1cM0 1dc0 1cM0 1dc0 1dc0 1dc0 1cM0 1dc0 1cM0 1dc0 1cM0 1dc0 1dc0 1dc0 1cM0 1dc0 1cM0 1dc0 1cM0 1dc0 1dc0 1dc0 1cM0 1dc0 1cM0 1dc0 1cM0 1dc0|66e5",
  	"Asia/Qatar|LMT +04 +03|-3q.8 -40 -30|012|-21Jfq.8 27BXq.8|96e4",
  	"Asia/Baku|LMT +03 +04 +05|-3j.o -30 -40 -50|01232323232323232323232123232323232323232323232323232323232323232|-1Pc3j.o 1jUoj.o WCL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 1cM0 9Je0 1o00 11z0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|27e5",
  	"Asia/Bangkok|LMT BMT +07|-6G.4 -6G.4 -70|012|-3D8SG.4 1C000|15e6",
  	"Asia/Barnaul|LMT +06 +07 +08|-5z -60 -70 -80|0123232323232323232323212323232321212121212121212121212121212121212|-21S5z pCnz 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 p90 LE0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 3rd0|",
  	"Asia/Beirut|LMT EET EEST|-2m -20 -30|0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-3D8Om 1BWom 1on0 1410 1db0 19B0 1in0 1ip0 WL0 1lQp0 11b0 1oN0 11b0 1oN0 11b0 1pd0 11b0 1oN0 11b0 q6N0 En0 1oN0 11b0 1oN0 11b0 1oN0 11b0 1pd0 11b0 1oN0 11b0 1op0 11b0 dA10 17b0 1iN0 17b0 1iN0 17b0 1iN0 17b0 1vB0 SL0 1mp0 13z0 1iN0 17b0 1iN0 17b0 1jd0 12n0 1a10 1cL0 1cN0 1cL0 1cN0 1cL0 1fB0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0|22e5",
  	"Asia/Bishkek|LMT +05 +06 +07|-4W.o -50 -60 -70|012323232323232323232321212121212121212121212121212|-1Pc4W.o eUnW.o 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2e00 1tX0 17b0 1ip0 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1cPu 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0|87e4",
  	"Asia/Brunei|LMT +0730 +08 +0820 +09|-7l.k -7u -80 -8k -90|0123232323232323242|-1KITl.k gDbP.k 6ynu AnE 1O0k AnE 1NAk AnE 1NAk AnE 1NAk AnE 1O0k AnE 1NAk AnE pAk 8Fz0|42e4",
  	"Asia/Kolkata|LMT HMT MMT IST +0630|-5R.s -5R.k -5l.a -5u -6u|01234343|-4Fg5R.s BKo0.8 1rDcw.a 1r2LP.a 1un0 HB0 7zX0|15e6",
  	"Asia/Chita|LMT +08 +09 +10|-7x.Q -80 -90 -a0|012323232323232323232321232323232323232323232323232323232323232312|-21Q7x.Q pAnx.Q 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 3re0|33e4",
  	"Asia/Choibalsan|LMT +07 +08 +10 +09|-7C -70 -80 -a0 -90|0123434343434343434343434343434343434343434343424242|-2APHC 2UkoC cKn0 1da0 1dd0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1fB0 1cL0 1cN0 1cL0 1cN0 1cL0 6hD0 11z0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 3Db0 h1f0 1cJ0 1cP0 1cJ0|38e3",
  	"Asia/Shanghai|LMT CST CDT|-85.H -80 -90|012121212121212121212121212121|-2M0U5.H Iuo5.H 18n0 OjB0 Rz0 11d0 1wL0 A10 8HX0 1G10 Tz0 1ip0 1jX0 1cN0 11b0 1oN0 aL0 1tU30 Rb0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0|23e6",
  	"Asia/Colombo|LMT MMT +0530 +06 +0630|-5j.o -5j.w -5u -60 -6u|012342432|-3D8Rj.o 13inX.Q 1rFbN.w 1zzu 7Apu 23dz0 11zu n3cu|22e5",
  	"Asia/Dhaka|LMT HMT +0630 +0530 +06 +07|-61.E -5R.k -6u -5u -60 -70|01232454|-3eLG1.E 26008.k 1unn.k HB0 m6n0 2kxbu 1i00|16e6",
  	"Asia/Damascus|LMT EET EEST +03|-2p.c -20 -30 -30|01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212123|-21Jep.c Hep.c 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1xRB0 11X0 1oN0 10L0 1pB0 11b0 1oN0 10L0 1mp0 13X0 1oN0 11b0 1pd0 11b0 1oN0 11b0 1oN0 11b0 1oN0 11b0 1pd0 11b0 1oN0 11b0 1oN0 11b0 1oN0 11b0 1pd0 11b0 1oN0 Nb0 1AN0 Nb0 bcp0 19X0 1gp0 19X0 3ld0 1xX0 Vd0 1Bz0 Sp0 1vX0 10p0 1dz0 1cN0 1cL0 1db0 1db0 1g10 1an0 1ap0 1db0 1fd0 1db0 1cN0 1db0 1dd0 1db0 1cp0 1dz0 1c10 1dX0 1cN0 1db0 1dd0 1db0 1cN0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1db0 1cN0 1db0 1cN0 19z0 1fB0 1qL0 11B0 1on0 Wp0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0|26e5",
  	"Asia/Dili|LMT +08 +09|-8m.k -80 -90|01212|-2le8m.k 1dnXm.k 1nfA0 Xld0|19e4",
  	"Asia/Dubai|LMT +04|-3F.c -40|01|-21JfF.c|39e5",
  	"Asia/Dushanbe|LMT +05 +06 +07|-4z.c -50 -60 -70|012323232323232323232321|-1Pc4z.c eUnz.c 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2hB0|76e4",
  	"Asia/Famagusta|LMT EET EEST +03|-2f.M -20 -30 -30|0121212121212121212121212121212121212121212121212121212121212121212121212121212121212312121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-1Vc2f.M 2a3cf.M 1cL0 1qp0 Xz0 19B0 19X0 1fB0 1db0 1cp0 1cL0 1fB0 19X0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1fB0 1cL0 1cN0 1cL0 1cN0 1o30 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 15U0 2Ks0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|",
  	"Asia/Gaza|LMT EET EEST IST IDT|-2h.Q -20 -30 -20 -30|0121212121212121212121212121212121234343434343434343434343434343431212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2MBCh.Q 1Azeh.Q MM0 iM0 4JA0 10o0 1pA0 10M0 1pA0 16o0 1jA0 16o0 1jA0 pBa0 Vz0 1oN0 11b0 1oO0 10N0 1pz0 10N0 1pb0 10N0 1pb0 10N0 1pb0 10N0 1pz0 10N0 1pb0 10N0 1pb0 11d0 1oL0 dW0 hfB0 Db0 1fB0 Rb0 bXB0 gM0 8Q00 IM0 1wo0 TX0 1HB0 IL0 1s10 10n0 1o10 WL0 1zd0 On0 1ld0 11z0 1o10 14n0 1o10 14n0 1nd0 12n0 1nd0 Xz0 1q10 12n0 M10 C00 17c0 1io0 17c0 1io0 17c0 1o00 1cL0 1fB0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 17c0 1io0 18N0 1bz0 19z0 1gp0 1610 1iL0 11z0 1o10 14o0 1lA1 SKX 1xd1 MKX 1AN0 1a00 1fA0 1cL0 1cN0 1nX0 1210 1nA0 1210 1qL0 WN0 1qL0 WN0 1qL0 11c0 1on0 11B0 1o00 11A0 1qo0 XA0 1qp0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0|18e5",
  	"Asia/Hebron|LMT EET EEST IST IDT|-2k.n -20 -30 -20 -30|012121212121212121212121212121212123434343434343434343434343434343121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2MBCk.n 1Azek.n MM0 iM0 4JA0 10o0 1pA0 10M0 1pA0 16o0 1jA0 16o0 1jA0 pBa0 Vz0 1oN0 11b0 1oO0 10N0 1pz0 10N0 1pb0 10N0 1pb0 10N0 1pb0 10N0 1pz0 10N0 1pb0 10N0 1pb0 11d0 1oL0 dW0 hfB0 Db0 1fB0 Rb0 bXB0 gM0 8Q00 IM0 1wo0 TX0 1HB0 IL0 1s10 10n0 1o10 WL0 1zd0 On0 1ld0 11z0 1o10 14n0 1o10 14n0 1nd0 12n0 1nd0 Xz0 1q10 12n0 M10 C00 17c0 1io0 17c0 1io0 17c0 1o00 1cL0 1fB0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 17c0 1io0 18N0 1bz0 19z0 1gp0 1610 1iL0 12L0 1mN0 14o0 1lc0 Tb0 1xd1 MKX bB0 cn0 1cN0 1a00 1fA0 1cL0 1cN0 1nX0 1210 1nA0 1210 1qL0 WN0 1qL0 WN0 1qL0 11c0 1on0 11B0 1o00 11A0 1qo0 XA0 1qp0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0|25e4",
  	"Asia/Ho_Chi_Minh|LMT PLMT +07 +08 +09|-76.u -76.u -70 -80 -90|0123423232|-2yC76.u bK00 1h7b6.u 5lz0 18o0 3Oq0 k5b0 aW00 BAM0|90e5",
  	"Asia/Hong_Kong|LMT HKT HKST HKWT JST|-7A.G -80 -90 -8u -90|0123412121212121212121212121212121212121212121212121212121212121212121|-2CFH0 1taO0 Hc0 xUu 9tBu 11z0 1tDu Rc0 1wo0 11A0 1cM0 11A0 1o00 11A0 1o00 11A0 1o00 14o0 1o00 11A0 1nX0 U10 1tz0 U10 1wn0 Rd0 1wn0 U10 1tz0 U10 1tz0 U10 1tz0 U10 1wn0 Rd0 1wn0 Rd0 1wn0 U10 1tz0 U10 1tz0 17d0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 s10 1Vz0 1cN0 1cL0 1cN0 1cL0 6fd0 14n0|73e5",
  	"Asia/Hovd|LMT +06 +07 +08|-66.A -60 -70 -80|012323232323232323232323232323232323232323232323232|-2APG6.A 2Uko6.A cKn0 1db0 1dd0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1fB0 1cL0 1cN0 1cL0 1cN0 1cL0 6hD0 11z0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 kEp0 1cJ0 1cP0 1cJ0|81e3",
  	"Asia/Irkutsk|LMT IMT +07 +08 +09|-6V.5 -6V.5 -70 -80 -90|012343434343434343434343234343434343434343434343434343434343434343|-3D8SV.5 1Bxc0 pjXV.5 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|60e4",
  	"Europe/Istanbul|LMT IMT EET EEST +03 +04|-1T.Q -1U.U -20 -30 -30 -40|01232323232323232323232323232323232323232323232345423232323232323232323232323232323232323232323232323232323232323234|-3D8NT.Q 1ePXW.U dzzU.U 11b0 8tB0 1on0 1410 1db0 19B0 1in0 3Rd0 Un0 1oN0 11b0 zSN0 CL0 mp0 1Vz0 1gN0 8yn0 1yp0 ML0 1kp0 17b0 1ip0 17b0 1fB0 19X0 1ip0 19X0 1ip0 17b0 qdB0 38L0 1jd0 Tz0 l6O0 11A0 WN0 1qL0 TB0 1tX0 U10 1tz0 11B0 1in0 17d0 z90 cne0 pb0 2Cp0 1800 14o0 1dc0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1a00 1fA0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WO0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 Xc0 1qo0 WM0 1qM0 11A0 1o00 1200 1nA0 11A0 1tA0 U00 15w0|13e6",
  	"Asia/Jakarta|LMT BMT +0720 +0730 +09 +08 WIB|-77.c -77.c -7k -7u -90 -80 -70|012343536|-49jH7.c 2hiLL.c luM0 mPzO 8vWu 6kpu 4PXu xhcu|31e6",
  	"Asia/Jayapura|LMT +09 +0930 WIT|-9m.M -90 -9u -90|0123|-1uu9m.M sMMm.M L4nu|26e4",
  	"Asia/Jerusalem|LMT JMT IST IDT IDDT|-2k.S -2k.E -20 -30 -40|012323232323232432323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-3D8Ok.S 1wvA0.e SyOk.E MM0 iM0 4JA0 10o0 1pA0 10M0 1pA0 16o0 1jA0 16o0 1jA0 3LA0 Eo0 oo0 1co0 1dA0 16o0 10M0 1jc0 1tA0 14o0 1cM0 1a00 11A0 1Nc0 Ao0 1Nc0 Ao0 1Ko0 LA0 1o00 WM0 EQK0 Db0 1fB0 Rb0 bXB0 gM0 8Q00 IM0 1wo0 TX0 1HB0 IL0 1s10 10n0 1o10 WL0 1zd0 On0 1ld0 11z0 1o10 14n0 1o10 14n0 1nd0 12n0 1nd0 Xz0 1q10 12n0 1hB0 1dX0 1ep0 1aL0 1eN0 17X0 1nf0 11z0 1tB0 19W0 1e10 17b0 1ep0 1gL0 18N0 1fz0 1eN0 17b0 1gq0 1gn0 19d0 1dz0 1c10 17X0 1hB0 1gn0 19d0 1dz0 1c10 17X0 1kp0 1dz0 1c10 1aL0 1eN0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0|81e4",
  	"Asia/Kabul|LMT +04 +0430|-4A.M -40 -4u|012|-3eLEA.M 2dTcA.M|46e5",
  	"Asia/Kamchatka|LMT +11 +12 +13|-ay.A -b0 -c0 -d0|012323232323232323232321232323232323232323232323232323232323212|-1SLKy.A ivXy.A 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 2sp0 WM0|18e4",
  	"Asia/Karachi|LMT +0530 +0630 +05 PKT PKST|-4s.c -5u -6u -50 -50 -60|012134545454|-2xoss.c 1qOKW.c 7zX0 eup0 LqMu 1fy00 1cL0 dK10 11b0 1610 1jX0|24e6",
  	"Asia/Kathmandu|LMT +0530 +0545|-5F.g -5u -5J|012|-21JhF.g 2EGMb.g|12e5",
  	"Asia/Khandyga|LMT +08 +09 +10 +11|-92.d -80 -90 -a0 -b0|0123232323232323232323212323232323232323232323232343434343434343432|-21Q92.d pAp2.d 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 qK0 yN0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 17V0 7zD0|66e2",
  	"Asia/Krasnoyarsk|LMT +06 +07 +08|-6b.q -60 -70 -80|01232323232323232323232123232323232323232323232323232323232323232|-21Hib.q prAb.q 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|10e5",
  	"Asia/Kuala_Lumpur|LMT SMT +07 +0720 +0730 +09 +08|-6T.p -6T.p -70 -7k -7u -90 -80|01234546|-2M0ST.p aIM0 17anT.p l5XE 17bO 8Fyu 1so10|71e5",
  	"Asia/Macau|LMT CST +09 +10 CDT|-7y.a -80 -90 -a0 -90|012323214141414141414141414141414141414141414141414141414141414141414141|-2CFHy.a 1uqKy.a PX0 1kn0 15B0 11b0 4Qq0 1oM0 11c0 1ko0 1u00 11A0 1cM0 11c0 1o00 11A0 1o00 11A0 1oo0 1400 1o00 11A0 1o00 U00 1tA0 U00 1wo0 Rc0 1wru U10 1tz0 U10 1tz0 U10 1tz0 U10 1wn0 Rd0 1wn0 Rd0 1wn0 U10 1tz0 U10 1tz0 17d0 1cK0 1cO0 1cK0 1cO0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 s10 1Vz0 1cN0 1cL0 1cN0 1cL0 6fd0 14n0|57e4",
  	"Asia/Magadan|LMT +10 +11 +12|-a3.c -a0 -b0 -c0|012323232323232323232321232323232323232323232323232323232323232312|-1Pca3.c eUo3.c 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 3Cq0|95e3",
  	"Asia/Makassar|LMT MMT +08 +09 WITA|-7V.A -7V.A -80 -90 -80|01234|-21JjV.A vfc0 myLV.A 8ML0|15e5",
  	"Asia/Manila|LMT LMT PST PDT JST|fU -84 -80 -90 -90|01232423232|-54m84 2clc0 1vfc4 AL0 cK10 65X0 mXB0 vX0 VK10 1db0|24e6",
  	"Asia/Nicosia|LMT EET EEST|-2d.s -20 -30|01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-1Vc2d.s 2a3cd.s 1cL0 1qp0 Xz0 19B0 19X0 1fB0 1db0 1cp0 1cL0 1fB0 19X0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1fB0 1cL0 1cN0 1cL0 1cN0 1o30 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|32e4",
  	"Asia/Novokuznetsk|LMT +06 +07 +08|-5M.M -60 -70 -80|012323232323232323232321232323232323232323232323232323232323212|-1PctM.M eULM.M 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 2sp0 WM0|55e4",
  	"Asia/Novosibirsk|LMT +06 +07 +08|-5v.E -60 -70 -80|0123232323232323232323212323212121212121212121212121212121212121212|-21Qnv.E pAFv.E 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 ml0 Os0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 4eN0|15e5",
  	"Asia/Omsk|LMT +05 +06 +07|-4R.u -50 -60 -70|01232323232323232323232123232323232323232323232323232323232323232|-224sR.u pMLR.u 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|12e5",
  	"Asia/Oral|LMT +03 +05 +06 +04|-3p.o -30 -50 -60 -40|01232323232323232424242424242424242424242424242|-1Pc3p.o eUop.o 23CK0 3Db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 2pB0 1cM0 1fA0 1cM0 1cM0 IM0 1EM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0|27e4",
  	"Asia/Pontianak|LMT PMT +0730 +09 +08 WITA WIB|-7h.k -7h.k -7u -90 -80 -80 -70|012324256|-2ua7h.k XE00 munL.k 8Rau 6kpu 4PXu xhcu Wqnu|23e4",
  	"Asia/Pyongyang|LMT KST JST KST|-8n -8u -90 -90|012313|-2um8n 97XR 1lTzu 2Onc0 6BA0|29e5",
  	"Asia/Qostanay|LMT +04 +05 +06|-4e.s -40 -50 -60|012323232323232323232123232323232323232323232323|-1Pc4e.s eUoe.s 23CL0 3Db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0|",
  	"Asia/Qyzylorda|LMT +04 +05 +06|-4l.Q -40 -50 -60|01232323232323232323232323232323232323232323232|-1Pc4l.Q eUol.Q 23CL0 3Db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 3ao0 1EM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 zQl0|73e4",
  	"Asia/Rangoon|LMT RMT +0630 +09|-6o.L -6o.L -6u -90|01232|-3D8So.L 1BnA0 SmnS.L 7j9u|48e5",
  	"Asia/Sakhalin|LMT +09 +11 +12 +10|-9u.M -90 -b0 -c0 -a0|01232323232323232323232423232323232424242424242424242424242424242|-2AGVu.M 1BoMu.M 1qFa0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 2pB0 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 3rd0|58e4",
  	"Asia/Samarkand|LMT +04 +05 +06|-4r.R -40 -50 -60|01232323232323232323232|-1Pc4r.R eUor.R 23CL0 3Db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0|36e4",
  	"Asia/Seoul|LMT KST JST KST KDT KDT|-8r.Q -8u -90 -90 -a0 -9u|012343434343151515151515134343|-2um8r.Q 97XV.Q 1m1zu 6CM0 Fz0 1kN0 14n0 1kN0 14L0 1zd0 On0 69B0 2I0u OL0 1FB0 Rb0 1qN0 TX0 1tB0 TX0 1tB0 TX0 1tB0 TX0 2ap0 12FBu 11A0 1o00 11A0|23e6",
  	"Asia/Srednekolymsk|LMT +10 +11 +12|-ae.Q -a0 -b0 -c0|01232323232323232323232123232323232323232323232323232323232323232|-1Pcae.Q eUoe.Q 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|35e2",
  	"Asia/Taipei|LMT CST JST CDT|-86 -80 -90 -90|012131313131313131313131313131313131313131|-30bk6 1FDc6 joM0 1yo0 Tz0 1ip0 1jX0 1cN0 11b0 1oN0 11b0 1oN0 11b0 1oN0 11b0 10N0 1BX0 10p0 1pz0 10p0 1pz0 10p0 1db0 1dd0 1db0 1cN0 1db0 1cN0 1db0 1cN0 1db0 1BB0 ML0 1Bd0 ML0 uq10 1db0 1cN0 1db0 97B0 AL0|74e5",
  	"Asia/Tashkent|LMT +05 +06 +07|-4B.b -50 -60 -70|012323232323232323232321|-1Pc4B.b eUnB.b 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0|23e5",
  	"Asia/Tbilisi|LMT TBMT +03 +04 +05|-2X.b -2X.b -30 -40 -50|01234343434343434343434323232343434343434343434323|-3D8OX.b 1LUM0 1jUnX.b WCL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 1cK0 1cL0 1cN0 1cL0 1cN0 2pz0 1cL0 1fB0 3Nz0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 An0 Os0 WM0|11e5",
  	"Asia/Tehran|LMT TMT +0330 +0430 +04 +05|-3p.I -3p.I -3u -4u -40 -50|012345423232323232323232323232323232323232323232323232323232323232323232|-2btDp.I Llc0 1FHaT.I 1pc0 120u Rc0 XA0 Wou JX0 1dB0 1en0 pNB0 UL0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 64p0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0|14e6",
  	"Asia/Thimphu|LMT +0530 +06|-5W.A -5u -60|012|-Su5W.A 1BGMs.A|79e3",
  	"Asia/Tokyo|LMT JST JDT|-9i.X -90 -a0|0121212121|-3jE90 2qSo0 Rc0 1lc0 14o0 1zc0 Oo0 1zc0 Oo0|38e6",
  	"Asia/Tomsk|LMT +06 +07 +08|-5D.P -60 -70 -80|0123232323232323232323212323232323232323232323212121212121212121212|-21NhD.P pxzD.P 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 co0 1bB0 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 3Qp0|10e5",
  	"Asia/Ulaanbaatar|LMT +07 +08 +09|-77.w -70 -80 -90|012323232323232323232323232323232323232323232323232|-2APH7.w 2Uko7.w cKn0 1db0 1dd0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1fB0 1cL0 1cN0 1cL0 1cN0 1cL0 6hD0 11z0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 kEp0 1cJ0 1cP0 1cJ0|12e5",
  	"Asia/Ust-Nera|LMT +08 +09 +12 +11 +10|-9w.S -80 -90 -c0 -b0 -a0|012343434343434343434345434343434343434343434343434343434343434345|-21Q9w.S pApw.S 23CL0 1d90 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 17V0 7zD0|65e2",
  	"Asia/Vladivostok|LMT +09 +10 +11|-8L.v -90 -a0 -b0|01232323232323232323232123232323232323232323232323232323232323232|-1SJIL.v itXL.v 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|60e4",
  	"Asia/Yakutsk|LMT +08 +09 +10|-8C.W -80 -90 -a0|01232323232323232323232123232323232323232323232323232323232323232|-21Q8C.W pAoC.W 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|28e4",
  	"Asia/Yekaterinburg|LMT PMT +04 +05 +06|-42.x -3J.5 -40 -50 -60|012343434343434343434343234343434343434343434343434343434343434343|-2ag42.x 7mQh.s qBvJ.5 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|14e5",
  	"Asia/Yerevan|LMT +03 +04 +05|-2W -30 -40 -50|0123232323232323232323212121212323232323232323232323232323232|-1Pc2W 1jUnW WCL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 4RX0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|13e5",
  	"Atlantic/Azores|LMT HMT -02 -01 +00 WET|1G.E 1S.w 20 10 0 0|01232323232323232323232323232323232323232323234323432343234323232323232323232323232323232323232323232343434343434343434343434343434345434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343|-3tomh.k 18aoh.k aPX0 Sp0 LX0 1vc0 Tc0 1uM0 SM0 1vc0 Tc0 1vc0 SM0 1vc0 6600 1co0 3E00 17c0 1fA0 1a00 1io0 1a00 1io0 17c0 3I00 17c0 1cM0 1cM0 3Fc0 1cM0 1a00 1fA0 1io0 17c0 1cM0 1cM0 1a00 1fA0 1io0 1qM0 Dc0 1tA0 1cM0 1dc0 1400 gL0 IM0 s10 U00 dX0 Rc0 pd0 Rc0 gL0 Oo0 pd0 Rc0 gL0 Oo0 pd0 14o0 1cM0 1cP0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 qIl0 1cM0 1fA0 1cM0 1cM0 1cN0 1cL0 1cN0 1cM0 1cM0 1cM0 1cM0 1cN0 1cL0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cL0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|25e4",
  	"Atlantic/Bermuda|LMT BMT BST AST ADT|4j.i 4j.i 3j.i 40 30|0121213434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343|-3eLvE.G 16mo0 1bb0 1i10 11X0 ru30 thbE.G 1PX0 11B0 1tz0 Rd0 1zb0 Op0 1zb0 3I10 Lz0 1EN0 FX0 1HB0 FX0 1Kp0 Db0 1Kp0 Db0 1Kp0 FX0 93d0 11z0 GAp0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|65e3",
  	"Atlantic/Canary|LMT -01 WET WEST|11.A 10 0 -10|01232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-1UtaW.o XPAW.o 1lAK0 1a10 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|54e4",
  	"Atlantic/Cape_Verde|LMT -02 -01|1y.4 20 10|01212|-2ldW0 1eEo0 7zX0 1djf0|50e4",
  	"Atlantic/Faroe|LMT WET WEST|r.4 0 -10|01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2uSnw.U 2Wgow.U 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|49e3",
  	"Atlantic/Madeira|LMT FMT -01 +00 +01 WET WEST|17.A 17.A 10 0 -10 0 -10|01232323232323232323232323232323232323232323234323432343234323232323232323232323232323232323232323232565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565|-3tomQ.o 18anQ.o aPX0 Sp0 LX0 1vc0 Tc0 1uM0 SM0 1vc0 Tc0 1vc0 SM0 1vc0 6600 1co0 3E00 17c0 1fA0 1a00 1io0 1a00 1io0 17c0 3I00 17c0 1cM0 1cM0 3Fc0 1cM0 1a00 1fA0 1io0 17c0 1cM0 1cM0 1a00 1fA0 1io0 1qM0 Dc0 1tA0 1cM0 1dc0 1400 gL0 IM0 s10 U00 dX0 Rc0 pd0 Rc0 gL0 Oo0 pd0 Rc0 gL0 Oo0 pd0 14o0 1cM0 1cP0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 qIl0 1cM0 1fA0 1cM0 1cM0 1cN0 1cL0 1cN0 1cM0 1cM0 1cM0 1cM0 1cN0 1cL0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|27e4",
  	"Atlantic/South_Georgia|LMT -02|2q.8 20|01|-3eLxx.Q|30",
  	"Atlantic/Stanley|LMT SMT -04 -03 -02|3P.o 3P.o 40 30 20|0123232323232323434323232323232323232323232323232323232323232323232323|-3eLw8.A S200 12bA8.A 19X0 1fB0 19X0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 Cn0 1Cc10 WL0 1qL0 U10 1tz0 2mN0 WN0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1tz0 U10 1tz0 WN0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1tz0 WN0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qN0 U10 1wn0 Rd0 1wn0 U10 1tz0 U10 1tz0 U10 1tz0 U10 1tz0 U10 1wn0 U10 1tz0 U10 1tz0 U10|21e2",
  	"Australia/Sydney|LMT AEST AEDT|-a4.Q -a0 -b0|01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212|-32oW4.Q RlC4.Q xc0 10jc0 yM0 1cM0 1cM0 1fA0 1a00 17c00 LA0 1C00 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 14o0 1o00 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 U00 1qM0 WM0 1tA0 WM0 1tA0 U00 1tA0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 11A0 1o00 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00 WM0 1qM0 14o0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0|40e5",
  	"Australia/Adelaide|LMT ACST ACST ACDT|-9e.k -90 -9u -au|012323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323|-32oVe.k ak0e.k H1Bu xc0 10jc0 yM0 1cM0 1cM0 1fA0 1a00 17c00 LA0 1C00 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 U00 1qM0 WM0 1tA0 WM0 1tA0 U00 1tA0 U00 1tA0 Oo0 1zc0 WM0 1qM0 Rc0 1zc0 U00 1tA0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00 WM0 1qM0 14o0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0|11e5",
  	"Australia/Brisbane|LMT AEST AEDT|-ac.8 -a0 -b0|012121212121212121|-32Bmc.8 Ry2c.8 xc0 10jc0 yM0 1cM0 1cM0 1fA0 1a00 17c00 LA0 H1A0 Oo0 1zc0 Oo0 1zc0 Oo0|20e5",
  	"Australia/Broken_Hill|LMT AEST ACST ACST ACDT|-9p.M -a0 -90 -9u -au|0123434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434|-32oVp.M 3Lzp.M 6wp0 H1Bu xc0 10jc0 yM0 1cM0 1cM0 1fA0 1a00 17c00 LA0 1C00 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 14o0 1o00 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 U00 1qM0 WM0 1tA0 WM0 1tA0 U00 1tA0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00 WM0 1qM0 14o0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0|18e3",
  	"Australia/Hobart|LMT AEST AEDT|-9N.g -a0 -b0|01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212|-3109N.g Pk1N.g 1a00 1qM0 Oo0 1zc0 Oo0 TAo0 yM0 1cM0 1cM0 1fA0 1a00 VfA0 1cM0 1o00 Rc0 1wo0 Rc0 1wo0 U00 1wo0 LA0 1C00 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 11A0 1qM0 WM0 1qM0 Oo0 1zc0 Oo0 1zc0 Oo0 1wo0 WM0 1tA0 WM0 1tA0 U00 1tA0 U00 1tA0 11A0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 11A0 1o00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1cM0 1a00 1io0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0|21e4",
  	"Australia/Darwin|LMT ACST ACST ACDT|-8H.k -90 -9u -au|01232323232|-32oUH.k ajXH.k H1Bu xc0 10jc0 yM0 1cM0 1cM0 1fA0 1a00|12e4",
  	"Australia/Eucla|LMT +0845 +0945|-8z.s -8J -9J|01212121212121212121|-30nIz.s PkpO.s xc0 10jc0 yM0 1cM0 1cM0 1gSo0 Oo0 l5A0 Oo0 iJA0 G00 zU00 IM0 1qM0 11A0 1o00 11A0|368",
  	"Australia/Lord_Howe|LMT AEST +1030 +1130 +11|-aA.k -a0 -au -bu -b0|01232323232424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424|-32oWA.k 3tzAA.k 1zdu Rb0 1zd0 On0 1zd0 On0 1zd0 On0 1zd0 TXu 1qMu WLu 1tAu WLu 1tAu TXu 1tAu Onu 1zcu Onu 1zcu Onu 1zcu Rbu 1zcu Onu 1zcu Onu 1zcu 11zu 1o0u 11zu 1o0u 11zu 1o0u 11zu 1qMu WLu 11Au 1nXu 1qMu 11zu 1o0u 11zu 1o0u 11zu 1qMu WLu 1qMu 11zu 1o0u WLu 1qMu 14nu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1fzu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1fzu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1fzu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1fzu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1fzu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1fzu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1fzu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1fzu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1fzu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1fzu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1fzu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1fzu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1fzu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1fzu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1fzu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1fzu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu|347",
  	"Australia/Lindeman|LMT AEST AEDT|-9T.U -a0 -b0|0121212121212121212121|-32BlT.U Ry1T.U xc0 10jc0 yM0 1cM0 1cM0 1fA0 1a00 17c00 LA0 H1A0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0|10",
  	"Australia/Melbourne|LMT AEST AEDT|-9D.Q -a0 -b0|01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212|-32oVD.Q RlBD.Q xc0 10jc0 yM0 1cM0 1cM0 1fA0 1a00 17c00 LA0 1C00 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 U00 1qM0 WM0 1qM0 11A0 1tA0 U00 1tA0 U00 1tA0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 11A0 1o00 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00 WM0 1qM0 14o0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0|39e5",
  	"Australia/Perth|LMT AWST AWDT|-7H.o -80 -90|01212121212121212121|-30nHH.o PkpH.o xc0 10jc0 yM0 1cM0 1cM0 1gSo0 Oo0 l5A0 Oo0 iJA0 G00 zU00 IM0 1qM0 11A0 1o00 11A0|18e5",
  	"CET|CET CEST|-10 -20|01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2aFe0 11d0 1iO0 11A0 1o00 11A0 Qrc0 6i00 WM0 1fA0 1cM0 1cM0 1cM0 16M0 1gMM0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|",
  	"Pacific/Easter|LMT EMT -07 -06 -05|7h.s 7h.s 70 60 50|0123232323232323232323232323234343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434|-3eLsG.w 1HRc0 1s4IG.w WL0 1zd0 On0 1ip0 11z0 1o10 11z0 1qN0 WL0 1ld0 14n0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 WL0 1qN0 11z0 1o10 2pA0 11z0 1o10 11z0 1qN0 WL0 1qN0 WL0 1qN0 1cL0 1cN0 11z0 1o10 11z0 1qN0 WL0 1fB0 19X0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 17b0 1ip0 11z0 1ip0 1fz0 1fB0 11z0 1qN0 WL0 1qN0 WL0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 17b0 1ip0 11z0 1o10 19X0 1fB0 1nX0 G10 1EL0 Op0 1zb0 Rd0 1wn0 Rd0 46n0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1zb0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0|30e2",
  	"CST6CDT|CST CDT CWT CPT|60 50 50 50|010102301010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-261s0 1nX0 11B0 1nX0 SgN0 8x30 iw0 QwN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|",
  	"EET|EET EEST|-20 -30|010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|hDB0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|",
  	"Europe/Dublin|LMT DMT IST GMT BST IST|p.l p.l -y.D 0 -10 -10|012343434343435353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353|-3BHby.D 1ra20 Rc0 1fzy.D 14M0 1fc0 1g00 1co0 1dc0 1co0 1oo0 1400 1dc0 19A0 1io0 1io0 WM0 1o00 14o0 1o00 17c0 1io0 17c0 1fA0 1a00 1lc0 17c0 1io0 17c0 1fA0 1a00 1io0 17c0 1io0 17c0 1fA0 1cM0 1io0 17c0 1fA0 1a00 1io0 17c0 1io0 17c0 1fA0 1a00 1io0 1qM0 Dc0 g600 14o0 1wo0 17c0 1io0 11A0 1o00 17c0 1fA0 1a00 1fA0 1cM0 1fA0 1a00 17c0 1fA0 1a00 1io0 17c0 1lc0 17c0 1fA0 1a00 1io0 17c0 1io0 17c0 1fA0 1a00 1a00 1qM0 WM0 1qM0 11A0 1o00 WM0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1tA0 IM0 90o0 U00 1tA0 U00 1tA0 U00 1tA0 U00 1tA0 WM0 1qM0 WM0 1qM0 WM0 1tA0 U00 1tA0 U00 1tA0 11z0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 14o0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|12e5",
  	"EST|EST|50|0||",
  	"EST5EDT|EST EDT EWT EPT|50 40 40 40|010102301010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-261t0 1nX0 11B0 1nX0 SgN0 8x40 iv0 QwN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|",
  	"Etc/GMT-0|GMT|0|0||",
  	"Etc/GMT-1|+01|-10|0||",
  	"Etc/GMT-10|+10|-a0|0||",
  	"Etc/GMT-11|+11|-b0|0||",
  	"Etc/GMT-12|+12|-c0|0||",
  	"Etc/GMT-13|+13|-d0|0||",
  	"Etc/GMT-14|+14|-e0|0||",
  	"Etc/GMT-2|+02|-20|0||",
  	"Etc/GMT-3|+03|-30|0||",
  	"Etc/GMT-4|+04|-40|0||",
  	"Etc/GMT-5|+05|-50|0||",
  	"Etc/GMT-6|+06|-60|0||",
  	"Etc/GMT-7|+07|-70|0||",
  	"Etc/GMT-8|+08|-80|0||",
  	"Etc/GMT-9|+09|-90|0||",
  	"Etc/GMT+1|-01|10|0||",
  	"Etc/GMT+10|-10|a0|0||",
  	"Etc/GMT+11|-11|b0|0||",
  	"Etc/GMT+12|-12|c0|0||",
  	"Etc/GMT+2|-02|20|0||",
  	"Etc/GMT+3|-03|30|0||",
  	"Etc/GMT+4|-04|40|0||",
  	"Etc/GMT+5|-05|50|0||",
  	"Etc/GMT+6|-06|60|0||",
  	"Etc/GMT+7|-07|70|0||",
  	"Etc/GMT+8|-08|80|0||",
  	"Etc/GMT+9|-09|90|0||",
  	"Etc/UTC|UTC|0|0||",
  	"Europe/Brussels|LMT BMT WET CET CEST WEST|-h.u -h.u 0 -10 -20 -10|012343434325252525252525252525252525252525252525252525434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343|-3D8Mh.u u1Ah.u SO00 3zX0 11c0 1iO0 11A0 1o00 11A0 my0 Ic0 1qM0 Rc0 1EM0 UM0 1u00 10o0 1io0 1io0 17c0 1a00 1fA0 1cM0 1cM0 1io0 17c0 1fA0 1a00 1io0 1a30 1io0 17c0 1fA0 1a00 1io0 17c0 1cM0 1cM0 1a00 1io0 1cM0 1cM0 1a00 1fA0 1io0 17c0 1cM0 1cM0 1a00 1fA0 1io0 1qM0 Dc0 y00 5Wn0 WM0 1fA0 1cM0 16M0 1iM0 16M0 1C00 Uo0 1eeo0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|21e5",
  	"Europe/Andorra|LMT WET CET CEST|-6.4 0 -10 -20|0123232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-2M0M6.4 1Pnc6.4 1xIN0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|79e3",
  	"Europe/Astrakhan|LMT +03 +04 +05|-3c.c -30 -40 -50|012323232323232323212121212121212121212121212121212121212121212|-1Pcrc.c eUMc.c 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 2pB0 1cM0 1fA0 1cM0 3Co0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 3rd0|10e5",
  	"Europe/Athens|LMT AMT EET EEST CEST CET|-1y.Q -1y.Q -20 -30 -20 -10|0123234545232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-30SNy.Q OMM1 CNbx.Q mn0 kU10 9b0 3Es0 Xa0 1fb0 1dd0 k3X0 Nz0 SCp0 1vc0 SO0 1cM0 1a00 1ao0 1fc0 1a10 1fG0 1cg0 1dX0 1bX0 1cQ0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|35e5",
  	"Europe/London|LMT GMT BST BDST|1.f 0 -10 -20|01212121212121212121212121212121212121212121212121232323232321212321212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-4VgnW.J 2KHdW.J Rc0 1fA0 14M0 1fc0 1g00 1co0 1dc0 1co0 1oo0 1400 1dc0 19A0 1io0 1io0 WM0 1o00 14o0 1o00 17c0 1io0 17c0 1fA0 1a00 1lc0 17c0 1io0 17c0 1fA0 1a00 1io0 17c0 1io0 17c0 1fA0 1cM0 1io0 17c0 1fA0 1a00 1io0 17c0 1io0 17c0 1fA0 1a00 1io0 1qM0 Dc0 2Rz0 Dc0 1zc0 Oo0 1zc0 Rc0 1wo0 17c0 1iM0 FA0 xB0 1fA0 1a00 14o0 bb0 LA0 xB0 Rc0 1wo0 11A0 1o00 17c0 1fA0 1a00 1fA0 1cM0 1fA0 1a00 17c0 1fA0 1a00 1io0 17c0 1lc0 17c0 1fA0 1a00 1io0 17c0 1io0 17c0 1fA0 1a00 1a00 1qM0 WM0 1qM0 11A0 1o00 WM0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1tA0 IM0 90o0 U00 1tA0 U00 1tA0 U00 1tA0 U00 1tA0 WM0 1qM0 WM0 1qM0 WM0 1tA0 U00 1tA0 U00 1tA0 11z0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 14o0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|10e6",
  	"Europe/Belgrade|LMT CET CEST|-1m -10 -20|012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-3topm 2juLm 3IP0 WM0 1fA0 1cM0 1cM0 1rc0 Qo0 1vmo0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|12e5",
  	"Europe/Prague|LMT PMT CET CEST GMT|-V.I -V.I -10 -20 0|0123232323232323232423232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-4QbAV.I 1FDc0 XPaV.I 11d0 1iO0 11A0 1o00 11A0 Qrc0 6i00 WM0 1fA0 1cM0 1cM0 1cM0 1cM0 1qM0 11c0 mp0 xA0 mn0 17c0 1io0 17c0 1fc0 1ao0 1bNc0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|13e5",
  	"Europe/Bucharest|LMT BMT EET EEST|-1I.o -1I.o -20 -30|01232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-3awpI.o 1AU00 20LI.o RA0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1Axc0 On0 1fA0 1a10 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cK0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cL0 1cN0 1cL0 1fB0 1nX0 11E0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|19e5",
  	"Europe/Budapest|LMT CET CEST|-1g.k -10 -20|01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-3cK1g.k 124Lg.k 11d0 1iO0 11A0 1o00 11A0 1oo0 11c0 1lc0 17c0 O1V0 3Nf0 WM0 1fA0 1cM0 1cM0 1oJ0 1dd0 1020 1fX0 1cp0 1cM0 1cM0 1cM0 1fA0 1a00 bhy0 Rb0 1wr0 Rc0 1C00 LA0 1C00 LA0 SNW0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cO0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|17e5",
  	"Europe/Zurich|LMT BMT CET CEST|-y.8 -t.K -10 -20|0123232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-4HyMy.8 1Dw04.m 1SfAt.K 11A0 1o00 11A0 1xG10 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|38e4",
  	"Europe/Chisinau|LMT CMT BMT EET EEST CEST CET MSK MSD|-1T.k -1T -1I.o -20 -30 -20 -10 -30 -40|0123434343434343434345656578787878787878787878434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343|-3D8NT.k 1wNA0.k wGMa.A 20LI.o RA0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 27A0 2en0 39g0 WM0 1fA0 1cM0 V90 1t7z0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 gL0 WO0 1cM0 1cM0 1cK0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1fB0 1nX0 11D0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|67e4",
  	"Europe/Gibraltar|LMT GMT BST BDST CET CEST|l.o 0 -10 -20 -10 -20|0121212121212121212121212121212121212121212121212123232323232121232121212121212121212145454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454|-3BHbC.A 1ra1C.A Rc0 1fA0 14M0 1fc0 1g00 1co0 1dc0 1co0 1oo0 1400 1dc0 19A0 1io0 1io0 WM0 1o00 14o0 1o00 17c0 1io0 17c0 1fA0 1a00 1lc0 17c0 1io0 17c0 1fA0 1a00 1io0 17c0 1io0 17c0 1fA0 1cM0 1io0 17c0 1fA0 1a00 1io0 17c0 1io0 17c0 1fA0 1a00 1io0 1qM0 Dc0 2Rz0 Dc0 1zc0 Oo0 1zc0 Rc0 1wo0 17c0 1iM0 FA0 xB0 1fA0 1a00 14o0 bb0 LA0 xB0 Rc0 1wo0 11A0 1o00 17c0 1fA0 1a00 1fA0 1cM0 1fA0 1a00 17c0 1fA0 1a00 1io0 17c0 1lc0 17c0 1fA0 10Jz0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|30e3",
  	"Europe/Helsinki|LMT HMT EET EEST|-1D.N -1D.N -20 -30|01232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-3H0ND.N 1Iu00 OULD.N 1dA0 1xGq0 1cM0 1cM0 1cM0 1cN0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|12e5",
  	"Europe/Kaliningrad|LMT CET CEST EET EEST MSK MSD +03|-1m -10 -20 -20 -30 -30 -40 -30|012121212121212343565656565656565654343434343434343434343434343434343434343434373|-36Rdm UbXm 11d0 1iO0 11A0 1o00 11A0 Qrc0 6i00 WM0 1fA0 1cM0 1cM0 1cM0 390 7A0 1en0 12N0 1pbb0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cN0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|44e4",
  	"Europe/Kiev|LMT KMT EET MSK CEST CET MSD EEST|-22.4 -22.4 -20 -30 -20 -10 -40 -30|01234545363636363636363636367272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272|-3D8O2.4 1LUM0 eUo2.4 rnz0 2Hg0 WM0 1fA0 da0 1v4m0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 Db0 3220 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o10 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|34e5",
  	"Europe/Kirov|LMT +03 +04 +05|-3i.M -30 -40 -50|01232323232323232321212121212121212121212121212121212121212121|-22WM0 qH90 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 2pB0 1cM0 1fA0 1cM0 3Co0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|48e4",
  	"Europe/Lisbon|LMT WET WEST WEMT CET CEST|A.J 0 -10 -20 -10 -20|01212121212121212121212121212121212121212121232123212321232121212121212121212121212121212121212121214121212121212121212121212121212124545454212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2le00 aPX0 Sp0 LX0 1vc0 Tc0 1uM0 SM0 1vc0 Tc0 1vc0 SM0 1vc0 6600 1co0 3E00 17c0 1fA0 1a00 1io0 1a00 1io0 17c0 3I00 17c0 1cM0 1cM0 3Fc0 1cM0 1a00 1fA0 1io0 17c0 1cM0 1cM0 1a00 1fA0 1io0 1qM0 Dc0 1tA0 1cM0 1dc0 1400 gL0 IM0 s10 U00 dX0 Rc0 pd0 Rc0 gL0 Oo0 pd0 Rc0 gL0 Oo0 pd0 14o0 1cM0 1cP0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 pvy0 1cM0 1cM0 1fA0 1cM0 1cM0 1cN0 1cL0 1cN0 1cM0 1cM0 1cM0 1cM0 1cN0 1cL0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|27e5",
  	"Europe/Madrid|LMT WET WEST WEMT CET CEST|e.I 0 -10 -20 -10 -20|0121212121212121212321454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454|-2M0M0 G5z0 19B0 1cL0 1dd0 b1z0 18p0 3HX0 17d0 1fz0 1a10 1io0 1a00 1in0 17d0 iIn0 Hd0 1cL0 bb0 1200 2s20 14n0 5aL0 Mp0 1vz0 17d0 1in0 17d0 1in0 17d0 1in0 17d0 6hX0 11B0 XHX0 1a10 1fz0 1a10 19X0 1cN0 1fz0 1a10 1fC0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|62e5",
  	"Europe/Malta|LMT CET CEST|-W.4 -10 -20|01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-35rcW.4 SXzW.4 Lz0 1cN0 1db0 1410 1on0 Wp0 1qL0 17d0 1cL0 M3B0 5M20 WM0 1fA0 1co0 17c0 1iM0 16m0 1de0 1lc0 14m0 1lc0 WO0 1qM0 GTW0 On0 1C10 LA0 1C00 LA0 1EM0 LA0 1C00 LA0 1zc0 Oo0 1C00 Oo0 1co0 1cM0 1lA0 Xc0 1qq0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1iN0 19z0 1fB0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|42e4",
  	"Europe/Minsk|LMT MMT EET MSK CEST CET MSD EEST +03|-1O.g -1O -20 -30 -20 -10 -40 -30 -30|012345454363636363636363636372727272727272727272727272727272727272728|-3D8NO.g 1LUM0.g eUnO qNX0 3gQ0 WM0 1fA0 1cM0 Al0 1tsn0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 3Fc0 1cN0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0|19e5",
  	"Europe/Paris|LMT PMT WET WEST CEST CET WEMT|-9.l -9.l 0 -10 -20 -10 -20|01232323232323232323232323232323232323232323232323234545463654545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545|-3bQ09.l MDA0 cNb9.l HA0 19A0 1iM0 11c0 1oo0 Wo0 1rc0 QM0 1EM0 UM0 1u00 10o0 1io0 1wo0 Rc0 1a00 1fA0 1cM0 1cM0 1io0 17c0 1fA0 1a00 1io0 1a00 1io0 17c0 1fA0 1a00 1io0 17c0 1cM0 1cM0 1a00 1io0 1cM0 1cM0 1a00 1fA0 1io0 17c0 1cM0 1cM0 1a00 1fA0 1io0 1qM0 Df0 Ik0 5M30 WM0 1fA0 1cM0 Vx0 hB0 1aq0 16M0 1ekn0 1cL0 1fC0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|11e6",
  	"Europe/Moscow|LMT MMT MMT MST MDST MSD MSK +05 EET EEST MSK|-2u.h -2u.h -2v.j -3v.j -4v.j -40 -30 -50 -20 -30 -40|01232434565756865656565656565656565698656565656565656565656565656565656565656a6|-3D8Ou.h 1sQM0 2pyW.W 1bA0 11X0 GN0 1Hb0 c4v.j ik0 3DA0 dz0 15A0 c10 2q10 iM10 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cN0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|16e6",
  	"Europe/Riga|LMT RMT LST EET MSK CEST CET MSD EEST|-1A.y -1A.y -2A.y -20 -30 -20 -10 -40 -30|0121213456565647474747474747474838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383838383|-3D8NA.y 1xde0 11A0 1iM0 ko0 gWm0 yDXA.y 2bX0 3fE0 WM0 1fA0 1cM0 1cM0 4m0 1sLy0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cN0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cN0 1o00 11A0 1o00 11A0 1qM0 3oo0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|64e4",
  	"Europe/Rome|LMT RMT CET CEST|-N.U -N.U -10 -20|012323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-4aU0N.U 15snN.U T000 Lz0 1cN0 1db0 1410 1on0 Wp0 1qL0 17d0 1cL0 M3B0 5M20 WM0 1fA0 1cM0 16M0 1iM0 16m0 1de0 1lc0 14m0 1lc0 WO0 1qM0 GTW0 On0 1C10 LA0 1C00 LA0 1EM0 LA0 1C00 LA0 1zc0 Oo0 1C00 Oo0 1C00 LA0 1zc0 Oo0 1C00 LA0 1C00 LA0 1zc0 Oo0 1C00 Oo0 1zc0 Oo0 1fC0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|39e5",
  	"Europe/Samara|LMT +03 +04 +05|-3k.k -30 -40 -50|0123232323232323232121232323232323232323232323232323232323212|-22WM0 qH90 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 2pB0 1cM0 1fA0 2y10 14m0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 2sp0 WM0|12e5",
  	"Europe/Saratov|LMT +03 +04 +05|-34.i -30 -40 -50|012323232323232321212121212121212121212121212121212121212121212|-22WM0 qH90 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 2pB0 1cM0 1cM0 1cM0 1fA0 1cM0 3Co0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 5810|",
  	"Europe/Simferopol|LMT SMT EET MSK CEST CET MSD EEST MSK|-2g.o -2g -20 -30 -20 -10 -40 -30 -40|0123454543636363636363636363272727636363727272727272727272727272727272727283|-3D8Og.o 1LUM0.o eUog rEn0 2qs0 WM0 1fA0 1cM0 3V0 1u0L0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1Q00 4eN0 1cM0 1cM0 1cM0 1cM0 dV0 WO0 1cM0 1cM0 1fy0 1o30 11B0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11z0 1nW0|33e4",
  	"Europe/Sofia|LMT IMT EET CET CEST EEST|-1x.g -1U.U -20 -10 -20 -30|0123434325252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252|-3D8Nx.g AiLA.k 1UFeU.U WM0 1fA0 1cM0 1cM0 1cN0 1mKH0 1dd0 1fb0 1ap0 1fb0 1a20 1fy0 1a30 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cK0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1fB0 1nX0 11E0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|12e5",
  	"Europe/Tallinn|LMT TMT CET CEST EET MSK MSD EEST|-1D -1D -10 -20 -20 -30 -40 -30|0123214532323565656565656565657474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474747474|-3D8ND 1wI00 teD 11A0 1Ta0 4rXl KSLD 2FX0 2Jg0 WM0 1fA0 1cM0 18J0 1sTX0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cN0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o10 11A0 1qM0 5QM0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|41e4",
  	"Europe/Tirane|LMT CET CEST|-1j.k -10 -20|01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2glBj.k 14pcj.k 5LC0 WM0 4M0 1fCK0 10n0 1op0 11z0 1pd0 11z0 1qN0 WL0 1qp0 Xb0 1qp0 Xb0 1qp0 11z0 1lB0 11z0 1qN0 11z0 1iN0 16n0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|42e4",
  	"Europe/Ulyanovsk|LMT +03 +04 +05 +02|-3d.A -30 -40 -50 -20|01232323232323232321214121212121212121212121212121212121212121212|-22WM0 qH90 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 2pB0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 3rd0|13e5",
  	"Europe/Vienna|LMT CET CEST|-15.l -10 -20|01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-36Rd5.l UbX5.l 11d0 1iO0 11A0 1o00 11A0 3KM0 14o0 LA00 6i00 WM0 1fA0 1cM0 1cM0 1cM0 400 2qM0 1ao0 1co0 1cM0 1io0 17c0 1gHa0 19X0 1cP0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|18e5",
  	"Europe/Vilnius|LMT WMT KMT CET EET MSK CEST MSD EEST|-1F.g -1o -1z.A -10 -20 -30 -20 -40 -30|0123435636365757575757575757584848484848484848463648484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484848484|-3D8NF.g 1u5Ah.g 6ILM.o 1Ooz.A zz0 Mfd0 29W0 3is0 WM0 1fA0 1cM0 LV0 1tgL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cN0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11B0 1o00 11A0 1qM0 8io0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|54e4",
  	"Europe/Volgograd|LMT +03 +04 +05|-2V.E -30 -40 -50|0123232323232323212121212121212121212121212121212121212121212121|-21IqV.E psLV.E 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 2pB0 1cM0 1cM0 1cM0 1fA0 1cM0 3Co0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 9Jd0 5gn0|10e5",
  	"Europe/Warsaw|LMT WMT CET CEST EET EEST|-1o -1o -10 -20 -20 -30|0123232345423232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-3D8No 1qDA0 1LXo 11d0 1iO0 11A0 1o00 11A0 1on0 11A0 6zy0 HWP0 5IM0 WM0 1fA0 1cM0 1dz0 1mL0 1en0 15B0 1aq0 1nA0 11A0 1io0 17c0 1fA0 1a00 iDX0 LA0 1cM0 1cM0 1C00 Oo0 1cM0 1cM0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1C00 LA0 uso0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cN0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|17e5",
  	"HST|HST|a0|0||",
  	"Indian/Chagos|LMT +05 +06|-4N.E -50 -60|012|-2xosN.E 3AGLN.E|30e2",
  	"Indian/Maldives|LMT MMT +05|-4S -4S -50|012|-3D8QS 3eLA0|35e4",
  	"Indian/Mauritius|LMT +04 +05|-3O -40 -50|012121|-2xorO 34unO 14L0 12kr0 11z0|15e4",
  	"Pacific/Kwajalein|LMT +11 +10 +09 -12 +12|-b9.k -b0 -a0 -90 c0 -c0|0123145|-2M0X9.k 1rDA9.k akp0 6Up0 12ry0 Wan0|14e3",
  	"MET|MET MEST|-10 -20|01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2aFe0 11d0 1iO0 11A0 1o00 11A0 Qrc0 6i00 WM0 1fA0 1cM0 1cM0 1cM0 16M0 1gMM0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|",
  	"MST|MST|70|0||",
  	"MST7MDT|MST MDT MWT MPT|70 60 60 60|010102301010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-261r0 1nX0 11B0 1nX0 SgN0 8x20 ix0 QwN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|",
  	"Pacific/Chatham|LMT +1215 +1245 +1345|-cd.M -cf -cJ -dJ|0123232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323|-46jMd.M 37RbW.M 1adef IM0 1C00 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1qM0 14o0 1lc0 14o0 1lc0 14o0 1lc0 17c0 1io0 17c0 1io0 17c0 1io0 17c0 1lc0 14o0 1lc0 14o0 1lc0 17c0 1io0 17c0 1io0 17c0 1lc0 14o0 1lc0 14o0 1lc0 17c0 1io0 17c0 1io0 17c0 1io0 17c0 1io0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00|600",
  	"Pacific/Apia|LMT LMT -1130 -11 -10 +14 +13|-cx.4 bq.U bu b0 a0 -e0 -d0|012343456565656565656565656|-38Fox.4 J1A0 1yW03.4 2rRbu 1ff0 1a00 CI0 AQ0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0|37e3",
  	"Pacific/Bougainville|LMT PMMT +10 +09 +11|-am.g -9M.w -a0 -90 -b0|012324|-3D8Wm.g AvAx.I 1TCLM.w 7CN0 2MQp0|18e4",
  	"Pacific/Efate|LMT +11 +12|-bd.g -b0 -c0|012121212121212121212121|-2l9nd.g 2uNXd.g Dc0 n610 1cL0 1cN0 1cL0 1fB0 19X0 1fB0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1fB0 Lz0 1Nd0 An0|66e3",
  	"Pacific/Enderbury|-00 -12 -11 +13|0 c0 b0 -d0|0123|-1iIo0 1GsA0 B7X0|1",
  	"Pacific/Fakaofo|LMT -11 +13|bo.U b0 -d0|012|-2M0Az.4 4ufXz.4|483",
  	"Pacific/Fiji|LMT +12 +13|-bT.I -c0 -d0|012121212121212121212121212121|-2bUzT.I 3m8NT.I LA0 1EM0 IM0 nJc0 LA0 1o00 Rc0 1wo0 Ao0 1Nc0 Ao0 1Q00 xz0 1SN0 uM0 1SM0 uM0 1VA0 s00 1VA0 s00 1VA0 s00 20o0 pc0 2hc0 bc0|88e4",
  	"Pacific/Tarawa|LMT +12|-bw.4 -c0|01|-2M0Xw.4|29e3",
  	"Pacific/Galapagos|LMT -05 -06|5W.o 50 60|01212|-1yVS1.A 2dTz1.A gNd0 rz0|25e3",
  	"Pacific/Gambier|LMT -09|8X.M 90|01|-2jof0.c|125",
  	"Pacific/Guadalcanal|LMT +11|-aD.M -b0|01|-2joyD.M|11e4",
  	"Pacific/Guam|LMT LMT GST +09 GDT ChST|el -9D -a0 -90 -b0 -a0|0123242424242424242425|-54m9D 2glc0 1DFbD 6pB0 AhB0 3QL0 g2p0 3p91 WOX rX0 1zd0 Rb0 1wp0 Rb0 5xd0 rX0 5sN0 zb1 1C0X On0 ULb0|17e4",
  	"Pacific/Honolulu|LMT HST HDT HWT HPT HST|av.q au 9u 9u 9u a0|01213415|-3061s.y 1uMdW.y 8x0 lef0 8wWu iAu 46p0|37e4",
  	"Pacific/Kiritimati|LMT -1040 -10 +14|at.k aE a0 -e0|0123|-2M0Bu.E 3bIMa.E B7Xk|51e2",
  	"Pacific/Kosrae|LMT LMT +11 +09 +10 +12|d8.4 -aP.U -b0 -90 -a0 -c0|0123243252|-54maP.U 2glc0 xsnP.U axC0 HBy0 akp0 axd0 WOK0 1bdz0|66e2",
  	"Pacific/Marquesas|LMT -0930|9i 9u|01|-2joeG|86e2",
  	"Pacific/Pago_Pago|LMT LMT SST|-cB.c bm.M b0|012|-38FoB.c J1A0|37e2",
  	"Pacific/Nauru|LMT +1130 +09 +12|-b7.E -bu -90 -c0|01213|-1Xdn7.E QCnB.E 7mqu 1lnbu|10e3",
  	"Pacific/Niue|LMT -1120 -11|bj.E bk b0|012|-FScE.k suo0.k|12e2",
  	"Pacific/Norfolk|LMT +1112 +1130 +1230 +11 +12|-bb.Q -bc -bu -cu -b0 -c0|0123245454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545|-2M0Xb.Q 21ILX.Q W01G Oo0 1COo0 9Jcu 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0|25e4",
  	"Pacific/Noumea|LMT +11 +12|-b5.M -b0 -c0|01212121|-2l9n5.M 2EqM5.M xX0 1PB0 yn0 HeP0 Ao0|98e3",
  	"Pacific/Palau|LMT LMT +09|f2.4 -8V.U -90|012|-54m8V.U 2glc0|21e3",
  	"Pacific/Pitcairn|LMT -0830 -08|8E.k 8u 80|012|-2M0Dj.E 3UVXN.E|56",
  	"Pacific/Rarotonga|LMT LMT -1030 -0930 -10|-dk.U aD.4 au 9u a0|01234343434343434343434343434|-2Otpk.U 28zc0 13tbO.U IL0 1zcu Onu 1zcu Onu 1zcu Rbu 1zcu Onu 1zcu Onu 1zcu Onu 1zcu Onu 1zcu Onu 1zcu Rbu 1zcu Onu 1zcu Onu 1zcu Onu|13e3",
  	"Pacific/Tahiti|LMT -10|9W.g a0|01|-2joe1.I|18e4",
  	"Pacific/Tongatapu|LMT +1220 +13 +14|-cj.c -ck -d0 -e0|01232323232|-XbMj.c BgLX.c 1yndk 15A0 1wo0 xz0 1Q10 xz0 zWN0 s00|75e3",
  	"PST8PDT|PST PDT PWT PPT|80 70 70 70|010102301010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-261q0 1nX0 11B0 1nX0 SgN0 8x10 iy0 QwN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|",
  	"WET|WET WEST|0 -10|010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|hDB0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|"
  ];
  var links = [
  	"Africa/Abidjan|Africa/Accra",
  	"Africa/Abidjan|Africa/Bamako",
  	"Africa/Abidjan|Africa/Banjul",
  	"Africa/Abidjan|Africa/Conakry",
  	"Africa/Abidjan|Africa/Dakar",
  	"Africa/Abidjan|Africa/Freetown",
  	"Africa/Abidjan|Africa/Lome",
  	"Africa/Abidjan|Africa/Nouakchott",
  	"Africa/Abidjan|Africa/Ouagadougou",
  	"Africa/Abidjan|Africa/Timbuktu",
  	"Africa/Abidjan|Atlantic/Reykjavik",
  	"Africa/Abidjan|Atlantic/St_Helena",
  	"Africa/Abidjan|Iceland",
  	"Africa/Cairo|Egypt",
  	"Africa/Johannesburg|Africa/Maseru",
  	"Africa/Johannesburg|Africa/Mbabane",
  	"Africa/Lagos|Africa/Bangui",
  	"Africa/Lagos|Africa/Brazzaville",
  	"Africa/Lagos|Africa/Douala",
  	"Africa/Lagos|Africa/Kinshasa",
  	"Africa/Lagos|Africa/Libreville",
  	"Africa/Lagos|Africa/Luanda",
  	"Africa/Lagos|Africa/Malabo",
  	"Africa/Lagos|Africa/Niamey",
  	"Africa/Lagos|Africa/Porto-Novo",
  	"Africa/Maputo|Africa/Blantyre",
  	"Africa/Maputo|Africa/Bujumbura",
  	"Africa/Maputo|Africa/Gaborone",
  	"Africa/Maputo|Africa/Harare",
  	"Africa/Maputo|Africa/Kigali",
  	"Africa/Maputo|Africa/Lubumbashi",
  	"Africa/Maputo|Africa/Lusaka",
  	"Africa/Nairobi|Africa/Addis_Ababa",
  	"Africa/Nairobi|Africa/Asmara",
  	"Africa/Nairobi|Africa/Asmera",
  	"Africa/Nairobi|Africa/Dar_es_Salaam",
  	"Africa/Nairobi|Africa/Djibouti",
  	"Africa/Nairobi|Africa/Kampala",
  	"Africa/Nairobi|Africa/Mogadishu",
  	"Africa/Nairobi|Indian/Antananarivo",
  	"Africa/Nairobi|Indian/Comoro",
  	"Africa/Nairobi|Indian/Mayotte",
  	"Africa/Tripoli|Libya",
  	"America/Adak|America/Atka",
  	"America/Adak|US/Aleutian",
  	"America/Anchorage|US/Alaska",
  	"America/Argentina/Buenos_Aires|America/Buenos_Aires",
  	"America/Argentina/Catamarca|America/Argentina/ComodRivadavia",
  	"America/Argentina/Catamarca|America/Catamarca",
  	"America/Argentina/Cordoba|America/Cordoba",
  	"America/Argentina/Cordoba|America/Rosario",
  	"America/Argentina/Jujuy|America/Jujuy",
  	"America/Argentina/Mendoza|America/Mendoza",
  	"America/Chicago|US/Central",
  	"America/Denver|America/Shiprock",
  	"America/Denver|Navajo",
  	"America/Denver|US/Mountain",
  	"America/Detroit|US/Michigan",
  	"America/Edmonton|Canada/Mountain",
  	"America/Fort_Wayne|America/Indiana/Indianapolis",
  	"America/Fort_Wayne|America/Indianapolis",
  	"America/Fort_Wayne|US/East-Indiana",
  	"America/Godthab|America/Nuuk",
  	"America/Halifax|Canada/Atlantic",
  	"America/Havana|Cuba",
  	"America/Indiana/Knox|America/Knox_IN",
  	"America/Indiana/Knox|US/Indiana-Starke",
  	"America/Iqaluit|America/Pangnirtung",
  	"America/Jamaica|Jamaica",
  	"America/Kentucky/Louisville|America/Louisville",
  	"America/Los_Angeles|US/Pacific",
  	"America/Manaus|Brazil/West",
  	"America/Mazatlan|Mexico/BajaSur",
  	"America/Mexico_City|Mexico/General",
  	"America/New_York|US/Eastern",
  	"America/Noronha|Brazil/DeNoronha",
  	"America/Panama|America/Atikokan",
  	"America/Panama|America/Cayman",
  	"America/Panama|America/Coral_Harbour",
  	"America/Phoenix|America/Creston",
  	"America/Phoenix|US/Arizona",
  	"America/Puerto_Rico|America/Anguilla",
  	"America/Puerto_Rico|America/Antigua",
  	"America/Puerto_Rico|America/Aruba",
  	"America/Puerto_Rico|America/Blanc-Sablon",
  	"America/Puerto_Rico|America/Curacao",
  	"America/Puerto_Rico|America/Dominica",
  	"America/Puerto_Rico|America/Grenada",
  	"America/Puerto_Rico|America/Guadeloupe",
  	"America/Puerto_Rico|America/Kralendijk",
  	"America/Puerto_Rico|America/Lower_Princes",
  	"America/Puerto_Rico|America/Marigot",
  	"America/Puerto_Rico|America/Montserrat",
  	"America/Puerto_Rico|America/Port_of_Spain",
  	"America/Puerto_Rico|America/St_Barthelemy",
  	"America/Puerto_Rico|America/St_Kitts",
  	"America/Puerto_Rico|America/St_Lucia",
  	"America/Puerto_Rico|America/St_Thomas",
  	"America/Puerto_Rico|America/St_Vincent",
  	"America/Puerto_Rico|America/Tortola",
  	"America/Puerto_Rico|America/Virgin",
  	"America/Regina|Canada/Saskatchewan",
  	"America/Rio_Branco|America/Porto_Acre",
  	"America/Rio_Branco|Brazil/Acre",
  	"America/Santiago|Chile/Continental",
  	"America/Sao_Paulo|Brazil/East",
  	"America/St_Johns|Canada/Newfoundland",
  	"America/Tijuana|America/Ensenada",
  	"America/Tijuana|America/Santa_Isabel",
  	"America/Tijuana|Mexico/BajaNorte",
  	"America/Toronto|America/Montreal",
  	"America/Toronto|America/Nassau",
  	"America/Toronto|America/Nipigon",
  	"America/Toronto|America/Thunder_Bay",
  	"America/Toronto|Canada/Eastern",
  	"America/Vancouver|Canada/Pacific",
  	"America/Whitehorse|Canada/Yukon",
  	"America/Winnipeg|America/Rainy_River",
  	"America/Winnipeg|Canada/Central",
  	"Asia/Ashgabat|Asia/Ashkhabad",
  	"Asia/Bangkok|Asia/Phnom_Penh",
  	"Asia/Bangkok|Asia/Vientiane",
  	"Asia/Bangkok|Indian/Christmas",
  	"Asia/Brunei|Asia/Kuching",
  	"Asia/Dhaka|Asia/Dacca",
  	"Asia/Dubai|Asia/Muscat",
  	"Asia/Dubai|Indian/Mahe",
  	"Asia/Dubai|Indian/Reunion",
  	"Asia/Ho_Chi_Minh|Asia/Saigon",
  	"Asia/Hong_Kong|Hongkong",
  	"Asia/Jerusalem|Asia/Tel_Aviv",
  	"Asia/Jerusalem|Israel",
  	"Asia/Kathmandu|Asia/Katmandu",
  	"Asia/Kolkata|Asia/Calcutta",
  	"Asia/Kuala_Lumpur|Asia/Singapore",
  	"Asia/Kuala_Lumpur|Singapore",
  	"Asia/Macau|Asia/Macao",
  	"Asia/Makassar|Asia/Ujung_Pandang",
  	"Asia/Nicosia|Europe/Nicosia",
  	"Asia/Qatar|Asia/Bahrain",
  	"Asia/Rangoon|Asia/Yangon",
  	"Asia/Rangoon|Indian/Cocos",
  	"Asia/Riyadh|Antarctica/Syowa",
  	"Asia/Riyadh|Asia/Aden",
  	"Asia/Riyadh|Asia/Kuwait",
  	"Asia/Seoul|ROK",
  	"Asia/Shanghai|Asia/Chongqing",
  	"Asia/Shanghai|Asia/Chungking",
  	"Asia/Shanghai|Asia/Harbin",
  	"Asia/Shanghai|PRC",
  	"Asia/Taipei|ROC",
  	"Asia/Tehran|Iran",
  	"Asia/Thimphu|Asia/Thimbu",
  	"Asia/Tokyo|Japan",
  	"Asia/Ulaanbaatar|Asia/Ulan_Bator",
  	"Asia/Urumqi|Antarctica/Vostok",
  	"Asia/Urumqi|Asia/Kashgar",
  	"Atlantic/Faroe|Atlantic/Faeroe",
  	"Australia/Adelaide|Australia/South",
  	"Australia/Brisbane|Australia/Queensland",
  	"Australia/Broken_Hill|Australia/Yancowinna",
  	"Australia/Darwin|Australia/North",
  	"Australia/Hobart|Australia/Currie",
  	"Australia/Hobart|Australia/Tasmania",
  	"Australia/Lord_Howe|Australia/LHI",
  	"Australia/Melbourne|Australia/Victoria",
  	"Australia/Perth|Australia/West",
  	"Australia/Sydney|Australia/ACT",
  	"Australia/Sydney|Australia/Canberra",
  	"Australia/Sydney|Australia/NSW",
  	"Etc/GMT-0|Etc/GMT",
  	"Etc/GMT-0|Etc/GMT+0",
  	"Etc/GMT-0|Etc/GMT0",
  	"Etc/GMT-0|Etc/Greenwich",
  	"Etc/GMT-0|GMT",
  	"Etc/GMT-0|GMT+0",
  	"Etc/GMT-0|GMT-0",
  	"Etc/GMT-0|GMT0",
  	"Etc/GMT-0|Greenwich",
  	"Etc/UTC|Etc/UCT",
  	"Etc/UTC|Etc/Universal",
  	"Etc/UTC|Etc/Zulu",
  	"Etc/UTC|UCT",
  	"Etc/UTC|UTC",
  	"Etc/UTC|Universal",
  	"Etc/UTC|Zulu",
  	"Europe/Belgrade|Europe/Ljubljana",
  	"Europe/Belgrade|Europe/Podgorica",
  	"Europe/Belgrade|Europe/Sarajevo",
  	"Europe/Belgrade|Europe/Skopje",
  	"Europe/Belgrade|Europe/Zagreb",
  	"Europe/Berlin|Arctic/Longyearbyen",
  	"Europe/Berlin|Atlantic/Jan_Mayen",
  	"Europe/Berlin|Europe/Copenhagen",
  	"Europe/Berlin|Europe/Oslo",
  	"Europe/Berlin|Europe/Stockholm",
  	"Europe/Brussels|Europe/Amsterdam",
  	"Europe/Brussels|Europe/Luxembourg",
  	"Europe/Chisinau|Europe/Tiraspol",
  	"Europe/Dublin|Eire",
  	"Europe/Helsinki|Europe/Mariehamn",
  	"Europe/Istanbul|Asia/Istanbul",
  	"Europe/Istanbul|Turkey",
  	"Europe/Kiev|Europe/Kyiv",
  	"Europe/Kiev|Europe/Uzhgorod",
  	"Europe/Kiev|Europe/Zaporozhye",
  	"Europe/Lisbon|Portugal",
  	"Europe/London|Europe/Belfast",
  	"Europe/London|Europe/Guernsey",
  	"Europe/London|Europe/Isle_of_Man",
  	"Europe/London|Europe/Jersey",
  	"Europe/London|GB",
  	"Europe/London|GB-Eire",
  	"Europe/Moscow|W-SU",
  	"Europe/Paris|Europe/Monaco",
  	"Europe/Prague|Europe/Bratislava",
  	"Europe/Rome|Europe/San_Marino",
  	"Europe/Rome|Europe/Vatican",
  	"Europe/Warsaw|Poland",
  	"Europe/Zurich|Europe/Busingen",
  	"Europe/Zurich|Europe/Vaduz",
  	"Indian/Maldives|Indian/Kerguelen",
  	"Pacific/Auckland|Antarctica/McMurdo",
  	"Pacific/Auckland|Antarctica/South_Pole",
  	"Pacific/Auckland|NZ",
  	"Pacific/Chatham|NZ-CHAT",
  	"Pacific/Easter|Chile/EasterIsland",
  	"Pacific/Enderbury|Pacific/Kanton",
  	"Pacific/Guadalcanal|Pacific/Pohnpei",
  	"Pacific/Guadalcanal|Pacific/Ponape",
  	"Pacific/Guam|Pacific/Saipan",
  	"Pacific/Honolulu|Pacific/Johnston",
  	"Pacific/Honolulu|US/Hawaii",
  	"Pacific/Kwajalein|Kwajalein",
  	"Pacific/Pago_Pago|Pacific/Midway",
  	"Pacific/Pago_Pago|Pacific/Samoa",
  	"Pacific/Pago_Pago|US/Samoa",
  	"Pacific/Port_Moresby|Antarctica/DumontDUrville",
  	"Pacific/Port_Moresby|Pacific/Chuuk",
  	"Pacific/Port_Moresby|Pacific/Truk",
  	"Pacific/Port_Moresby|Pacific/Yap",
  	"Pacific/Tarawa|Pacific/Funafuti",
  	"Pacific/Tarawa|Pacific/Majuro",
  	"Pacific/Tarawa|Pacific/Wake",
  	"Pacific/Tarawa|Pacific/Wallis"
  ];
  var countries = [
  	"AD|Europe/Andorra",
  	"AE|Asia/Dubai",
  	"AF|Asia/Kabul",
  	"AG|America/Puerto_Rico America/Antigua",
  	"AI|America/Puerto_Rico America/Anguilla",
  	"AL|Europe/Tirane",
  	"AM|Asia/Yerevan",
  	"AO|Africa/Lagos Africa/Luanda",
  	"AQ|Antarctica/Casey Antarctica/Davis Antarctica/Mawson Antarctica/Palmer Antarctica/Rothera Antarctica/Troll Asia/Urumqi Pacific/Auckland Pacific/Port_Moresby Asia/Riyadh Antarctica/McMurdo Antarctica/DumontDUrville Antarctica/Syowa Antarctica/Vostok",
  	"AR|America/Argentina/Buenos_Aires America/Argentina/Cordoba America/Argentina/Salta America/Argentina/Jujuy America/Argentina/Tucuman America/Argentina/Catamarca America/Argentina/La_Rioja America/Argentina/San_Juan America/Argentina/Mendoza America/Argentina/San_Luis America/Argentina/Rio_Gallegos America/Argentina/Ushuaia",
  	"AS|Pacific/Pago_Pago",
  	"AT|Europe/Vienna",
  	"AU|Australia/Lord_Howe Antarctica/Macquarie Australia/Hobart Australia/Melbourne Australia/Sydney Australia/Broken_Hill Australia/Brisbane Australia/Lindeman Australia/Adelaide Australia/Darwin Australia/Perth Australia/Eucla",
  	"AW|America/Puerto_Rico America/Aruba",
  	"AX|Europe/Helsinki Europe/Mariehamn",
  	"AZ|Asia/Baku",
  	"BA|Europe/Belgrade Europe/Sarajevo",
  	"BB|America/Barbados",
  	"BD|Asia/Dhaka",
  	"BE|Europe/Brussels",
  	"BF|Africa/Abidjan Africa/Ouagadougou",
  	"BG|Europe/Sofia",
  	"BH|Asia/Qatar Asia/Bahrain",
  	"BI|Africa/Maputo Africa/Bujumbura",
  	"BJ|Africa/Lagos Africa/Porto-Novo",
  	"BL|America/Puerto_Rico America/St_Barthelemy",
  	"BM|Atlantic/Bermuda",
  	"BN|Asia/Kuching Asia/Brunei",
  	"BO|America/La_Paz",
  	"BQ|America/Puerto_Rico America/Kralendijk",
  	"BR|America/Noronha America/Belem America/Fortaleza America/Recife America/Araguaina America/Maceio America/Bahia America/Sao_Paulo America/Campo_Grande America/Cuiaba America/Santarem America/Porto_Velho America/Boa_Vista America/Manaus America/Eirunepe America/Rio_Branco",
  	"BS|America/Toronto America/Nassau",
  	"BT|Asia/Thimphu",
  	"BW|Africa/Maputo Africa/Gaborone",
  	"BY|Europe/Minsk",
  	"BZ|America/Belize",
  	"CA|America/St_Johns America/Halifax America/Glace_Bay America/Moncton America/Goose_Bay America/Toronto America/Iqaluit America/Winnipeg America/Resolute America/Rankin_Inlet America/Regina America/Swift_Current America/Edmonton America/Cambridge_Bay America/Yellowknife America/Inuvik America/Dawson_Creek America/Fort_Nelson America/Whitehorse America/Dawson America/Vancouver America/Panama America/Puerto_Rico America/Phoenix America/Blanc-Sablon America/Atikokan America/Creston",
  	"CC|Asia/Yangon Indian/Cocos",
  	"CD|Africa/Maputo Africa/Lagos Africa/Kinshasa Africa/Lubumbashi",
  	"CF|Africa/Lagos Africa/Bangui",
  	"CG|Africa/Lagos Africa/Brazzaville",
  	"CH|Europe/Zurich",
  	"CI|Africa/Abidjan",
  	"CK|Pacific/Rarotonga",
  	"CL|America/Santiago America/Punta_Arenas Pacific/Easter",
  	"CM|Africa/Lagos Africa/Douala",
  	"CN|Asia/Shanghai Asia/Urumqi",
  	"CO|America/Bogota",
  	"CR|America/Costa_Rica",
  	"CU|America/Havana",
  	"CV|Atlantic/Cape_Verde",
  	"CW|America/Puerto_Rico America/Curacao",
  	"CX|Asia/Bangkok Indian/Christmas",
  	"CY|Asia/Nicosia Asia/Famagusta",
  	"CZ|Europe/Prague",
  	"DE|Europe/Zurich Europe/Berlin Europe/Busingen",
  	"DJ|Africa/Nairobi Africa/Djibouti",
  	"DK|Europe/Berlin Europe/Copenhagen",
  	"DM|America/Puerto_Rico America/Dominica",
  	"DO|America/Santo_Domingo",
  	"DZ|Africa/Algiers",
  	"EC|America/Guayaquil Pacific/Galapagos",
  	"EE|Europe/Tallinn",
  	"EG|Africa/Cairo",
  	"EH|Africa/El_Aaiun",
  	"ER|Africa/Nairobi Africa/Asmara",
  	"ES|Europe/Madrid Africa/Ceuta Atlantic/Canary",
  	"ET|Africa/Nairobi Africa/Addis_Ababa",
  	"FI|Europe/Helsinki",
  	"FJ|Pacific/Fiji",
  	"FK|Atlantic/Stanley",
  	"FM|Pacific/Kosrae Pacific/Port_Moresby Pacific/Guadalcanal Pacific/Chuuk Pacific/Pohnpei",
  	"FO|Atlantic/Faroe",
  	"FR|Europe/Paris",
  	"GA|Africa/Lagos Africa/Libreville",
  	"GB|Europe/London",
  	"GD|America/Puerto_Rico America/Grenada",
  	"GE|Asia/Tbilisi",
  	"GF|America/Cayenne",
  	"GG|Europe/London Europe/Guernsey",
  	"GH|Africa/Abidjan Africa/Accra",
  	"GI|Europe/Gibraltar",
  	"GL|America/Nuuk America/Danmarkshavn America/Scoresbysund America/Thule",
  	"GM|Africa/Abidjan Africa/Banjul",
  	"GN|Africa/Abidjan Africa/Conakry",
  	"GP|America/Puerto_Rico America/Guadeloupe",
  	"GQ|Africa/Lagos Africa/Malabo",
  	"GR|Europe/Athens",
  	"GS|Atlantic/South_Georgia",
  	"GT|America/Guatemala",
  	"GU|Pacific/Guam",
  	"GW|Africa/Bissau",
  	"GY|America/Guyana",
  	"HK|Asia/Hong_Kong",
  	"HN|America/Tegucigalpa",
  	"HR|Europe/Belgrade Europe/Zagreb",
  	"HT|America/Port-au-Prince",
  	"HU|Europe/Budapest",
  	"ID|Asia/Jakarta Asia/Pontianak Asia/Makassar Asia/Jayapura",
  	"IE|Europe/Dublin",
  	"IL|Asia/Jerusalem",
  	"IM|Europe/London Europe/Isle_of_Man",
  	"IN|Asia/Kolkata",
  	"IO|Indian/Chagos",
  	"IQ|Asia/Baghdad",
  	"IR|Asia/Tehran",
  	"IS|Africa/Abidjan Atlantic/Reykjavik",
  	"IT|Europe/Rome",
  	"JE|Europe/London Europe/Jersey",
  	"JM|America/Jamaica",
  	"JO|Asia/Amman",
  	"JP|Asia/Tokyo",
  	"KE|Africa/Nairobi",
  	"KG|Asia/Bishkek",
  	"KH|Asia/Bangkok Asia/Phnom_Penh",
  	"KI|Pacific/Tarawa Pacific/Kanton Pacific/Kiritimati",
  	"KM|Africa/Nairobi Indian/Comoro",
  	"KN|America/Puerto_Rico America/St_Kitts",
  	"KP|Asia/Pyongyang",
  	"KR|Asia/Seoul",
  	"KW|Asia/Riyadh Asia/Kuwait",
  	"KY|America/Panama America/Cayman",
  	"KZ|Asia/Almaty Asia/Qyzylorda Asia/Qostanay Asia/Aqtobe Asia/Aqtau Asia/Atyrau Asia/Oral",
  	"LA|Asia/Bangkok Asia/Vientiane",
  	"LB|Asia/Beirut",
  	"LC|America/Puerto_Rico America/St_Lucia",
  	"LI|Europe/Zurich Europe/Vaduz",
  	"LK|Asia/Colombo",
  	"LR|Africa/Monrovia",
  	"LS|Africa/Johannesburg Africa/Maseru",
  	"LT|Europe/Vilnius",
  	"LU|Europe/Brussels Europe/Luxembourg",
  	"LV|Europe/Riga",
  	"LY|Africa/Tripoli",
  	"MA|Africa/Casablanca",
  	"MC|Europe/Paris Europe/Monaco",
  	"MD|Europe/Chisinau",
  	"ME|Europe/Belgrade Europe/Podgorica",
  	"MF|America/Puerto_Rico America/Marigot",
  	"MG|Africa/Nairobi Indian/Antananarivo",
  	"MH|Pacific/Tarawa Pacific/Kwajalein Pacific/Majuro",
  	"MK|Europe/Belgrade Europe/Skopje",
  	"ML|Africa/Abidjan Africa/Bamako",
  	"MM|Asia/Yangon",
  	"MN|Asia/Ulaanbaatar Asia/Hovd Asia/Choibalsan",
  	"MO|Asia/Macau",
  	"MP|Pacific/Guam Pacific/Saipan",
  	"MQ|America/Martinique",
  	"MR|Africa/Abidjan Africa/Nouakchott",
  	"MS|America/Puerto_Rico America/Montserrat",
  	"MT|Europe/Malta",
  	"MU|Indian/Mauritius",
  	"MV|Indian/Maldives",
  	"MW|Africa/Maputo Africa/Blantyre",
  	"MX|America/Mexico_City America/Cancun America/Merida America/Monterrey America/Matamoros America/Chihuahua America/Ciudad_Juarez America/Ojinaga America/Mazatlan America/Bahia_Banderas America/Hermosillo America/Tijuana",
  	"MY|Asia/Kuching Asia/Singapore Asia/Kuala_Lumpur",
  	"MZ|Africa/Maputo",
  	"NA|Africa/Windhoek",
  	"NC|Pacific/Noumea",
  	"NE|Africa/Lagos Africa/Niamey",
  	"NF|Pacific/Norfolk",
  	"NG|Africa/Lagos",
  	"NI|America/Managua",
  	"NL|Europe/Brussels Europe/Amsterdam",
  	"NO|Europe/Berlin Europe/Oslo",
  	"NP|Asia/Kathmandu",
  	"NR|Pacific/Nauru",
  	"NU|Pacific/Niue",
  	"NZ|Pacific/Auckland Pacific/Chatham",
  	"OM|Asia/Dubai Asia/Muscat",
  	"PA|America/Panama",
  	"PE|America/Lima",
  	"PF|Pacific/Tahiti Pacific/Marquesas Pacific/Gambier",
  	"PG|Pacific/Port_Moresby Pacific/Bougainville",
  	"PH|Asia/Manila",
  	"PK|Asia/Karachi",
  	"PL|Europe/Warsaw",
  	"PM|America/Miquelon",
  	"PN|Pacific/Pitcairn",
  	"PR|America/Puerto_Rico",
  	"PS|Asia/Gaza Asia/Hebron",
  	"PT|Europe/Lisbon Atlantic/Madeira Atlantic/Azores",
  	"PW|Pacific/Palau",
  	"PY|America/Asuncion",
  	"QA|Asia/Qatar",
  	"RE|Asia/Dubai Indian/Reunion",
  	"RO|Europe/Bucharest",
  	"RS|Europe/Belgrade",
  	"RU|Europe/Kaliningrad Europe/Moscow Europe/Simferopol Europe/Kirov Europe/Volgograd Europe/Astrakhan Europe/Saratov Europe/Ulyanovsk Europe/Samara Asia/Yekaterinburg Asia/Omsk Asia/Novosibirsk Asia/Barnaul Asia/Tomsk Asia/Novokuznetsk Asia/Krasnoyarsk Asia/Irkutsk Asia/Chita Asia/Yakutsk Asia/Khandyga Asia/Vladivostok Asia/Ust-Nera Asia/Magadan Asia/Sakhalin Asia/Srednekolymsk Asia/Kamchatka Asia/Anadyr",
  	"RW|Africa/Maputo Africa/Kigali",
  	"SA|Asia/Riyadh",
  	"SB|Pacific/Guadalcanal",
  	"SC|Asia/Dubai Indian/Mahe",
  	"SD|Africa/Khartoum",
  	"SE|Europe/Berlin Europe/Stockholm",
  	"SG|Asia/Singapore",
  	"SH|Africa/Abidjan Atlantic/St_Helena",
  	"SI|Europe/Belgrade Europe/Ljubljana",
  	"SJ|Europe/Berlin Arctic/Longyearbyen",
  	"SK|Europe/Prague Europe/Bratislava",
  	"SL|Africa/Abidjan Africa/Freetown",
  	"SM|Europe/Rome Europe/San_Marino",
  	"SN|Africa/Abidjan Africa/Dakar",
  	"SO|Africa/Nairobi Africa/Mogadishu",
  	"SR|America/Paramaribo",
  	"SS|Africa/Juba",
  	"ST|Africa/Sao_Tome",
  	"SV|America/El_Salvador",
  	"SX|America/Puerto_Rico America/Lower_Princes",
  	"SY|Asia/Damascus",
  	"SZ|Africa/Johannesburg Africa/Mbabane",
  	"TC|America/Grand_Turk",
  	"TD|Africa/Ndjamena",
  	"TF|Asia/Dubai Indian/Maldives Indian/Kerguelen",
  	"TG|Africa/Abidjan Africa/Lome",
  	"TH|Asia/Bangkok",
  	"TJ|Asia/Dushanbe",
  	"TK|Pacific/Fakaofo",
  	"TL|Asia/Dili",
  	"TM|Asia/Ashgabat",
  	"TN|Africa/Tunis",
  	"TO|Pacific/Tongatapu",
  	"TR|Europe/Istanbul",
  	"TT|America/Puerto_Rico America/Port_of_Spain",
  	"TV|Pacific/Tarawa Pacific/Funafuti",
  	"TW|Asia/Taipei",
  	"TZ|Africa/Nairobi Africa/Dar_es_Salaam",
  	"UA|Europe/Simferopol Europe/Kyiv",
  	"UG|Africa/Nairobi Africa/Kampala",
  	"UM|Pacific/Pago_Pago Pacific/Tarawa Pacific/Honolulu Pacific/Midway Pacific/Wake",
  	"US|America/New_York America/Detroit America/Kentucky/Louisville America/Kentucky/Monticello America/Indiana/Indianapolis America/Indiana/Vincennes America/Indiana/Winamac America/Indiana/Marengo America/Indiana/Petersburg America/Indiana/Vevay America/Chicago America/Indiana/Tell_City America/Indiana/Knox America/Menominee America/North_Dakota/Center America/North_Dakota/New_Salem America/North_Dakota/Beulah America/Denver America/Boise America/Phoenix America/Los_Angeles America/Anchorage America/Juneau America/Sitka America/Metlakatla America/Yakutat America/Nome America/Adak Pacific/Honolulu",
  	"UY|America/Montevideo",
  	"UZ|Asia/Samarkand Asia/Tashkent",
  	"VA|Europe/Rome Europe/Vatican",
  	"VC|America/Puerto_Rico America/St_Vincent",
  	"VE|America/Caracas",
  	"VG|America/Puerto_Rico America/Tortola",
  	"VI|America/Puerto_Rico America/St_Thomas",
  	"VN|Asia/Bangkok Asia/Ho_Chi_Minh",
  	"VU|Pacific/Efate",
  	"WF|Pacific/Tarawa Pacific/Wallis",
  	"WS|Pacific/Apia",
  	"YE|Asia/Riyadh Asia/Aden",
  	"YT|Africa/Nairobi Indian/Mayotte",
  	"ZA|Africa/Johannesburg",
  	"ZM|Africa/Maputo Africa/Lusaka",
  	"ZW|Africa/Maputo Africa/Harare"
  ];
  var latest = {
  	version: version,
  	zones: zones,
  	links: links,
  	countries: countries
  };

  var latest$1 = {
    __proto__: null,
    version: version,
    zones: zones,
    links: links,
    countries: countries,
    'default': latest
  };

  var require$$1 = getCjsExportFromNamespace(latest$1);

  var momentTimezone = createCommonjsModule$1(function (module) {
  var moment = module.exports = momentTimezone$1;
  moment.tz.load(require$$1);
  });

  class MomentNamedTimeZone extends NamedTimeZoneImpl {
      offsetForArray(a) {
          return momentTimezone.tz(a, this.timeZoneName).utcOffset();
      }
      timestampToArray(ms) {
          return momentTimezone.tz(ms, this.timeZoneName).toArray();
      }
  }

  var index$3 = createPlugin({
      name: '@fullcalendar/moment-timezone',
      namedTimeZonedImpl: MomentNamedTimeZone,
  });

  describe('moment-timezone', () => {
      testTimeZoneImpl(index$3);
  });

  function expectRenderRange(start, end) {
      let { dateProfile } = currentCalendar.getCurrentData(); // not a great way to get this info
      expect(dateProfile.renderRange.start).toEqualDate(start);
      expect(dateProfile.renderRange.end).toEqualDate(end);
  }
  function expectActiveRange(start, end) {
      let currentView = currentCalendar.view;
      expect(currentView.activeStart).toEqualDate(start);
      expect(currentView.activeEnd).toEqualDate(end);
  }

  describe('next', () => {
      pushOptions({
          initialDate: '2017-06-08',
      });
      describe('when in week view', () => {
          pushOptions({
              initialView: 'timeGridWeek',
          });
          describe('when dateIncrement not specified', () => {
              it('moves forward by one week', () => {
                  initCalendar();
                  currentCalendar.next();
                  expectActiveRange('2017-06-11', '2017-06-18');
              });
          });
          describeOptions('dateIncrement', {
              'when two week dateIncrement specified as a plain object': { weeks: 2 },
              'when two week dateIncrement specified as a string': '14.00:00:00',
          }, () => {
              it('moves forward by two weeks', () => {
                  initCalendar();
                  currentCalendar.next();
                  expectActiveRange('2017-06-18', '2017-06-25');
              });
          });
          it('does not duplicate-render skeleton', () => {
              let calendar = initCalendar();
              calendar.next();
              let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
              expect(timeGridWrapper.isStructureValid()).toBe(true);
          });
      });
      describe('when in a month view', () => {
          pushOptions({
              initialView: 'dayGridMonth',
          });
          describe('when dateIncrement not specified', () => {
              it('moves forward by one month', () => {
                  initCalendar();
                  currentCalendar.next();
                  expectActiveRange('2017-06-25', '2017-08-06');
              });
          });
          describe('when two month dateIncrement is specified', () => {
              pushOptions({
                  dateIncrement: { months: 2 },
              });
              it('moves forward by two months', () => {
                  initCalendar();
                  currentCalendar.next();
                  expectActiveRange('2017-07-30', '2017-09-10');
              });
          });
      });
      describe('when in custom three day view', () => {
          pushOptions({
              initialView: 'dayGrid',
              duration: { days: 3 },
          });
          describe('when no dateAlignment is specified', () => {
              describe('when dateIncrement not specified', () => {
                  it('moves forward three days', () => {
                      initCalendar();
                      currentCalendar.next();
                      expectActiveRange('2017-06-11', '2017-06-14');
                  });
              });
              describe('when two day dateIncrement is specified', () => {
                  pushOptions({
                      dateIncrement: { days: 2 },
                  });
                  it('moves forward two days', () => {
                      initCalendar();
                      currentCalendar.next();
                      expectActiveRange('2017-06-10', '2017-06-13');
                  });
              });
          });
          describe('when week dateAlignment is specified', () => {
              pushOptions({
                  dateAlignment: 'week',
              });
              describe('when dateIncrement not specified', () => {
                  it('moves forward one week', () => {
                      initCalendar();
                      currentCalendar.next();
                      expectActiveRange('2017-06-11', '2017-06-14');
                  });
              });
              describe('when two day dateIncrement is specified', () => {
                  pushOptions({
                      dateIncrement: { days: 2 },
                  });
                  it('does not navigate nor rerender', () => {
                      let called;
                      initCalendar({
                          dayCellDidMount() {
                              called = true;
                          },
                      });
                      called = false;
                      currentCalendar.next();
                      expectActiveRange('2017-06-04', '2017-06-07'); // the same as how it started
                      expect(called).toBe(false);
                  });
              });
          });
      });
      describe('when in a custom two day view and weekends:false', () => {
          pushOptions({
              weekends: false,
              initialView: 'timeGrid',
              duration: { days: 2 },
          });
          it('skips over weekends if there would be alignment with weekend', () => {
              initCalendar({
                  initialDate: '2017-11-09',
              });
              currentCalendar.next();
          });
      });
  });

  describe('view duration', () => {
      pushOptions({
          initialView: 'timeGrid',
          initialDate: '2017-03-15',
      });
      describe('when specified as a week integer', () => {
          pushOptions({
              duration: { weeks: 1 },
          });
          it('aligns with start of week', () => {
              initCalendar();
              expectActiveRange('2017-03-12', '2017-03-19');
          });
      });
      describe('when specified as 7 days', () => {
          pushOptions({
              duration: { days: 7 },
          });
          it('aligns with start of week', () => {
              initCalendar();
              expectActiveRange('2017-03-15', '2017-03-22');
          });
      });
  });

  function startOfLocalDay(date) {
      return new Date(date.getFullYear(), date.getMonth(), date.getDate());
  }
  function addLocalDays(date, n) {
      let newDate = new Date(date.valueOf());
      newDate.setDate(newDate.getDate() + n);
      return newDate;
  }
  function startOfUtcDay(date) {
      return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));
  }
  function addUtcDays(date, n) {
      let newDate = new Date(date.valueOf());
      newDate.setUTCDate(newDate.getUTCDate() + n);
      return newDate;
  }

  describe('visibleRange', () => {
      describe('when custom view with a flexible range', () => {
          pushOptions({
              initialView: 'timeGrid',
          });
          describe('when given a valid date range', () => {
              let startInput = '2017-06-26';
              let endInput = '2017-06-29';
              describeOptions('visibleRange', {
                  'of Date objects': {
                      start: new Date(startInput),
                      end: new Date(endInput),
                  },
                  'of strings': {
                      start: startInput,
                      end: endInput,
                  },
                  'of a function that returns date objects': () => ({
                      start: new Date(startInput),
                      end: new Date(endInput),
                  }),
                  'of a function that returns strings': () => ({
                      start: startInput,
                      end: endInput,
                  }),
              }, () => {
                  it('gets set to the given range', () => {
                      initCalendar();
                      expectActiveRange(startInput, endInput);
                  });
              });
              it('works as a custom view', () => {
                  initCalendar({
                      views: {
                          myCustomView: {
                              type: 'timeGrid',
                              visibleRange: {
                                  start: startInput,
                                  end: endInput,
                              },
                          },
                      },
                      initialView: 'myCustomView',
                  });
                  expectActiveRange(startInput, endInput);
              });
              it('ignores dateAlignment', () => {
                  initCalendar({
                      dateAlignment: 'dayGridMonth',
                      visibleRange: {
                          start: startInput,
                          end: endInput,
                      },
                  });
                  expectActiveRange(startInput, endInput);
              });
              it('works as a dynamic option', () => {
                  initCalendar({
                      initialView: 'dayGrid',
                  });
                  currentCalendar.setOption('visibleRange', {
                      start: startInput,
                      end: endInput,
                  });
                  expectActiveRange(startInput, endInput);
              });
          });
          describe('when a function', () => {
              let initialDateInput = '2017-06-08T12:30:00';
              it('receives the calendar\'s initialDate, with local timezone, and emits local range', () => {
                  let matched = false;
                  initCalendar({
                      timeZone: 'local',
                      initialDate: initialDateInput,
                      visibleRange(date) {
                          // this function will receive the date for prev/next,
                          // which should be ignored. make sure just one call matches.
                          if (date.valueOf() === parseLocalDate(initialDateInput).valueOf()) {
                              matched = true;
                          }
                          let dayStart = startOfLocalDay(date);
                          return {
                              start: addLocalDays(dayStart, -1),
                              end: addLocalDays(dayStart, 2),
                          };
                      },
                  });
                  expect(matched).toBe(true);
                  expectActiveRange(parseLocalDate('2017-06-07'), parseLocalDate('2017-06-10'));
              });
              it('receives the calendar\'s initialDate, with UTC timezone, and emits UTC range', () => {
                  let matched = false;
                  initCalendar({
                      timeZone: 'UTC',
                      initialDate: initialDateInput,
                      visibleRange(date) {
                          // this function will receive the date for prev/next,
                          // which should be ignored. make sure just one call matches.
                          if (date.valueOf() === parseUtcDate(initialDateInput).valueOf()) {
                              matched = true;
                          }
                          let dayStart = startOfUtcDay(date);
                          return {
                              start: addUtcDays(dayStart, -1),
                              end: addUtcDays(dayStart, 2),
                          };
                      },
                  });
                  expect(matched).toBe(true);
                  expectActiveRange('2017-06-07', '2017-06-10');
              });
              // https://github.com/fullcalendar/fullcalendar/issues/4517
              it('can emit and timed UTC range that will be rounded', () => {
                  initCalendar({
                      dateIncrement: { days: 3 },
                      timeZone: 'UTC',
                      initialDate: initialDateInput,
                      visibleRange(date) {
                          return {
                              start: addUtcDays(date, -1),
                              end: addUtcDays(date, 2), // 2017-06-10T12:30:00 -> 2017-06-11
                          };
                      },
                  });
                  expectActiveRange('2017-06-07', '2017-06-11');
                  currentCalendar.prev();
                  expectActiveRange('2017-06-04', '2017-06-07'); // second computation will round down the end
              });
          });
          describe('when given an invalid range', () => {
              describeOptions('visibleRange', {
                  'with end before start': {
                      start: '2017-06-18',
                      end: '2017-06-15',
                  },
                  'with no end': {
                      start: '2017-06-18',
                  },
                  'with no start': {
                      end: '2017-06-15',
                  },
              }, () => {
                  it('defaults to the initialDate', () => {
                      initCalendar({
                          initialDate: '2017-08-01',
                      });
                      expectActiveRange('2017-08-01', '2017-08-02');
                  });
              });
          });
          describe('when later switching to a one-day view', () => {
              it('constrains an earlier current date to the start of visibleRange', () => {
                  initCalendar({
                      initialDate: '2017-06-25',
                      visibleRange: {
                          start: '2017-06-26',
                          end: '2017-06-29',
                      },
                  });
                  currentCalendar.changeView('timeGridDay');
                  expectActiveRange('2017-06-26', '2017-06-27');
              });
              it('constrains a later current date to the start of visibleRange', () => {
                  initCalendar({
                      initialDate: '2017-07-01',
                      visibleRange: {
                          start: '2017-06-26',
                          end: '2017-06-29',
                      },
                  });
                  currentCalendar.changeView('timeGridDay');
                  expectActiveRange('2017-06-26', '2017-06-27');
              });
          });
      });
      describe('when a list view', () => {
          pushOptions({
              initialView: 'list',
              visibleRange: {
                  start: '2017-06-07',
                  end: '2017-06-10',
              },
              events: [
                  { start: '2017-06-08' },
              ],
          });
          it('respects the given range', () => {
              initCalendar();
              expectActiveRange('2017-06-07', '2017-06-10');
          });
      });
      describe('when custom view with fixed duration', () => {
          pushOptions({
              initialDate: '2015-06-08',
              initialView: 'timeGrid',
              duration: { days: 3 },
          });
          it('ignores the given visibleRange', () => {
              initCalendar({
                  visibleRange: {
                      start: '2017-06-29',
                      end: '2017-07-04',
                  },
              });
              expectActiveRange('2015-06-08', '2015-06-11');
          });
      });
      describe('when standard view', () => {
          pushOptions({
              initialDate: '2015-06-08',
              initialView: 'timeGridWeek',
          });
          it('ignores the given visibleRange', () => {
              initCalendar({
                  visibleRange: {
                      start: '2017-06-29',
                      end: '2017-07-04',
                  },
              });
              expectActiveRange('2015-06-07', '2015-06-14');
          });
      });
  });

  describe('gotoDate', () => {
      it('will update calendar\'s date even if no navigation', () => {
          initCalendar({
              initialDate: '2018-12-25',
              initialView: 'dayGridMonth',
          });
          expect(currentCalendar.getDate()).toEqualDate('2018-12-25');
          currentCalendar.gotoDate('2018-12-30');
          expect(currentCalendar.getDate()).toEqualDate('2018-12-30');
      });
      describe('when asynchronicity', () => {
          pushOptions({
              events(arg, callback) {
                  setTimeout(() => {
                      callback([]);
                  }, 0);
              },
          });
          it('works when called right after initialization', () => {
              initCalendar({
                  initialView: 'dayGridMonth',
                  initialDate: '2017-03-30',
              });
              currentCalendar.gotoDate('2017-06-01');
          });
          it('works when called right after initialization when date already in range', () => {
              initCalendar({
                  initialView: 'dayGridMonth',
                  initialDate: '2017-03-30',
              });
              currentCalendar.gotoDate('2017-03-01');
          });
      });
      // https://github.com/fullcalendar/fullcalendar/issues/4929
      it('moves view\'s date range when small dateAlignment', () => {
          let calendar = initCalendar({
              initialDate: '2019-04-09',
              initialView: 'dayGridFourDays',
              views: {
                  dayGridFourDays: {
                      type: 'dayGrid',
                      duration: { days: 4 },
                      dateAlignment: 'day',
                  },
              },
          });
          calendar.gotoDate('2019-04-10');
          expectActiveRange('2019-04-10', '2019-04-14');
      });
  });

  function expectDayRange(start, end) {
      if (typeof start === 'string') {
          expect(start.indexOf('T')).toBe(-1);
          start = new Date(start);
      }
      if (typeof end === 'string') {
          expect(end.indexOf('T')).toBe(-1);
          end = new Date(end);
      }
      let dayBefore = addDays(start, -1);
      expectDay(dayBefore, false);
      let date = start;
      while (date < end) { // eslint-disable-line
          expectDay(date, true);
          date = addDays(date, 1);
      }
      // `date` is now the first day after the range
      expectDay(date, false);
  }
  function expectDay(date, bool) {
      if (typeof date === 'string') {
          expect(date.indexOf('T')).toBe(-1);
          date = new Date(date);
      }
      let calendarWrapper = new CalendarWrapper(currentCalendar);
      let dayEl = calendarWrapper.getDateCellEl(formatIsoDay(date));
      if (bool) {
          expect(dayEl).toBeTruthy();
      }
      else {
          expect(dayEl).toBeFalsy();
      }
  }

  describe('dayCount', () => {
      pushOptions({
          initialDate: '2017-03-15',
          weekends: false,
      });
      describeOptions({
          'when specified as top-level options': {
              initialView: 'dayGrid',
              dayCount: 5,
          },
          'when specified as custom view': {
              views: {
                  myCustomView: {
                      type: 'dayGrid',
                      dayCount: 5,
                  },
              },
              initialView: 'myCustomView',
          },
      }, () => {
          it('renders the exact day count', () => {
              initCalendar();
              expectActiveRange('2017-03-15', '2017-03-22');
              expectDay('2017-03-15', true);
              expectDay('2017-03-16', true);
              expectDay('2017-03-17', true);
              expectDay('2017-03-18', false); // sat
              expectDay('2017-03-19', false); // sun
              expectDay('2017-03-20', true);
              expectDay('2017-03-21', true);
          });
      });
      it('can span multiple weeks', () => {
          initCalendar({
              initialView: 'timeGrid',
              dayCount: 9,
          });
          expectActiveRange('2017-03-15', '2017-03-28');
          expectDay('2017-03-15', true);
          expectDay('2017-03-16', true);
          expectDay('2017-03-17', true);
          expectDay('2017-03-18', false); // sat
          expectDay('2017-03-19', false); // sun
          expectDay('2017-03-20', true);
          expectDay('2017-03-21', true);
          expectDay('2017-03-22', true);
          expectDay('2017-03-23', true);
          expectDay('2017-03-24', true);
          expectDay('2017-03-25', false); // sat
          expectDay('2017-03-26', false); // sun
          expectDay('2017-03-27', true);
      });
      it('can navigate in reverse with a small dateIncrement split by hidden days', () => {
          initCalendar({
              initialDate: '2018-06-11',
              initialView: 'timeGridTwoDay',
              headerToolbar: {
                  left: 'prev,next',
                  center: 'title',
                  right: 'dayGridMonth,timeGridWeek,timeGridDay,timeGridTwoDay',
              },
              hiddenDays: [0, 6],
              views: {
                  timeGridTwoDay: {
                      type: 'timeGrid',
                      dayCount: 2,
                      dateIncrement: { days: 1 },
                      buttonText: '2 days',
                  },
              },
          });
          currentCalendar.prev();
          expectActiveRange('2018-06-08', '2018-06-12');
      });
  });

  /*
  SEE ALSO:
  - next (does core of date switching)
  */
  describe('prev', () => {
      pushOptions({
          initialDate: '2017-06-08',
      });
      describe('when in a week view', () => {
          pushOptions({
              initialView: 'timeGridWeek',
          });
          it('moves back by one week', () => {
              initCalendar();
              currentCalendar.prev();
              expectActiveRange('2017-05-28', '2017-06-04');
          });
          describe('when two week dateIncrement', () => {
              pushOptions({
                  dateIncrement: { weeks: 2 },
              });
              it('moves back by two weeks', () => {
                  initCalendar();
                  currentCalendar.prev();
                  expectActiveRange('2017-05-21', '2017-05-28');
              });
          });
      });
      // https://github.com/fullcalendar/fullcalendar/issues/4595
      it('can navigate back when starting late in month', () => {
          initCalendar({
              initialDate: '2019-03-31T12:00',
              initialView: 'dayGridMonth',
          });
          expectActiveRange('2019-02-24', '2019-04-07');
          currentCalendar.prev();
          expectActiveRange('2019-01-27', '2019-03-10');
      });
      // related to #4595
      it('can navigate forward when starting late in month', () => {
          initCalendar({
              initialDate: '2019-03-31T12:00',
              initialView: 'dayGridMonth',
          });
          expectActiveRange('2019-02-24', '2019-04-07');
          currentCalendar.next();
          expectActiveRange('2019-03-31', '2019-05-12');
      });
      // https://github.com/fullcalendar/fullcalendar/issues/5319
      it('can navigate back twice when duration greater than dateIncrement', () => {
          let calendar = initCalendar({
              firstDay: 1,
              initialDate: '2021-06-14',
              initialView: 'dayGridFourWeeks',
              views: {
                  dayGridFourWeeks: {
                      type: 'dayGrid',
                      duration: { weeks: 4 },
                      dateIncrement: { weeks: 1 },
                  },
              },
          });
          expectActiveRange('2021-06-14', '2021-07-12');
          calendar.prev(); // back a week
          expectActiveRange('2021-06-07', '2021-07-05');
          calendar.prev(); // back a week
          expectActiveRange('2021-05-31', '2021-06-28');
      });
  });

  describe('datesSet', () => {
      pushOptions({
          initialView: 'dayGridMonth',
          now: '2020-06-21',
      });
      it('won\'t fire when a non-dateprofile-related option is reset', () => {
          let fireCnt = 0;
          let options = Object.assign(Object.assign({}, getCurrentOptions()), { weekNumbers: false, datesSet() {
                  fireCnt += 1;
              } });
          let $calendarEl = $('<div>').appendTo('body');
          let calendar = new Calendar($calendarEl[0], options);
          calendar.render();
          expect(fireCnt).toBe(1);
          calendar.resetOptions(Object.assign(Object.assign({}, options), { weekNumbers: true }));
          expect(fireCnt).toBe(1);
          calendar.destroy();
          $calendarEl.remove();
      });
      it('won\'t fire when a complex object-like option is reset', () => {
          function buildHeaderToolbar() {
              return {
                  left: 'today',
              };
          }
          let fireCnt = 0;
          let options = Object.assign(Object.assign({}, getCurrentOptions()), { headerToolbar: buildHeaderToolbar(), datesSet() {
                  fireCnt += 1;
              } });
          let $calendarEl = $('<div>').appendTo('body');
          let calendar = new Calendar($calendarEl[0], options);
          calendar.render();
          expect(fireCnt).toBe(1);
          calendar.resetOptions(Object.assign(Object.assign({}, options), { headerToolbar: buildHeaderToolbar() }));
          expect(fireCnt).toBe(1);
          calendar.destroy();
          $calendarEl.remove();
      });
      it('won\'t fire when plugins option is reset', () => {
          let fireCnt = 0;
          let options = Object.assign(Object.assign({}, getCurrentOptions()), { plugins: [index$a], datesSet() {
                  fireCnt += 1;
              } });
          let $calendarEl = $('<div>').appendTo('body');
          let calendar = new Calendar($calendarEl[0], options);
          calendar.render();
          expect(fireCnt).toBe(1);
          calendar.resetOptions(Object.assign(Object.assign({}, options), { plugins: [index$a] }));
          expect(fireCnt).toBe(1);
          calendar.destroy();
          $calendarEl.remove();
      });
  });

  describe('validRange', () => {
      pushOptions({
          timeZone: 'UTC',
          initialDate: '2017-06-08',
      });
      describe('when one week view', () => {
          pushOptions({
              initialView: 'timeGridWeek', // default range = 2017-06-04 - 2017-06-11
          });
          describe('when default range is partially before validRange', () => {
              pushOptions({
                  validRange: { start: '2017-06-06' },
              });
              it('allows full renderRange but restricts activeRange', () => {
                  initCalendar();
                  expectRenderRange('2017-06-04', '2017-06-11');
                  expectActiveRange('2017-06-06', '2017-06-11');
              });
          });
          describe('when default range is partially after validRange', () => {
              pushOptions({
                  validRange: { end: '2017-06-05' },
              });
              it('allows full renderRange but restricts activeRange', () => {
                  initCalendar();
                  expectRenderRange('2017-06-04', '2017-06-11');
                  expectActiveRange('2017-06-04', '2017-06-05');
              });
          });
          describe('when default range is completely before validRange', () => {
              pushOptions({
                  validRange: { start: '2017-06-14' }, // a Wednesday
              });
              it('initializes at earliest partially visible week', () => {
                  initCalendar();
                  expectRenderRange('2017-06-11', '2017-06-18');
                  expectActiveRange('2017-06-14', '2017-06-18');
              });
          });
          describe('when default range is completely before validRange', () => {
              pushOptions({
                  validRange: { end: '2017-05-24' }, // a Wednesday
              });
              it('initializes at latest partially visible week', () => {
                  initCalendar();
                  expectRenderRange('2017-05-21', '2017-05-28');
                  expectActiveRange('2017-05-21', '2017-05-24');
              });
          });
          describe('when validRange is a function', () => {
              let nowInput = '2017-06-09T06:00:00';
              it('receives the nowDate, timezoneless', () => {
                  let validRangeSpy = spyOnCalendarCallback('validRange', (date) => {
                      expect(date instanceof Date).toBe(true);
                      expect(date).toEqualDate(nowInput + 'Z');
                  });
                  initCalendar({
                      now: nowInput,
                  });
                  expect(validRangeSpy).toHaveBeenCalled();
              });
              it('can return a range object with strings', () => {
                  let validRangeSpy = spyOnCalendarCallback('validRange', () => ({ start: '2017-06-06' }));
                  initCalendar();
                  expect(validRangeSpy).toHaveBeenCalled();
                  expectRenderRange('2017-06-04', '2017-06-11');
                  expectActiveRange('2017-06-06', '2017-06-11');
              });
              it('can return a range object with Date objects', () => {
                  let validRangeSpy = spyOnCalendarCallback('validRange', () => ({ start: parseUtcDate('2017-06-06') }));
                  initCalendar();
                  expect(validRangeSpy).toHaveBeenCalled();
                  expectRenderRange('2017-06-04', '2017-06-11');
                  expectActiveRange('2017-06-06', '2017-06-11');
              });
          });
      });
      describe('when a three-day view', () => {
          pushOptions({
              initialView: 'timeGrid',
              duration: { days: 3 },
          });
          describe('when default range is completely before of validRange', () => {
              pushOptions({
                  validRange: { start: '2017-06-14' },
              });
              it('renders earliest three valid days', () => {
                  initCalendar();
                  expectRenderRange('2017-06-14', '2017-06-17');
                  expectActiveRange('2017-06-14', '2017-06-17');
              });
          });
          describe('when default range is completely after validRange', () => {
              pushOptions({
                  validRange: { end: '2017-05-31' },
              });
              it('renders latest possible valid day and two invalid days', () => {
                  initCalendar();
                  expectRenderRange('2017-05-30', '2017-06-02');
                  expectActiveRange('2017-05-30', '2017-05-31');
              });
          });
      });
      describe('when hiddenDays causes no days to be active', () => {
          pushOptions({
              initialView: 'timeGridWeek',
              initialDate: '2017-10-04',
              hiddenDays: [6],
              validRange: {
                  start: '2036-05-03',
                  end: '2036-06-01',
              },
          });
          it('pushes view to nearest valid range', () => {
              initCalendar();
              expectRenderRange('2036-05-04', '2036-05-10');
              expectActiveRange('2036-05-04', '2036-05-10');
          });
      });
  });

  /*
  SEE ALSO: next/prev
  */
  describe('dateAlignment', () => {
      describe('when week alignment', () => {
          pushOptions({
              initialView: 'timeGrid',
              dateAlignment: 'week',
              initialDate: '2017-06-15',
          });
          describe('when 3 day duration', () => {
              pushOptions({
                  duration: { days: 3 },
              });
              it('aligns with the week', () => {
                  initCalendar();
                  expectActiveRange('2017-06-11', '2017-06-14');
              });
          });
          describe('when 5 day count', () => {
              pushOptions({
                  dayCount: 5,
                  weekends: false,
              });
              it('aligns with first visible day of the week', () => {
                  initCalendar();
                  expectActiveRange('2017-06-12', '2017-06-17');
              });
          });
      });
      // test in Safari!
      // https://github.com/fullcalendar/fullcalendar/issues/4363
      describe('when year alignment', () => {
          pushOptions({
              initialView: 'dayGrid',
              duration: { months: 1 },
              dateAlignment: 'year',
              initialDate: '2017-06-15',
          });
          it('aligns with first day of year', () => {
              initCalendar();
              expectActiveRange('2017-01-01', '2017-02-05');
          });
      });
  });

  describe('changeView', () => {
      pushOptions({
          initialDate: '2017-06-08',
          initialView: 'dayGridMonth',
      });
      it('can change views', () => {
          let calendar = initCalendar();
          calendar.changeView('timeGridWeek');
          expectActiveRange('2017-06-04', '2017-06-11');
      });
      it('can change views and navigate date', () => {
          let calendar = initCalendar();
          calendar.changeView('timeGridDay', '2017-06-26');
          expectActiveRange('2017-06-26', '2017-06-27');
      });
      it('can change views and change activeRange', () => {
          let calendar = initCalendar();
          calendar.changeView('timeGrid', {
              start: '2017-07-04',
              end: '2017-07-08',
          });
          expectActiveRange('2017-07-04', '2017-07-08');
      });
      describe('when switching away from view, then back', () => {
          // serves as a smoke test too
          it('correctly renders original view again', () => {
              let calendar = initCalendar({
                  initialView: 'dayGridMonth',
              });
              expect(calendar.view.type).toBe('dayGridMonth');
              checkViewIntegrity(calendar);
              calendar.changeView('timeGridWeek');
              expect(calendar.view.type).toBe('timeGridWeek');
              checkViewIntegrity(calendar);
              let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
              expect(timeGridWrapper.isStructureValid()).toBe(true);
              calendar.changeView('dayGridWeek');
              expect(calendar.view.type).toBe('dayGridWeek');
              checkViewIntegrity(calendar);
              calendar.changeView('listWeek');
              expect(calendar.view.type).toBe('listWeek');
              checkViewIntegrity(calendar);
              calendar.changeView('dayGridMonth');
              expect(calendar.view.type).toBe('dayGridMonth');
              checkViewIntegrity(calendar);
          });
      });
      // https://github.com/fullcalendar/fullcalendar/issues/3689
      it('can when switching to/from view while loading events', (done) => {
          let calendar = initCalendar({
              headerToolbar: {
                  left: 'title dayGridDay timeGridDay',
              },
              initialView: 'timeGridDay',
              now: '2017-06-08T01:00:00',
              events(fetchInfo, successCallback) {
                  setTimeout(() => {
                      successCallback([
                          { start: '2017-06-08T01:00:00' }, // needs to be timed to cause the JS error
                      ]);
                  }, 100);
              },
          });
          calendar.changeView('dayGridDay');
          checkViewIntegrity(calendar);
          expect(calendar.view.type).toBe('dayGridDay');
          setTimeout(() => {
              calendar.changeView('timeGridDay');
              checkViewIntegrity(calendar);
              expect(calendar.view.type).toBe('timeGridDay');
              done();
          }, 200);
      });
      function checkViewIntegrity(calendar) {
          let $el = $(new CalendarWrapper(calendar).getViewEl());
          expect($el).toBeInDOM();
          expect($el.children().length).toBeGreaterThan(0);
          expect($el.text()).toBeTruthy();
      }
  });

  describe('internal View/Grid classes', () => {
      it('are exposed', () => {
          expect(typeof DayTimeColsView).toBe('function');
          expect(typeof DayTableView).toBe('function');
          expect(typeof ListView).toBe('function');
          expect(typeof DayTable).toBe('function');
          expect(typeof DayTimeCols).toBe('function');
      });
  });

  describe('calendar title', () => {
      pushOptions({
          now: '2017-03-29',
      });
      describe('when switching to and from a view', () => {
          it('updates the title at each switch', () => {
              let calendar = initCalendar({
                  initialView: 'dayGridMonth',
              });
              let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
              expect(toolbarWrapper.getTitleText()).toBe('March 2017');
              currentCalendar.changeView('timeGridWeek');
              expect(toolbarWrapper.getTitleText()).toBe('Mar 26 – Apr 1, 2017');
              currentCalendar.changeView('dayGridMonth');
              expect(toolbarWrapper.getTitleText()).toBe('March 2017');
          });
      });
  });

  /*
  TODO:
  - quick test for when button is clicked

  SEE ALSO:
  - other range intersection tests handled by next-button
  */
  describe('prev button', () => {
      pushOptions({
          initialView: 'timeGridWeek',
          initialDate: '2017-06-08',
      });
      describe('when there is no specified validRange', () => {
          it('is enabled', () => {
              expectEnabled(initCalendar(), true);
          });
      });
      describe('when prev date range is completely before validRange', () => {
          pushOptions({
              validRange: { start: '2018-06-12' },
              dateIncrement: { years: 1 }, // prev range is 2016-06-05 - 2016-06-12
          });
          it('is disabled', () => {
              expectEnabled(initCalendar(), false);
          });
      });
      describe('when month view', () => {
          pushOptions({
              initialView: 'dayGridMonth',
              initialDate: '2017-03-01',
              validRange: { start: '2017-02-07' },
              dateIncrement: { years: 1 }, // prev range is 2016-06-05 - 2016-06-12
          });
          it('when prev date range is partially before validRange', () => {
              expectEnabled(initCalendar(), false);
          });
      });
      describe('when day before current day is a hidden day', () => {
          pushOptions({
              initialDate: '2017-03-27',
              initialView: 'dayGridDay',
              weekends: false,
              dateIncrement: { years: 1 }, // prev range is 2016-06-05 - 2016-06-12
          });
          it('is enabled', () => {
              expectEnabled(initCalendar(), true);
          });
      });
      describe('when initialDate is constrained backward to validRange and prev week is valid', () => {
          pushOptions({
              initialDate: '2017-07-17',
              initialView: 'timeGridWeek',
              validRange: { start: '2017-03-20', end: '2017-03-30' },
          });
          it('is enabled', () => {
              expectEnabled(initCalendar(), true);
          });
      });
      function expectEnabled(calendar, bool) {
          let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
          expect(toolbarWrapper.getButtonEnabled('prev')).toBe(bool);
      }
  });

  var css_248z = ".fc-theme-bootstrap a:not([href]){color:inherit}.fc-theme-bootstrap .fc-more-link:hover{text-decoration:none}";
  injectStyles(css_248z);

  class BootstrapTheme extends Theme {
  }
  BootstrapTheme.prototype.classes = {
      root: 'fc-theme-bootstrap',
      table: 'table-bordered',
      tableCellShaded: 'table-active',
      buttonGroup: 'btn-group',
      button: 'btn btn-primary',
      buttonActive: 'active',
      popover: 'popover',
      popoverHeader: 'popover-header',
      popoverContent: 'popover-body',
  };
  BootstrapTheme.prototype.baseIconClass = 'fa';
  BootstrapTheme.prototype.iconClasses = {
      close: 'fa-times',
      prev: 'fa-chevron-left',
      next: 'fa-chevron-right',
      prevYear: 'fa-angle-double-left',
      nextYear: 'fa-angle-double-right',
  };
  BootstrapTheme.prototype.rtlIconClasses = {
      prev: 'fa-chevron-right',
      next: 'fa-chevron-left',
      prevYear: 'fa-angle-double-right',
      nextYear: 'fa-angle-double-left',
  };
  BootstrapTheme.prototype.iconOverrideOption = 'bootstrapFontAwesome'; // TODO: make TS-friendly. move the option-processing into this plugin
  BootstrapTheme.prototype.iconOverrideCustomButtonOption = 'bootstrapFontAwesome';
  BootstrapTheme.prototype.iconOverridePrefix = 'fa-';

  var index$2 = createPlugin({
      name: '@fullcalendar/bootstrap',
      themeClasses: {
          bootstrap: BootstrapTheme,
      },
  });

  describe('customButtons', () => {
      pushOptions({
          plugins: [index$2, index$a],
      });
      it('can specify text', () => {
          let calendar = initCalendar({
              customButtons: {
                  mybutton: { text: 'asdf' },
              },
              headerToolbar: { left: 'mybutton', center: '', right: '' },
          });
          let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
          let buttonInfo = toolbarWrapper.getButtonInfo('mybutton');
          expect(buttonInfo.text).toBe('asdf');
      });
      it('can specify an icon', () => {
          let calendar = initCalendar({
              customButtons: {
                  mybutton: { icon: 'asdf' },
              },
              headerToolbar: { left: 'mybutton', center: '', right: '' },
          });
          let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
          let buttonInfo = toolbarWrapper.getButtonInfo('mybutton');
          expect(buttonInfo.iconName).toBe('asdf');
      });
      it('can specify a bootstrap font-awesome icon', () => {
          let calendar = initCalendar({
              themeSystem: 'bootstrap',
              customButtons: {
                  mybutton: { bootstrapFontAwesome: 'asdf' },
              },
              headerToolbar: { left: 'mybutton', center: '', right: '' },
          });
          let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
          let buttonInfo = toolbarWrapper.getButtonInfo('mybutton', 'fa');
          expect(buttonInfo.iconName).toBe('asdf');
      });
  });

  describe('toolbar rendering', () => {
      it('produces type="button" attributes', () => {
          let calendar = initCalendar({
              headerToolbar: {
                  left: 'today',
                  center: 'title',
                  right: 'prev,next',
              },
          });
          let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
          let todayButtonEl = toolbarWrapper.getButtonEl('today');
          let prevButtonEl = toolbarWrapper.getButtonEl('prev');
          expect(todayButtonEl.getAttribute('type')).toBe('button');
          expect(prevButtonEl.getAttribute('type')).toBe('button');
      });
  });

  /*
  TODO:
  - quick test for when button is clicked

  SEE ALSO:
  - other range intersection tests handled by next-button
  */
  describe('today button', () => {
      pushOptions({
          initialView: 'dayGridMonth',
          now: '2017-06-30',
      });
      describe('when now is in current month', () => {
          pushOptions({
              initialDate: '2017-06-01',
          });
          it('is disabled', () => {
              expectEnabled(initCalendar(), false);
          });
      });
      describe('when now is not current month, but still visible', () => {
          pushOptions({
              initialDate: '2017-07-01',
          });
          it('is enabled', () => {
              expectEnabled(initCalendar(), true);
          });
      });
      describe('when now is out of view', () => {
          pushOptions({
              initialDate: '2017-08-01',
          });
          describe('when no specified validRange', () => {
              it('is enabled', () => {
                  expectEnabled(initCalendar(), true);
              });
          });
          describe('when now\'s month is entirely before validRange', () => {
              pushOptions({
                  validRange: { start: '2017-07-02' }, // previous day is visible in the June
              });
              it('is disabled', () => {
                  expectEnabled(initCalendar(), false);
              });
          });
      });
      function expectEnabled(calendar, bool) {
          let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
          expect(toolbarWrapper.getButtonEnabled('today')).toBe(bool);
      }
  });

  /*
  TODO:
  - quick test for when button is clicked

  SEE ALSO:
  - visibleRange, dateAlignment, dateIncrement
  */
  describe('next button', () => {
      pushOptions({
          initialView: 'timeGridWeek',
          initialDate: '2017-06-08',
      });
      describe('when there is no validRange', () => {
          it('is enabled', () => {
              expectEnabled(initCalendar(), true);
          });
      });
      describe('when next date range is completely within validRange', () => {
          pushOptions({
              validRange: { end: '2018-06-10' },
              dateIncrement: { years: 1 }, // next range is 2018-06-03 - 2018-06-10
          });
          it('is enabled', () => {
              expectEnabled(initCalendar(), true);
          });
      });
      describe('when next date range is partially outside validRange', () => {
          pushOptions({
              validRange: { end: '2018-06-05' },
              dateIncrement: { years: 1 }, // next range is 2018-06-03 - 2018-06-10
          });
          it('is enabled', () => {
              expectEnabled(initCalendar(), true);
          });
      });
      describe('when next date range is completely beyond validRange', () => {
          pushOptions({
              validRange: { end: '2018-06-03' },
              dateIncrement: { years: 1 }, // next range is 2018-06-03 - 2018-06-10
          });
          it('is disabled', () => {
              expectEnabled(initCalendar(), false);
          });
      });
      describe('when day after current day is a hidden day', () => {
          pushOptions({
              initialDate: '2017-03-31',
              initialView: 'dayGridDay',
              weekends: false,
              dateIncrement: { years: 1 }, // next range is 2018-06-03 - 2018-06-10
          });
          it('is enabled', () => {
              expectEnabled(initCalendar(), true);
          });
      });
      describe('when initialDate is constrained forward to validRange and next week is valid', () => {
          pushOptions({
              initialDate: '2017-07-17',
              initialView: 'timeGridWeek',
              validRange: { start: '2036-05-03', end: '2036-06-01' },
          });
          it('is enabled', () => {
              expectEnabled(initCalendar(), true);
          });
      });
      function expectEnabled(calendar, bool) {
          let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
          expect(toolbarWrapper.getButtonEnabled('next')).toBe(bool);
      }
  });

  var l20 = {
      code: 'en-gb',
      week: {
          dow: 1,
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
      buttonHints: {
          prev: 'Previous $0',
          next: 'Next $0',
          today: 'This $0',
      },
      viewHint: '$0 view',
      navLinkHint: 'Go to $0',
      moreLinkHint(eventCnt) {
          return `Show ${eventCnt} more event${eventCnt === 1 ? '' : 's'}`;
      },
  };

  describe('eventTimeFormat', () => {
      pushOptions({
          initialDate: '2014-06-04',
          events: [{
                  title: 'my event',
                  start: '2014-06-04T15:00:00',
                  end: '2014-06-04T17:00:00',
              }],
      });
      describe('when in month view', () => {
          pushOptions({
              initialView: 'dayGridMonth',
          });
          it('renders correctly when default', () => {
              let calendar = initCalendar();
              expectEventTimeText(calendar, '3p');
          });
          it('renders correctly when default and the locale is customized', () => {
              let calendar = initCalendar({
                  locale: l20,
              });
              expectEventTimeText(calendar, '15');
          });
          it('renders correctly when customized', () => {
              let calendar = initCalendar({
                  eventTimeFormat: { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false },
              });
              expectEventTimeText(calendar, '15:00:00');
          });
      });
      describe('when in week view', () => {
          pushOptions({
              initialView: 'timeGridWeek',
          });
          it('renders correctly when default', () => {
              let calendar = initCalendar();
              expectEventTimeText(calendar, '3:00 - 5:00');
          });
          it('renders correctly when default and the locale is customized', () => {
              let calendar = initCalendar({
                  locale: l20,
              });
              expectEventTimeText(calendar, '15:00 - 17:00');
          });
          it('renders correctly when customized', () => {
              let calendar = initCalendar({
                  eventTimeFormat: { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false },
              });
              expectEventTimeText(calendar, '15:00:00 - 17:00:00');
          });
      });
      describe('when in multi-day custom dayGrid view', () => {
          pushOptions({
              views: {
                  dayGridTwoDay: {
                      type: 'dayGrid',
                      duration: { days: 2 },
                  },
              },
              initialView: 'dayGridTwoDay',
          });
          it('defaults to no end time', () => {
              let calendar = initCalendar();
              expectEventTimeText(calendar, '3p');
          });
      });
      describe('when in dayGridDay view', () => {
          pushOptions({
              initialView: 'dayGridDay',
          });
          it('defaults to showing the end time', () => {
              let calendar = initCalendar();
              expectEventTimeText(calendar, '3p - 5p');
          });
      });
      function expectEventTimeText(calendar, expected) {
          let calendarWrapper = new CalendarWrapper(calendar);
          let firstEventEl = calendarWrapper.getFirstEventEl();
          let eventInfo = calendarWrapper.getEventElInfo(firstEventEl);
          expect(eventInfo.timeText).toBe(expected);
      }
  });

  describe('when weekends option is set', () => {
      it('should show sat and sun if true', () => {
          let calendar = initCalendar({
              weekends: true,
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          expect(dayGridWrapper.getDayEls(0).length).toBeGreaterThan(0); // 0=sunday
          expect(dayGridWrapper.getDayEls(6).length).toBeGreaterThan(0); // 6=saturday
      });
      it('should not show sat and sun if false', () => {
          let calendar = initCalendar({
              weekends: false,
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          expect(dayGridWrapper.getDayEls(0).length).toBe(0); // 0=sunday
          expect(dayGridWrapper.getDayEls(6).length).toBe(0); // 6=saturday
      });
  });

  function waitEventDrag(calendar, dragging) {
      return new Promise((resolve) => {
          let modifiedEvent = false;
          calendar.on('eventDrop', (arg) => {
              modifiedEvent = arg.event;
          });
          calendar.on('_noEventDrop', () => {
              resolve(false);
          });
          dragging.then(() => {
              setTimeout(() => {
                  resolve(modifiedEvent);
              });
          });
      });
  }
  function waitEventDrag2(calendar, dragging) {
      return new Promise((resolve) => {
          let theArg = false;
          calendar.on('eventDrop', (arg) => {
              theArg = arg;
          });
          calendar.on('_noEventDrop', () => {
              resolve(false);
          });
          dragging.then(() => {
              setTimeout(() => {
                  resolve(theArg);
              });
          });
      });
  }
  function waitEventResize(calendar, dragging) {
      return new Promise((resolve) => {
          let modifiedEvent = false;
          calendar.on('eventResize', (arg) => {
              modifiedEvent = arg.event;
          });
          dragging.then(() => {
              setTimeout(() => {
                  resolve(modifiedEvent);
              });
          });
      });
  }
  function waitEventResize2(calendar, dragging) {
      return new Promise((resolve) => {
          let theArg = false;
          calendar.on('eventResize', (arg) => {
              theArg = arg;
          });
          dragging.then(() => {
              setTimeout(() => {
                  resolve(theArg);
              });
          });
      });
  }
  function waitDateSelect(calendar, dragging) {
      return new Promise((resolve) => {
          let selectInfo = null;
          calendar.on('select', (arg) => {
              selectInfo = arg;
          });
          dragging.then(() => {
              setTimeout(() => {
                  resolve(selectInfo);
              });
          });
      });
  }

  describe('eventDrop', () => {
      pushOptions({
          timeZone: 'UTC',
          initialDate: '2014-06-11',
          editable: true,
          dragScroll: false,
          longPressDelay: 100,
      });
      describe('when in month view', () => {
          pushOptions({
              initialView: 'dayGridMonth',
          });
          // TODO: test that event's dragged via touch that don't wait long enough for longPressDelay
          // SHOULD NOT drag
          [false, true].forEach((isTouch) => {
              describe('with ' + (isTouch ? 'touch' : 'mouse'), () => {
                  describe('when dragging an all-day event to another day', () => {
                      it('should be given correct arguments, with whole-day delta', (done) => {
                          let calendar = initCalendarWithSpies({
                              events: [{
                                      title: 'all-day event',
                                      start: '2014-06-11',
                                      allDay: true,
                                  }],
                          });
                          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                          let dragging = dayGridWrapper.dragEventToDate(dayGridWrapper.getFirstEventEl(), '2014-06-11', '2014-06-20', isTouch);
                          waitEventDrag2(calendar, dragging).then((arg) => {
                              let delta = createDuration({ day: 9 });
                              expect(arg.delta).toEqual(delta);
                              expect(arg.event.start).toEqualDate('2014-06-20');
                              expect(arg.event.end).toBeNull();
                              arg.revert();
                              let event = currentCalendar.getEvents()[0];
                              expect(event.start).toEqualDate('2014-06-11');
                              expect(event.end).toBeNull();
                              done();
                          });
                      });
                  });
              });
          });
          describe('when gragging a timed event to another day', () => {
              it('should be given correct arguments, with whole-day delta', (done) => {
                  let calendar = initCalendarWithSpies({
                      events: [{
                              title: 'timed event',
                              start: '2014-06-11T06:00:00',
                              allDay: false,
                          }],
                  });
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  let dragging = dayGridWrapper.dragEventToDate(dayGridWrapper.getFirstEventEl(), '2014-06-11', '2014-06-16');
                  waitEventDrag2(calendar, dragging).then((arg) => {
                      let delta = createDuration({ day: 5 });
                      expect(arg.delta).toEqual(delta);
                      expect(arg.event.start).toEqualDate('2014-06-16T06:00:00Z');
                      expect(arg.event.end).toBeNull();
                      arg.revert();
                      let event = currentCalendar.getEvents()[0];
                      expect(event.start).toEqualDate('2014-06-11T06:00:00Z');
                      expect(event.end).toBeNull();
                      done();
                  });
              });
          });
          // https://github.com/fullcalendar/fullcalendar/issues/4458
          describe('when dragging an event back in time when duration not editable', () => {
              it('should work', (done) => {
                  let calendar = initCalendarWithSpies({
                      initialDate: '2019-01-16',
                      eventDurationEditable: false,
                      events: [{
                              title: 'event',
                              start: '2019-01-16T10:30:00+00:00',
                              end: '2019-01-16T12:30:00+00:00',
                          }],
                  });
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  let dragging = dayGridWrapper.dragEventToDate(dayGridWrapper.getFirstEventEl(), '2019-01-16', '2019-01-14');
                  waitEventDrag2(calendar, dragging).then((arg) => {
                      expect(arg.delta).toEqual(createDuration({ day: -2 }));
                      expect(arg.event.start).toEqualDate('2019-01-14T10:30:00+00:00');
                      expect(arg.event.end).toEqualDate('2019-01-14T12:30:00+00:00');
                      done();
                  });
              });
          });
          // TODO: tests for eventMouseEnter/eventMouseLeave firing correctly when no dragging
          it('should not fire any eventMouseEnter/eventMouseLeave events while dragging', (done) => {
              let eventMouseEnterSpy = spyOnCalendarCallback('eventMouseEnter');
              let eventMouseLeaveSpy = spyOnCalendarCallback('eventMouseLeave');
              let calendar = initCalendar({
                  events: [
                      {
                          title: 'all-day event',
                          start: '2014-06-11',
                          allDay: true,
                          className: 'event1',
                      },
                      {
                          title: 'event2',
                          start: '2014-06-10',
                          allDay: true,
                          className: 'event2',
                      },
                  ],
              });
              let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
              $('.event1').simulate('drag', {
                  end: dayGridWrapper.getDayEl('2014-06-20'),
                  moves: 10,
                  duration: 1000,
                  onRelease() {
                      done();
                  },
              });
              setTimeout(() => {
                  $('.event2')
                      .simulate('mouseover')
                      .simulate('mouseenter')
                      .simulate('mouseout')
                      .simulate('mouseleave');
                  setTimeout(() => {
                      expect(eventMouseEnterSpy).not.toHaveBeenCalled();
                      expect(eventMouseLeaveSpy).not.toHaveBeenCalled();
                  }, 0);
              }, 500);
          });
      });
      describe('when in timeGrid view', () => {
          pushOptions({
              initialView: 'timeGridWeek',
          });
          [false, true].forEach((isTouch) => {
              describe('with ' + (isTouch ? 'touch' : 'mouse'), () => {
                  describe('when dragging a timed event to another time on a different day', () => {
                      it('should be given correct arguments and delta with days/time', (done) => {
                          let calendar = initCalendarWithSpies({
                              events: [{
                                      title: 'timed event',
                                      start: '2014-06-11T06:00:00',
                                      allDay: false,
                                  }],
                          });
                          let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                          let dragging = timeGridWrapper.dragEventToDate(timeGridWrapper.getFirstEventEl(), '2014-06-12T07:30:00');
                          waitEventDrag2(calendar, dragging).then((arg) => {
                              let delta = createDuration({ day: 1, hour: 1, minute: 30 });
                              expect(arg.delta).toEqual(delta);
                              expect(arg.event.start).toEqualDate('2014-06-12T07:30:00Z');
                              expect(arg.event.end).toBeNull();
                              arg.revert();
                              let event = currentCalendar.getEvents()[0];
                              expect(event.start).toEqualDate('2014-06-11T06:00:00Z');
                              expect(event.end).toBeNull();
                              done();
                          });
                      });
                  });
              });
          });
          describe('when dragging an all-day event to another all-day', () => {
              it('should be given correct arguments, with whole-day delta', (done) => {
                  let calendar = initCalendarWithSpies({
                      events: [{
                              title: 'all-day event',
                              start: '2014-06-11',
                              allDay: true,
                          }],
                  });
                  let dayGridWrapper = new TimeGridViewWrapper(calendar).dayGrid;
                  let dragging = dayGridWrapper.dragEventToDate(dayGridWrapper.getFirstEventEl(), '2014-06-11', '2014-06-13');
                  waitEventDrag2(calendar, dragging).then((arg) => {
                      let delta = createDuration({ day: 2 });
                      expect(arg.delta).toEqual(delta);
                      expect(arg.event.start).toEqualDate('2014-06-13');
                      expect(arg.event.end).toBeNull();
                      arg.revert();
                      let event = currentCalendar.getEvents()[0];
                      expect(event.start).toEqualDate('2014-06-11');
                      expect(event.end).toBeNull();
                      done();
                  });
              });
          });
          describe('when dragging an all-day event to a time slot on a different day', () => {
              it('should be given correct arguments and delta with days/time', (done) => {
                  let calendar = initCalendarWithSpies({
                      scrollTime: '01:00:00',
                      height: 400,
                      events: [{
                              title: 'all-day event',
                              start: '2014-06-11',
                              allDay: true,
                          }],
                  });
                  let viewWrapper = new TimeGridViewWrapper(calendar);
                  let dragging = viewWrapper.timeGrid.dragEventToDate(viewWrapper.dayGrid.getFirstEventEl(), '2014-06-10T01:00:00');
                  waitEventDrag2(calendar, dragging).then((arg) => {
                      let delta = createDuration({ day: -1, hour: 1 });
                      expect(arg.delta).toEqual(delta);
                      expect(arg.event.start).toEqualDate('2014-06-10T01:00:00Z');
                      expect(arg.event.end).toBeNull();
                      expect(arg.event.allDay).toBe(false);
                      arg.revert();
                      let event = currentCalendar.getEvents()[0];
                      expect(event.start).toEqualDate('2014-06-11');
                      expect(event.end).toBeNull();
                      expect(event.allDay).toBe(true);
                      done();
                  });
              });
          });
          describe('when dragging a timed event to an all-day slot on a different day', () => {
              it('should be given correct arguments, with whole-day delta', (done) => {
                  let calendar = initCalendarWithSpies({
                      scrollTime: '01:00:00',
                      height: 400,
                      events: [{
                              title: 'timed event',
                              start: '2014-06-11T01:00:00',
                              allDay: false,
                          }],
                  });
                  let viewWrapper = new TimeGridViewWrapper(calendar);
                  let dragging = viewWrapper.dayGrid.dragEventToDate(viewWrapper.timeGrid.getFirstEventEl(), null, '2014-06-10');
                  waitEventDrag2(calendar, dragging).then((arg) => {
                      let delta = createDuration({ day: -1 });
                      expect(arg.delta).toEqual(delta);
                      expect(arg.event.start).toEqualDate('2014-06-10');
                      expect(arg.event.end).toBeNull();
                      expect(arg.event.allDay).toBe(true);
                      arg.revert();
                      let event = currentCalendar.getEvents()[0];
                      expect(event.start).toEqualDate('2014-06-11T01:00:00Z');
                      expect(event.end).toBeNull();
                      expect(event.allDay).toBe(false);
                      done();
                  });
              });
          });
          describe('when dragging a timed event with no end time', () => {
              it('should continue to only show the updated start time', (done) => {
                  let dragged = false;
                  let calendar = initCalendarWithSpies({
                      scrollTime: '01:00:00',
                      height: 400,
                      events: [{
                              title: 'timed event',
                              start: '2014-06-11T01:00:00',
                              allDay: false,
                          }],
                  });
                  let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                  let dragging = timeGridWrapper.dragEventToDate(timeGridWrapper.getFirstEventEl(), '2014-06-11T02:30:00', () => {
                      dragged = true;
                      let mirrorEls = timeGridWrapper.getMirrorEls();
                      expect(mirrorEls.length).toBe(1);
                      expect(queryEventElInfo(mirrorEls[0]).timeText).toBe('2:30');
                  });
                  waitEventDrag2(calendar, dragging).then(() => {
                      expect(dragged).toBe(true);
                      done();
                  });
              });
          });
          describe('when dragging a timed event with an end time', () => {
              it('should continue to show the updated start and end time', (done) => {
                  let dragged = false;
                  let calendar = initCalendarWithSpies({
                      scrollTime: '01:00:00',
                      height: 400,
                      events: [{
                              title: 'timed event',
                              start: '2014-06-11T01:00:00',
                              end: '2014-06-11T02:00:00',
                              allDay: false,
                          }],
                  });
                  let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                  let dragging = timeGridWrapper.dragEventToDate(timeGridWrapper.getFirstEventEl(), '2014-06-11T02:30:00', () => {
                      dragged = true;
                      let mirrorEls = timeGridWrapper.getMirrorEls();
                      expect(mirrorEls.length).toBe(1);
                      expect(queryEventElInfo(mirrorEls[0]).timeText).toBe('2:30 - 3:30');
                  });
                  waitEventDrag2(calendar, dragging).then(() => {
                      expect(dragged).toBe(true);
                      done();
                  });
              });
          });
          // https://github.com/fullcalendar/fullcalendar/issues/4503
          describe('when dragging to one of the last slots', () => {
              it('should work', (done) => {
                  let calendar = initCalendarWithSpies({
                      scrollTime: '23:00:00',
                      height: 400,
                      events: [{
                              title: 'timed event',
                              start: '2014-06-11T18:00:00',
                              allDay: false,
                          }],
                  });
                  let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                  let dragging = timeGridWrapper.dragEventToDate(timeGridWrapper.getFirstEventEl(), '2014-06-11T23:30:00');
                  waitEventDrag2(calendar, dragging).then(() => {
                      let event = currentCalendar.getEvents()[0];
                      expect(event.start).toEqualDate('2014-06-11T23:30:00Z');
                      expect(event.end).toBeNull();
                      expect(event.allDay).toBe(false);
                      done();
                  });
              });
          });
      });
      // Initialize a calendar, run a drag, and do type-checking of all arguments for all handlers.
      // TODO: more discrimination instead of just checking for 'object'
      function initCalendarWithSpies(options) {
          options.eventDragStart = (arg) => {
              expect(arg.el instanceof Element).toBe(true);
              expect(arg.el).toHaveClass(CalendarWrapper.EVENT_CLASSNAME);
              expect(typeof arg.event).toBe('object');
              expect(typeof arg.jsEvent).toBe('object');
              expect(typeof arg.view).toBe('object');
          };
          options.eventDragStop = (arg) => {
              expect(options.eventDragStart).toHaveBeenCalled();
              expect(arg.el instanceof Element).toBe(true);
              expect(arg.el).toHaveClass(CalendarWrapper.EVENT_CLASSNAME);
              expect(typeof arg.event).toBe('object');
              expect(typeof arg.jsEvent).toBe('object');
              expect(typeof arg.view).toBe('object');
          };
          options.eventDrop = (arg) => {
              expect(options.eventDragStop).toHaveBeenCalled();
              expect(arg.el instanceof Element).toBe(true);
              expect(arg.el).toHaveClass(CalendarWrapper.EVENT_CLASSNAME);
              expect(typeof arg.delta).toBe('object');
              expect(typeof arg.revert).toBe('function');
              expect(typeof arg.jsEvent).toBe('object');
              expect(typeof arg.view).toBe('object');
          };
          spyOn(options, 'eventDragStart').and.callThrough();
          spyOn(options, 'eventDragStop').and.callThrough();
          return initCalendar(options);
      }
  });

  describe('events as a function', () => {
      pushOptions({
          initialView: 'dayGridMonth',
          initialDate: '2014-05-01',
      });
      function testEventFunctionParams(arg, callback) {
          expect(arg.start instanceof Date).toEqual(true);
          expect(arg.end instanceof Date).toEqual(true);
          expect(typeof callback).toEqual('function');
      }
      it('requests correctly when local timezone', (done) => {
          initCalendar({
              timeZone: 'local',
              events(arg, callback) {
                  testEventFunctionParams(arg, callback);
                  expect(arg.timeZone).toEqual('local');
                  expect(arg.start).toEqualLocalDate('2014-04-27T00:00:00');
                  expect(arg.startStr).toMatch(/^2014-04-27T00:00:00[-+]/);
                  expect(arg.end).toEqualLocalDate('2014-06-08T00:00:00');
                  expect(arg.endStr).toMatch(/^2014-06-08T00:00:00[-+]/);
                  callback([]);
                  setTimeout(done); // :(
              },
          });
      });
      it('requests correctly when UTC timezone', (done) => {
          initCalendar({
              timeZone: 'UTC',
              events(arg, callback) {
                  testEventFunctionParams(arg, callback);
                  expect(arg.timeZone).toEqual('UTC');
                  expect(arg.start).toEqualDate('2014-04-27T00:00:00Z');
                  expect(arg.startStr).toEqual('2014-04-27T00:00:00Z');
                  expect(arg.end).toEqualDate('2014-06-08T00:00:00Z');
                  expect(arg.endStr).toEqual('2014-06-08T00:00:00Z');
                  callback([]);
                  setTimeout(done); // :(
              },
          });
      });
      it('requests correctly when custom timezone', (done) => {
          initCalendar({
              timeZone: 'America/Chicago',
              events(arg, callback) {
                  testEventFunctionParams(arg, callback);
                  expect(arg.timeZone).toEqual('America/Chicago');
                  expect(arg.start).toEqualDate('2014-04-27T00:00:00Z');
                  expect(arg.startStr).toEqual('2014-04-27T00:00:00'); // no Z
                  expect(arg.end).toEqualDate('2014-06-08T00:00:00Z');
                  expect(arg.endStr).toEqual('2014-06-08T00:00:00'); // no Z
                  callback([]);
                  setTimeout(done); // :(
              },
          });
      });
      it('requests correctly when timezone changed dynamically', (done) => {
          let callCnt = 0;
          let options = {
              timeZone: 'America/Chicago',
              events(arg, callback) {
                  testEventFunctionParams(arg, callback);
                  callCnt += 1;
                  if (callCnt === 1) {
                      expect(arg.timeZone).toEqual('America/Chicago');
                      expect(arg.start).toEqualDate('2014-04-27');
                      expect(arg.end).toEqualDate('2014-06-08');
                      setTimeout(() => {
                          currentCalendar.setOption('timeZone', 'UTC');
                      }, 0);
                  }
                  else if (callCnt === 2) {
                      expect(arg.timeZone).toEqual('UTC');
                      expect(arg.start).toEqualDate('2014-04-27');
                      expect(arg.end).toEqualDate('2014-06-08');
                      setTimeout(done); // :(
                  }
              },
          };
          initCalendar(options);
      });
      it('requests correctly with event source extended form', (done) => {
          let eventSource = {
              className: 'customeventclass',
              events(arg, callback) {
                  testEventFunctionParams(arg, callback);
                  expect(arg.timeZone).toEqual('UTC');
                  expect(arg.start).toEqualDate('2014-04-27');
                  expect(arg.end).toEqualDate('2014-06-08');
                  callback([
                      {
                          title: 'event1',
                          start: '2014-05-10',
                      },
                  ]);
              },
          };
          spyOn(eventSource, 'events').and.callThrough();
          initCalendar({
              timeZone: 'UTC',
              eventSources: [eventSource],
              eventDidMount(arg) {
                  expect(eventSource.events.calls.count()).toEqual(1);
                  expect(arg.el).toHaveClass('customeventclass');
                  setTimeout(done); // :(
              },
          });
      });
      it('can return a promise-like object', (done) => {
          let calendar = initCalendar({
              events() {
                  let deferred = $.Deferred(); // we want tests to run in IE11, which doesn't have native promises
                  setTimeout(() => {
                      deferred.resolve([
                          { start: '2018-09-04' },
                      ]);
                  }, 100);
                  return deferred.promise();
              },
          });
          setTimeout(() => {
              expect(calendar.getEvents().length).toBe(1);
              setTimeout(done); // :(
          }, 101);
      });
  });

  const RED_REGEX = /red|rgb\(255,\s*0,\s*0\)/;
  function getStockScrollbarWidths(direction) {
      let el = $('<div><div style="position:relative"/></div>')
          .css({
          position: 'absolute',
          top: -1000,
          left: 0,
          border: 0,
          padding: 0,
          overflow: 'scroll',
          direction: direction || 'ltr',
      })
          .appendTo('body');
      let elRect = el[0].getBoundingClientRect();
      let innerEl = el.children();
      let innerElRect = innerEl[0].getBoundingClientRect();
      let girths = {
          left: innerElRect.left - elRect.left,
          right: elRect.left + elRect.width - innerElRect.left,
          top: innerElRect.top - elRect.top,
          bottom: elRect.top + elRect.height - innerElRect.top,
      };
      el.remove();
      return girths;
  }
  function filterVisibleEls(els) {
      return els.filter((el) => {
          let $el = $(el);
          return $el.is(':visible') && $el.css('visibility') !== 'hidden';
      });
  }
  // TODO: make sure these matchers are loaded globally first
  beforeEach(() => {
      jasmine.addMatchers({
          toHaveScrollbars() {
              return {
                  compare(actual) {
                      let elm = $(actual);
                      let result = {
                          pass: elm[0].scrollWidth - 1 > elm[0].clientWidth || // -1 !!!
                              elm[0].scrollHeight - 1 > elm[0].clientHeight, // -1 !!!
                      };
                      // !!! - IE was reporting a scrollWidth/scrollHeight 1 pixel taller than what it was :(
                      return result;
                  },
              };
          },
      });
  });

  describe('computeEdges', () => {
      defineTests('when margin', { margin: '5px 10px' });
      defineTests('when padding', { padding: '5px 10px' });
      defineTests('when border', { border: '5px solid red' });
      defineTests('when border and padding', { border: '5px solid red', padding: '5px 10px' });
      function defineTests(description, cssProps) {
          describe(description, () => {
              describe('when no scrolling', () => {
                  describe('when LTR', () => {
                      defineTest(false, 'ltr', cssProps);
                  });
                  describe('when RTL', () => {
                      defineTest(false, 'rtl', cssProps);
                  });
              });
              describe('when scrolling', () => {
                  describe('when LTR', () => {
                      defineTest(true, 'ltr', cssProps);
                  });
                  describe('when RTL', () => {
                      defineTest(true, 'rtl', cssProps);
                  });
              });
          });
      }
      function defineTest(isScrolling, direction, cssProps) {
          it('computes correct widths', () => {
              let el = $('<div style="position:absolute" />')
                  .css('overflow', isScrolling ? 'scroll' : 'hidden')
                  .css('direction', direction)
                  .css(cssProps)
                  .append('<div style="position:relative;width:100px;height:100px" />')
                  .appendTo('body');
              let edges = computeEdges(el[0]);
              let correctWidths;
              if (isScrolling) {
                  correctWidths = getStockScrollbarWidths(direction);
              }
              else {
                  correctWidths = { left: 0, right: 0, bottom: 0 };
              }
              expect(edges.scrollbarLeft).toBe(correctWidths.left);
              expect(edges.scrollbarRight).toBe(correctWidths.right);
              expect(edges.scrollbarBottom).toBe(correctWidths.bottom);
              el.remove();
          });
      }
  });

  describe('events as an array', () => {
      pushOptions({
          initialView: 'dayGridMonth',
          initialDate: '2014-05-01',
      });
      function getEventArray() {
          return [
              {
                  title: 'my event',
                  start: '2014-05-21',
              },
          ];
      }
      it('accepts an event using dayGrid form', (done) => {
          initCalendar({
              events: getEventArray(),
              eventDidMount(arg) {
                  expect(arg.event.title).toEqual('my event');
                  done();
              },
          });
      });
      it('accepts an event using extended form', (done) => {
          initCalendar({
              eventSources: [
                  {
                      classNames: 'customeventclass',
                      events: getEventArray(),
                  },
              ],
              eventDidMount(arg) {
                  expect(arg.event.title).toEqual('my event');
                  expect(arg.el).toHaveClass('customeventclass');
                  done();
              },
          });
      });
      it('doesn\'t mutate the original array', (done) => {
          let eventArray = getEventArray();
          let origArray = eventArray;
          let origEvent = eventArray[0];
          initCalendar({
              events: eventArray,
              eventDidMount() {
                  expect(origArray).toEqual(eventArray);
                  expect(origEvent).toEqual(eventArray[0]);
                  done();
              },
          });
      });
  });

  describe('headerToolbar rendering', () => {
      it('renders the default headerToolbar option', () => {
          let calendar = initCalendar();
          let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
          expect(toolbarWrapper.getSectionContent(0)).toEqual([{ type: 'title' }]);
          expect(toolbarWrapper.getSectionContent(1)).toEqual([]);
          expect(toolbarWrapper.getSectionContent(2)).toEqual([
              { type: 'button', name: 'today' },
              {
                  type: 'button-group',
                  children: [
                      { type: 'button', name: 'prev' },
                      { type: 'button', name: 'next' },
                  ],
              },
          ]);
      });
      it('renders a given headerToolbar option', () => {
          let calendar = initCalendar({
              headerToolbar: {
                  left: 'next,prev',
                  center: 'prevYear today nextYear timeGridDay,timeGridWeek',
                  right: 'title',
              },
          });
          let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
          expect(toolbarWrapper.getSectionContent(0)).toEqual([
              {
                  type: 'button-group',
                  children: [
                      { type: 'button', name: 'next' },
                      { type: 'button', name: 'prev' },
                  ],
              },
          ]);
          expect(toolbarWrapper.getSectionContent(1)).toEqual([
              { type: 'button', name: 'prevYear' },
              { type: 'button', name: 'today' },
              { type: 'button', name: 'nextYear' },
              {
                  type: 'button-group',
                  children: [
                      { type: 'button', name: 'timeGridDay' },
                      { type: 'button', name: 'timeGridWeek' },
                  ],
              },
          ]);
          expect(toolbarWrapper.getSectionContent(2)).toEqual([
              { type: 'title' },
          ]);
      });
      describe('when setting headerToolbar to false', () => {
          pushOptions({
              headerToolbar: false,
          });
          it('should not have headerToolbar', () => {
              let calendar = initCalendar();
              let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
              expect(toolbarWrapper).toBeFalsy();
          });
      });
      it('allow for dynamically changing', () => {
          let calendar = initCalendar();
          let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
          expect(toolbarWrapper).toBeTruthy();
          calendar.setOption('headerToolbar', false);
          toolbarWrapper = new CalendarWrapper(calendar).toolbar;
          expect(toolbarWrapper).toBeFalsy();
      });
      describeOptions('direction', {
          'when direction is LTR': 'ltr',
          'when direction is RTL': 'rtl',
      }, () => {
          it('renders left and right literally', () => {
              let calendar = initCalendar({
                  headerToolbar: {
                      left: 'prev',
                      center: 'today',
                      right: 'next',
                  },
              });
              let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
              expect(toolbarWrapper.getSectionContent(0)).toEqual([
                  { type: 'button', name: 'prev' },
              ]);
              expect(toolbarWrapper.getSectionContent(1)).toEqual([
                  { type: 'button', name: 'today' },
              ]);
              expect(toolbarWrapper.getSectionContent(2)).toEqual([
                  { type: 'button', name: 'next' },
              ]);
          });
      });
      describe('when calendar is within a form', () => {
          it('should not submit the form when clicking the button', (done) => {
              let unloadCalled = false;
              let el = $('<div id="calendar"/>')
                  .wrap('<form action="https://google.com/"></form>')
                  .appendTo('body');
              function beforeUnloadHandler() {
                  console.log('when calendar is within a form, it submits!!!'); // eslint-disable-line no-console
                  unloadCalled = true;
                  cleanup();
                  return 'click stay on this page';
              }
              $(window).on('beforeunload', beforeUnloadHandler);
              function cleanup() {
                  el.remove();
                  $(window).off('beforeunload', beforeUnloadHandler);
              }
              let calendar = initCalendar({
                  headerToolbar: {
                      left: 'prev,next',
                      right: 'title',
                  },
              }, el);
              let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
              $(toolbarWrapper.getButtonEl('next')).simulate('click');
              setTimeout(() => {
                  expect(unloadCalled).toBe(false);
                  cleanup();
                  done();
              }, 100);
          });
      });
  });

  describe('defaultAllDayEventDuration', () => {
      pushOptions({
          initialDate: '2014-05-01',
          initialView: 'dayGridMonth',
          timeZone: 'UTC',
      });
      describe('when forceEventDuration is on', () => {
          pushOptions({
              forceEventDuration: true,
          });
          it('correctly calculates an unspecified end when using a Duration object input', () => {
              initCalendar({
                  defaultAllDayEventDuration: { days: 2 },
                  events: [
                      {
                          allDay: true,
                          start: '2014-05-05',
                      },
                  ],
              });
              let event = currentCalendar.getEvents()[0];
              expect(event.end).toEqualDate('2014-05-07');
          });
          it('correctly calculates an unspecified end when using a string Duration input', () => {
              initCalendar({
                  defaultAllDayEventDuration: '3.00:00:00',
                  events: [
                      {
                          allDay: true,
                          start: '2014-05-05',
                      },
                  ],
              });
              let event = currentCalendar.getEvents()[0];
              expect(event.end).toEqualDate('2014-05-08');
          });
      });
      describe('when forceEventDuration is off', () => {
          pushOptions({
              forceEventDuration: false,
          });
          describeOptions('initialView', {
              'with dayGridWeek view': 'dayGridWeek',
              'with week view': 'timeGridWeek',
          }, () => {
              it('renders an all-day event with no `end` to appear to have the default duration', () => {
                  let calendar = initCalendar({
                      defaultAllDayEventDuration: { days: 2 },
                      events: [
                          {
                              // a control. so we know how wide it should be
                              title: 'control event',
                              allDay: true,
                              start: '2014-04-28',
                              end: '2014-04-30',
                          },
                          {
                              // one day after the control. no specified end
                              title: 'test event',
                              allDay: true,
                              start: '2014-04-28',
                          },
                      ],
                  });
                  let calendarWrapper = new CalendarWrapper(calendar);
                  let eventElms = calendarWrapper.getEventEls();
                  let width0 = eventElms[0].offsetWidth;
                  let width1 = eventElms[1].offsetWidth;
                  expect(width0).toBeGreaterThan(0);
                  expect(width0).toEqual(width1);
              });
          });
      });
  });

  describe('TimeGrid event rendering', () => {
      pushOptions({
          initialDate: '2014-08-23',
          initialView: 'timeGridWeek',
          scrollTime: '00:00:00',
      });
      it('renders the start and end time of an event that spans only 1 day', () => {
          let calendar = initCalendar({
              events: [{
                      title: 'event1',
                      start: '2014-08-18T02:00:00',
                      end: '2014-08-18T22:00:00',
                  }],
          });
          let calendarWrapper = new CalendarWrapper(calendar);
          let eventEl = calendarWrapper.getFirstEventEl();
          let eventText = calendarWrapper.getEventElInfo(eventEl).timeText;
          expect(eventText).toBe('2:00 - 10:00');
      });
      it('renders time to/from midnight for an event that spans two days', () => {
          let calendar = initCalendar({
              events: [{
                      title: 'event1',
                      start: '2014-08-18T02:00:00',
                      end: '2014-08-19T22:00:00',
                  }],
          });
          let calendarWrapper = new CalendarWrapper(calendar);
          let eventEls = calendarWrapper.getEventEls();
          let eventText0 = calendarWrapper.getEventElInfo(eventEls[0]).timeText;
          let eventText1 = calendarWrapper.getEventElInfo(eventEls[1]).timeText;
          expect(eventText0).toBe('2:00 - 12:00');
          expect(eventText1).toBe('12:00 - 10:00');
      });
      it('renders no time on an event segment that spans through an entire day', () => {
          let calendar = initCalendar({
              events: [{
                      title: 'event1',
                      start: '2014-08-18T02:00:00',
                      end: '2014-08-20T22:00:00',
                  }],
          });
          let calendarWrapper = new CalendarWrapper(calendar);
          let eventEls = calendarWrapper.getEventEls();
          let eventText1 = calendarWrapper.getEventElInfo(eventEls[1]).timeText;
          expect(eventText1).toBe('');
      });
      it('renders an event with no url with no <a> href', () => {
          let calendar = initCalendar({
              events: [{
                      title: 'event1',
                      start: '2014-08-18T02:00:00',
                  }],
          });
          let calendarWrapper = new CalendarWrapper(calendar);
          let eventEl = calendarWrapper.getFirstEventEl();
          expect(eventEl).not.toHaveAttr('href');
      });
      it('renders an event with a url with an <a> href', () => {
          let calendar = initCalendar({
              events: [{
                      title: 'event1',
                      start: '2014-08-18T02:00:00',
                      url: 'http://google.com/',
                  }],
          });
          let calendarWrapper = new CalendarWrapper(calendar);
          let eventEl = calendarWrapper.getFirstEventEl();
          expect(eventEl).toHaveAttr('href');
      });
  });

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function unwrapExports (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  /**
   * Helpers.
   */

  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;

  /**
   * Parse or format the given `val`.
   *
   * Options:
   *
   *  - `long` verbose formatting [false]
   *
   * @param {String|Number} val
   * @param {Object} [options]
   * @throws {Error} throw an error if val is not a non-empty string or a number
   * @return {String|Number}
   * @api public
   */

  var ms = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === 'string' && val.length > 0) {
      return parse(val);
    } else if (type === 'number' && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      'val is not a non-empty string or a valid number. val=' +
        JSON.stringify(val)
    );
  };

  /**
   * Parse the given `str` and return milliseconds.
   *
   * @param {String} str
   * @return {Number}
   * @api private
   */

  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y;
      case 'weeks':
      case 'week':
      case 'w':
        return n * w;
      case 'days':
      case 'day':
      case 'd':
        return n * d;
      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h;
      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m;
      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s;
      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;
      default:
        return undefined;
    }
  }

  /**
   * Short format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + 'd';
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + 'h';
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + 'm';
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + 's';
    }
    return ms + 'ms';
  }

  /**
   * Long format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, 'day');
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, 'hour');
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, 'minute');
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, 'second');
    }
    return ms + ' ms';
  }

  /**
   * Pluralization helper.
   */

  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
  }

  /**
   * This is the common logic for both the Node.js and web browser
   * implementations of `debug()`.
   */

  function setup(env) {
  	createDebug.debug = createDebug;
  	createDebug.default = createDebug;
  	createDebug.coerce = coerce;
  	createDebug.disable = disable;
  	createDebug.enable = enable;
  	createDebug.enabled = enabled;
  	createDebug.humanize = ms;
  	createDebug.destroy = destroy;

  	Object.keys(env).forEach(key => {
  		createDebug[key] = env[key];
  	});

  	/**
  	* The currently active debug mode names, and names to skip.
  	*/

  	createDebug.names = [];
  	createDebug.skips = [];

  	/**
  	* Map of special "%n" handling functions, for the debug "format" argument.
  	*
  	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  	*/
  	createDebug.formatters = {};

  	/**
  	* Selects a color for a debug namespace
  	* @param {String} namespace The namespace string for the for the debug instance to be colored
  	* @return {Number|String} An ANSI color code for the given namespace
  	* @api private
  	*/
  	function selectColor(namespace) {
  		let hash = 0;

  		for (let i = 0; i < namespace.length; i++) {
  			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
  			hash |= 0; // Convert to 32bit integer
  		}

  		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  	}
  	createDebug.selectColor = selectColor;

  	/**
  	* Create a debugger with the given `namespace`.
  	*
  	* @param {String} namespace
  	* @return {Function}
  	* @api public
  	*/
  	function createDebug(namespace) {
  		let prevTime;
  		let enableOverride = null;

  		function debug(...args) {
  			// Disabled?
  			if (!debug.enabled) {
  				return;
  			}

  			const self = debug;

  			// Set `diff` timestamp
  			const curr = Number(new Date());
  			const ms = curr - (prevTime || curr);
  			self.diff = ms;
  			self.prev = prevTime;
  			self.curr = curr;
  			prevTime = curr;

  			args[0] = createDebug.coerce(args[0]);

  			if (typeof args[0] !== 'string') {
  				// Anything else let's inspect with %O
  				args.unshift('%O');
  			}

  			// Apply any `formatters` transformations
  			let index = 0;
  			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
  				// If we encounter an escaped % then don't increase the array index
  				if (match === '%%') {
  					return '%';
  				}
  				index++;
  				const formatter = createDebug.formatters[format];
  				if (typeof formatter === 'function') {
  					const val = args[index];
  					match = formatter.call(self, val);

  					// Now we need to remove `args[index]` since it's inlined in the `format`
  					args.splice(index, 1);
  					index--;
  				}
  				return match;
  			});

  			// Apply env-specific formatting (colors, etc.)
  			createDebug.formatArgs.call(self, args);

  			const logFn = self.log || createDebug.log;
  			logFn.apply(self, args);
  		}

  		debug.namespace = namespace;
  		debug.useColors = createDebug.useColors();
  		debug.color = createDebug.selectColor(namespace);
  		debug.extend = extend;
  		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

  		Object.defineProperty(debug, 'enabled', {
  			enumerable: true,
  			configurable: false,
  			get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,
  			set: v => {
  				enableOverride = v;
  			}
  		});

  		// Env-specific initialization logic for debug instances
  		if (typeof createDebug.init === 'function') {
  			createDebug.init(debug);
  		}

  		return debug;
  	}

  	function extend(namespace, delimiter) {
  		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
  		newDebug.log = this.log;
  		return newDebug;
  	}

  	/**
  	* Enables a debug mode by namespaces. This can include modes
  	* separated by a colon and wildcards.
  	*
  	* @param {String} namespaces
  	* @api public
  	*/
  	function enable(namespaces) {
  		createDebug.save(namespaces);

  		createDebug.names = [];
  		createDebug.skips = [];

  		let i;
  		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  		const len = split.length;

  		for (i = 0; i < len; i++) {
  			if (!split[i]) {
  				// ignore empty strings
  				continue;
  			}

  			namespaces = split[i].replace(/\*/g, '.*?');

  			if (namespaces[0] === '-') {
  				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
  			} else {
  				createDebug.names.push(new RegExp('^' + namespaces + '$'));
  			}
  		}
  	}

  	/**
  	* Disable debug output.
  	*
  	* @return {String} namespaces
  	* @api public
  	*/
  	function disable() {
  		const namespaces = [
  			...createDebug.names.map(toNamespace),
  			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
  		].join(',');
  		createDebug.enable('');
  		return namespaces;
  	}

  	/**
  	* Returns true if the given mode name is enabled, false otherwise.
  	*
  	* @param {String} name
  	* @return {Boolean}
  	* @api public
  	*/
  	function enabled(name) {
  		if (name[name.length - 1] === '*') {
  			return true;
  		}

  		let i;
  		let len;

  		for (i = 0, len = createDebug.skips.length; i < len; i++) {
  			if (createDebug.skips[i].test(name)) {
  				return false;
  			}
  		}

  		for (i = 0, len = createDebug.names.length; i < len; i++) {
  			if (createDebug.names[i].test(name)) {
  				return true;
  			}
  		}

  		return false;
  	}

  	/**
  	* Convert regexp to namespace
  	*
  	* @param {RegExp} regxep
  	* @return {String} namespace
  	* @api private
  	*/
  	function toNamespace(regexp) {
  		return regexp.toString()
  			.substring(2, regexp.toString().length - 2)
  			.replace(/\.\*\?$/, '*');
  	}

  	/**
  	* Coerce `val`.
  	*
  	* @param {Mixed} val
  	* @return {Mixed}
  	* @api private
  	*/
  	function coerce(val) {
  		if (val instanceof Error) {
  			return val.stack || val.message;
  		}
  		return val;
  	}

  	/**
  	* XXX DO NOT USE. This is a temporary stub function.
  	* XXX It WILL be removed in the next major release.
  	*/
  	function destroy() {
  		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
  	}

  	createDebug.enable(createDebug.load());

  	return createDebug;
  }

  var common = setup;

  var browser = createCommonjsModule(function (module, exports) {
  /* eslint-env browser */

  /**
   * This is the web browser implementation of `debug()`.
   */

  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
  	let warned = false;

  	return () => {
  		if (!warned) {
  			warned = true;
  			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
  		}
  	};
  })();

  /**
   * Colors.
   */

  exports.colors = [
  	'#0000CC',
  	'#0000FF',
  	'#0033CC',
  	'#0033FF',
  	'#0066CC',
  	'#0066FF',
  	'#0099CC',
  	'#0099FF',
  	'#00CC00',
  	'#00CC33',
  	'#00CC66',
  	'#00CC99',
  	'#00CCCC',
  	'#00CCFF',
  	'#3300CC',
  	'#3300FF',
  	'#3333CC',
  	'#3333FF',
  	'#3366CC',
  	'#3366FF',
  	'#3399CC',
  	'#3399FF',
  	'#33CC00',
  	'#33CC33',
  	'#33CC66',
  	'#33CC99',
  	'#33CCCC',
  	'#33CCFF',
  	'#6600CC',
  	'#6600FF',
  	'#6633CC',
  	'#6633FF',
  	'#66CC00',
  	'#66CC33',
  	'#9900CC',
  	'#9900FF',
  	'#9933CC',
  	'#9933FF',
  	'#99CC00',
  	'#99CC33',
  	'#CC0000',
  	'#CC0033',
  	'#CC0066',
  	'#CC0099',
  	'#CC00CC',
  	'#CC00FF',
  	'#CC3300',
  	'#CC3333',
  	'#CC3366',
  	'#CC3399',
  	'#CC33CC',
  	'#CC33FF',
  	'#CC6600',
  	'#CC6633',
  	'#CC9900',
  	'#CC9933',
  	'#CCCC00',
  	'#CCCC33',
  	'#FF0000',
  	'#FF0033',
  	'#FF0066',
  	'#FF0099',
  	'#FF00CC',
  	'#FF00FF',
  	'#FF3300',
  	'#FF3333',
  	'#FF3366',
  	'#FF3399',
  	'#FF33CC',
  	'#FF33FF',
  	'#FF6600',
  	'#FF6633',
  	'#FF9900',
  	'#FF9933',
  	'#FFCC00',
  	'#FFCC33'
  ];

  /**
   * Currently only WebKit-based Web Inspectors, Firefox >= v31,
   * and the Firebug extension (any Firefox version) are known
   * to support "%c" CSS customizations.
   *
   * TODO: add a `localStorage` variable to explicitly enable/disable colors
   */

  // eslint-disable-next-line complexity
  function useColors() {
  	// NB: In an Electron preload script, document will be defined but not fully
  	// initialized. Since we know we're in Chrome, we'll just detect this case
  	// explicitly
  	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
  		return true;
  	}

  	// Internet Explorer and Edge do not support colors.
  	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
  		return false;
  	}

  	// Is webkit? http://stackoverflow.com/a/16459606/376773
  	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
  		// Is firebug? http://stackoverflow.com/a/398120/376773
  		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
  		// Is firefox >= v31?
  		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
  		// Double check webkit in userAgent just in case we are in a worker
  		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
  }

  /**
   * Colorize log arguments if enabled.
   *
   * @api public
   */

  function formatArgs(args) {
  	args[0] = (this.useColors ? '%c' : '') +
  		this.namespace +
  		(this.useColors ? ' %c' : ' ') +
  		args[0] +
  		(this.useColors ? '%c ' : ' ') +
  		'+' + module.exports.humanize(this.diff);

  	if (!this.useColors) {
  		return;
  	}

  	const c = 'color: ' + this.color;
  	args.splice(1, 0, c, 'color: inherit');

  	// The final "%c" is somewhat tricky, because there could be other
  	// arguments passed either before or after the %c, so we need to
  	// figure out the correct index to insert the CSS into
  	let index = 0;
  	let lastC = 0;
  	args[0].replace(/%[a-zA-Z%]/g, match => {
  		if (match === '%%') {
  			return;
  		}
  		index++;
  		if (match === '%c') {
  			// We only are interested in the *last* %c
  			// (the user may have provided their own)
  			lastC = index;
  		}
  	});

  	args.splice(lastC, 0, c);
  }

  /**
   * Invokes `console.debug()` when available.
   * No-op when `console.debug` is not a "function".
   * If `console.debug` is not available, falls back
   * to `console.log`.
   *
   * @api public
   */
  exports.log = console.debug || console.log || (() => {});

  /**
   * Save `namespaces`.
   *
   * @param {String} namespaces
   * @api private
   */
  function save(namespaces) {
  	try {
  		if (namespaces) {
  			exports.storage.setItem('debug', namespaces);
  		} else {
  			exports.storage.removeItem('debug');
  		}
  	} catch (error) {
  		// Swallow
  		// XXX (@Qix-) should we be logging these?
  	}
  }

  /**
   * Load `namespaces`.
   *
   * @return {String} returns the previously persisted debug modes
   * @api private
   */
  function load() {
  	let r;
  	try {
  		r = exports.storage.getItem('debug');
  	} catch (error) {
  		// Swallow
  		// XXX (@Qix-) should we be logging these?
  	}

  	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  	if (!r && typeof process !== 'undefined' && 'env' in process) {
  		r = process.env.DEBUG;
  	}

  	return r;
  }

  /**
   * Localstorage attempts to return the localstorage.
   *
   * This is necessary because safari throws
   * when a user disables cookies/localstorage
   * and you attempt to access it.
   *
   * @return {LocalStorage}
   * @api private
   */

  function localstorage() {
  	try {
  		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
  		// The Browser also has localStorage in the global context.
  		return localStorage;
  	} catch (error) {
  		// Swallow
  		// XXX (@Qix-) should we be logging these?
  	}
  }

  module.exports = common(exports);

  const {formatters} = module.exports;

  /**
   * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
   */

  formatters.j = function (v) {
  	try {
  		return JSON.stringify(v);
  	} catch (error) {
  		return '[UnexpectedJSONParseError]: ' + error.message;
  	}
  };
  });
  browser.formatArgs;
  browser.save;
  browser.load;
  browser.useColors;
  browser.storage;
  browser.destroy;
  browser.colors;
  browser.log;

  let debugFunc;
  let phase = 'default';
  let namespace = '';
  const newDebug = () => {
  	debugFunc = namespace
  		? browser(`fetch-mock:${phase}:${namespace}`)
  		: browser(`fetch-mock:${phase}`);
  };

  const newDebugSandbox = (ns) => browser(`fetch-mock:${phase}:${ns}`);

  newDebug();

  var debug_1 = {
  	debug: (...args) => {
  		debugFunc(...args);
  	},
  	setDebugNamespace: (str) => {
  		namespace = str;
  		newDebug();
  	},
  	setDebugPhase: (str) => {
  		phase = str || 'default';
  		newDebug();
  	},
  	getDebug: (namespace) => newDebugSandbox(namespace),
  };

  const { debug, setDebugPhase } = debug_1;
  const FetchMock = {};

  FetchMock.mock = function (...args) {
  	setDebugPhase('setup');
  	if (args.length) {
  		this.addRoute(args);
  	}

  	return this._mock();
  };

  FetchMock.addRoute = function (uncompiledRoute) {
  	debug('Adding route', uncompiledRoute);
  	const route = this.compileRoute(uncompiledRoute);
  	const clashes = this.routes.filter(({ identifier, method }) => {
  		const isMatch =
  			typeof identifier === 'function'
  				? identifier === route.identifier
  				: String(identifier) === String(route.identifier);
  		return isMatch && (!method || !route.method || method === route.method);
  	});

  	if (this.getOption('overwriteRoutes', route) === false || !clashes.length) {
  		this._uncompiledRoutes.push(uncompiledRoute);
  		return this.routes.push(route);
  	}

  	if (this.getOption('overwriteRoutes', route) === true) {
  		clashes.forEach((clash) => {
  			const index = this.routes.indexOf(clash);
  			this._uncompiledRoutes.splice(index, 1, uncompiledRoute);
  			this.routes.splice(index, 1, route);
  		});
  		return this.routes;
  	}

  	if (clashes.length) {
  		throw new Error(
  			'fetch-mock: Adding route with same name or matcher as existing route. See `overwriteRoutes` option.'
  		);
  	}

  	this._uncompiledRoutes.push(uncompiledRoute);
  	this.routes.push(route);
  };

  FetchMock._mock = function () {
  	if (!this.isSandbox) {
  		// Do this here rather than in the constructor to ensure it's scoped to the test
  		this.realFetch = this.realFetch || this.global.fetch;
  		this.global.fetch = this.fetchHandler;
  	}
  	setDebugPhase();
  	return this;
  };

  FetchMock.catch = function (response) {
  	if (this.fallbackResponse) {
  		console.warn(
  			'calling fetchMock.catch() twice - are you sure you want to overwrite the previous fallback response'
  		); // eslint-disable-line
  	}
  	this.fallbackResponse = response || 'ok';
  	return this._mock();
  };

  FetchMock.spy = function (route) {
  	// even though ._mock() is called by .mock() and .catch() we still need to
  	// call it here otherwise .getNativeFetch() won't be able to use the reference
  	// to .realFetch that ._mock() sets up
  	this._mock();
  	return route
  		? this.mock(route, this.getNativeFetch())
  		: this.catch(this.getNativeFetch());
  };

  const defineShorthand = (methodName, underlyingMethod, shorthandOptions) => {
  	FetchMock[methodName] = function (matcher, response, options) {
  		return this[underlyingMethod](
  			matcher,
  			response,
  			Object.assign(options || {}, shorthandOptions)
  		);
  	};
  };

  const defineGreedyShorthand = (methodName, underlyingMethod) => {
  	FetchMock[methodName] = function (response, options) {
  		return this[underlyingMethod]({}, response, options);
  	};
  };

  defineShorthand('sticky', 'mock', { sticky: true });
  defineShorthand('once', 'mock', { repeat: 1 });
  defineGreedyShorthand('any', 'mock');
  defineGreedyShorthand('anyOnce', 'once');

  ['get', 'post', 'put', 'delete', 'head', 'patch'].forEach((method) => {
  	defineShorthand(method, 'mock', { method });
  	defineShorthand(`${method}Once`, 'once', { method });
  	defineGreedyShorthand(`${method}Any`, method);
  	defineGreedyShorthand(`${method}AnyOnce`, `${method}Once`);
  });

  const mochaAsyncHookWorkaround = (options) => {
  	// HACK workaround for this https://github.com/mochajs/mocha/issues/4280
  	// Note that it doesn't matter that we call it _before_ carrying out all
  	// the things resetBehavior does as everything in there is synchronous
  	if (typeof options === 'function') {
  		console.warn(`Deprecated: Passing fetch-mock reset methods
directly in as handlers for before/after test runner hooks.
Wrap in an arrow function instead e.g. \`() => fetchMock.restore()\``);
  		options();
  	}
  };

  const getRouteRemover = ({ sticky: removeStickyRoutes }) => (routes) =>
  	removeStickyRoutes ? [] : routes.filter(({ sticky }) => sticky);

  FetchMock.resetBehavior = function (options = {}) {
  	mochaAsyncHookWorkaround(options);
  	const removeRoutes = getRouteRemover(options);

  	this.routes = removeRoutes(this.routes);
  	this._uncompiledRoutes = removeRoutes(this._uncompiledRoutes);

  	if (this.realFetch && !this.routes.length) {
  		this.global.fetch = this.realFetch;
  		this.realFetch = undefined;
  	}

  	this.fallbackResponse = undefined;
  	return this;
  };

  FetchMock.resetHistory = function () {
  	this._calls = [];
  	this._holdingPromises = [];
  	this.routes.forEach((route) => route.reset && route.reset());
  	return this;
  };

  FetchMock.restore = FetchMock.reset = function (options) {
  	this.resetBehavior(options);
  	this.resetHistory();
  	return this;
  };

  var setUpAndTearDown = FetchMock;

  const { getDebug } = debug_1;
  const responseConfigProps = [
  	'body',
  	'headers',
  	'throws',
  	'status',
  	'redirectUrl',
  ];

  class ResponseBuilder {
  	constructor(options) {
  		this.debug = getDebug('ResponseBuilder()');
  		this.debug('Response builder created with options', options);
  		Object.assign(this, options);
  	}

  	exec() {
  		this.debug('building response');
  		this.normalizeResponseConfig();
  		this.constructFetchOpts();
  		this.constructResponseBody();

  		const realResponse = new this.fetchMock.config.Response(
  			this.body,
  			this.options
  		);
  		const proxyResponse = this.buildObservableResponse(realResponse);
  		return [realResponse, proxyResponse];
  	}

  	sendAsObject() {
  		if (responseConfigProps.some((prop) => this.responseConfig[prop])) {
  			if (
  				Object.keys(this.responseConfig).every((key) =>
  					responseConfigProps.includes(key)
  				)
  			) {
  				return false;
  			} else {
  				return true;
  			}
  		} else {
  			return true;
  		}
  	}

  	normalizeResponseConfig() {
  		// If the response config looks like a status, start to generate a simple response
  		if (typeof this.responseConfig === 'number') {
  			this.debug('building response using status', this.responseConfig);
  			this.responseConfig = {
  				status: this.responseConfig,
  			};
  			// If the response config is not an object, or is an object that doesn't use
  			// any reserved properties, assume it is meant to be the body of the response
  		} else if (typeof this.responseConfig === 'string' || this.sendAsObject()) {
  			this.debug('building text response from', this.responseConfig);
  			this.responseConfig = {
  				body: this.responseConfig,
  			};
  		}
  	}

  	validateStatus(status) {
  		if (!status) {
  			this.debug('No status provided. Defaulting to 200');
  			return 200;
  		}

  		if (
  			(typeof status === 'number' &&
  				parseInt(status, 10) !== status &&
  				status >= 200) ||
  			status < 600
  		) {
  			this.debug('Valid status provided', status);
  			return status;
  		}

  		throw new TypeError(`fetch-mock: Invalid status ${status} passed on response object.
To respond with a JSON object that has status as a property assign the object to body
e.g. {"body": {"status: "registered"}}`);
  	}

  	constructFetchOpts() {
  		this.options = this.responseConfig.options || {};
  		this.options.url = this.responseConfig.redirectUrl || this.url;
  		this.options.status = this.validateStatus(this.responseConfig.status);
  		this.options.statusText = this.fetchMock.statusTextMap[
  			String(this.options.status)
  		];

  		// Set up response headers. The empty object is to cope with
  		// new Headers(undefined) throwing in Chrome
  		// https://code.google.com/p/chromium/issues/detail?id=335871
  		this.options.headers = new this.fetchMock.config.Headers(
  			this.responseConfig.headers || {}
  		);
  	}

  	getOption(name) {
  		return this.fetchMock.getOption(name, this.route);
  	}

  	convertToJson() {
  		// convert to json if we need to
  		if (
  			this.getOption('sendAsJson') &&
  			this.responseConfig.body != null && //eslint-disable-line
  			typeof this.body === 'object'
  		) {
  			this.debug('Stringifying JSON response body');
  			this.body = JSON.stringify(this.body);
  			if (!this.options.headers.has('Content-Type')) {
  				this.options.headers.set('Content-Type', 'application/json');
  			}
  		}
  	}

  	setContentLength() {
  		// add a Content-Length header if we need to
  		if (
  			this.getOption('includeContentLength') &&
  			typeof this.body === 'string' &&
  			!this.options.headers.has('Content-Length')
  		) {
  			this.debug('Setting content-length header:', this.body.length.toString());
  			this.options.headers.set('Content-Length', this.body.length.toString());
  		}
  	}

  	constructResponseBody() {
  		// start to construct the body
  		this.body = this.responseConfig.body;
  		this.convertToJson();
  		this.setContentLength();

  		// On the server we need to manually construct the readable stream for the
  		// Response object (on the client this done automatically)
  		if (this.Stream) {
  			this.debug('Creating response stream');
  			const stream = new this.Stream.Readable();
  			if (this.body != null) { //eslint-disable-line
  				stream.push(this.body, 'utf-8');
  			}
  			stream.push(null);
  			this.body = stream;
  		}
  		this.body = this.body;
  	}

  	buildObservableResponse(response) {
  		const fetchMock = this.fetchMock;
  		response._fmResults = {};
  		// Using a proxy means we can set properties that may not be writable on
  		// the original Response. It also means we can track the resolution of
  		// promises returned by res.json(), res.text() etc
  		this.debug('Wrapping Response in ES proxy for observability');
  		return new Proxy(response, {
  			get: (originalResponse, name) => {
  				if (this.responseConfig.redirectUrl) {
  					if (name === 'url') {
  						this.debug(
  							'Retrieving redirect url',
  							this.responseConfig.redirectUrl
  						);
  						return this.responseConfig.redirectUrl;
  					}

  					if (name === 'redirected') {
  						this.debug('Retrieving redirected status', true);
  						return true;
  					}
  				}

  				if (typeof originalResponse[name] === 'function') {
  					this.debug('Wrapping body promises in ES proxies for observability');
  					return new Proxy(originalResponse[name], {
  						apply: (func, thisArg, args) => {
  							this.debug(`Calling res.${name}`);
  							const result = func.apply(response, args);
  							if (result.then) {
  								fetchMock._holdingPromises.push(result.catch(() => null));
  								originalResponse._fmResults[name] = result;
  							}
  							return result;
  						},
  					});
  				}

  				return originalResponse[name];
  			},
  		});
  	}
  }

  var responseBuilder = (options) => new ResponseBuilder(options).exec();

  let URL$1;
  // https://stackoverflow.com/a/19709846/308237
  // split, URL constructor does not support protocol-relative urls
  const absoluteUrlRX = new RegExp('^[a-z]+://', 'i');
  const protocolRelativeUrlRX = new RegExp('^//', 'i');

  const headersToArray = (headers) => {
  	// node-fetch 1 Headers
  	if (typeof headers.raw === 'function') {
  		return Object.entries(headers.raw());
  	} else if (headers[Symbol.iterator]) {
  		return [...headers];
  	} else {
  		return Object.entries(headers);
  	}
  };

  const zipObject = (entries) =>
  	entries.reduce((obj, [key, val]) => Object.assign(obj, { [key]: val }), {});

  const normalizeUrl = (url) => {
  	if (
  		typeof url === 'function' ||
  		url instanceof RegExp ||
  		/^(begin|end|glob|express|path)\:/.test(url)
  	) {
  		return url;
  	}
  	if (absoluteUrlRX.test(url)) {
  		const u = new URL$1(url);
  		return u.href;
  	} else if (protocolRelativeUrlRX.test(url)) {
  		const u = new URL$1(url, 'http://dummy');
  		return u.href;
  	} else {
  		const u = new URL$1(url, 'http://dummy');
  		return u.pathname + u.search;
  	}
  };

  const extractBody = async (request) => {
  	try {
  		// node-fetch
  		if ('body' in request) {
  			return request.body.toString();
  		}
  		// fetch
  		return request.clone().text();
  	} catch (err) {}
  };

  var requestUtils = {
  	setUrlImplementation: (it) => {
  		URL$1 = it;
  	},
  	normalizeRequest: (url, options, Request) => {
  		if (Request.prototype.isPrototypeOf(url)) {
  			const derivedOptions = {
  				method: url.method,
  			};

  			const body = extractBody(url);

  			if (typeof body !== 'undefined') {
  				derivedOptions.body = body;
  			}

  			const normalizedRequestObject = {
  				url: normalizeUrl(url.url),
  				options: Object.assign(derivedOptions, options),
  				request: url,
  				signal: (options && options.signal) || url.signal,
  			};

  			const headers = headersToArray(url.headers);

  			if (headers.length) {
  				normalizedRequestObject.options.headers = zipObject(headers);
  			}
  			return normalizedRequestObject;
  		} else if (
  			typeof url === 'string' ||
  			// horrible URL object duck-typing
  			(typeof url === 'object' && 'href' in url)
  		) {
  			return {
  				url: normalizeUrl(url),
  				options: options,
  				signal: options && options.signal,
  			};
  		} else if (typeof url === 'object') {
  			throw new TypeError(
  				'fetch-mock: Unrecognised Request object. Read the Config and Installation sections of the docs'
  			);
  		} else {
  			throw new TypeError('fetch-mock: Invalid arguments passed to fetch');
  		}
  	},
  	normalizeUrl,
  	getPath: (url) => {
  		const u = absoluteUrlRX.test(url)
  			? new URL$1(url)
  			: new URL$1(url, 'http://dummy');
  		return u.pathname;
  	},

  	getQuery: (url) => {
  		const u = absoluteUrlRX.test(url)
  			? new URL$1(url)
  			: new URL$1(url, 'http://dummy');
  		return u.search ? u.search.substr(1) : '';
  	},
  	headers: {
  		normalize: (headers) => zipObject(headersToArray(headers)),
  		toLowerCase: (headers) =>
  			Object.keys(headers).reduce((obj, k) => {
  				obj[k.toLowerCase()] = headers[k];
  				return obj;
  			}, {}),
  		equal: (actualHeader, expectedHeader) => {
  			actualHeader = Array.isArray(actualHeader)
  				? actualHeader
  				: [actualHeader];
  			expectedHeader = Array.isArray(expectedHeader)
  				? expectedHeader
  				: [expectedHeader];

  			if (actualHeader.length !== expectedHeader.length) {
  				return false;
  			}

  			return actualHeader.every((val, i) => val === expectedHeader[i]);
  		},
  	},
  };

  const { debug: debug$1, setDebugPhase: setDebugPhase$1, getDebug: getDebug$1 } = debug_1;


  const FetchMock$1 = {};

  // see https://heycam.github.io/webidl/#aborterror for the standardised interface
  // Note that this differs slightly from node-fetch
  class AbortError extends Error {
  	constructor() {
  		super(...arguments);
  		this.name = 'AbortError';
  		this.message = 'The operation was aborted.';

  		// Do not include this class in the stacktrace
  		if (Error.captureStackTrace) {
  			Error.captureStackTrace(this, this.constructor);
  		}
  	}
  }

  // Patch native fetch to avoid "NotSupportedError:ReadableStream uploading is not supported" in Safari.
  // See also https://github.com/wheresrhys/fetch-mock/issues/584
  // See also https://stackoverflow.com/a/50952018/1273406
  const patchNativeFetchForSafari = (nativeFetch) => {
  	// Try to patch fetch only on Safari
  	if (
  		typeof navigator === 'undefined' ||
  		!navigator.vendor ||
  		navigator.vendor !== 'Apple Computer, Inc.'
  	) {
  		return nativeFetch;
  	}
  	// It seems the code is working on Safari thus patch native fetch to avoid the error.
  	return async (request) => {
  		const { method } = request;
  		if (!['POST', 'PUT', 'PATCH'].includes(method)) {
  			// No patch is required in this case
  			return nativeFetch(request);
  		}
  		const body = await request.clone().text();
  		const {
  			cache,
  			credentials,
  			headers,
  			integrity,
  			mode,
  			redirect,
  			referrer,
  		} = request;
  		const init = {
  			body,
  			cache,
  			credentials,
  			headers,
  			integrity,
  			mode,
  			redirect,
  			referrer,
  			method,
  		};
  		return nativeFetch(request.url, init);
  	};
  };

  const resolve = async (
  	{ response, responseIsFetch = false },
  	url,
  	options,
  	request
  ) => {
  	const debug = getDebug$1('resolve()');
  	debug('Recursively resolving function and promise responses');
  	// We want to allow things like
  	// - function returning a Promise for a response
  	// - delaying (using a timeout Promise) a function's execution to generate
  	//   a response
  	// Because of this we can't safely check for function before Promisey-ness,
  	// or vice versa. So to keep it DRY, and flexible, we keep trying until we
  	// have something that looks like neither Promise nor function
  	while (true) {
  		if (typeof response === 'function') {
  			debug('  Response is a function');
  			// in the case of falling back to the network we need to make sure we're using
  			// the original Request instance, not our normalised url + options
  			if (responseIsFetch) {
  				if (request) {
  					debug('  -> Calling fetch with Request instance');
  					return response(request);
  				}
  				debug('  -> Calling fetch with url and options');
  				return response(url, options);
  			} else {
  				debug('  -> Calling response function');
  				response = response(url, options, request);
  			}
  		} else if (typeof response.then === 'function') {
  			debug('  Response is a promise');
  			debug('  -> Resolving promise');
  			response = await response;
  		} else {
  			debug('  Response is not a function or a promise');
  			debug('  -> Exiting response resolution recursion');
  			return response;
  		}
  	}
  };

  FetchMock$1.needsAsyncBodyExtraction = function ({ request }) {
  	return request && this.routes.some(({ usesBody }) => usesBody);
  };

  FetchMock$1.fetchHandler = function (url, options) {
  	setDebugPhase$1('handle');
  	const debug = getDebug$1('fetchHandler()');
  	debug('fetch called with:', url, options);

  	const normalizedRequest = requestUtils.normalizeRequest(
  		url,
  		options,
  		this.config.Request
  	);

  	debug('Request normalised');
  	debug('  url', normalizedRequest.url);
  	debug('  options', normalizedRequest.options);
  	debug('  request', normalizedRequest.request);
  	debug('  signal', normalizedRequest.signal);

  	if (this.needsAsyncBodyExtraction(normalizedRequest)) {
  		debug(
  			'Need to wait for Body to be streamed before calling router: switching to async mode'
  		);
  		return this._extractBodyThenHandle(normalizedRequest);
  	}
  	return this._fetchHandler(normalizedRequest);
  };

  FetchMock$1._extractBodyThenHandle = async function (normalizedRequest) {
  	normalizedRequest.options.body = await normalizedRequest.options.body;
  	return this._fetchHandler(normalizedRequest);
  };

  FetchMock$1._fetchHandler = function ({ url, options, request, signal }) {
  	const { route, callLog } = this.executeRouter(url, options, request);

  	this.recordCall(callLog);

  	// this is used to power the .flush() method
  	let done;
  	this._holdingPromises.push(new this.config.Promise((res) => (done = res)));

  	// wrapped in this promise to make sure we respect custom Promise
  	// constructors defined by the user
  	return new this.config.Promise((res, rej) => {
  		if (signal) {
  			debug$1('signal exists - enabling fetch abort');
  			const abort = () => {
  				debug$1('aborting fetch');
  				// note that DOMException is not available in node.js;
  				// even node-fetch uses a custom error class:
  				// https://github.com/bitinn/node-fetch/blob/master/src/abort-error.js
  				rej(
  					typeof DOMException !== 'undefined'
  						? new DOMException('The operation was aborted.', 'AbortError')
  						: new AbortError()
  				);
  				done();
  			};
  			if (signal.aborted) {
  				debug$1('signal is already aborted - aborting the fetch');
  				abort();
  			}
  			signal.addEventListener('abort', abort);
  		}

  		this.generateResponse({ route, url, options, request, callLog })
  			.then(res, rej)
  			.then(done, done)
  			.then(() => {
  				setDebugPhase$1();
  			});
  	});
  };

  FetchMock$1.fetchHandler.isMock = true;

  FetchMock$1.executeRouter = function (url, options, request) {
  	const debug = getDebug$1('executeRouter()');
  	const callLog = { url, options, request, isUnmatched: true };
  	debug(`Attempting to match request to a route`);
  	if (this.getOption('fallbackToNetwork') === 'always') {
  		debug(
  			'  Configured with fallbackToNetwork=always - passing through to fetch'
  		);
  		return {
  			route: { response: this.getNativeFetch(), responseIsFetch: true },
  			// BUG - this callLog never used to get sent. Discovered the bug
  			// but can't fix outside a major release as it will potentially
  			// cause too much disruption
  			//
  			// callLog,
  		};
  	}

  	const route = this.router(url, options, request);

  	if (route) {
  		debug('  Matching route found');
  		return {
  			route,
  			callLog: {
  				url,
  				options,
  				request,
  				identifier: route.identifier,
  			},
  		};
  	}

  	if (this.getOption('warnOnFallback')) {
  		console.warn(`Unmatched ${(options && options.method) || 'GET'} to ${url}`); // eslint-disable-line
  	}

  	if (this.fallbackResponse) {
  		debug('  No matching route found - using fallbackResponse');
  		return { route: { response: this.fallbackResponse }, callLog };
  	}

  	if (!this.getOption('fallbackToNetwork')) {
  		throw new Error(
  			`fetch-mock: No fallback response defined for ${
				(options && options.method) || 'GET'
			} to ${url}`
  		);
  	}

  	debug('  Configured to fallbackToNetwork - passing through to fetch');
  	return {
  		route: { response: this.getNativeFetch(), responseIsFetch: true },
  		callLog,
  	};
  };

  FetchMock$1.generateResponse = async function ({
  	route,
  	url,
  	options,
  	request,
  	callLog = {},
  }) {
  	const debug = getDebug$1('generateResponse()');
  	const response = await resolve(route, url, options, request);

  	// If the response says to throw an error, throw it
  	// Type checking is to deal with sinon spies having a throws property :-0
  	if (response.throws && typeof response !== 'function') {
  		debug('response.throws is defined - throwing an error');
  		throw response.throws;
  	}

  	// If the response is a pre-made Response, respond with it
  	if (this.config.Response.prototype.isPrototypeOf(response)) {
  		debug('response is already a Response instance - returning it');
  		callLog.response = response;
  		return response;
  	}

  	// finally, if we need to convert config into a response, we do it
  	const [realResponse, finalResponse] = responseBuilder({
  		url,
  		responseConfig: response,
  		fetchMock: this,
  		route,
  	});

  	callLog.response = realResponse;

  	return finalResponse;
  };

  FetchMock$1.router = function (url, options, request) {
  	const route = this.routes.find((route, i) => {
  		debug$1(`Trying to match route ${i}`);
  		return route.matcher(url, options, request);
  	});

  	if (route) {
  		return route;
  	}
  };

  FetchMock$1.getNativeFetch = function () {
  	const func = this.realFetch || (this.isSandbox && this.config.fetch);
  	if (!func) {
  		throw new Error(
  			'fetch-mock: Falling back to network only available on global fetch-mock, or by setting config.fetch on sandboxed fetch-mock'
  		);
  	}
  	return patchNativeFetchForSafari(func);
  };

  FetchMock$1.recordCall = function (obj) {
  	debug$1('Recording fetch call', obj);
  	if (obj) {
  		this._calls.push(obj);
  	}
  };

  var fetchHandler = FetchMock$1;

  var globToRegexp = function (glob, opts) {
    if (typeof glob !== 'string') {
      throw new TypeError('Expected a string');
    }

    var str = String(glob);

    // The regexp we are building, as a string.
    var reStr = "";

    // Whether we are matching so called "extended" globs (like bash) and should
    // support single character matching, matching ranges of characters, group
    // matching, etc.
    var extended = opts ? !!opts.extended : false;

    // When globstar is _false_ (default), '/foo/*' is translated a regexp like
    // '^\/foo\/.*$' which will match any string beginning with '/foo/'
    // When globstar is _true_, '/foo/*' is translated to regexp like
    // '^\/foo\/[^/]*$' which will match any string beginning with '/foo/' BUT
    // which does not have a '/' to the right of it.
    // E.g. with '/foo/*' these will match: '/foo/bar', '/foo/bar.txt' but
    // these will not '/foo/bar/baz', '/foo/bar/baz.txt'
    // Lastely, when globstar is _true_, '/foo/**' is equivelant to '/foo/*' when
    // globstar is _false_
    var globstar = opts ? !!opts.globstar : false;

    // If we are doing extended matching, this boolean is true when we are inside
    // a group (eg {*.html,*.js}), and false otherwise.
    var inGroup = false;

    // RegExp flags (eg "i" ) to pass in to RegExp constructor.
    var flags = opts && typeof( opts.flags ) === "string" ? opts.flags : "";

    var c;
    for (var i = 0, len = str.length; i < len; i++) {
      c = str[i];

      switch (c) {
      case "/":
      case "$":
      case "^":
      case "+":
      case ".":
      case "(":
      case ")":
      case "=":
      case "!":
      case "|":
        reStr += "\\" + c;
        break;

      case "?":
        if (extended) {
          reStr += ".";
  	    break;
        }

      case "[":
      case "]":
        if (extended) {
          reStr += c;
  	    break;
        }

      case "{":
        if (extended) {
          inGroup = true;
  	    reStr += "(";
  	    break;
        }

      case "}":
        if (extended) {
          inGroup = false;
  	    reStr += ")";
  	    break;
        }

      case ",":
        if (inGroup) {
          reStr += "|";
  	    break;
        }
        reStr += "\\" + c;
        break;

      case "*":
        // Move over all consecutive "*"'s.
        // Also store the previous and next characters
        var prevChar = str[i - 1];
        var starCount = 1;
        while(str[i + 1] === "*") {
          starCount++;
          i++;
        }
        var nextChar = str[i + 1];

        if (!globstar) {
          // globstar is disabled, so treat any number of "*" as one
          reStr += ".*";
        } else {
          // globstar is enabled, so determine if this is a globstar segment
          var isGlobstar = starCount > 1                      // multiple "*"'s
            && (prevChar === "/" || prevChar === undefined)   // from the start of the segment
            && (nextChar === "/" || nextChar === undefined);   // to the end of the segment

          if (isGlobstar) {
            // it's a globstar, so match zero or more path segments
            reStr += "((?:[^/]*(?:\/|$))*)";
            i++; // move over the "/"
          } else {
            // it's not a globstar, so only match one path segment
            reStr += "([^/]*)";
          }
        }
        break;

      default:
        reStr += c;
      }
    }

    // When regexp 'g' flag is specified don't
    // constrain the regular expression with ^ & $
    if (!flags || !~flags.indexOf('g')) {
      reStr = "^" + reStr + "$";
    }

    return new RegExp(reStr, flags);
  };

  /**
   * Expose `pathToRegexp`.
   */
  var pathToRegexp_1 = pathToRegexp;
  var parse_1 = parse$1;
  var compile_1 = compile;
  var tokensToFunction_1 = tokensToFunction;
  var tokensToRegExp_1 = tokensToRegExp;

  /**
   * Default configs.
   */
  var DEFAULT_DELIMITER = '/';
  var DEFAULT_DELIMITERS = './';

  /**
   * The main path matching regexp utility.
   *
   * @type {RegExp}
   */
  var PATH_REGEXP = new RegExp([
    // Match escaped characters that would otherwise appear in future matches.
    // This allows the user to escape special characters that won't transform.
    '(\\\\.)',
    // Match Express-style parameters and un-named parameters with a prefix
    // and optional suffixes. Matches appear as:
    //
    // ":test(\\d+)?" => ["test", "\d+", undefined, "?"]
    // "(\\d+)"  => [undefined, undefined, "\d+", undefined]
    '(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?'
  ].join('|'), 'g');

  /**
   * Parse a string for the raw tokens.
   *
   * @param  {string}  str
   * @param  {Object=} options
   * @return {!Array}
   */
  function parse$1 (str, options) {
    var tokens = [];
    var key = 0;
    var index = 0;
    var path = '';
    var defaultDelimiter = (options && options.delimiter) || DEFAULT_DELIMITER;
    var delimiters = (options && options.delimiters) || DEFAULT_DELIMITERS;
    var pathEscaped = false;
    var res;

    while ((res = PATH_REGEXP.exec(str)) !== null) {
      var m = res[0];
      var escaped = res[1];
      var offset = res.index;
      path += str.slice(index, offset);
      index = offset + m.length;

      // Ignore already escaped sequences.
      if (escaped) {
        path += escaped[1];
        pathEscaped = true;
        continue
      }

      var prev = '';
      var next = str[index];
      var name = res[2];
      var capture = res[3];
      var group = res[4];
      var modifier = res[5];

      if (!pathEscaped && path.length) {
        var k = path.length - 1;

        if (delimiters.indexOf(path[k]) > -1) {
          prev = path[k];
          path = path.slice(0, k);
        }
      }

      // Push the current path onto the tokens.
      if (path) {
        tokens.push(path);
        path = '';
        pathEscaped = false;
      }

      var partial = prev !== '' && next !== undefined && next !== prev;
      var repeat = modifier === '+' || modifier === '*';
      var optional = modifier === '?' || modifier === '*';
      var delimiter = prev || defaultDelimiter;
      var pattern = capture || group;

      tokens.push({
        name: name || key++,
        prefix: prev,
        delimiter: delimiter,
        optional: optional,
        repeat: repeat,
        partial: partial,
        pattern: pattern ? escapeGroup(pattern) : '[^' + escapeString(delimiter) + ']+?'
      });
    }

    // Push any remaining characters.
    if (path || index < str.length) {
      tokens.push(path + str.substr(index));
    }

    return tokens
  }

  /**
   * Compile a string to a template function for the path.
   *
   * @param  {string}             str
   * @param  {Object=}            options
   * @return {!function(Object=, Object=)}
   */
  function compile (str, options) {
    return tokensToFunction(parse$1(str, options))
  }

  /**
   * Expose a method for transforming tokens into the path function.
   */
  function tokensToFunction (tokens) {
    // Compile all the tokens into regexps.
    var matches = new Array(tokens.length);

    // Compile all the patterns before compilation.
    for (var i = 0; i < tokens.length; i++) {
      if (typeof tokens[i] === 'object') {
        matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
      }
    }

    return function (data, options) {
      var path = '';
      var encode = (options && options.encode) || encodeURIComponent;

      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];

        if (typeof token === 'string') {
          path += token;
          continue
        }

        var value = data ? data[token.name] : undefined;
        var segment;

        if (Array.isArray(value)) {
          if (!token.repeat) {
            throw new TypeError('Expected "' + token.name + '" to not repeat, but got array')
          }

          if (value.length === 0) {
            if (token.optional) continue

            throw new TypeError('Expected "' + token.name + '" to not be empty')
          }

          for (var j = 0; j < value.length; j++) {
            segment = encode(value[j], token);

            if (!matches[i].test(segment)) {
              throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '"')
            }

            path += (j === 0 ? token.prefix : token.delimiter) + segment;
          }

          continue
        }

        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
          segment = encode(String(value), token);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but got "' + segment + '"')
          }

          path += token.prefix + segment;
          continue
        }

        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) path += token.prefix;

          continue
        }

        throw new TypeError('Expected "' + token.name + '" to be ' + (token.repeat ? 'an array' : 'a string'))
      }

      return path
    }
  }

  /**
   * Escape a regular expression string.
   *
   * @param  {string} str
   * @return {string}
   */
  function escapeString (str) {
    return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, '\\$1')
  }

  /**
   * Escape the capturing group by escaping special characters and meaning.
   *
   * @param  {string} group
   * @return {string}
   */
  function escapeGroup (group) {
    return group.replace(/([=!:$/()])/g, '\\$1')
  }

  /**
   * Get the flags for a regexp from the options.
   *
   * @param  {Object} options
   * @return {string}
   */
  function flags (options) {
    return options && options.sensitive ? '' : 'i'
  }

  /**
   * Pull out keys from a regexp.
   *
   * @param  {!RegExp} path
   * @param  {Array=}  keys
   * @return {!RegExp}
   */
  function regexpToRegexp (path, keys) {
    if (!keys) return path

    // Use a negative lookahead to match only capturing groups.
    var groups = path.source.match(/\((?!\?)/g);

    if (groups) {
      for (var i = 0; i < groups.length; i++) {
        keys.push({
          name: i,
          prefix: null,
          delimiter: null,
          optional: false,
          repeat: false,
          partial: false,
          pattern: null
        });
      }
    }

    return path
  }

  /**
   * Transform an array into a regexp.
   *
   * @param  {!Array}  path
   * @param  {Array=}  keys
   * @param  {Object=} options
   * @return {!RegExp}
   */
  function arrayToRegexp (path, keys, options) {
    var parts = [];

    for (var i = 0; i < path.length; i++) {
      parts.push(pathToRegexp(path[i], keys, options).source);
    }

    return new RegExp('(?:' + parts.join('|') + ')', flags(options))
  }

  /**
   * Create a path regexp from string input.
   *
   * @param  {string}  path
   * @param  {Array=}  keys
   * @param  {Object=} options
   * @return {!RegExp}
   */
  function stringToRegexp (path, keys, options) {
    return tokensToRegExp(parse$1(path, options), keys, options)
  }

  /**
   * Expose a function for taking tokens and returning a RegExp.
   *
   * @param  {!Array}  tokens
   * @param  {Array=}  keys
   * @param  {Object=} options
   * @return {!RegExp}
   */
  function tokensToRegExp (tokens, keys, options) {
    options = options || {};

    var strict = options.strict;
    var start = options.start !== false;
    var end = options.end !== false;
    var delimiter = escapeString(options.delimiter || DEFAULT_DELIMITER);
    var delimiters = options.delimiters || DEFAULT_DELIMITERS;
    var endsWith = [].concat(options.endsWith || []).map(escapeString).concat('$').join('|');
    var route = start ? '^' : '';
    var isEndDelimited = tokens.length === 0;

    // Iterate over the tokens and create our regexp string.
    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        route += escapeString(token);
        isEndDelimited = i === tokens.length - 1 && delimiters.indexOf(token[token.length - 1]) > -1;
      } else {
        var capture = token.repeat
          ? '(?:' + token.pattern + ')(?:' + escapeString(token.delimiter) + '(?:' + token.pattern + '))*'
          : token.pattern;

        if (keys) keys.push(token);

        if (token.optional) {
          if (token.partial) {
            route += escapeString(token.prefix) + '(' + capture + ')?';
          } else {
            route += '(?:' + escapeString(token.prefix) + '(' + capture + '))?';
          }
        } else {
          route += escapeString(token.prefix) + '(' + capture + ')';
        }
      }
    }

    if (end) {
      if (!strict) route += '(?:' + delimiter + ')?';

      route += endsWith === '$' ? '$' : '(?=' + endsWith + ')';
    } else {
      if (!strict) route += '(?:' + delimiter + '(?=' + endsWith + '))?';
      if (!isEndDelimited) route += '(?=' + delimiter + '|' + endsWith + ')';
    }

    return new RegExp(route, flags(options))
  }

  /**
   * Normalize the given path string, returning a regular expression.
   *
   * An empty array can be passed in for the keys, which will hold the
   * placeholder key descriptions. For example, using `/user/:id`, `keys` will
   * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
   *
   * @param  {(string|RegExp|Array)} path
   * @param  {Array=}                keys
   * @param  {Object=}               options
   * @return {!RegExp}
   */
  function pathToRegexp (path, keys, options) {
    if (path instanceof RegExp) {
      return regexpToRegexp(path, keys)
    }

    if (Array.isArray(path)) {
      return arrayToRegexp(/** @type {!Array} */ (path), keys, options)
    }

    return stringToRegexp(/** @type {string} */ (path), keys, options)
  }
  pathToRegexp_1.parse = parse_1;
  pathToRegexp_1.compile = compile_1;
  pathToRegexp_1.tokensToFunction = tokensToFunction_1;
  pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;

  // Copyright Joyent, Inc. and other Node contributors.

  // If obj.hasOwnProperty has been overridden, then calling
  // obj.hasOwnProperty(prop) will break.
  // See: https://github.com/joyent/node/issues/1707
  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  var decode = function(qs, sep, eq, options) {
    sep = sep || '&';
    eq = eq || '=';
    var obj = {};

    if (typeof qs !== 'string' || qs.length === 0) {
      return obj;
    }

    var regexp = /\+/g;
    qs = qs.split(sep);

    var maxKeys = 1000;
    if (options && typeof options.maxKeys === 'number') {
      maxKeys = options.maxKeys;
    }

    var len = qs.length;
    // maxKeys <= 0 means that we should not limit keys count
    if (maxKeys > 0 && len > maxKeys) {
      len = maxKeys;
    }

    for (var i = 0; i < len; ++i) {
      var x = qs[i].replace(regexp, '%20'),
          idx = x.indexOf(eq),
          kstr, vstr, k, v;

      if (idx >= 0) {
        kstr = x.substr(0, idx);
        vstr = x.substr(idx + 1);
      } else {
        kstr = x;
        vstr = '';
      }

      k = decodeURIComponent(kstr);
      v = decodeURIComponent(vstr);

      if (!hasOwnProperty(obj, k)) {
        obj[k] = v;
      } else if (Array.isArray(obj[k])) {
        obj[k].push(v);
      } else {
        obj[k] = [obj[k], v];
      }
    }

    return obj;
  };

  // Copyright Joyent, Inc. and other Node contributors.

  var stringifyPrimitive = function(v) {
    switch (typeof v) {
      case 'string':
        return v;

      case 'boolean':
        return v ? 'true' : 'false';

      case 'number':
        return isFinite(v) ? v : '';

      default:
        return '';
    }
  };

  var encode = function(obj, sep, eq, name) {
    sep = sep || '&';
    eq = eq || '=';
    if (obj === null) {
      obj = undefined;
    }

    if (typeof obj === 'object') {
      return Object.keys(obj).map(function(k) {
        var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
        if (Array.isArray(obj[k])) {
          return obj[k].map(function(v) {
            return ks + encodeURIComponent(stringifyPrimitive(v));
          }).join(sep);
        } else {
          return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
        }
      }).join(sep);

    }

    if (!name) return '';
    return encodeURIComponent(stringifyPrimitive(name)) + eq +
           encodeURIComponent(stringifyPrimitive(obj));
  };

  var querystring = createCommonjsModule(function (module, exports) {

  exports.decode = exports.parse = decode;
  exports.encode = exports.stringify = encode;
  });
  querystring.decode;
  querystring.parse;
  querystring.encode;
  querystring.stringify;

  var isSubset_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  /**
   * Check if an object is contained within another object.
   *
   * Returns `true` if:
   * - all enumerable keys of *subset* are also enumerable in *superset*, and
   * - every value assigned to an enumerable key of *subset* strictly equals
   *   the value assigned to the same key of *superset* – or is a subset of it.
   *
   * @param  {Object}  superset
   * @param  {Object}  subset
   *
   * @returns  {Boolean}
   *
   * @module    is-subset
   * @function  default
   * @alias     isSubset
   */
  var isSubset = (function (_isSubset) {
    function isSubset(_x, _x2) {
      return _isSubset.apply(this, arguments);
    }

    isSubset.toString = function () {
      return _isSubset.toString();
    };

    return isSubset;
  })(function (superset, subset) {
    if (typeof superset !== 'object' || superset === null || (typeof subset !== 'object' || subset === null)) return false;

    return Object.keys(subset).every(function (key) {
      if (!superset.propertyIsEnumerable(key)) return false;

      var subsetItem = subset[key];
      var supersetItem = superset[key];
      if (typeof subsetItem === 'object' && subsetItem !== null ? !isSubset(supersetItem, subsetItem) : supersetItem !== subsetItem) return false;

      return true;
    });
  });

  exports['default'] = isSubset;
  module.exports = exports['default'];
  });

  unwrapExports(isSubset_1);

  var lodash_isequal = createCommonjsModule(function (module, exports) {
  /**
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="npm" -o ./`
   * Copyright JS Foundation and other contributors <https://js.foundation/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER = 9007199254740991;

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      asyncTag = '[object AsyncFunction]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      nullTag = '[object Null]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      proxyTag = '[object Proxy]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      undefinedTag = '[object Undefined]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports =  exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  /* Node.js helper references. */
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  /** Used for built-in method references. */
  var arrayProto = Array.prototype,
      funcProto = Function.prototype,
      objectProto = Object.prototype;

  /** Used to detect overreaching core-js shims. */
  var coreJsData = root['__core-js_shared__'];

  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /** Used to detect methods masquerading as native. */
  var maskSrcKey = (function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? ('Symbol(src)_1.' + uid) : '';
  }());

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto.toString;

  /** Used to detect if a method is native. */
  var reIsNative = RegExp('^' +
    funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
  );

  /** Built-in value references. */
  var Buffer = moduleExports ? root.Buffer : undefined,
      Symbol = root.Symbol,
      Uint8Array = root.Uint8Array,
      propertyIsEnumerable = objectProto.propertyIsEnumerable,
      splice = arrayProto.splice,
      symToStringTag = Symbol ? Symbol.toStringTag : undefined;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeGetSymbols = Object.getOwnPropertySymbols,
      nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
      nativeKeys = overArg(Object.keys, Object);

  /* Built-in method references that are verified to be native. */
  var DataView = getNative(root, 'DataView'),
      Map = getNative(root, 'Map'),
      Promise = getNative(root, 'Promise'),
      Set = getNative(root, 'Set'),
      WeakMap = getNative(root, 'WeakMap'),
      nativeCreate = getNative(Object, 'create');

  /** Used to detect maps, sets, and weakmaps. */
  var dataViewCtorString = toSource(DataView),
      mapCtorString = toSource(Map),
      promiseCtorString = toSource(Promise),
      setCtorString = toSource(Set),
      weakMapCtorString = toSource(WeakMap);

  /** Used to convert symbols to primitives and strings. */
  var symbolProto = Symbol ? Symbol.prototype : undefined,
      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  }

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
  }

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
    return this;
  }

  // Add methods to `Hash`.
  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    return index < 0 ? undefined : data[index][1];
  }

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet(key, value) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  // Add methods to `ListCache`.
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new Hash,
      'map': new (Map || ListCache),
      'string': new Hash
    };
  }

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete(key) {
    var result = getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet(key, value) {
    var data = getMapData(this, key),
        size = data.size;

    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  // Add methods to `MapCache`.
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;

  /**
   *
   * Creates an array cache object to store unique values.
   *
   * @private
   * @constructor
   * @param {Array} [values] The values to cache.
   */
  function SetCache(values) {
    var index = -1,
        length = values == null ? 0 : values.length;

    this.__data__ = new MapCache;
    while (++index < length) {
      this.add(values[index]);
    }
  }

  /**
   * Adds `value` to the array cache.
   *
   * @private
   * @name add
   * @memberOf SetCache
   * @alias push
   * @param {*} value The value to cache.
   * @returns {Object} Returns the cache instance.
   */
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }

  /**
   * Checks if `value` is in the array cache.
   *
   * @private
   * @name has
   * @memberOf SetCache
   * @param {*} value The value to search for.
   * @returns {number} Returns `true` if `value` is found, else `false`.
   */
  function setCacheHas(value) {
    return this.__data__.has(value);
  }

  // Add methods to `SetCache`.
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;

  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }

  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */
  function stackClear() {
    this.__data__ = new ListCache;
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function stackDelete(key) {
    var data = this.__data__,
        result = data['delete'](key);

    this.size = data.size;
    return result;
  }

  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function stackGet(key) {
    return this.__data__.get(key);
  }

  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function stackHas(key) {
    return this.__data__.has(key);
  }

  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs = data.__data__;
      if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }

  // Add methods to `Stack`.
  Stack.prototype.clear = stackClear;
  Stack.prototype['delete'] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;

  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value),
        isArg = !isArr && isArguments(value),
        isBuff = !isArr && !isArg && isBuffer(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? baseTimes(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) &&
          !(skipIndexes && (
             // Safari 9 has enumerable `arguments.length` in strict mode.
             key == 'length' ||
             // Node.js 0.10 has enumerable non-index properties on buffers.
             (isBuff && (key == 'offset' || key == 'parent')) ||
             // PhantomJS 2 has enumerable non-index properties on typed arrays.
             (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
             // Skip index properties.
             isIndex(key, length)
          ))) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @param {Function} symbolsFunc The function to get the symbols of `object`.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  }

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return (symToStringTag && symToStringTag in Object(value))
      ? getRawTag(value)
      : objectToString(value);
  }

  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
  }

  /**
   * The base implementation of `_.isEqual` which supports partial comparisons
   * and tracks traversed objects.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Unordered comparison
   *  2 - Partial comparison
   * @param {Function} [customizer] The function to customize comparisons.
   * @param {Object} [stack] Tracks traversed `value` and `other` objects.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   */
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }

  /**
   * A specialized version of `baseIsEqual` for arrays and objects which performs
   * deep comparisons and tracks traversed objects enabling objects with circular
   * references to be compared.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} [stack] Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray(object),
        othIsArr = isArray(other),
        objTag = objIsArr ? arrayTag : getTag(object),
        othTag = othIsArr ? arrayTag : getTag(other);

    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;

    var objIsObj = objTag == objectTag,
        othIsObj = othTag == objectTag,
        isSameTag = objTag == othTag;

    if (isSameTag && isBuffer(object)) {
      if (!isBuffer(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack);
      return (objIsArr || isTypedArray(object))
        ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
        : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
          othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object,
            othUnwrapped = othIsWrapped ? other.value() : other;

        stack || (stack = new Stack);
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack);
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }

  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */
  function baseIsTypedArray(value) {
    return isObjectLike(value) &&
      isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }

  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * A specialized version of `baseIsEqualDeep` for arrays with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Array} array The array to compare.
   * @param {Array} other The other array to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `array` and `other` objects.
   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
   */
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        arrLength = array.length,
        othLength = other.length;

    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    // Assume cyclic values are equal.
    var stacked = stack.get(array);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var index = -1,
        result = true,
        seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

    stack.set(array, other);
    stack.set(other, array);

    // Ignore non-index properties.
    while (++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index];

      if (customizer) {
        var compared = isPartial
          ? customizer(othValue, arrValue, index, other, array, stack)
          : customizer(arrValue, othValue, index, array, other, stack);
      }
      if (compared !== undefined) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      // Recursively compare arrays (susceptible to call stack limits).
      if (seen) {
        if (!arraySome(other, function(othValue, othIndex) {
              if (!cacheHas(seen, othIndex) &&
                  (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
          result = false;
          break;
        }
      } else if (!(
            arrValue === othValue ||
              equalFunc(arrValue, othValue, bitmask, customizer, stack)
          )) {
        result = false;
        break;
      }
    }
    stack['delete'](array);
    stack['delete'](other);
    return result;
  }

  /**
   * A specialized version of `baseIsEqualDeep` for comparing objects of
   * the same `toStringTag`.
   *
   * **Note:** This function only supports comparing values with tags of
   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {string} tag The `toStringTag` of the objects to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if ((object.byteLength != other.byteLength) ||
            (object.byteOffset != other.byteOffset)) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;

      case arrayBufferTag:
        if ((object.byteLength != other.byteLength) ||
            !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
          return false;
        }
        return true;

      case boolTag:
      case dateTag:
      case numberTag:
        // Coerce booleans to `1` or `0` and dates to milliseconds.
        // Invalid dates are coerced to `NaN`.
        return eq(+object, +other);

      case errorTag:
        return object.name == other.name && object.message == other.message;

      case regexpTag:
      case stringTag:
        // Coerce regexes to strings and treat strings, primitives and objects,
        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
        // for more details.
        return object == (other + '');

      case mapTag:
        var convert = mapToArray;

      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
        convert || (convert = setToArray);

        if (object.size != other.size && !isPartial) {
          return false;
        }
        // Assume cyclic values are equal.
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG;

        // Recursively compare objects (susceptible to call stack limits).
        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack['delete'](object);
        return result;

      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }

  /**
   * A specialized version of `baseIsEqualDeep` for objects with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        objProps = getAllKeys(object),
        objLength = objProps.length,
        othProps = getAllKeys(other),
        othLength = othProps.length;

    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
        return false;
      }
    }
    // Assume cyclic values are equal.
    var stacked = stack.get(object);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);

    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
          othValue = other[key];

      if (customizer) {
        var compared = isPartial
          ? customizer(othValue, objValue, key, other, object, stack)
          : customizer(objValue, othValue, key, object, other, stack);
      }
      // Recursively compare objects (susceptible to call stack limits).
      if (!(compared === undefined
            ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
            : compared
          )) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == 'constructor');
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor;

      // Non `Object` object instances with different constructors are not equal.
      if (objCtor != othCtor &&
          ('constructor' in object && 'constructor' in other) &&
          !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
            typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack['delete'](object);
    stack['delete'](other);
    return result;
  }

  /**
   * Creates an array of own enumerable property names and symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key)
      ? data[typeof key == 'string' ? 'string' : 'hash']
      : data.map;
  }

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag),
        tag = value[symToStringTag];

    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }

  /**
   * Creates an array of the own enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */
  var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };

  /**
   * Gets the `toStringTag` of `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  var getTag = baseGetTag;

  // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
  if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
      (Map && getTag(new Map) != mapTag) ||
      (Promise && getTag(Promise.resolve()) != promiseTag) ||
      (Set && getTag(new Set) != setTag) ||
      (WeakMap && getTag(new WeakMap) != weakMapTag)) {
    getTag = function(value) {
      var result = baseGetTag(value),
          Ctor = result == objectTag ? value.constructor : undefined,
          ctorString = Ctor ? toSource(Ctor) : '';

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString: return dataViewTag;
          case mapCtorString: return mapTag;
          case promiseCtorString: return promiseTag;
          case setCtorString: return setTag;
          case weakMapCtorString: return weakMapTag;
        }
      }
      return result;
    };
  }

  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length &&
      (typeof value == 'number' || reIsUint.test(value)) &&
      (value > -1 && value % 1 == 0 && value < length);
  }

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable(value) {
    var type = typeof value;
    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
      ? (value !== '__proto__')
      : (value === null);
  }

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked(func) {
    return !!maskSrcKey && (maskSrcKey in func);
  }

  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */
  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

    return value === proto;
  }

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}
      try {
        return (func + '');
      } catch (e) {}
    }
    return '';
  }

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq(value, other) {
    return value === other || (value !== value && other !== other);
  }

  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
      !propertyIsEnumerable.call(value, 'callee');
  };

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray = Array.isArray;

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }

  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */
  var isBuffer = nativeIsBuffer || stubFalse;

  /**
   * Performs a deep comparison between two values to determine if they are
   * equivalent.
   *
   * **Note:** This method supports comparing arrays, array buffers, booleans,
   * date objects, error objects, maps, numbers, `Object` objects, regexes,
   * sets, strings, symbols, and typed arrays. `Object` objects are compared
   * by their own, not inherited, enumerable properties. Functions and DOM
   * nodes are compared by strict equality, i.e. `===`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.isEqual(object, other);
   * // => true
   *
   * object === other;
   * // => false
   */
  function isEqual(value, other) {
    return baseIsEqual(value, other);
  }

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength(value) {
    return typeof value == 'number' &&
      value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }

  /**
   * This method returns a new empty array.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {Array} Returns the new empty array.
   * @example
   *
   * var arrays = _.times(2, _.stubArray);
   *
   * console.log(arrays);
   * // => [[], []]
   *
   * console.log(arrays[0] === arrays[1]);
   * // => false
   */
  function stubArray() {
    return [];
  }

  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */
  function stubFalse() {
    return false;
  }

  module.exports = isEqual;
  });

  const { debug: debug$2 } = debug_1;




  const {
  	headers: headerUtils,
  	getPath,
  	getQuery,
  	normalizeUrl: normalizeUrl$1,
  } = requestUtils;


  const debuggableUrlFunc = (func) => (url) => {
  	debug$2('Actual url:', url);
  	return func(url);
  };

  const stringMatchers = {
  	begin: (targetString) =>
  		debuggableUrlFunc((url) => url.indexOf(targetString) === 0),
  	end: (targetString) =>
  		debuggableUrlFunc(
  			(url) => url.substr(-targetString.length) === targetString
  		),
  	glob: (targetString) => {
  		const urlRX = globToRegexp(targetString);
  		return debuggableUrlFunc((url) => urlRX.test(url));
  	},
  	express: (targetString) => {
  		const urlRX = pathToRegexp_1(targetString);
  		return debuggableUrlFunc((url) => urlRX.test(getPath(url)));
  	},
  	path: (targetString) =>
  		debuggableUrlFunc((url) => getPath(url) === targetString),
  };

  const getHeaderMatcher = ({ headers: expectedHeaders }) => {
  	debug$2('Generating header matcher');
  	if (!expectedHeaders) {
  		debug$2('  No header expectations defined - skipping');
  		return;
  	}
  	const expectation = headerUtils.toLowerCase(expectedHeaders);
  	debug$2('  Expected headers:', expectation);
  	return (url, { headers = {} }) => {
  		debug$2('Attempting to match headers');
  		const lowerCaseHeaders = headerUtils.toLowerCase(
  			headerUtils.normalize(headers)
  		);
  		debug$2('  Expected headers:', expectation);
  		debug$2('  Actual headers:', lowerCaseHeaders);
  		return Object.keys(expectation).every((headerName) =>
  			headerUtils.equal(lowerCaseHeaders[headerName], expectation[headerName])
  		);
  	};
  };

  const getMethodMatcher = ({ method: expectedMethod }) => {
  	debug$2('Generating method matcher');
  	if (!expectedMethod) {
  		debug$2('  No method expectations defined - skipping');
  		return;
  	}
  	debug$2('  Expected method:', expectedMethod);
  	return (url, { method }) => {
  		debug$2('Attempting to match method');
  		const actualMethod = method ? method.toLowerCase() : 'get';
  		debug$2('  Expected method:', expectedMethod);
  		debug$2('  Actual method:', actualMethod);
  		return expectedMethod === actualMethod;
  	};
  };

  const getQueryStringMatcher = ({ query: passedQuery }) => {
  	debug$2('Generating query parameters matcher');
  	if (!passedQuery) {
  		debug$2('  No query parameters expectations defined - skipping');
  		return;
  	}
  	const expectedQuery = querystring.parse(querystring.stringify(passedQuery));
  	debug$2('  Expected query parameters:', passedQuery);
  	const keys = Object.keys(expectedQuery);
  	return (url) => {
  		debug$2('Attempting to match query parameters');
  		const query = querystring.parse(getQuery(url));
  		debug$2('  Expected query parameters:', expectedQuery);
  		debug$2('  Actual query parameters:', query);
  		return keys.every((key) => {
  			if (Array.isArray(query[key])) {
  				if (!Array.isArray(expectedQuery[key])) {
  					return false;
  				} else {
  					return lodash_isequal(query[key].sort(), expectedQuery[key].sort());
  				}
  			}
  			return query[key] === expectedQuery[key];
  		});
  	};
  };

  const getParamsMatcher = ({ params: expectedParams, url: matcherUrl }) => {
  	debug$2('Generating path parameters matcher');
  	if (!expectedParams) {
  		debug$2('  No path parameters expectations defined - skipping');
  		return;
  	}
  	if (!/express:/.test(matcherUrl)) {
  		throw new Error(
  			'fetch-mock: matching on params is only possible when using an express: matcher'
  		);
  	}
  	debug$2('  Expected path parameters:', expectedParams);
  	const expectedKeys = Object.keys(expectedParams);
  	const keys = [];
  	const re = pathToRegexp_1(matcherUrl.replace(/^express:/, ''), keys);
  	return (url) => {
  		debug$2('Attempting to match path parameters');
  		const vals = re.exec(getPath(url)) || [];
  		vals.shift();
  		const params = keys.reduce(
  			(map, { name }, i) =>
  				vals[i] ? Object.assign(map, { [name]: vals[i] }) : map,
  			{}
  		);
  		debug$2('  Expected path parameters:', expectedParams);
  		debug$2('  Actual path parameters:', params);
  		return expectedKeys.every((key) => params[key] === expectedParams[key]);
  	};
  };

  const getBodyMatcher = (route, fetchMock) => {
  	const matchPartialBody = fetchMock.getOption('matchPartialBody', route);
  	const { body: expectedBody } = route;

  	debug$2('Generating body matcher');
  	return (url, { body, method = 'get' }) => {
  		debug$2('Attempting to match body');
  		if (method.toLowerCase() === 'get') {
  			debug$2('  GET request - skip matching body');
  			// GET requests don’t send a body so the body matcher should be ignored for them
  			return true;
  		}

  		let sentBody;

  		try {
  			debug$2('  Parsing request body as JSON');
  			sentBody = JSON.parse(body);
  		} catch (err) {
  			debug$2('  Failed to parse request body as JSON', err);
  		}
  		debug$2('Expected body:', expectedBody);
  		debug$2('Actual body:', sentBody);
  		if (matchPartialBody) {
  			debug$2('matchPartialBody is true - checking for partial match only');
  		}

  		return (
  			sentBody &&
  			(matchPartialBody
  				? isSubset_1(sentBody, expectedBody)
  				: lodash_isequal(sentBody, expectedBody))
  		);
  	};
  };

  const getFullUrlMatcher = (route, matcherUrl, query) => {
  	// if none of the special syntaxes apply, it's just a simple string match
  	// but we have to be careful to normalize the url we check and the name
  	// of the route to allow for e.g. http://it.at.there being indistinguishable
  	// from http://it.at.there/ once we start generating Request/Url objects
  	debug$2('  Matching using full url', matcherUrl);
  	const expectedUrl = normalizeUrl$1(matcherUrl);
  	debug$2('  Normalised url to:', matcherUrl);
  	if (route.identifier === matcherUrl) {
  		debug$2('  Updating route identifier to match normalized url:', matcherUrl);
  		route.identifier = expectedUrl;
  	}

  	return (matcherUrl) => {
  		debug$2('Expected url:', expectedUrl);
  		debug$2('Actual url:', matcherUrl);
  		if (query && expectedUrl.indexOf('?')) {
  			debug$2('Ignoring query string when matching url');
  			return matcherUrl.indexOf(expectedUrl) === 0;
  		}
  		return normalizeUrl$1(matcherUrl) === expectedUrl;
  	};
  };

  const getFunctionMatcher = ({ functionMatcher }) => {
  	debug$2('Detected user defined function matcher', functionMatcher);
  	return (...args) => {
  		debug$2('Calling function matcher with arguments', args);
  		return functionMatcher(...args);
  	};
  };

  const getUrlMatcher = (route) => {
  	debug$2('Generating url matcher');
  	const { url: matcherUrl, query } = route;

  	if (matcherUrl === '*') {
  		debug$2('  Using universal * rule to match any url');
  		return () => true;
  	}

  	if (matcherUrl instanceof RegExp) {
  		debug$2('  Using regular expression to match url:', matcherUrl);
  		return (url) => matcherUrl.test(url);
  	}

  	if (matcherUrl.href) {
  		debug$2(`  Using URL object to match url`, matcherUrl);
  		return getFullUrlMatcher(route, matcherUrl.href, query);
  	}

  	for (const shorthand in stringMatchers) {
  		if (matcherUrl.indexOf(shorthand + ':') === 0) {
  			debug$2(`  Using ${shorthand}: pattern to match url`, matcherUrl);
  			const urlFragment = matcherUrl.replace(new RegExp(`^${shorthand}:`), '');
  			return stringMatchers[shorthand](urlFragment);
  		}
  	}

  	return getFullUrlMatcher(route, matcherUrl, query);
  };

  var matchers = [
  	{ name: 'query', matcher: getQueryStringMatcher },
  	{ name: 'method', matcher: getMethodMatcher },
  	{ name: 'headers', matcher: getHeaderMatcher },
  	{ name: 'params', matcher: getParamsMatcher },
  	{ name: 'body', matcher: getBodyMatcher, usesBody: true },
  	{ name: 'functionMatcher', matcher: getFunctionMatcher },
  	{ name: 'url', matcher: getUrlMatcher },
  ];

  const { debug: debug$3, setDebugNamespace, getDebug: getDebug$2 } = debug_1;

  const isUrlMatcher = (matcher) =>
  	matcher instanceof RegExp ||
  	typeof matcher === 'string' ||
  	(typeof matcher === 'object' && 'href' in matcher);

  const isFunctionMatcher = (matcher) => typeof matcher === 'function';

  class Route {
  	constructor(args, fetchMock) {
  		this.fetchMock = fetchMock;
  		const debug = getDebug$2('compileRoute()');
  		debug('Compiling route');
  		this.init(args);
  		this.sanitize();
  		this.validate();
  		this.generateMatcher();
  		this.limit();
  		this.delayResponse();
  	}

  	validate() {
  		if (!('response' in this)) {
  			throw new Error('fetch-mock: Each route must define a response');
  		}

  		if (!Route.registeredMatchers.some(({ name }) => name in this)) {
  			throw new Error(
  				"fetch-mock: Each route must specify some criteria for matching calls to fetch. To match all calls use '*'"
  			);
  		}
  	}

  	init(args) {
  		const [matcher, response, options = {}] = args;

  		const routeConfig = {};

  		if (isUrlMatcher(matcher) || isFunctionMatcher(matcher)) {
  			routeConfig.matcher = matcher;
  		} else {
  			Object.assign(routeConfig, matcher);
  		}

  		if (typeof response !== 'undefined') {
  			routeConfig.response = response;
  		}

  		Object.assign(routeConfig, options);
  		Object.assign(this, routeConfig);
  	}

  	sanitize() {
  		const debug = getDebug$2('sanitize()');
  		debug('Sanitizing route properties');

  		if (this.method) {
  			debug(`Converting method ${this.method} to lower case`);
  			this.method = this.method.toLowerCase();
  		}
  		if (isUrlMatcher(this.matcher)) {
  			debug('Mock uses a url matcher', this.matcher);
  			this.url = this.matcher;
  			delete this.matcher;
  		}

  		this.functionMatcher = this.matcher || this.functionMatcher;

  		debug('Setting route.identifier...');
  		debug(`  route.name is ${this.name}`);
  		debug(`  route.url is ${this.url}`);
  		debug(`  route.functionMatcher is ${this.functionMatcher}`);
  		this.identifier = this.name || this.url || this.functionMatcher;
  		debug(`  -> route.identifier set to ${this.identifier}`);
  	}

  	generateMatcher() {
  		setDebugNamespace('generateMatcher()');
  		debug$3('Compiling matcher for route');

  		const activeMatchers = Route.registeredMatchers
  			.map(
  				({ name, matcher, usesBody }) =>
  					this[name] && { matcher: matcher(this, this.fetchMock), usesBody }
  			)
  			.filter((matcher) => Boolean(matcher));

  		this.usesBody = activeMatchers.some(({ usesBody }) => usesBody);

  		debug$3('Compiled matcher for route');
  		setDebugNamespace();
  		this.matcher = (url, options = {}, request) =>
  			activeMatchers.every(({ matcher }) => matcher(url, options, request));
  	}

  	limit() {
  		const debug = getDebug$2('limit()');
  		debug('Limiting number of requests to handle by route');
  		if (!this.repeat) {
  			debug(
  				'  No `repeat` value set on route. Will match any number of requests'
  			);
  			return;
  		}

  		debug(`  Route set to repeat ${this.repeat} times`);
  		const matcher = this.matcher;
  		let timesLeft = this.repeat;
  		this.matcher = (url, options) => {
  			const match = timesLeft && matcher(url, options);
  			if (match) {
  				timesLeft--;
  				return true;
  			}
  		};
  		this.reset = () => (timesLeft = this.repeat);
  	}

  	delayResponse() {
  		const debug = getDebug$2('delayResponse()');
  		debug(`Applying response delay settings`);
  		if (this.delay) {
  			debug(`  Wrapping response in delay of ${this.delay} miliseconds`);
  			const response = this.response;
  			this.response = () => {
  				debug(`Delaying response by ${this.delay} miliseconds`);
  				return new Promise((res) =>
  					setTimeout(() => res(response), this.delay)
  				);
  			};
  		} else {
  			debug(
  				`  No delay set on route. Will respond 'immediately' (but asynchronously)`
  			);
  		}
  	}

  	static addMatcher(matcher) {
  		Route.registeredMatchers.push(matcher);
  	}
  }

  Route.registeredMatchers = [];

  matchers.forEach(Route.addMatcher);

  var Route_1 = Route;

  const { setDebugPhase: setDebugPhase$2, setDebugNamespace: setDebugNamespace$1, debug: debug$4 } = debug_1;
  const { normalizeUrl: normalizeUrl$2 } = requestUtils;

  const FetchMock$2 = {};
  const isName = (nameOrMatcher) =>
  	typeof nameOrMatcher === 'string' && /^[\da-zA-Z\-]+$/.test(nameOrMatcher);

  const filterCallsWithMatcher = function (matcher, options = {}, calls) {
  	({ matcher } = new Route_1(
  		[Object.assign({ matcher, response: 'ok' }, options)],
  		this
  	));
  	return calls.filter(({ url, options }) =>
  		matcher(normalizeUrl$2(url), options)
  	);
  };

  const formatDebug = (func) => {
  	return function (...args) {
  		setDebugPhase$2('inspect');
  		const result = func.call(this, ...args);
  		setDebugPhase$2();
  		return result;
  	};
  };

  const callObjToArray = (obj) => {
  	if (!obj) {
  		return undefined;
  	}
  	const { url, options, request, identifier, isUnmatched, response } = obj;
  	const arr = [url, options];
  	arr.request = request;
  	arr.identifier = identifier;
  	arr.isUnmatched = isUnmatched;
  	arr.response = response;
  	return arr;
  };

  FetchMock$2.filterCalls = function (nameOrMatcher, options) {
  	debug$4('Filtering fetch calls');
  	let calls = this._calls;
  	let matcher = '*';

  	if ([true, 'matched'].includes(nameOrMatcher)) {
  		debug$4(`Filter provided is ${nameOrMatcher}. Returning matched calls only`);
  		calls = calls.filter(({ isUnmatched }) => !isUnmatched);
  	} else if ([false, 'unmatched'].includes(nameOrMatcher)) {
  		debug$4(
  			`Filter provided is ${nameOrMatcher}. Returning unmatched calls only`
  		);
  		calls = calls.filter(({ isUnmatched }) => isUnmatched);
  	} else if (typeof nameOrMatcher === 'undefined') {
  		debug$4(`Filter provided is undefined. Returning all calls`);
  		calls = calls;
  	} else if (isName(nameOrMatcher)) {
  		debug$4(
  			`Filter provided, looks like the name of a named route. Returning only calls handled by that route`
  		);
  		calls = calls.filter(({ identifier }) => identifier === nameOrMatcher);
  	} else {
  		matcher = nameOrMatcher === '*' ? '*' : normalizeUrl$2(nameOrMatcher);
  		if (this.routes.some(({ identifier }) => identifier === matcher)) {
  			debug$4(
  				`Filter provided, ${nameOrMatcher}, identifies a route. Returning only calls handled by that route`
  			);
  			calls = calls.filter((call) => call.identifier === matcher);
  		}
  	}

  	if ((options || matcher !== '*') && calls.length) {
  		if (typeof options === 'string') {
  			options = { method: options };
  		}
  		debug$4(
  			'Compiling filter and options to route in order to filter all calls',
  			nameOrMatcher
  		);
  		calls = filterCallsWithMatcher.call(this, matcher, options, calls);
  	}
  	debug$4(`Retrieved ${calls.length} calls`);
  	return calls.map(callObjToArray);
  };

  FetchMock$2.calls = formatDebug(function (nameOrMatcher, options) {
  	debug$4('retrieving matching calls');
  	return this.filterCalls(nameOrMatcher, options);
  });

  FetchMock$2.lastCall = formatDebug(function (nameOrMatcher, options) {
  	debug$4('retrieving last matching call');
  	return [...this.filterCalls(nameOrMatcher, options)].pop();
  });

  FetchMock$2.lastUrl = formatDebug(function (nameOrMatcher, options) {
  	debug$4('retrieving url of last matching call');
  	return (this.lastCall(nameOrMatcher, options) || [])[0];
  });

  FetchMock$2.lastOptions = formatDebug(function (nameOrMatcher, options) {
  	debug$4('retrieving options of last matching call');
  	return (this.lastCall(nameOrMatcher, options) || [])[1];
  });

  FetchMock$2.lastResponse = formatDebug(function (nameOrMatcher, options) {
  	debug$4('retrieving respose of last matching call');
  	console.warn(`When doing all the following:
- using node-fetch
- responding with a real network response (using spy() or fallbackToNetwork)
- using \`fetchMock.LastResponse()\`
- awaiting the body content
... the response will hang unless your source code also awaits the response body.
This is an unavoidable consequence of the nodejs implementation of streams.
`);
  	const response = (this.lastCall(nameOrMatcher, options) || []).response;
  	try {
  		const clonedResponse = response.clone();
  		return clonedResponse;
  	} catch (err) {
  		Object.entries(response._fmResults).forEach(([name, result]) => {
  			response[name] = () => result;
  		});
  		return response;
  	}
  });

  FetchMock$2.called = formatDebug(function (nameOrMatcher, options) {
  	debug$4('checking if matching call was made');
  	return Boolean(this.filterCalls(nameOrMatcher, options).length);
  });

  FetchMock$2.flush = formatDebug(async function (waitForResponseMethods) {
  	setDebugNamespace$1('flush');
  	debug$4(
  		`flushing all fetch calls. ${
			waitForResponseMethods ? '' : 'Not '
		}waiting for response bodies to complete download`
  	);

  	const queuedPromises = this._holdingPromises;
  	this._holdingPromises = [];
  	debug$4(`${queuedPromises.length} fetch calls to be awaited`);

  	await Promise.all(queuedPromises);
  	debug$4(`All fetch calls have completed`);
  	if (waitForResponseMethods && this._holdingPromises.length) {
  		debug$4(`Awaiting all fetch bodies to download`);
  		await this.flush(waitForResponseMethods);
  		debug$4(`All fetch bodies have completed downloading`);
  	}
  	setDebugNamespace$1();
  });

  FetchMock$2.done = formatDebug(function (nameOrMatcher) {
  	setDebugPhase$2('inspect');
  	setDebugNamespace$1('done');
  	debug$4('Checking to see if expected calls have been made');
  	let routesToCheck;

  	if (nameOrMatcher && typeof nameOrMatcher !== 'boolean') {
  		debug$4(
  			'Checking to see if expected calls have been made for single route:',
  			nameOrMatcher
  		);
  		routesToCheck = [{ identifier: nameOrMatcher }];
  	} else {
  		debug$4('Checking to see if expected calls have been made for all routes');
  		routesToCheck = this.routes;
  	}

  	// Can't use array.every because would exit after first failure, which would
  	// break the logging
  	const result = routesToCheck
  		.map(({ identifier }) => {
  			if (!this.called(identifier)) {
  				debug$4('No calls made for route:', identifier);
  				console.warn(`Warning: ${identifier} not called`); // eslint-disable-line
  				return false;
  			}

  			const expectedTimes = (
  				this.routes.find((r) => r.identifier === identifier) || {}
  			).repeat;

  			if (!expectedTimes) {
  				debug$4(
  					'Route has been called at least once, and no expectation of more set:',
  					identifier
  				);
  				return true;
  			}
  			const actualTimes = this.filterCalls(identifier).length;

  			debug$4(`Route called ${actualTimes} times:`, identifier);
  			if (expectedTimes > actualTimes) {
  				debug$4(
  					`Route called ${actualTimes} times, but expected ${expectedTimes}:`,
  					identifier
  				);
  				console.warn(
  					`Warning: ${identifier} only called ${actualTimes} times, but ${expectedTimes} expected`
  				); // eslint-disable-line
  				return false;
  			} else {
  				return true;
  			}
  		})
  		.every((isDone) => isDone);

  	setDebugNamespace$1();
  	setDebugPhase$2();
  	return result;
  });

  var inspecting = FetchMock$2;

  const { debug: debug$5 } = debug_1;





  const FetchMock$3 = Object.assign({}, fetchHandler, setUpAndTearDown, inspecting);

  FetchMock$3.addMatcher = function (matcher) {
  	Route_1.addMatcher(matcher);
  };

  FetchMock$3.config = {
  	fallbackToNetwork: false,
  	includeContentLength: true,
  	sendAsJson: true,
  	warnOnFallback: true,
  	overwriteRoutes: undefined,
  };

  FetchMock$3.createInstance = function () {
  	debug$5('Creating fetch-mock instance');
  	const instance = Object.create(FetchMock$3);
  	instance._uncompiledRoutes = (this._uncompiledRoutes || []).slice();
  	instance.routes = instance._uncompiledRoutes.map((config) =>
  		this.compileRoute(config)
  	);
  	instance.fallbackResponse = this.fallbackResponse || undefined;
  	instance.config = Object.assign({}, this.config || FetchMock$3.config);
  	instance._calls = [];
  	instance._holdingPromises = [];
  	instance.bindMethods();
  	return instance;
  };

  FetchMock$3.compileRoute = function (config) {
  	return new Route_1(config, this);
  };

  FetchMock$3.bindMethods = function () {
  	this.fetchHandler = FetchMock$3.fetchHandler.bind(this);
  	this.reset = this.restore = FetchMock$3.reset.bind(this);
  	this.resetHistory = FetchMock$3.resetHistory.bind(this);
  	this.resetBehavior = FetchMock$3.resetBehavior.bind(this);
  };

  FetchMock$3.sandbox = function () {
  	debug$5('Creating sandboxed fetch-mock instance');
  	// this construct allows us to create a fetch-mock instance which is also
  	// a callable function, while circumventing circularity when defining the
  	// object that this function should be bound to
  	const fetchMockProxy = (url, options) => sandbox.fetchHandler(url, options);

  	const sandbox = Object.assign(
  		fetchMockProxy, // Ensures that the entire returned object is a callable function
  		FetchMock$3, // prototype methods
  		this.createInstance(), // instance data
  		{
  			Headers: this.config.Headers,
  			Request: this.config.Request,
  			Response: this.config.Response,
  		}
  	);

  	sandbox.bindMethods();
  	sandbox.isSandbox = true;
  	sandbox.default = sandbox;
  	return sandbox;
  };

  FetchMock$3.getOption = function (name, route = {}) {
  	return name in route ? route[name] : this.config[name];
  };

  var lib = FetchMock$3;

  const statusTextMap = {
  	100: 'Continue',
  	101: 'Switching Protocols',
  	102: 'Processing',
  	200: 'OK',
  	201: 'Created',
  	202: 'Accepted',
  	203: 'Non-Authoritative Information',
  	204: 'No Content',
  	205: 'Reset Content',
  	206: 'Partial Content',
  	207: 'Multi-Status',
  	208: 'Already Reported',
  	226: 'IM Used',
  	300: 'Multiple Choices',
  	301: 'Moved Permanently',
  	302: 'Found',
  	303: 'See Other',
  	304: 'Not Modified',
  	305: 'Use Proxy',
  	307: 'Temporary Redirect',
  	308: 'Permanent Redirect',
  	400: 'Bad Request',
  	401: 'Unauthorized',
  	402: 'Payment Required',
  	403: 'Forbidden',
  	404: 'Not Found',
  	405: 'Method Not Allowed',
  	406: 'Not Acceptable',
  	407: 'Proxy Authentication Required',
  	408: 'Request Timeout',
  	409: 'Conflict',
  	410: 'Gone',
  	411: 'Length Required',
  	412: 'Precondition Failed',
  	413: 'Payload Too Large',
  	414: 'URI Too Long',
  	415: 'Unsupported Media Type',
  	416: 'Range Not Satisfiable',
  	417: 'Expectation Failed',
  	418: "I'm a teapot",
  	421: 'Misdirected Request',
  	422: 'Unprocessable Entity',
  	423: 'Locked',
  	424: 'Failed Dependency',
  	425: 'Unordered Collection',
  	426: 'Upgrade Required',
  	428: 'Precondition Required',
  	429: 'Too Many Requests',
  	431: 'Request Header Fields Too Large',
  	451: 'Unavailable For Legal Reasons',
  	500: 'Internal Server Error',
  	501: 'Not Implemented',
  	502: 'Bad Gateway',
  	503: 'Service Unavailable',
  	504: 'Gateway Timeout',
  	505: 'HTTP Version Not Supported',
  	506: 'Variant Also Negotiates',
  	507: 'Insufficient Storage',
  	508: 'Loop Detected',
  	509: 'Bandwidth Limit Exceeded',
  	510: 'Not Extended',
  	511: 'Network Authentication Required',
  };

  var statusText = statusTextMap;

  const theGlobal = typeof window !== 'undefined' ? window : self;
  const { setUrlImplementation } = requestUtils;
  setUrlImplementation(theGlobal.URL);

  lib.global = theGlobal;
  lib.statusTextMap = statusText;

  lib.config = Object.assign(lib.config, {
  	Promise: theGlobal.Promise,
  	Request: theGlobal.Request,
  	Response: theGlobal.Response,
  	Headers: theGlobal.Headers,
  });

  var client = lib.createInstance();

  describe('events as a json feed', () => {
      pushOptions({
          initialDate: '2014-05-01',
          initialView: 'dayGridMonth',
      });
      afterEach(() => {
          client.restore();
      });
      it('requests correctly when local timezone', () => {
          const START = '2014-04-27T00:00:00';
          const END = '2014-06-08T00:00:00';
          const givenUrl = window.location.href + '/my-feed.php';
          client.get(/my-feed\.php/, { body: [] });
          initCalendar({
              events: givenUrl,
              timeZone: 'local',
          });
          const [requestUrl] = client.lastCall();
          const requestParams = new URL(requestUrl).searchParams;
          expect(requestParams.get('start')).toBe(START + formatIsoTimeZoneOffset(new Date(START)));
          expect(requestParams.get('end')).toBe(END + formatIsoTimeZoneOffset(new Date(END)));
      });
      it('requests correctly when UTC timezone', () => {
          const givenUrl = window.location.href + '/my-feed.php';
          client.get(/my-feed\.php/, { body: [] });
          initCalendar({
              events: givenUrl,
              timeZone: 'UTC',
          });
          const [requestUrl] = client.lastCall();
          const requestParams = new URL(requestUrl).searchParams;
          expect(requestParams.get('start')).toBe('2014-04-27T00:00:00Z');
          expect(requestParams.get('end')).toBe('2014-06-08T00:00:00Z');
          expect(requestParams.get('timeZone')).toBe('UTC');
      });
      it('requests correctly when named timezone', () => {
          const givenUrl = window.location.href + '/my-feed.php';
          client.get(/my-feed\.php/, { body: [] });
          initCalendar({
              events: givenUrl,
              timeZone: 'America/Chicago',
          });
          const [requestUrl] = client.lastCall();
          const requestParams = new URL(requestUrl).searchParams;
          expect(requestParams.get('start')).toBe('2014-04-27T00:00:00');
          expect(requestParams.get('end')).toBe('2014-06-08T00:00:00');
          expect(requestParams.get('timeZone')).toBe('America/Chicago');
      });
      // https://github.com/fullcalendar/fullcalendar/issues/5485
      it('processes new events under updated time zone', (done) => {
          const givenUrl = window.location.href + '/my-feed.php';
          client.get(/my-feed\.php/, (requestUrl) => {
              const requestParams = new URL(requestUrl).searchParams;
              let reqTimeZone = requestParams.get('timeZone');
              return {
                  body: [
                      reqTimeZone === 'America/Chicago'
                          ? { start: '2014-06-08T01:00:00' }
                          : { start: '2014-06-08T03:00:00' },
                  ],
              };
          });
          let calendar = initCalendar({
              events: givenUrl,
              timeZone: 'America/Chicago',
          });
          setTimeout(() => {
              let eventStartStr = calendar.getEvents()[0].startStr;
              expect(eventStartStr).toBe('2014-06-08T01:00:00');
              calendar.setOption('timeZone', 'America/New_York');
              setTimeout(() => {
                  eventStartStr = calendar.getEvents()[0].startStr;
                  expect(eventStartStr).toBe('2014-06-08T03:00:00');
                  done();
              }, 100);
          }, 100);
      });
      it('requests correctly with event source extended form', (done) => {
          const givenUrl = window.location.href + '/my-feed.php';
          client.get(/my-feed\.php/, {
              body: [
                  {
                      title: 'my event',
                      start: '2014-05-21',
                  },
              ],
          });
          initCalendar({
              eventSources: [{
                      url: givenUrl,
                      classNames: 'customeventclass',
                  }],
              timeZone: 'America/Chicago',
              eventDidMount(arg) {
                  expect(arg.el).toHaveClass('customeventclass');
                  done();
              },
          });
          const [requestUrl] = client.lastCall();
          const requestParams = new URL(requestUrl).searchParams;
          expect(requestParams.get('start')).toBe('2014-04-27T00:00:00');
          expect(requestParams.get('end')).toBe('2014-06-08T00:00:00');
          expect(requestParams.get('timeZone')).toBe('America/Chicago');
      });
      it('requests POST correctly', (done) => {
          const givenUrl = window.location.href + '/my-feed.php';
          client.post(/my-feed\.php/, (url, options) => {
              const paramStrGet = new URL(url).searchParams.toString();
              const paramStrPost = options.body.toString();
              expect(paramStrGet).toBe('');
              expect(paramStrPost).toBe('start=2014-04-27T00%3A00%3A00Z&end=2014-06-08T00%3A00%3A00Z&timeZone=UTC');
              done();
              return { body: [] };
          });
          initCalendar({
              events: {
                  url: givenUrl,
                  method: 'POST',
              },
              timeZone: 'UTC',
          });
      });
      it('accepts a extraParams object', () => {
          const givenUrl = window.location.href + '/my-feed.php';
          client.get(/my-feed\.php/, { body: [] });
          initCalendar({
              eventSources: [{
                      url: givenUrl,
                      extraParams: {
                          customParam: 'yes',
                      },
                  }],
          });
          const [requestUrl] = client.lastCall();
          const requestParams = new URL(requestUrl).searchParams;
          expect(requestParams.get('start')).toBe('2014-04-27T00:00:00Z');
          expect(requestParams.get('end')).toBe('2014-06-08T00:00:00Z');
          expect(requestParams.get('timeZone')).toBe('UTC');
          expect(requestParams.get('customParam')).toBe('yes');
      });
      it('accepts a dynamic extraParams function', () => {
          const givenUrl = window.location.href + '/my-feed.php';
          client.get(/my-feed\.php/, { body: [] });
          initCalendar({
              eventSources: [{
                      url: givenUrl,
                      extraParams() {
                          return {
                              customParam: 'heckyeah',
                          };
                      },
                  }],
          });
          const [requestUrl] = client.lastCall();
          const requestParams = new URL(requestUrl).searchParams;
          expect(requestParams.get('start')).toBe('2014-04-27T00:00:00Z');
          expect(requestParams.get('end')).toBe('2014-06-08T00:00:00Z');
          expect(requestParams.get('timeZone')).toBe('UTC');
          expect(requestParams.get('customParam')).toBe('heckyeah');
      });
      it('calls loading callback', (done) => {
          const loadingCallArgs = [];
          const givenUrl = window.location.href + '/my-feed.php';
          client.get(/my-feed\.php/, { body: [] });
          initCalendar({
              events: { url: givenUrl },
              loading(bool) {
                  loadingCallArgs.push(bool);
              },
          });
          setTimeout(() => {
              expect(loadingCallArgs).toEqual([true, false]);
              done();
          }, 100);
      });
      it('has and Event Source object with certain props', () => {
          const givenUrl = window.location.href + '/my-feed.php';
          client.get(/my-feed\.php/, { body: [] });
          initCalendar({
              events: { url: givenUrl },
          });
          expect(currentCalendar.getEventSources()[0].url).toBe(givenUrl);
      });
      it('throws JsonRequestError if mangled JSON', (done) => {
          const givenUrl = window.location.href + '/my-feed.php';
          client.get(/my-feed\.php/, { body: '[{title:' });
          let eventSourceFailureCalled = false;
          initCalendar({
              events: { url: givenUrl },
              eventSourceFailure(error) {
                  let isJsonRequestFailure = error instanceof JsonRequestError;
                  if (isJsonRequestFailure) {
                      expect(typeof error.response.url).toBe('string'); // NOTE: fetchMock mangles exact url
                  }
                  expect(isJsonRequestFailure).toBe(true);
                  eventSourceFailureCalled = true;
              },
          });
          setTimeout(() => {
              expect(eventSourceFailureCalled).toBe(true);
              done();
          }, 100);
      });
  });

  // SEE ALSO: event-color.js
  describe('background events', () => {
      pushOptions({
          initialDate: '2014-11-04',
          scrollTime: '00:00',
      });
      describe('when in month view', () => {
          pushOptions({ initialView: 'dayGridMonth' });
          describe('when LTR', () => {
              it('render correctly on a single day', () => {
                  let calendar = initCalendar({
                      events: [{
                              title: 'hi',
                              start: '2014-11-04',
                              display: 'background',
                          }],
                  });
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  let allBgEls = dayGridWrapper.getBgEventEls();
                  expect(allBgEls.length).toBe(1);
                  expect(dayGridWrapper.getBgEventEls(1).length).toBe(1);
                  expect(allBgEls[0]).toBeLeftOf(dayGridWrapper.getDayEl('2014-11-05'));
                  expect(dayGridWrapper.getEventEls().length).toBe(0);
              });
              it('render correctly spanning multiple weeks', () => {
                  let calendar = initCalendar({
                      events: [{
                              title: 'hi',
                              start: '2014-11-04',
                              end: '2014-11-11',
                              display: 'background',
                          }],
                  });
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  let allBgEls = dayGridWrapper.getBgEventEls();
                  expect(allBgEls.length).toBe(2);
                  expect(dayGridWrapper.getBgEventEls(1).length).toBe(1);
                  expect(dayGridWrapper.getBgEventEls(2).length).toBe(1);
                  expect(allBgEls[0]).toBeRightOf(dayGridWrapper.getDayEl('2014-11-03'));
                  expect(allBgEls[1]).toBeLeftOf(dayGridWrapper.getDayEl('2014-11-12'));
                  expect(dayGridWrapper.getEventEls().length).toBe(0);
              });
              it('render correctly when two span on top of each other', () => {
                  let calendar = initCalendar({
                      events: [
                          {
                              start: '2014-11-04',
                              end: '2014-11-07',
                              display: 'background',
                          },
                          {
                              start: '2014-11-05',
                              end: '2014-11-08',
                              display: 'background',
                          },
                      ],
                  });
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  let allBgEls = dayGridWrapper.getBgEventEls();
                  expect(allBgEls.length).toBe(2);
                  expect(dayGridWrapper.getBgEventEls(1).length).toBe(2);
                  expect(allBgEls[0]).toBeRightOf(dayGridWrapper.getDayEl('2014-11-02'));
                  expect(allBgEls[1]).toBeLeftOf(dayGridWrapper.getDayEl('2014-11-08'));
                  expect(dayGridWrapper.getEventEls().length).toBe(0);
              });
              it('renders "business hours" on whole days', () => {
                  let calendar = initCalendar({
                      businessHours: true,
                  });
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  expect(dayGridWrapper.getNonBusinessDayEls().length).toBe(12); // there are 6 weeks. 2 weekend days each
              });
          });
          describe('when RTL', () => {
              pushOptions({ direction: 'rtl' });
              it('render correctly on a single day', () => {
                  let calendar = initCalendar({
                      events: [{
                              title: 'hi',
                              start: '2014-11-04',
                              display: 'background',
                          }],
                  });
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  let allBgEls = dayGridWrapper.getBgEventEls();
                  expect(allBgEls.length).toBe(1);
                  expect(dayGridWrapper.getBgEventEls(1).length).toBe(1);
                  expect(allBgEls[0]).toBeRightOf(dayGridWrapper.getDayEl('2014-11-06'));
                  expect(dayGridWrapper.getEventEls().length).toBe(0);
              });
              it('render correctly spanning multiple weeks', () => {
                  let calendar = initCalendar({
                      events: [{
                              title: 'hi',
                              start: '2014-11-04',
                              end: '2014-11-11',
                              display: 'background',
                          }],
                  });
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  let allBgEls = dayGridWrapper.getBgEventEls();
                  expect(allBgEls.length).toBe(2);
                  expect(dayGridWrapper.getBgEventEls(1).length).toBe(1);
                  expect(dayGridWrapper.getBgEventEls(2).length).toBe(1);
                  expect(allBgEls[0]).toBeLeftOf(dayGridWrapper.getDayEl('2014-11-02'));
                  expect(allBgEls[1]).toBeRightOf(dayGridWrapper.getDayEl('2014-11-12'));
                  expect(dayGridWrapper.getEventEls().length).toBe(0);
              });
          });
          describe('when inverse', () => {
              describe('when LTR', () => {
                  it('render correctly on a single day', () => {
                      let calendar = initCalendar({
                          events: [{
                                  title: 'hi',
                                  start: '2014-11-04',
                                  display: 'inverse-background',
                              }],
                      });
                      let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                      expect(dayGridWrapper.getBgEventEls().length).toBe(7);
                      expect(dayGridWrapper.getBgEventEls(0).length).toBe(1);
                      expect(dayGridWrapper.getBgEventEls(1).length).toBe(2);
                      expect(dayGridWrapper.getBgEventEls(2).length).toBe(1);
                      expect(dayGridWrapper.getBgEventEls(3).length).toBe(1);
                      expect(dayGridWrapper.getBgEventEls(4).length).toBe(1);
                      expect(dayGridWrapper.getBgEventEls(5).length).toBe(1);
                      let secondRowBgEls = dayGridWrapper.getBgEventEls(1);
                      expect(secondRowBgEls[0])
                          .toBeLeftOf(dayGridWrapper.getDayEl('2014-11-05'));
                      expect(secondRowBgEls[1])
                          .toBeRightOf(dayGridWrapper.getDayEl('2014-11-03'));
                      expect(dayGridWrapper.getEventEls().length).toBe(0);
                  });
                  it('render correctly spanning multiple weeks', () => {
                      let calendar = initCalendar({
                          events: [{
                                  title: 'hi',
                                  start: '2014-11-04',
                                  end: '2014-11-11',
                                  display: 'inverse-background',
                              }],
                      });
                      let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                      expect(dayGridWrapper.getBgEventEls().length).toBe(6);
                      expect(dayGridWrapper.getBgEventEls(0).length).toBe(1);
                      expect(dayGridWrapper.getBgEventEls(1).length).toBe(1);
                      expect(dayGridWrapper.getBgEventEls(2).length).toBe(1);
                      expect(dayGridWrapper.getBgEventEls(3).length).toBe(1);
                      expect(dayGridWrapper.getBgEventEls(4).length).toBe(1);
                      expect(dayGridWrapper.getBgEventEls(5).length).toBe(1);
                      expect(dayGridWrapper.getBgEventEls(1)[0])
                          .toBeLeftOf(dayGridWrapper.getDayEl('2014-11-05'));
                      expect(dayGridWrapper.getBgEventEls(2)[0])
                          .toBeRightOf(dayGridWrapper.getDayEl('2014-11-09'));
                      expect(dayGridWrapper.getEventEls().length).toBe(0);
                  });
                  it('render correctly when starts before start of month', () => {
                      let calendar = initCalendar({
                          events: [{
                                  start: '2014-10-24',
                                  end: '2014-11-06',
                                  display: 'inverse-background',
                              }],
                      });
                      let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                      expect(dayGridWrapper.getBgEventEls().length).toBe(5);
                      expect(dayGridWrapper.getBgEventEls(0).length).toBe(0);
                      expect(dayGridWrapper.getBgEventEls(1).length).toBe(1);
                      expect(dayGridWrapper.getBgEventEls(2).length).toBe(1);
                      expect(dayGridWrapper.getBgEventEls(3).length).toBe(1);
                      expect(dayGridWrapper.getBgEventEls(4).length).toBe(1);
                      expect(dayGridWrapper.getBgEventEls(5).length).toBe(1);
                      expect(dayGridWrapper.getBgEventEls(1))
                          .toBeRightOf(dayGridWrapper.getDayEl('2014-11-04'));
                  });
                  it('render correctly when ends after end of month', () => {
                      let calendar = initCalendar({
                          events: [{
                                  start: '2014-11-27',
                                  end: '2014-12-08',
                                  display: 'inverse-background',
                              }],
                      });
                      let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                      expect(dayGridWrapper.getBgEventEls().length).toBe(5);
                      expect(dayGridWrapper.getBgEventEls(0).length).toBe(1);
                      expect(dayGridWrapper.getBgEventEls(1).length).toBe(1);
                      expect(dayGridWrapper.getBgEventEls(2).length).toBe(1);
                      expect(dayGridWrapper.getBgEventEls(3).length).toBe(1);
                      expect(dayGridWrapper.getBgEventEls(4).length).toBe(1);
                      expect(dayGridWrapper.getBgEventEls(5).length).toBe(0);
                      expect(dayGridWrapper.getBgEventEls(4))
                          .toBeLeftOf(dayGridWrapper.getDayEl('2014-11-28'));
                  });
                  it('render correctly with two related events, in reverse order', () => {
                      let calendar = initCalendar({
                          events: [
                              {
                                  groupId: 'hi',
                                  start: '2014-11-06',
                                  display: 'inverse-background',
                              },
                              {
                                  groupId: 'hi',
                                  start: '2014-11-04',
                                  display: 'inverse-background',
                              },
                          ],
                      });
                      let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                      expect(dayGridWrapper.getBgEventEls().length).toBe(8);
                      expect(dayGridWrapper.getBgEventEls(0).length).toBe(1);
                      expect(dayGridWrapper.getBgEventEls(1).length).toBe(3);
                      expect(dayGridWrapper.getBgEventEls(2).length).toBe(1);
                      expect(dayGridWrapper.getBgEventEls(3).length).toBe(1);
                      expect(dayGridWrapper.getBgEventEls(4).length).toBe(1);
                      expect(dayGridWrapper.getBgEventEls(5).length).toBe(1);
                  });
              });
              describe('when RTL', () => {
                  pushOptions({ direction: 'rtl' });
                  it('render correctly on a single day', () => {
                      let calendar = initCalendar({
                          events: [{
                                  title: 'hi',
                                  start: '2014-11-04',
                                  display: 'inverse-background',
                              }],
                      });
                      let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                      expect(dayGridWrapper.getBgEventEls().length).toBe(7);
                      expect(dayGridWrapper.getBgEventEls(0).length).toBe(1);
                      expect(dayGridWrapper.getBgEventEls(1).length).toBe(2);
                      expect(dayGridWrapper.getBgEventEls(2).length).toBe(1);
                      expect(dayGridWrapper.getBgEventEls(3).length).toBe(1);
                      expect(dayGridWrapper.getBgEventEls(4).length).toBe(1);
                      expect(dayGridWrapper.getBgEventEls(5).length).toBe(1);
                  });
              });
          });
          describe('when in month view', () => {
              it('can be activated when rendering set on the source', () => {
                  let calendar = initCalendar({
                      initialView: 'dayGridMonth',
                      eventSources: [{
                              display: 'background',
                              events: [{
                                      start: '2014-11-04',
                                  }],
                          }],
                  });
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  expect(dayGridWrapper.getBgEventEls().length).toBe(1);
                  expect(dayGridWrapper.getEventEls().length).toBe(0);
              });
          });
          describe('when in timeGrid view and timed event', () => {
              it('can be activated when rendering set on the source', () => {
                  let calendar = initCalendar({
                      initialView: 'timeGridWeek',
                      eventSources: [{
                              display: 'background',
                              events: [{
                                      start: '2014-11-04T01:00:00',
                                  }],
                          }],
                  });
                  let viewWrapper = new TimeGridViewWrapper(calendar);
                  expect(viewWrapper.dayGrid.getEventEls().length).toBe(0);
                  expect(viewWrapper.timeGrid.getBgEventEls().length).toBe(1);
              });
          });
      });
      describe('when in week view', () => {
          pushOptions({ initialView: 'timeGridWeek' });
          describe('when LTR', () => {
              it('render correctly on one day', () => {
                  let calendar = initCalendar({
                      events: [{
                              start: '2014-11-04T01:00:00',
                              end: '2014-11-04T05:00:00',
                              display: 'background',
                          }],
                  });
                  let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                  let allBgEvents = timeGridWrapper.getBgEventEls();
                  expect(allBgEvents.length).toBe(1);
                  expect(timeGridWrapper.queryBgEventsInCol(2).length).toBe(1); // column
                  expect(timeGridWrapper.getEventEls().length).toBe(0); // no fg events
                  let rect = allBgEvents[0].getBoundingClientRect();
                  let topDiff = Math.abs(rect.top - timeGridWrapper.getTimeTop('01:00:00')); // TODO: make more exact
                  let bottomDiff = Math.abs(rect.bottom - timeGridWrapper.getTimeTop('05:00:00'));
                  expect(topDiff).toBeLessThanOrEqual(1);
                  expect(bottomDiff).toBeLessThanOrEqual(1);
              });
              it('render correctly spanning multiple days', () => {
                  let calendar = initCalendar({
                      events: [{
                              start: '2014-11-04T01:00:00',
                              end: '2014-11-05T05:00:00',
                              display: 'background',
                          }],
                  });
                  let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                  expect(timeGridWrapper.getBgEventEls().length).toBe(2);
                  expect(timeGridWrapper.queryBgEventsInCol(2).length).toBe(1);
                  expect(timeGridWrapper.queryBgEventsInCol(3).length).toBe(1);
              });
              it('render correctly when two span on top of each other', () => {
                  let calendar = initCalendar({
                      events: [
                          {
                              start: '2014-11-04T01:00:00',
                              end: '2014-11-05T05:00:00',
                              display: 'background',
                          },
                          {
                              start: '2014-11-04T03:00:00',
                              end: '2014-11-05T08:00:00',
                              display: 'background',
                          },
                      ],
                  });
                  let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                  expect(timeGridWrapper.getBgEventEls().length).toBe(4);
                  expect(timeGridWrapper.queryBgEventsInCol(2).length).toBe(2);
                  expect(timeGridWrapper.queryBgEventsInCol(3).length).toBe(2);
                  // TODO: maybe check y coords
              });
              describe('when businessHours', () => {
                  it('renders correctly if assumed default', () => {
                      let calendar = initCalendar({
                          businessHours: true,
                      });
                      let viewWrapper = new TimeGridViewWrapper(calendar);
                      expect(viewWrapper.dayGrid.getNonBusinessDayEls().length).toBe(2); // whole days in the day area
                      expect(viewWrapper.timeGrid.getNonBusinessDayEls().length).toBe(12); // strips of gray on the timed area
                  });
                  it('renders correctly if custom', () => {
                      let calendar = initCalendar({
                          businessHours: {
                              startTime: '02:00',
                              endTime: '06:00',
                              daysOfWeek: [1, 2, 3, 4], // Mon-Thu
                          },
                      });
                      let viewWrapper = new TimeGridViewWrapper(calendar);
                      // whole days
                      expect(viewWrapper.dayGrid.getNonBusinessDayEls().length).toBe(2); // each multi-day stretch is one element
                      // time area
                      let timeGridWrapper = viewWrapper.timeGrid;
                      expect(timeGridWrapper.getNonBusinessDayEls().length).toBe(11);
                      expect(timeGridWrapper.queryNonBusinessSegsInCol(0).length).toBe(1);
                      expect(timeGridWrapper.queryNonBusinessSegsInCol(1).length).toBe(2);
                      expect(timeGridWrapper.queryNonBusinessSegsInCol(2).length).toBe(2);
                      expect(timeGridWrapper.queryNonBusinessSegsInCol(3).length).toBe(2);
                      expect(timeGridWrapper.queryNonBusinessSegsInCol(4).length).toBe(2);
                      expect(timeGridWrapper.queryNonBusinessSegsInCol(5).length).toBe(1);
                      expect(timeGridWrapper.queryNonBusinessSegsInCol(6).length).toBe(1);
                  });
              });
          });
          describe('when RTL', () => {
              pushOptions({
                  direction: 'rtl',
              });
              it('render correctly on one day', () => {
                  let calendar = initCalendar({
                      events: [{
                              start: '2014-11-04T01:00:00',
                              end: '2014-11-04T05:00:00',
                              display: 'background',
                          }],
                  });
                  let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                  let allBgEls = timeGridWrapper.getBgEventEls();
                  expect(allBgEls.length).toBe(1);
                  expect(timeGridWrapper.queryBgEventsInCol(2).length).toBe(1);
                  let rect = allBgEls[0].getBoundingClientRect();
                  let topDiff = Math.abs(rect.top - timeGridWrapper.getTimeTop('01:00:00'));
                  let bottomDiff = Math.abs(rect.bottom - timeGridWrapper.getTimeTop('05:00:00'));
                  expect(topDiff).toBeLessThanOrEqual(1); // TODO: tighten up
                  expect(bottomDiff).toBeLessThanOrEqual(1);
              });
              it('render correctly spanning multiple days', () => {
                  let calendar = initCalendar({
                      events: [{
                              start: '2014-11-04T01:00:00',
                              end: '2014-11-05T05:00:00',
                              display: 'background',
                          }],
                  });
                  let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                  expect(timeGridWrapper.getBgEventEls().length).toBe(2);
                  expect(timeGridWrapper.queryBgEventsInCol(3).length).toBe(1);
                  expect(timeGridWrapper.queryBgEventsInCol(2).length).toBe(1);
              });
              describe('when businessHours', () => {
                  it('renders correctly if custom', () => {
                      let calendar = initCalendar({
                          businessHours: {
                              startTime: '02:00',
                              endTime: '06:00',
                              daysOfWeek: [1, 2, 3, 4], // Mon-Thu
                          },
                      });
                      let viewWrapper = new TimeGridViewWrapper(calendar);
                      // whole days
                      let dayGridWrapper = viewWrapper.dayGrid;
                      expect(dayGridWrapper.getNonBusinessDayEls().length).toBe(2); // each stretch of days is one element
                      // time area
                      let timeGridWrapper = viewWrapper.timeGrid;
                      expect(timeGridWrapper.getNonBusinessDayEls().length).toBe(11);
                      expect(timeGridWrapper.queryNonBusinessSegsInCol(0).length).toBe(1);
                      expect(timeGridWrapper.queryNonBusinessSegsInCol(1).length).toBe(2);
                      expect(timeGridWrapper.queryNonBusinessSegsInCol(2).length).toBe(2);
                      expect(timeGridWrapper.queryNonBusinessSegsInCol(3).length).toBe(2);
                      expect(timeGridWrapper.queryNonBusinessSegsInCol(4).length).toBe(2);
                      expect(timeGridWrapper.queryNonBusinessSegsInCol(5).length).toBe(1);
                      expect(timeGridWrapper.queryNonBusinessSegsInCol(6).length).toBe(1);
                  });
              });
          });
          describe('when inverse', () => {
              describe('when LTR', () => {
                  it('render correctly on one day', () => {
                      let calendar = initCalendar({
                          events: [{
                                  start: '2014-11-04T01:00:00',
                                  end: '2014-11-04T05:00:00',
                                  display: 'inverse-background',
                              }],
                      });
                      let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                      expect(timeGridWrapper.getBgEventEls().length).toBe(8);
                      expect(timeGridWrapper.queryBgEventsInCol(0).length).toBe(1);
                      expect(timeGridWrapper.queryBgEventsInCol(1).length).toBe(1);
                      expect(timeGridWrapper.queryBgEventsInCol(2).length).toBe(2);
                      expect(timeGridWrapper.queryBgEventsInCol(3).length).toBe(1);
                      expect(timeGridWrapper.queryBgEventsInCol(4).length).toBe(1);
                      expect(timeGridWrapper.queryBgEventsInCol(5).length).toBe(1);
                      expect(timeGridWrapper.queryBgEventsInCol(6).length).toBe(1);
                      // TODO: maybe check y coords
                  });
                  it('render correctly spanning multiple days', () => {
                      let calendar = initCalendar({
                          events: [{
                                  start: '2014-11-04T01:00:00',
                                  end: '2014-11-05T05:00:00',
                                  display: 'inverse-background',
                              }],
                      });
                      let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                      expect(timeGridWrapper.getBgEventEls().length).toBe(7);
                      expect(timeGridWrapper.queryBgEventsInCol(0).length).toBe(1);
                      expect(timeGridWrapper.queryBgEventsInCol(1).length).toBe(1);
                      expect(timeGridWrapper.queryBgEventsInCol(2).length).toBe(1);
                      expect(timeGridWrapper.queryBgEventsInCol(3).length).toBe(1);
                      expect(timeGridWrapper.queryBgEventsInCol(4).length).toBe(1);
                      expect(timeGridWrapper.queryBgEventsInCol(5).length).toBe(1);
                      expect(timeGridWrapper.queryBgEventsInCol(6).length).toBe(1);
                      // TODO: maybe check y coords
                  });
                  it('render correctly when starts before start of week', () => {
                      let calendar = initCalendar({
                          events: [{
                                  start: '2014-10-30T01:00:00',
                                  end: '2014-11-04T05:00:00',
                                  display: 'inverse-background',
                              }],
                      });
                      let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                      expect(timeGridWrapper.getBgEventEls().length).toBe(5);
                      expect(timeGridWrapper.queryBgEventsInCol(0).length).toBe(0);
                      expect(timeGridWrapper.queryBgEventsInCol(1).length).toBe(0);
                      expect(timeGridWrapper.queryBgEventsInCol(2).length).toBe(1);
                      expect(timeGridWrapper.queryBgEventsInCol(3).length).toBe(1);
                      expect(timeGridWrapper.queryBgEventsInCol(4).length).toBe(1);
                      expect(timeGridWrapper.queryBgEventsInCol(5).length).toBe(1);
                      expect(timeGridWrapper.queryBgEventsInCol(6).length).toBe(1);
                      // TODO: maybe check y coords
                  });
                  it('render correctly when ends after end of week', () => {
                      let calendar = initCalendar({
                          events: [{
                                  start: '2014-11-04T01:00:00',
                                  end: '2014-11-12T05:00:00',
                                  display: 'inverse-background',
                              }],
                      });
                      let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                      expect(timeGridWrapper.getBgEventEls().length).toBe(3);
                      expect(timeGridWrapper.queryBgEventsInCol(0).length).toBe(1);
                      expect(timeGridWrapper.queryBgEventsInCol(1).length).toBe(1);
                      expect(timeGridWrapper.queryBgEventsInCol(2).length).toBe(1);
                      // TODO: maybe check y coords
                  });
                  it('render correctly with two related events, in reverse order', () => {
                      let calendar = initCalendar({
                          events: [
                              {
                                  groupId: 'hello',
                                  start: '2014-11-05T01:00:00',
                                  end: '2014-11-05T05:00:00',
                                  display: 'inverse-background',
                              },
                              {
                                  groupId: 'hello',
                                  start: '2014-11-03T01:00:00',
                                  end: '2014-11-03T05:00:00',
                                  display: 'inverse-background',
                              },
                          ],
                      });
                      let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                      expect(timeGridWrapper.getBgEventEls().length).toBe(9);
                      expect(timeGridWrapper.queryBgEventsInCol(0).length).toBe(1);
                      expect(timeGridWrapper.queryBgEventsInCol(1).length).toBe(2);
                      expect(timeGridWrapper.queryBgEventsInCol(2).length).toBe(1);
                      expect(timeGridWrapper.queryBgEventsInCol(3).length).toBe(2);
                      expect(timeGridWrapper.queryBgEventsInCol(4).length).toBe(1);
                      expect(timeGridWrapper.queryBgEventsInCol(5).length).toBe(1);
                      expect(timeGridWrapper.queryBgEventsInCol(6).length).toBe(1);
                      // TODO: maybe check y coords
                  });
                  it('render correctly with two related events, nested', () => {
                      let calendar = initCalendar({
                          events: [
                              {
                                  groupId: 'hello',
                                  start: '2014-11-05T01:00:00',
                                  end: '2014-11-05T05:00:00',
                                  display: 'inverse-background',
                              },
                              {
                                  groupId: 'hello',
                                  start: '2014-11-05T02:00:00',
                                  end: '2014-11-05T04:00:00',
                                  display: 'inverse-background',
                              },
                          ],
                      });
                      let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                      let allBgEls = timeGridWrapper.getBgEventEls();
                      expect(allBgEls.length).toBe(8);
                      expect(timeGridWrapper.queryBgEventsInCol(0).length).toBe(1);
                      expect(timeGridWrapper.queryBgEventsInCol(1).length).toBe(1);
                      expect(timeGridWrapper.queryBgEventsInCol(2).length).toBe(1);
                      expect(timeGridWrapper.queryBgEventsInCol(3).length).toBe(2);
                      expect(timeGridWrapper.queryBgEventsInCol(4).length).toBe(1);
                      expect(timeGridWrapper.queryBgEventsInCol(5).length).toBe(1);
                      expect(timeGridWrapper.queryBgEventsInCol(6).length).toBe(1);
                      expect(allBgEls[3].getBoundingClientRect().top)
                          .toBeLessThan(timeGridWrapper.getTimeTop('01:00:00'));
                      expect(allBgEls[4].getBoundingClientRect().bottom)
                          .toBeGreaterThan(timeGridWrapper.getTimeTop('05:00:00'));
                  });
              });
              describe('when RTL', () => {
                  pushOptions({
                      direction: 'rtl',
                  });
                  it('render correctly on one day', () => {
                      let calendar = initCalendar({
                          events: [{
                                  start: '2014-11-04T01:00:00',
                                  end: '2014-11-04T05:00:00',
                                  display: 'inverse-background',
                              }],
                      });
                      let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                      expect(timeGridWrapper.getBgEventEls().length).toBe(8);
                      expect(timeGridWrapper.queryBgEventsInCol(0).length).toBe(1);
                      expect(timeGridWrapper.queryBgEventsInCol(1).length).toBe(1);
                      expect(timeGridWrapper.queryBgEventsInCol(2).length).toBe(2);
                      expect(timeGridWrapper.queryBgEventsInCol(3).length).toBe(1);
                      expect(timeGridWrapper.queryBgEventsInCol(4).length).toBe(1);
                      expect(timeGridWrapper.queryBgEventsInCol(5).length).toBe(1);
                      expect(timeGridWrapper.queryBgEventsInCol(6).length).toBe(1);
                      // TODO: maybe check y coords
                  });
              });
              describe('when out of view range', () => {
                  it('should still render', () => {
                      let calendar = initCalendar({
                          events: [{
                                  start: '2014-01-01T01:00:00',
                                  end: '2014-01-01T05:00:00',
                                  display: 'inverse-background',
                              }],
                      });
                      let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                      expect(timeGridWrapper.getBgEventEls().length).toBe(7);
                  });
              });
          });
          it('can have custom Event Object color', () => {
              let calendar = initCalendar({
                  events: [{
                          start: '2014-11-04T01:00:00',
                          display: 'background',
                          color: 'red',
                      }],
              });
              let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
              let bgEl = timeGridWrapper.getBgEventEls()[0];
              expect($(bgEl).css('background-color')).toMatch(RED_REGEX);
          });
          it('can have custom Event Object backgroundColor', () => {
              let calendar = initCalendar({
                  events: [{
                          start: '2014-11-04T01:00:00',
                          display: 'background',
                          backgroundColor: 'red',
                      }],
              });
              let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
              let bgEl = timeGridWrapper.getBgEventEls()[0];
              expect($(bgEl).css('background-color')).toMatch(RED_REGEX);
          });
          it('can have custom Event Source color', () => {
              let calendar = initCalendar({
                  eventSources: [{
                          color: 'red',
                          events: [{
                                  start: '2014-11-04T01:00:00',
                                  display: 'background',
                              }],
                      }],
              });
              let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
              let bgEl = timeGridWrapper.getBgEventEls()[0];
              expect($(bgEl).css('background-color')).toMatch(RED_REGEX);
          });
          it('can have custom Event Source backgroundColor', () => {
              let calendar = initCalendar({
                  eventSources: [{
                          backgroundColor: 'red',
                          events: [{
                                  start: '2014-11-04T01:00:00',
                                  display: 'background',
                              }],
                      }],
              });
              let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
              let bgEl = timeGridWrapper.getBgEventEls()[0];
              expect($(bgEl).css('background-color')).toMatch(RED_REGEX);
          });
          it('is affected by global eventColor', () => {
              let calendar = initCalendar({
                  eventColor: 'red',
                  eventSources: [{
                          events: [{
                                  start: '2014-11-04T01:00:00',
                                  display: 'background',
                              }],
                      }],
              });
              let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
              let bgEl = timeGridWrapper.getBgEventEls()[0];
              expect($(bgEl).css('background-color')).toMatch(RED_REGEX);
          });
          it('is affected by global eventBackgroundColor', () => {
              let calendar = initCalendar({
                  eventBackgroundColor: 'red',
                  eventSources: [{
                          events: [{
                                  start: '2014-11-04T01:00:00',
                                  display: 'background',
                              }],
                      }],
              });
              let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
              let bgEl = timeGridWrapper.getBgEventEls()[0];
              expect($(bgEl).css('background-color')).toMatch(RED_REGEX);
          });
      });
  });

  describe('timeZone', () => {
      // NOTE: Only deals with the processing of *received* events.
      // Verification of a correct AJAX *request* is done in events-json-feed.js
      pushOptions({
          initialView: 'dayGridMonth',
          initialDate: '2014-05-01',
          events: [
              {
                  id: '1',
                  title: 'all day event',
                  start: '2014-05-02',
              },
              {
                  id: '2',
                  title: 'timed event',
                  start: '2014-05-10T12:00:00',
              },
              {
                  id: '3',
                  title: 'timed and zoned event',
                  start: '2014-05-10T14:00:00+11:00',
              },
          ],
      });
      it('receives events correctly when local timezone', () => {
          initCalendar({
              timeZone: 'local',
          });
          expectLocalTimezone();
      });
      function expectLocalTimezone() {
          let allDayEvent = currentCalendar.getEventById('1');
          let timedEvent = currentCalendar.getEventById('2');
          let zonedEvent = currentCalendar.getEventById('3');
          expect(allDayEvent.allDay).toEqual(true);
          expect(allDayEvent.start).toEqualLocalDate('2014-05-02T00:00:00');
          expect(timedEvent.allDay).toEqual(false);
          expect(timedEvent.start).toEqualLocalDate('2014-05-10T12:00:00');
          expect(zonedEvent.allDay).toEqual(false);
          expect(zonedEvent.start).toEqualDate('2014-05-10T14:00:00+11:00');
      }
      it('receives events correctly when UTC timezone', () => {
          initCalendar({
              timeZone: 'UTC',
          });
          expectUtcTimezone();
      });
      function expectUtcTimezone() {
          let allDayEvent = currentCalendar.getEventById('1');
          let timedEvent = currentCalendar.getEventById('2');
          let zonedEvent = currentCalendar.getEventById('3');
          expect(allDayEvent.allDay).toEqual(true);
          expect(allDayEvent.start).toEqualDate('2014-05-02');
          expect(timedEvent.allDay).toEqual(false);
          expect(timedEvent.start).toEqualDate('2014-05-10T12:00:00Z');
          expect(zonedEvent.allDay).toEqual(false);
          expect(zonedEvent.start).toEqualDate('2014-05-10T14:00:00+11:00');
      }
      it('receives events correctly when custom timezone', () => {
          initCalendar({
              timeZone: 'America/Chicago',
          });
          expectCustomTimezone();
      });
      function expectCustomTimezone() {
          let allDayEvent = currentCalendar.getEventById('1');
          let timedEvent = currentCalendar.getEventById('2');
          let zonedEvent = currentCalendar.getEventById('3');
          expect(allDayEvent.allDay).toEqual(true);
          expect(allDayEvent.start).toEqualDate('2014-05-02');
          expect(timedEvent.allDay).toEqual(false);
          expect(timedEvent.start).toEqualDate('2014-05-10T12:00:00Z');
          expect(zonedEvent.allDay).toEqual(false);
          expect(zonedEvent.start).toEqualDate('2014-05-10T14:00:00Z'); // coerced to UTC
      }
      it('can be set dynamically', () => {
          initCalendar({
              timeZone: 'local',
          });
          expectLocalTimezone();
          currentCalendar.setOption('timeZone', 'UTC');
          let allDayEvent = currentCalendar.getEventById('1');
          let timedEvent = currentCalendar.getEventById('2');
          let zonedEvent = currentCalendar.getEventById('3');
          expect(allDayEvent.allDay).toEqual(true);
          expect(allDayEvent.start).toEqualDate('2014-05-02');
          expect(timedEvent.allDay).toEqual(false);
          expect(timedEvent.start).toEqualLocalDate('2014-05-10T12:00:00'); // was parsed as LOCAL originally
          expect(zonedEvent.allDay).toEqual(false);
          expect(zonedEvent.start).toEqualDate('2014-05-10T14:00:00+11:00');
      });
  });

  describe('selectAllow', () => {
      pushOptions({
          now: '2016-09-04',
          initialView: 'timeGridWeek',
          scrollTime: '00:00',
          selectable: true,
      });
      it('disallows selecting when returning false', (done) => {
          let options = {
              selectAllow(selectInfo) {
                  expect(typeof selectInfo).toBe('object');
                  expect(selectInfo.start instanceof Date).toBe(true);
                  expect(selectInfo.end instanceof Date).toBe(true);
                  return false;
              },
          };
          spyOn(options, 'selectAllow').and.callThrough();
          let calendar = initCalendar(options);
          let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
          let selecting = timeGridWrapper.selectDates('2016-09-04T01:00:00Z', '2016-09-04T05:00:00Z');
          waitDateSelect(calendar, selecting).then((selectInfo) => {
              expect(selectInfo).toBeFalsy();
              expect(options.selectAllow).toHaveBeenCalled();
              done();
          });
      });
      it('allows selecting when returning true', (done) => {
          let options = {
              selectAllow(selectInfo) {
                  return true;
              },
          };
          spyOn(options, 'selectAllow').and.callThrough();
          let calendar = initCalendar(options);
          let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
          let selecting = timeGridWrapper.selectDates('2016-09-04T01:00:00Z', '2016-09-04T05:00:00Z');
          waitDateSelect(calendar, selecting).then((selectInfo) => {
              expect(typeof selectInfo).toBe('object');
              expect(selectInfo.start).toEqualDate('2016-09-04T01:00:00Z');
              expect(selectInfo.end).toEqualDate('2016-09-04T05:00:00Z');
              expect(options.selectAllow).toHaveBeenCalled();
              done();
          });
      });
  });

  describe('eventMaxStack', () => {
      pushOptions({
          initialView: 'timeGridDay',
          initialDate: '2021-05-07',
          scrollTime: 0,
          eventMaxStack: 2,
      });
      it('puts hidden events in a popover', (done) => {
          let calendar = initCalendar({
              events: [
                  { start: '2021-05-07T00:00:00', end: '2021-05-07T01:00:00' },
                  { start: '2021-05-07T00:00:00', end: '2021-05-07T01:00:00' },
                  { start: '2021-05-07T00:00:00', end: '2021-05-07T01:00:00' }, // hidden
              ],
          });
          let timeGrid = new TimeGridViewWrapper(calendar).timeGrid;
          let moreLinkEls = timeGrid.getMoreEls();
          expect(moreLinkEls.length).toBe(1);
          timeGrid.openMorePopover();
          setTimeout(() => {
              let moreEventEls = timeGrid.getMorePopoverEventEls();
              expect(moreEventEls.length).toBe(1);
              done();
          });
      });
      it('can drag events out of popover', (done) => {
          let calendar = initCalendar({
              editable: true,
              events: [
                  { id: '1', start: '2021-05-07T00:00:00', end: '2021-05-07T01:00:00' },
                  { id: '2', start: '2021-05-07T00:00:00', end: '2021-05-07T01:00:00' },
                  { id: '3', start: '2021-05-07T00:00:00', end: '2021-05-07T01:00:00' }, // hidden
              ],
          });
          let timeGrid = new TimeGridViewWrapper(calendar).timeGrid;
          timeGrid.openMorePopover();
          setTimeout(() => {
              let moreEventEls = timeGrid.getMorePopoverEventEls();
              let newStart = '2021-05-07T02:00:00';
              $(moreEventEls).simulate('drag', {
                  end: timeGrid.getPoint(newStart),
                  onRelease() {
                      let event = calendar.getEventById('3');
                      expect(event.start).toEqualDate(newStart);
                      done();
                  },
              });
          });
      });
      it('causes separate adjacent more links', () => {
          let calendar = initCalendar({
              events: [
                  { start: '2021-05-07T00:00:00', end: '2021-05-07T01:00:00' },
                  { start: '2021-05-07T00:00:00', end: '2021-05-07T01:00:00' },
                  { start: '2021-05-07T00:00:00', end: '2021-05-07T01:00:00' },
                  { start: '2021-05-07T01:00:00', end: '2021-05-07T02:00:00' },
                  { start: '2021-05-07T01:00:00', end: '2021-05-07T02:00:00' },
                  { start: '2021-05-07T01:00:00', end: '2021-05-07T02:00:00' }, // hidden
              ],
          });
          let timeGrid = new TimeGridViewWrapper(calendar).timeGrid;
          let moreLinkEls = timeGrid.getMoreEls();
          expect(moreLinkEls.length).toBe(2);
      });
      it('puts overlapping hidden events in same popover, respecting eventOrder', (done) => {
          let calendar = initCalendar({
              eventOrder: 'title',
              events: [
                  { title: '1', start: '2021-05-07T00:00:00', end: '2021-05-07T02:00:00' },
                  { title: '2', start: '2021-05-07T00:00:00', end: '2021-05-07T02:00:00' },
                  { title: '3', start: '2021-05-07T01:00:00', end: '2021-05-07T03:00:00' },
                  { title: '4', start: '2021-05-07T00:30:00', end: '2021-05-07T02:30:00' }, // hidden
              ],
          });
          let timeGrid = new TimeGridViewWrapper(calendar).timeGrid;
          let moreLinkEls = timeGrid.getMoreEls();
          expect(moreLinkEls.length).toBe(1);
          const canvasCoords = timeGrid.el.getBoundingClientRect();
          const moreLinkCoords = moreLinkEls[0].getBoundingClientRect();
          const moreLinkTop = moreLinkCoords.top - canvasCoords.top;
          // TODO: more precise coord matching
          expect(moreLinkTop).toBeGreaterThan(10);
          timeGrid.openMorePopover();
          setTimeout(() => {
              let moreEventEls = timeGrid.getMorePopoverEventEls();
              expect(moreEventEls.length).toBe(2);
              expect(TimeGridWrapper.getEventElInfo(moreEventEls[0]).title).toBe('3');
              done();
          });
      });
  });

  describe('emitter', () => {
      it('calls a handler', () => {
          let o = new Emitter();
          let handlers = {
              something(arg1, arg2) {
                  expect(arg1).toBe(7);
                  expect(arg2).toBe(8);
              },
          };
          spyOn(handlers, 'something').and.callThrough();
          o.on('something', handlers.something);
          o.trigger('something', 7, 8);
          expect(handlers.something).toHaveBeenCalled();
      });
      it('unbinds with an exact reference', () => {
          let o = new Emitter();
          let handlers = {
              something() { },
          };
          spyOn(handlers, 'something');
          o.on('something', handlers.something);
          o.trigger('something');
          expect(handlers.something).toHaveBeenCalled();
          o.off('something', handlers.something);
          o.trigger('something');
          expect(handlers.something.calls.count()).toBe(1);
      });
      it('unbinds all when no reference', () => {
          let o = new Emitter();
          let handlers = {
              something1() { },
              something2() { },
          };
          spyOn(handlers, 'something1');
          spyOn(handlers, 'something2');
          o.on('something', handlers.something1);
          o.on('something', handlers.something2);
          o.trigger('something');
          expect(handlers.something1).toHaveBeenCalled();
          expect(handlers.something2).toHaveBeenCalled();
          o.off('something');
          o.trigger('something');
          expect(handlers.something1.calls.count()).toBe(1);
          expect(handlers.something2.calls.count()).toBe(1);
      });
  });

  describe('footerToolbar rendering', () => {
      pushOptions({
          initialDate: '2014-06-04',
          initialView: 'timeGridWeek',
      });
      describe('when supplying footerToolbar options', () => {
          it('should append a footerToolbar element to the DOM', () => {
              let calendar = initCalendar({
                  footerToolbar: {
                      left: 'next,prev',
                      center: 'prevYear today nextYear timeGridDay,timeGridWeek',
                      right: 'title',
                  },
              });
              let calendarWrapper = new CalendarWrapper(calendar);
              expect(calendarWrapper.footerToolbar).toBeTruthy();
          });
      });
      describe('when setting footerToolbar to false', () => {
          it('should not have footerToolbar table', () => {
              let calendar = initCalendar({
                  footerToolbar: false,
              });
              let calendarWrapper = new CalendarWrapper(calendar);
              expect(calendarWrapper.footerToolbar).toBeFalsy();
          });
      });
      it('allow for dynamically changing', () => {
          let calendar = initCalendar({
              footerToolbar: {
                  left: 'next,prev',
                  center: 'prevYear today nextYear timeGridDay,timeGridWeek',
                  right: 'title',
              },
          });
          let calendarWrapper = new CalendarWrapper(calendar);
          expect(calendarWrapper.footerToolbar).toBeTruthy();
          currentCalendar.setOption('footerToolbar', false);
          expect(calendarWrapper.footerToolbar).toBeFalsy();
      });
  });

  /*
  opts:
    - el (optional)
    - row (optional)
    - firstCol
    - lastCol
    - isStart
    - isEnd
  */
  function directionallyTestSeg(opts) {
      let dayGridWrapper = new DayGridViewWrapper(currentCalendar).dayGrid;
      let el = opts.el ? $(opts.el) : dayGridWrapper.getEventEls()[0];
      let row = opts.row || 0;
      let rowTds = dayGridWrapper.getDayElsInRow(row);
      expect(rowTds.length).toBeGreaterThan(1);
      let leftCol = opts.firstCol;
      let rightCol = opts.lastCol;
      let col;
      let td;
      for (col = leftCol; col <= rightCol; col += 1) {
          td = rowTds[col];
          expect(el).toIntersectWith(td);
      }
      for (col = 0; col < rowTds.length; col += 1) {
          if (col < leftCol || col > rightCol) {
              td = rowTds[col];
              expect(el).not.toIntersectWith(td);
          }
      }
      if (opts.isStart) {
          expect(el).toHaveClass(DayGridWrapper.EVENT_IS_START_CLASSNAME);
      }
      else {
          expect(el).not.toHaveClass(DayGridWrapper.EVENT_IS_START_CLASSNAME);
      }
      if (opts.isEnd) {
          expect(el).toHaveClass(DayGridWrapper.EVENT_IS_END_CLASSNAME);
      }
      else {
          expect(el).not.toHaveClass(DayGridWrapper.EVENT_IS_END_CLASSNAME);
      }
  }

  describe('DayGrid event rendering', () => {
      pushOptions({
          initialDate: '2014-08-01',
          initialView: 'dayGridMonth',
      });
      describe('when LTR', () => {
          initMonthTesting('ltr');
      });
      describe('when RTL', () => {
          initMonthTesting('rtl');
      });
      function initMonthTesting(direction) {
          it('correctly renders an event starting before view\'s start', () => {
              let options = {
                  events: [
                      { start: '2014-07-26', end: '2014-07-30' },
                  ],
              };
              let testSegOptions = {
                  firstCol: 0,
                  lastCol: 2,
                  isStart: false,
                  isEnd: true,
              };
              testSeg(options, testSegOptions);
          });
          it('correctly renders an event starting at view\'s start', () => {
              let options = {
                  events: [
                      { start: '2014-07-27', end: '2014-07-29' },
                  ],
              };
              let testSegOptions = {
                  firstCol: 0,
                  lastCol: 1,
                  isStart: true,
                  isEnd: true,
              };
              testSeg(options, testSegOptions);
          });
          it('correctly renders an event starting after view\'s start', () => {
              let options = {
                  events: [
                      { start: '2014-08-01', end: '2014-08-02' },
                  ],
              };
              let testSegOptions = {
                  firstCol: 5,
                  lastCol: 5,
                  isStart: true,
                  isEnd: true,
              };
              testSeg(options, testSegOptions);
          });
          it('correctly renders an event starting on a hidden day at week start', () => {
              let options = {
                  weekends: false,
                  events: [
                      { start: '2014-07-27', end: '2014-07-30' },
                  ],
              };
              let testSegOptions = {
                  firstCol: 0,
                  lastCol: 1,
                  isStart: false,
                  isEnd: true,
              };
              testSeg(options, testSegOptions);
          });
          it('correctly renders an event starting on a hidden day in middle of week', () => {
              let options = {
                  hiddenDays: [2],
                  events: [
                      { start: '2014-07-29', end: '2014-08-01' },
                  ],
              };
              let testSegOptions = {
                  firstCol: 2,
                  lastCol: 3,
                  isStart: false,
                  isEnd: true,
              };
              testSeg(options, testSegOptions);
          });
          it('correctly renders an event ending before view\'s end', () => {
              let options = {
                  events: [
                      { start: '2014-09-02', end: '2014-09-05' },
                  ],
              };
              let testSegOptions = {
                  row: 5,
                  firstCol: 2,
                  lastCol: 4,
                  isStart: true,
                  isEnd: true,
              };
              testSeg(options, testSegOptions);
          });
          it('correctly renders an event ending at view\'s end', () => {
              let options = {
                  events: [
                      { start: '2014-09-04', end: '2014-09-07' },
                  ],
              };
              let testSegOptions = {
                  row: 5,
                  firstCol: 4,
                  lastCol: 6,
                  isStart: true,
                  isEnd: true,
              };
              testSeg(options, testSegOptions);
          });
          it('correctly renders an event ending after view\'s end', () => {
              let options = {
                  events: [
                      { start: '2014-09-04', end: '2014-09-08' },
                  ],
              };
              let testSegOptions = {
                  row: 5,
                  firstCol: 4,
                  lastCol: 6,
                  isStart: true,
                  isEnd: false,
              };
              testSeg(options, testSegOptions);
          });
          it('correctly renders an event ending at a week\'s end', () => {
              let options = {
                  events: [
                      { start: '2014-08-28', end: '2014-08-31' },
                  ],
              };
              let testSegOptions = {
                  row: 4,
                  firstCol: 4,
                  lastCol: 6,
                  isStart: true,
                  isEnd: true,
              };
              testSeg(options, testSegOptions);
          });
          it('correctly renders an event ending on a hidden day at week end', () => {
              let options = {
                  weekends: false,
                  events: [
                      { start: '2014-07-30', end: '2014-08-03' },
                  ],
              };
              let testSegOptions = {
                  firstCol: 2,
                  lastCol: 4,
                  isStart: true,
                  isEnd: false,
              };
              testSeg(options, testSegOptions);
          });
          it('correctly renders an event ending on a hidden day in middle of week', () => {
              let options = {
                  hiddenDays: [4],
                  events: [
                      { start: '2014-07-28', end: '2014-08-01' },
                  ],
              };
              let testSegOptions = {
                  firstCol: 1,
                  lastCol: 3,
                  isStart: true,
                  isEnd: false,
              };
              testSeg(options, testSegOptions);
          });
          function testSeg(calendarOptions, testSegOptions) {
              calendarOptions.direction = direction;
              initCalendar(calendarOptions);
              directionallyTestSeg(testSegOptions);
          }
      }
      it('rendering of events across weeks stays consistent', () => {
          let calendar = initCalendar({
              events: [
                  {
                      title: 'event1',
                      start: '2014-08-01',
                      end: '2014-08-04',
                      className: 'event1',
                  },
                  {
                      title: 'event2',
                      start: '2014-08-02',
                      end: '2014-08-05',
                      className: 'event2',
                  },
              ],
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          let row0 = dayGridWrapper.getRowEl(0);
          let row0event1 = row0.querySelector('.event1');
          let row0event2 = row0.querySelector('.event2');
          let row1 = dayGridWrapper.getRowEl(1);
          let row1event1 = row1.querySelector('.event1');
          let row1event2 = row1.querySelector('.event2');
          expect($(row0event1).offset().top).toBeLessThan($(row0event2).offset().top);
          expect($(row1event1).offset().top).toBeLessThan($(row1event2).offset().top);
      });
      it('renders an event with no url with no <a> href', () => {
          let calendar = initCalendar({
              events: [{
                      title: 'event1',
                      start: '2014-08-01',
                  }],
          });
          let eventEl = new CalendarWrapper(calendar).getFirstEventEl();
          expect(eventEl).not.toHaveAttr('href');
      });
      it('renders an event with a url with an <a> href', () => {
          let calendar = initCalendar({
              events: [{
                      title: 'event1',
                      start: '2014-08-01',
                      url: 'http://google.com/',
                  }],
          });
          let eventEl = new CalendarWrapper(calendar).getFirstEventEl();
          expect(eventEl).toHaveAttr('href');
      });
  });

  describe('themeSystem', () => {
      pushOptions({
          plugins: [index$2, index$9],
          initialView: 'timeGridWeek',
          headerToolbar: {
              left: 'title',
              center: '',
              right: 'next',
          },
      });
      it('can be changed dynamically', () => {
          let calendar = initCalendar();
          let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
          let buttonInfo = toolbarWrapper.getButtonInfo('next');
          expect(calendar.el).toHaveClass(CalendarWrapper.ROOT_CLASSNAME);
          expect(calendar.el).toHaveClass(CalendarWrapper.UNTHEMED_CLASSNAME);
          expect(calendar.el).not.toHaveClass(CalendarWrapper.BOOTSTRAP_CLASSNAME);
          expect(buttonInfo.iconName).toBeTruthy();
          expect($('.table-bordered').length).toBe(0);
          let viewWrapper = new TimeGridViewWrapper(calendar);
          let scrollEl = viewWrapper.getScrollerEl();
          scrollEl.scrollTop = 99999; // scroll all the way down
          // change option!
          calendar.setOption('themeSystem', 'bootstrap');
          buttonInfo = toolbarWrapper.getButtonInfo('next', 'fa');
          expect(calendar.el).toHaveClass(CalendarWrapper.ROOT_CLASSNAME);
          expect(calendar.el).toHaveClass(CalendarWrapper.BOOTSTRAP_CLASSNAME);
          expect(calendar.el).not.toHaveClass(CalendarWrapper.UNTHEMED_CLASSNAME);
          expect(buttonInfo.iconName).toBeTruthy();
          expect($('.table-bordered').length).toBeGreaterThan(0);
          // make sure scrolled down at least just a little bit
          // since we don't have the bootstrap stylesheet loaded, this will be janky
          expect(scrollEl.scrollTop).toBeGreaterThan(10);
      });
      // this tests the options setter with a single hash argument.
      // TODO: not best place for this.
      it('can be change with other options', () => {
          let calendar = initCalendar();
          expect(calendar.el).toHaveClass(CalendarWrapper.ROOT_CLASSNAME);
          expect(calendar.el).toHaveClass(CalendarWrapper.UNTHEMED_CLASSNAME);
          expect(calendar.el).not.toHaveClass(CalendarWrapper.BOOTSTRAP_CLASSNAME);
          // change option!
          calendar.batchRendering(() => {
              calendar.setOption('themeSystem', 'bootstrap');
              calendar.setOption('businessHours', true);
          });
          expect(calendar.el).toHaveClass(CalendarWrapper.ROOT_CLASSNAME);
          expect(calendar.el).toHaveClass(CalendarWrapper.BOOTSTRAP_CLASSNAME);
          expect(calendar.el).not.toHaveClass(CalendarWrapper.UNTHEMED_CLASSNAME);
      });
  });

  describe('fixedWeekCount', () => {
      pushOptions({
          initialView: 'dayGridMonth',
          initialDate: '2014-07-01', // has 5 weeks
      });
      describe('when true', () => {
          pushOptions({
              fixedWeekCount: true,
          });
          it('renders a 5-week month with 6 rows', () => {
              let calendar = initCalendar();
              let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
              expect(dayGridWrapper.getRowEls().length).toBe(6);
          });
      });
      describe('when false', () => {
          pushOptions({
              fixedWeekCount: false,
          });
          it('renders a 5-week month with 5 rows', () => {
              let calendar = initCalendar();
              let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
              expect(dayGridWrapper.getRowEls().length).toBe(5);
          });
      });
      [true, false].forEach((bool) => {
          describe('regardless of value (' + bool + ')', () => {
              pushOptions({
                  fixedWeekCount: bool,
                  initialDate: '2014-08-01', // has 6 weeks
              });
              it('should render a 6-week month consistently', () => {
                  let calendar = initCalendar();
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  expect(dayGridWrapper.getRowEls().length).toBe(6);
              });
          });
      });
  });

  describe('eventDidMount+eventContent', () => {
      pushOptions({
          initialDate: '2014-11-12',
          scrollTime: '00:00:00',
          events: [{
                  title: 'my event',
                  start: '2014-11-12T09:00:00',
              }],
      });
      describeOptions('initialView', {
          'when in day-grid': 'dayGridMonth',
          'when in time-grid': 'timeGridWeek',
      }, () => {
          describe('with foreground event', () => {
              it('receives correct args AND can modify the element', () => {
                  let options = {
                      eventContent(arg) {
                          expect(typeof arg.event).toBe('object');
                          expect(arg.event.display).toBe('auto');
                          expect(arg.event.start).toBeDefined();
                          expect(typeof arg.view).toBe('object');
                          expect(arg.isMirror).toBe(false);
                      },
                      eventDidMount(arg) {
                          $(arg.el).css('font-size', '20px');
                      },
                  };
                  spyOn(options, 'eventContent').and.callThrough();
                  spyOn(options, 'eventDidMount').and.callThrough();
                  let calendar = initCalendar(options);
                  let calendarWrapper = new CalendarWrapper(calendar);
                  let eventEl = calendarWrapper.getFirstEventEl();
                  expect(options.eventContent).toHaveBeenCalled();
                  expect(options.eventDidMount).toHaveBeenCalled();
                  expect($(eventEl).css('font-size')).toBe('20px');
              });
          });
      });
      describe('when in month view', () => {
          pushOptions({
              initialView: 'dayGridMonth',
              events: [{
                      title: 'my event',
                      start: '2014-11-12',
                  }],
          });
          describe('with a foreground event', () => {
              it('can return a new element', () => {
                  let options = {
                      eventContent() {
                          let domNodes = $('<div class="sup" style="background-color:green">sup g</div>').get();
                          return { domNodes };
                      },
                  };
                  spyOn(options, 'eventContent').and.callThrough();
                  let calendar = initCalendar(options);
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  let eventEl = dayGridWrapper.getFirstEventEl();
                  expect(eventEl.querySelector('.sup')).toBeTruthy();
                  expect(options.eventContent).toHaveBeenCalled();
              });
          });
          describe('with an all-day background event', () => {
              pushOptions({
                  events: [{
                          title: 'my event',
                          start: '2014-11-12',
                          display: 'background',
                      }],
              });
              it('receives correct args AND can modify the element', () => {
                  let options = {
                      eventContent(arg) {
                          expect(typeof arg.event).toBe('object');
                          expect(arg.event.display).toBe('background');
                          expect(arg.event.start).toBeDefined();
                          expect(typeof arg.view).toBe('object');
                      },
                      eventDidMount(arg) {
                          $(arg.el).css('font-size', '20px');
                      },
                  };
                  spyOn(options, 'eventContent').and.callThrough();
                  spyOn(options, 'eventDidMount').and.callThrough();
                  let calendar = initCalendar(options);
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  let bgEventEls = dayGridWrapper.getBgEventEls();
                  expect(bgEventEls.length).toBe(1);
                  expect(options.eventContent).toHaveBeenCalled();
                  expect(options.eventDidMount).toHaveBeenCalled();
                  expect($(bgEventEls).css('font-size')).toBe('20px');
              });
          });
      });
  });

  // TODO: expose somehow
  const API_BASE = 'https://www.googleapis.com/calendar/v3/calendars';
  const eventSourceDef$1 = {
      parseMeta(refined) {
          let { googleCalendarId } = refined;
          if (!googleCalendarId && refined.url) {
              googleCalendarId = parseGoogleCalendarId(refined.url);
          }
          if (googleCalendarId) {
              return {
                  googleCalendarId,
                  googleCalendarApiKey: refined.googleCalendarApiKey,
                  googleCalendarApiBase: refined.googleCalendarApiBase,
                  extraParams: refined.extraParams,
              };
          }
          return null;
      },
      fetch(arg, successCallback, errorCallback) {
          let { dateEnv, options } = arg.context;
          let meta = arg.eventSource.meta;
          let apiKey = meta.googleCalendarApiKey || options.googleCalendarApiKey;
          if (!apiKey) {
              errorCallback(new Error('Specify a googleCalendarApiKey. See https://fullcalendar.io/docs/google-calendar'));
          }
          else {
              let url = buildUrl(meta);
              // TODO: make DRY with json-feed-event-source
              let { extraParams } = meta;
              let extraParamsObj = typeof extraParams === 'function' ? extraParams() : extraParams;
              let requestParams = buildRequestParams(arg.range, apiKey, extraParamsObj, dateEnv);
              return requestJson('GET', url, requestParams).then(([body, response]) => {
                  if (body.error) {
                      errorCallback(new JsonRequestError('Google Calendar API: ' + body.error.message, response));
                  }
                  else {
                      successCallback({
                          rawEvents: gcalItemsToRawEventDefs(body.items, requestParams.timeZone),
                          response,
                      });
                  }
              }, errorCallback);
          }
      },
  };
  function parseGoogleCalendarId(url) {
      let match;
      // detect if the ID was specified as a single string.
      // will match calendars like "asdf1234@calendar.google.com" in addition to person email calendars.
      if (/^[^/]+@([^/.]+\.)*(google|googlemail|gmail)\.com$/.test(url)) {
          return url;
      }
      if ((match = /^https:\/\/www.googleapis.com\/calendar\/v3\/calendars\/([^/]*)/.exec(url)) ||
          (match = /^https?:\/\/www.google.com\/calendar\/feeds\/([^/]*)/.exec(url))) {
          return decodeURIComponent(match[1]);
      }
      return null;
  }
  function buildUrl(meta) {
      let apiBase = meta.googleCalendarApiBase;
      if (!apiBase) {
          apiBase = API_BASE;
      }
      return apiBase + '/' + encodeURIComponent(meta.googleCalendarId) + '/events';
  }
  function buildRequestParams(range, apiKey, extraParams, dateEnv) {
      let params;
      let startStr;
      let endStr;
      if (dateEnv.canComputeOffset) {
          // strings will naturally have offsets, which GCal needs
          startStr = dateEnv.formatIso(range.start);
          endStr = dateEnv.formatIso(range.end);
      }
      else {
          // when timezone isn't known, we don't know what the UTC offset should be, so ask for +/- 1 day
          // from the UTC day-start to guarantee we're getting all the events
          // (start/end will be UTC-coerced dates, so toISOString is okay)
          startStr = addDays(range.start, -1).toISOString();
          endStr = addDays(range.end, 1).toISOString();
      }
      params = Object.assign(Object.assign({}, (extraParams || {})), { key: apiKey, timeMin: startStr, timeMax: endStr, singleEvents: true, maxResults: 9999 });
      if (dateEnv.timeZone !== 'local') {
          params.timeZone = dateEnv.timeZone;
      }
      return params;
  }
  function gcalItemsToRawEventDefs(items, gcalTimezone) {
      return items.map((item) => gcalItemToRawEventDef(item, gcalTimezone));
  }
  function gcalItemToRawEventDef(item, gcalTimezone) {
      let url = item.htmlLink || null;
      // make the URLs for each event show times in the correct timezone
      if (url && gcalTimezone) {
          url = injectQsComponent(url, 'ctz=' + gcalTimezone);
      }
      return {
          id: item.id,
          title: item.summary,
          start: item.start.dateTime || item.start.date,
          end: item.end.dateTime || item.end.date,
          url,
          location: item.location,
          description: item.description,
          attachments: item.attachments || [],
          extendedProps: (item.extendedProperties || {}).shared || {},
      };
  }
  // Injects a string like "arg=value" into the querystring of a URL
  // TODO: move to a general util file?
  function injectQsComponent(url, component) {
      // inject it after the querystring but before the fragment
      return url.replace(/(\?.*?)?(#|$)/, (whole, qs, hash) => (qs ? qs + '&' : '?') + component + hash);
  }

  const OPTION_REFINERS = {
      googleCalendarApiKey: String,
  };

  const EVENT_SOURCE_REFINERS = {
      googleCalendarApiKey: String,
      googleCalendarId: String,
      googleCalendarApiBase: String,
      extraParams: identity,
  };

  var index$1 = createPlugin({
      name: '@fullcalendar/google-calendar',
      eventSourceDefs: [eventSourceDef$1],
      optionRefiners: OPTION_REFINERS,
      eventSourceRefiners: EVENT_SOURCE_REFINERS,
  });

  // In our CI setup, requests to the google-calendar api were failing for some reason
  // (requests to other services were working however)
  const noGCal = window.__karma__.config.cliArgs.includes('--no-gcal');
  if (noGCal) {
      console.log('skipping google-calendar'); // eslint-disable-line no-console
  }
  // eslint-disable-next-line
  noGCal ||
      describe('Google Calendar plugin', () => {
          const API_KEY = 'AIzaSyDcnW6WejpTOCffshGDDb4neIrXVUA1EAE';
          const HOLIDAY_CALENDAR_ID = 'en.usa#holiday@group.v.calendar.google.com';
          // Google sometimes stops returning old events. Will need to update this sometimes.
          const DEFAULT_MONTH = '2023-05';
          const NUM_EVENTS = 5; // number of holidays
          pushOptions({
              plugins: [index$1, index$a],
              initialView: 'dayGridMonth',
              initialDate: DEFAULT_MONTH + '-01',
          });
          it('request/receives correctly when local timezone', (done) => {
              let calendar = initCalendar({
                  googleCalendarApiKey: API_KEY,
                  events: { googleCalendarId: HOLIDAY_CALENDAR_ID },
                  timeZone: 'local',
              });
              afterEventsLoaded(calendar, () => {
                  let events = calendar.getEvents();
                  let i;
                  expect(events.length).toBe(NUM_EVENTS);
                  for (i = 0; i < events.length; i += 1) {
                      expect(events[i].url).not.toMatch('ctz=');
                  }
                  done();
              });
          });
          it('request/receives correctly when UTC timezone', (done) => {
              let calendar = initCalendar({
                  googleCalendarApiKey: API_KEY,
                  events: { googleCalendarId: HOLIDAY_CALENDAR_ID },
                  timeZone: 'UTC',
              });
              afterEventsLoaded(calendar, () => {
                  let events = calendar.getEvents();
                  let i;
                  expect(events.length).toBe(NUM_EVENTS);
                  for (i = 0; i < events.length; i += 1) {
                      expect(events[i].url).toMatch('ctz=UTC');
                  }
                  done();
              });
          });
          it('request/receives correctly when named timezone, defaults to not editable', (done) => {
              let calendar = initCalendar({
                  googleCalendarApiKey: API_KEY,
                  events: { googleCalendarId: HOLIDAY_CALENDAR_ID },
                  timeZone: 'America/New_York',
              });
              afterEventsLoaded(calendar, () => {
                  let events = calendar.getEvents();
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  let eventEls = dayGridWrapper.getEventEls();
                  let i;
                  expect(events.length).toBe(NUM_EVENTS);
                  for (i = 0; i < events.length; i += 1) {
                      expect(events[i].url).toMatch('ctz=America/New_York');
                  }
                  expect(eventEls.length).toBe(NUM_EVENTS);
                  expect($('.' + CalendarWrapper.EVENT_RESIZER_CLASSNAME, eventEls[0]).length).toBe(0); // not editable
                  done();
              });
          });
          it('allows editable to explicitly be set to true', (done) => {
              let calendar = initCalendar({
                  googleCalendarApiKey: API_KEY,
                  events: {
                      googleCalendarId: HOLIDAY_CALENDAR_ID,
                      editable: true,
                  },
              });
              afterEventsLoaded(calendar, () => {
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  let eventEls = dayGridWrapper.getEventEls();
                  expect(eventEls.length).toBe(NUM_EVENTS);
                  for (let eventEl of eventEls) {
                      expect($('.' + CalendarWrapper.EVENT_RESIZER_CLASSNAME, eventEl).length).toBeGreaterThan(0); // editable!
                  }
                  done();
              });
          });
          it('fetches events correctly when API key is in the event source', (done) => {
              let calendar = initCalendar({
                  events: {
                      googleCalendarId: HOLIDAY_CALENDAR_ID,
                      googleCalendarApiKey: API_KEY,
                  },
              });
              afterEventsLoaded(calendar, () => {
                  let events = calendar.getEvents();
                  expect(events.length).toBe(NUM_EVENTS); // 5 holidays in November 2016 (and end of Oct)
                  done();
              });
          });
          describe('when not given an API key', () => {
              it('calls error handlers, raises warning, and receives no events', (done) => {
                  let options = {
                      events: {
                          failure(err) {
                              expect(typeof err).toBe('object');
                          },
                          googleCalendarId: HOLIDAY_CALENDAR_ID,
                      },
                      eventSourceFailure(err) {
                          expect(typeof err).toBe('object');
                          setTimeout(() => {
                              let events = this.getEvents();
                              expect(events.length).toBe(0);
                              expect(options.events.failure).toHaveBeenCalled();
                              done();
                          }, 0);
                      },
                  };
                  spyOn(options.events, 'failure').and.callThrough();
                  initCalendar(options);
              });
          });
          describe('when given a bad API key', () => {
              it('calls error handlers, raises warning, and receives no event', (done) => {
                  let options = {
                      googleCalendarApiKey: 'asdfasdfasdf',
                      events: {
                          failure(err) {
                              expect(typeof err).toBe('object');
                          },
                          googleCalendarId: HOLIDAY_CALENDAR_ID,
                      },
                      eventSourceFailure(err) {
                          expect(typeof err).toBe('object');
                          setTimeout(() => {
                              let events = this.getEvents();
                              expect(events.length).toBe(0);
                              expect(options.events.failure).toHaveBeenCalled();
                              done();
                          }, 0);
                      },
                  };
                  spyOn(options.events, 'failure').and.callThrough();
                  initCalendar(options);
              });
          });
          it('calls loading with true then false', (done) => {
              let cmds = [];
              initCalendar({
                  googleCalendarApiKey: API_KEY,
                  events: { googleCalendarId: HOLIDAY_CALENDAR_ID },
                  loading(bool) {
                      cmds.push(bool);
                      if (cmds.length === 1) {
                          expect(cmds).toEqual([true]);
                      }
                      else if (cmds.length === 2) {
                          expect(cmds).toEqual([true, false]);
                          done();
                      }
                  },
              });
          });
          describe('EventSource::remove', () => {
              it('works when specifying only the Google Calendar ID', (done) => {
                  let called = false;
                  let calendar = initCalendar({
                      googleCalendarApiKey: API_KEY,
                      eventSources: [{ googleCalendarId: HOLIDAY_CALENDAR_ID }],
                  });
                  afterEventsLoaded(calendar, () => {
                      let events;
                      if (called) {
                          return;
                      } // only the first time
                      called = true;
                      events = calendar.getEvents();
                      expect(events.length).toBe(NUM_EVENTS); // 5 holidays in November 2016 (and end of Oct)
                      setTimeout(() => {
                          calendar.getEventSources()[0].remove();
                          events = calendar.getEvents();
                          expect(events.length).toBe(0);
                          done();
                      }, 0);
                  });
              });
              it('works when specifying a raw Google Calendar source object', (done) => {
                  let googleSource = { googleCalendarId: HOLIDAY_CALENDAR_ID };
                  let called = false;
                  let calendar = initCalendar({
                      googleCalendarApiKey: API_KEY,
                      eventSources: [googleSource],
                  });
                  afterEventsLoaded(calendar, () => {
                      let events;
                      if (called) {
                          return;
                      } // only the first time
                      called = true;
                      events = calendar.getEvents();
                      expect(events.length).toBe(NUM_EVENTS); // 5 holidays in November 2016 (and end of Oct)
                      setTimeout(() => {
                          calendar.getEventSources()[0].remove();
                          events = calendar.getEvents();
                          expect(events.length).toBe(0);
                          done();
                      }, 0);
                  });
              });
          });
          function afterEventsLoaded(calendar, callback) {
              calendar.on('eventsSet', () => {
                  setTimeout(callback); // because nothing is rendered yet when eventSourceSuccess fires
              });
          }
      });

  var l31 = {
      code: 'fr',
      week: {
          dow: 1,
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
      buttonText: {
          prev: 'Précédent',
          next: 'Suivant',
          today: 'Aujourd\'hui',
          year: 'Année',
          month: 'Mois',
          week: 'Semaine',
          day: 'Jour',
          list: 'Planning',
      },
      weekText: 'Sem.',
      weekTextLong: 'Semaine',
      allDayText: 'Toute la journée',
      moreLinkText: 'en plus',
      noEventsText: 'Aucun évènement à afficher',
  };

  describe('custom view', () => {
      it('renders a 4 day dayGrid view', () => {
          let calendar = initCalendar({
              views: {
                  dayGridFourDay: {
                      type: 'dayGrid',
                      duration: { days: 4 },
                  },
              },
              initialView: 'dayGridFourDay',
              initialDate: '2014-12-25',
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          let dayEls = dayGridWrapper.getAllDayEls();
          expect(dayGridWrapper.getRowEls().length).toBe(1);
          expect(dayEls.length).toBe(4);
          expect(dayEls[0].getAttribute('data-date')).toBe('2014-12-25'); // starts on initialDate
      });
      it('renders a 2 week dayGrid view', () => {
          let calendar = initCalendar({
              views: {
                  dayGridTwoWeek: {
                      type: 'dayGrid',
                      duration: { weeks: 2 },
                  },
              },
              initialView: 'dayGridTwoWeek',
              initialDate: '2014-12-25',
              firstDay: 2, // Tues
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          let dayEls = dayGridWrapper.getAllDayEls();
          expect(dayGridWrapper.getRowEls().length).toBe(2);
          expect(dayEls.length).toBe(14);
          expect(dayEls[0]).toHaveClass(CalendarWrapper.DOW_CLASSNAMES[2]); // respects start-of-week
          expect(dayEls[0].getAttribute('data-date')).toBe('2014-12-23'); // week start. tues
      });
      it('will use the provided options', () => {
          let calendar = initCalendar({
              views: {
                  dayGridFourDay: {
                      type: 'dayGrid',
                      duration: { days: 4 },
                      titleFormat() { return 'special'; },
                  },
              },
              initialView: 'dayGridFourDay',
          });
          let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
          expect(toolbarWrapper.getTitleText()).toBe('special');
      });
      it('will inherit options from the parent view type', () => {
          let calendar = initCalendar({
              views: {
                  dayGrid: {
                      titleFormat() { return 'dayGridtitle'; },
                  },
                  dayGridFourDay: {
                      type: 'dayGrid',
                      duration: { days: 4 },
                  },
              },
              initialView: 'dayGridFourDay',
          });
          let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
          expect(toolbarWrapper.getTitleText()).toBe('dayGridtitle');
      });
      it('will override an option from the parent view type', () => {
          let calendar = initCalendar({
              views: {
                  dayGrid: {
                      titleFormat() { return 'dayGridtitle'; },
                  },
                  dayGridFourDay: {
                      type: 'dayGrid',
                      duration: { days: 4 },
                      titleFormat() { return 'dayGridfourweekttitle'; },
                  },
              },
              initialView: 'dayGridFourDay',
          });
          let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
          expect(toolbarWrapper.getTitleText()).toBe('dayGridfourweekttitle');
      });
      it('will inherit options from generic "week" type', () => {
          let calendar = initCalendar({
              views: {
                  week: {
                      titleFormat() { return 'weektitle'; },
                  },
                  dayGridOneWeek: {
                      type: 'dayGrid',
                      duration: { weeks: 1 },
                  },
              },
              initialView: 'dayGridOneWeek',
          });
          let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
          expect(toolbarWrapper.getTitleText()).toBe('weektitle');
      });
      it('generic type options for "dayGrid" will override generic "week" options', () => {
          let calendar = initCalendar({
              views: {
                  week: {
                      titleFormat() { return 'weektitle'; },
                  },
                  dayGrid: {
                      titleFormat() { return 'dayGridtitle'; },
                  },
                  dayGridOneWeek: {
                      type: 'dayGrid',
                      duration: { weeks: 1 },
                  },
              },
              initialView: 'dayGridOneWeek',
          });
          let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
          expect(toolbarWrapper.getTitleText()).toBe('dayGridtitle');
      });
      it('will not inherit "week" options if more than a single week', () => {
          let calendar = initCalendar({
              titleFormat() { return 'defaultitle'; },
              initialView: 'dayGridTwoWeek',
              views: {
                  week: {
                      titleFormat() { return 'weektitle'; },
                  },
                  dayGridTwoWeek: {
                      type: 'dayGrid',
                      duration: { weeks: 2 },
                  },
              },
          });
          let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
          expect(toolbarWrapper.getTitleText()).toBe('defaultitle');
      });
      it('renders a 4 day timeGrid view', () => {
          let calendar = initCalendar({
              initialView: 'timeGridFourDay',
              initialDate: '2014-12-25',
              views: {
                  timeGridFourDay: {
                      type: 'timeGrid',
                      duration: { days: 4 },
                  },
              },
          });
          let viewWrapper = new TimeGridViewWrapper(calendar);
          let timeGridDayEls = viewWrapper.timeGrid.getAllDayEls();
          expect(viewWrapper.dayGrid.getRowEls().length).toBe(1);
          expect(viewWrapper.dayGrid.getAllDayEls().length).toBe(4);
          expect(timeGridDayEls.length).toBe(4);
          expect(timeGridDayEls[0].getAttribute('data-date')).toBe('2014-12-25'); // starts on initialDate
      });
      it('renders a two week timeGrid view', () => {
          let calendar = initCalendar({
              initialView: 'timeGridTwoWeek',
              initialDate: '2014-12-25',
              views: {
                  timeGridTwoWeek: {
                      type: 'timeGrid',
                      duration: { weeks: 2 },
                  },
              },
          });
          let viewWrapper = new TimeGridViewWrapper(calendar);
          let timeGridDayEls = viewWrapper.timeGrid.getAllDayEls();
          expect(viewWrapper.dayGrid.getRowEls().length).toBe(1);
          expect(viewWrapper.dayGrid.getAllDayEls().length).toBe(14);
          expect(timeGridDayEls.length).toBe(14);
          expect(timeGridDayEls[0].getAttribute('data-date')).toBe('2014-12-21'); // week start
      });
      it('renders a two month timeGrid view', () => {
          let calendar = initCalendar({
              initialView: 'timeGridTwoWeek',
              initialDate: '2014-11-27',
              views: {
                  timeGridTwoWeek: {
                      type: 'timeGrid',
                      duration: { months: 2 },
                  },
              },
          });
          let viewWrapper = new TimeGridViewWrapper(calendar);
          let timeGridDayEls = viewWrapper.timeGrid.getAllDayEls();
          expect(viewWrapper.dayGrid.getRowEls().length).toBe(1);
          expect(viewWrapper.dayGrid.getAllDayEls().length).toBe(61);
          expect(timeGridDayEls.length).toBe(61);
          expect(timeGridDayEls[0].getAttribute('data-date')).toBe('2014-11-01');
          expect(timeGridDayEls[timeGridDayEls.length - 1].getAttribute('data-date')).toBe('2014-12-31'); // last
      });
      it('renders a two month dayGrid view', () => {
          let calendar = initCalendar({
              initialView: 'dayGridTwoWeek',
              initialDate: '2014-11-27',
              views: {
                  dayGridTwoWeek: {
                      type: 'dayGrid',
                      duration: { months: 2 },
                  },
              },
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          let dayEls = dayGridWrapper.getAllDayEls();
          expect(dayGridWrapper.getRowEls().length).toBe(10);
          expect(dayGridWrapper.getDayElsInRow(0).length).toBe(7);
          expect(dayEls[0].getAttribute('data-date')).toBe('2014-10-26');
          expect(dayEls[dayEls.length - 1].getAttribute('data-date')).toBe('2015-01-03');
      });
      it('renders a one year dayGrid view', () => {
          let options = {
              initialView: 'dayGridYear',
              initialDate: '2014-11-27',
              views: {
                  dayGridYear: {
                      type: 'dayGrid',
                      duration: { years: 1 },
                  },
              },
          };
          let calendar = initCalendar(options);
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          let dayEls = dayGridWrapper.getAllDayEls();
          expect(dayEls[0]).toBeMatchedBy('[data-date="2013-12-29"]');
          expect(dayEls[dayEls.length - 1]).toBeMatchedBy('[data-date="2015-01-03"]');
      });
      describe('buttonText', () => {
          it('accepts buttonText exact-match override', () => {
              let options = {
                  buttonText: {
                      custom: 'over-ridden',
                  },
                  headerToolbar: {
                      center: 'custom,dayGridMonth',
                  },
                  initialView: 'custom',
                  views: {
                      custom: {
                          type: 'dayGrid',
                          duration: { days: 4 },
                          buttonText: 'awesome',
                      },
                  },
              };
              let calendar = initCalendar(options);
              let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
              let buttonInfo = toolbarWrapper.getButtonInfo('custom');
              expect(buttonInfo.text).toBe('over-ridden');
          });
          it('accepts buttonText single-unit-match override', () => {
              let options = {
                  buttonText: {
                      day: '1day-over-ridden',
                  },
                  headerToolbar: {
                      center: 'custom,dayGridMonth',
                  },
                  initialView: 'custom',
                  views: {
                      custom: {
                          type: 'dayGrid',
                          duration: { days: 1 },
                          buttonText: 'awesome',
                      },
                  },
              };
              let calendar = initCalendar(options);
              let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
              let buttonInfo = toolbarWrapper.getButtonInfo('custom');
              expect(buttonInfo.text).toBe('1day-over-ridden');
          });
          it('does not accept buttonText unit-match override when unit is more than one', () => {
              let options = {
                  buttonText: {
                      day: '1day!!!???',
                  },
                  headerToolbar: {
                      center: 'custom,dayGridMonth',
                  },
                  initialView: 'custom',
                  views: {
                      custom: {
                          type: 'dayGrid',
                          duration: { days: 2 },
                          buttonText: 'awesome',
                      },
                  },
              };
              let calendar = initCalendar(options);
              let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
              let buttonInfo = toolbarWrapper.getButtonInfo('custom');
              expect(buttonInfo.text).toBe('awesome');
          });
          it('accepts locale\'s single-unit-match override', () => {
              let calendar = initCalendar({
                  locale: l31,
                  headerToolbar: {
                      center: 'custom,dayGridMonth',
                  },
                  initialView: 'custom',
                  views: {
                      custom: {
                          type: 'dayGrid',
                          duration: { days: 1 },
                      },
                  },
              });
              let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
              let buttonInfo = toolbarWrapper.getButtonInfo('custom');
              expect(buttonInfo.text).toBe('Jour');
          });
          it('accepts explicit View-Specific buttonText, overriding locale\'s single-unit-match override', () => {
              let calendar = initCalendar({
                  locale: l31,
                  headerToolbar: {
                      center: 'custom,dayGridMonth',
                  },
                  initialView: 'custom',
                  views: {
                      custom: {
                          type: 'dayGrid',
                          duration: { days: 1 },
                          buttonText: 'awesome',
                      },
                  },
              });
              let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
              let buttonInfo = toolbarWrapper.getButtonInfo('custom');
              expect(buttonInfo.text).toBe('awesome');
          });
          it('respects custom view\'s value', () => {
              let options = {
                  headerToolbar: {
                      center: 'custom,dayGridMonth',
                  },
                  initialView: 'custom',
                  views: {
                      custom: {
                          type: 'dayGrid',
                          duration: { days: 4 },
                          buttonText: 'awesome',
                      },
                  },
              };
              let calendar = initCalendar(options);
              let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
              let buttonInfo = toolbarWrapper.getButtonInfo('custom');
              expect(buttonInfo.text).toBe('awesome');
          });
          it('respects custom view\'s value, even when a "smart" property name', () => {
              let options = {
                  headerToolbar: {
                      center: 'dayGridFourDay,dayGridMonth',
                  },
                  initialView: 'dayGridFourDay',
                  views: {
                      dayGridFourDay: {
                          type: 'dayGrid',
                          duration: { days: 4 },
                          buttonText: 'awesome',
                      },
                  },
              };
              let calendar = initCalendar(options);
              let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
              let buttonInfo = toolbarWrapper.getButtonInfo('dayGridFourDay');
              expect(buttonInfo.text).toBe('awesome');
          });
          it('falls back to view name when view lacks metadata', () => {
              // also sorta tests plugin system
              let calendar = initCalendar({
                  plugins: [
                      createPlugin({
                          name: 'test-plugin',
                          views: {
                              crazy: {
                                  content: 'hello world',
                              },
                          },
                      }),
                  ],
                  headerToolbar: {
                      center: 'crazy,dayGridMonth',
                  },
                  initialView: 'crazy',
              });
              let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
              let buttonInfo = toolbarWrapper.getButtonInfo('crazy');
              expect(buttonInfo.text).toBe('crazy');
          });
      });
      it('throws an error when type is self', () => {
          let error = null;
          try {
              initCalendar({
                  initialView: 'month',
                  views: {
                      month: {
                          type: 'month',
                      },
                  },
              });
          }
          catch (_error) {
              error = _error;
          }
          expect(error).toBeTruthy();
          expect(error.message).toBe('Can\'t have a custom view type that references itself');
      });
  });

  describe('button text', () => {
      pushOptions({
          headerToolbar: {
              left: 'prevYear,prev,today,next,nextYear',
              center: '',
              right: 'dayGridMonth,dayGridWeek,dayGridDay,timeGridWeek,timeGridDay',
          },
      });
      describe('with default locale', () => {
          describe('with default buttonIcons', () => {
              it('should contain default text values', () => {
                  let calendar = initCalendar();
                  let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
                  // will have button icons, to text will be empty
                  expect(toolbarWrapper.getButtonInfo('next').text).toBe('');
                  expect(toolbarWrapper.getButtonInfo('nextYear').text).toBe('');
                  expect(toolbarWrapper.getButtonInfo('prev').text).toBe('');
                  expect(toolbarWrapper.getButtonInfo('prevYear').text).toBe('');
                  expect(toolbarWrapper.getButtonInfo('today').text).toBe('today');
                  expect(toolbarWrapper.getButtonInfo('dayGridMonth').text).toBe('month');
                  expect(toolbarWrapper.getButtonInfo('dayGridWeek').text).toBe('week');
                  expect(toolbarWrapper.getButtonInfo('timeGridWeek').text).toBe('week');
                  expect(toolbarWrapper.getButtonInfo('dayGridDay').text).toBe('day');
              });
              it('should contain specified text values', () => {
                  let calendar = initCalendar({
                      buttonText: {
                          prev: '<-',
                          next: '->',
                          prevYear: '<--',
                          nextYear: '-->',
                          today: 'tidei',
                          month: 'mun',
                          week: 'wiki',
                          day: 'dei',
                      },
                  });
                  let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
                  expect(toolbarWrapper.getButtonInfo('next').text).toBe('->');
                  expect(toolbarWrapper.getButtonInfo('nextYear').text).toBe('-->');
                  expect(toolbarWrapper.getButtonInfo('prev').text).toBe('<-');
                  expect(toolbarWrapper.getButtonInfo('prevYear').text).toBe('<--');
                  expect(toolbarWrapper.getButtonInfo('today').text).toBe('tidei');
                  expect(toolbarWrapper.getButtonInfo('dayGridMonth').text).toBe('mun');
                  expect(toolbarWrapper.getButtonInfo('dayGridWeek').text).toBe('wiki');
                  expect(toolbarWrapper.getButtonInfo('dayGridDay').text).toBe('dei');
                  expect(toolbarWrapper.getButtonInfo('timeGridWeek').text).toBe('wiki');
              });
          });
          describe('with buttonIcons turned off', () => {
              pushOptions({
                  buttonIcons: false,
              });
              it('should contain default text values', () => {
                  let calendar = initCalendar();
                  let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
                  // will have actual text now
                  expect(toolbarWrapper.getButtonInfo('next').text).toBe('next');
                  expect(toolbarWrapper.getButtonInfo('nextYear').text).toBe('next year');
                  expect(toolbarWrapper.getButtonInfo('prev').text).toBe('prev');
                  expect(toolbarWrapper.getButtonInfo('prevYear').text).toBe('prev year');
                  expect(toolbarWrapper.getButtonInfo('today').text).toBe('today');
                  expect(toolbarWrapper.getButtonInfo('dayGridMonth').text).toBe('month');
                  expect(toolbarWrapper.getButtonInfo('dayGridWeek').text).toBe('week');
                  expect(toolbarWrapper.getButtonInfo('dayGridDay').text).toBe('day');
                  expect(toolbarWrapper.getButtonInfo('timeGridWeek').text).toBe('week');
              });
              it('should contain specified text values', () => {
                  let calendar = initCalendar({
                      buttonText: {
                          prev: '<-',
                          next: '->',
                          prevYear: '<--',
                          nextYear: '-->',
                          today: 'tidei',
                          month: 'mun',
                          week: 'wiki',
                          day: 'dei',
                      },
                  });
                  let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
                  expect(toolbarWrapper.getButtonInfo('next').text).toBe('->');
                  expect(toolbarWrapper.getButtonInfo('nextYear').text).toBe('-->');
                  expect(toolbarWrapper.getButtonInfo('prev').text).toBe('<-');
                  expect(toolbarWrapper.getButtonInfo('prevYear').text).toBe('<--');
                  expect(toolbarWrapper.getButtonInfo('today').text).toBe('tidei');
                  expect(toolbarWrapper.getButtonInfo('dayGridMonth').text).toBe('mun');
                  expect(toolbarWrapper.getButtonInfo('dayGridWeek').text).toBe('wiki');
                  expect(toolbarWrapper.getButtonInfo('dayGridDay').text).toBe('dei');
                  expect(toolbarWrapper.getButtonInfo('timeGridWeek').text).toBe('wiki');
              });
          });
      });
      describe('when locale is not default', () => {
          pushOptions({
              locale: l31,
          });
          describe('with default buttonIcons', () => {
              it('should contain default text values', () => {
                  let calendar = initCalendar();
                  let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
                  // will contain icons, so will contain no text
                  expect(toolbarWrapper.getButtonInfo('next').text).toBe('');
                  expect(toolbarWrapper.getButtonInfo('nextYear').text).toBe('');
                  expect(toolbarWrapper.getButtonInfo('prev').text).toBe('');
                  expect(toolbarWrapper.getButtonInfo('prevYear').text).toBe('');
                  expect(toolbarWrapper.getButtonInfo('today').text).toBe('Aujourd\'hui');
                  expect(toolbarWrapper.getButtonInfo('dayGridMonth').text).toBe('Mois');
                  expect(toolbarWrapper.getButtonInfo('dayGridWeek').text).toBe('Semaine');
                  expect(toolbarWrapper.getButtonInfo('dayGridDay').text).toBe('Jour');
                  expect(toolbarWrapper.getButtonInfo('timeGridWeek').text).toBe('Semaine');
              });
              it('should contain specified text values', () => {
                  let calendar = initCalendar({
                      buttonText: {
                          prev: '<-',
                          next: '->',
                          prevYear: '<--',
                          nextYear: '-->',
                          today: 'tidei',
                          month: 'mun',
                          week: 'wiki',
                          day: 'dei',
                      },
                  });
                  let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
                  expect(toolbarWrapper.getButtonInfo('next').text).toBe('->');
                  expect(toolbarWrapper.getButtonInfo('nextYear').text).toBe('-->');
                  expect(toolbarWrapper.getButtonInfo('prev').text).toBe('<-');
                  expect(toolbarWrapper.getButtonInfo('prevYear').text).toBe('<--');
                  expect(toolbarWrapper.getButtonInfo('today').text).toBe('tidei');
                  expect(toolbarWrapper.getButtonInfo('dayGridMonth').text).toBe('mun');
                  expect(toolbarWrapper.getButtonInfo('dayGridWeek').text).toBe('wiki');
                  expect(toolbarWrapper.getButtonInfo('dayGridDay').text).toBe('dei');
                  expect(toolbarWrapper.getButtonInfo('timeGridWeek').text).toBe('wiki');
              });
          });
          describe('with buttonIcons turned off', () => {
              pushOptions({
                  buttonIcons: false,
              });
              it('should contain default text values', () => {
                  let calendar = initCalendar();
                  let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
                  // will have the locale's actual text now
                  expect(toolbarWrapper.getButtonInfo('next').text).toBe('Suivant');
                  expect(toolbarWrapper.getButtonInfo('prev').text).toBe('Précédent');
                  /// / locales files don't have data for prev/next *year*
                  // expect(toolbarWrapper.getButtonInfo('nextYear').text).toBe('Suivant');
                  // expect(toolbarWrapper.getButtonInfo('prevYear').text).toBe('Précédent');
                  expect(toolbarWrapper.getButtonInfo('today').text).toBe('Aujourd\'hui');
                  expect(toolbarWrapper.getButtonInfo('dayGridMonth').text).toBe('Mois');
                  expect(toolbarWrapper.getButtonInfo('dayGridWeek').text).toBe('Semaine');
                  expect(toolbarWrapper.getButtonInfo('timeGridWeek').text).toBe('Semaine');
                  expect(toolbarWrapper.getButtonInfo('dayGridDay').text).toBe('Jour');
                  expect(toolbarWrapper.getButtonInfo('dayGridDay').text).toBe('Jour');
              });
              it('should contain specified text values', () => {
                  let calendar = initCalendar({
                      buttonText: {
                          prev: '<-',
                          next: '->',
                          prevYear: '<--',
                          nextYear: '-->',
                          today: 'tidei',
                          month: 'mun',
                          week: 'wiki',
                          day: 'dei',
                      },
                  });
                  let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
                  expect(toolbarWrapper.getButtonInfo('next').text).toBe('->');
                  expect(toolbarWrapper.getButtonInfo('nextYear').text).toBe('-->');
                  expect(toolbarWrapper.getButtonInfo('prev').text).toBe('<-');
                  expect(toolbarWrapper.getButtonInfo('prevYear').text).toBe('<--');
                  expect(toolbarWrapper.getButtonInfo('today').text).toBe('tidei');
                  expect(toolbarWrapper.getButtonInfo('dayGridMonth').text).toBe('mun');
                  expect(toolbarWrapper.getButtonInfo('dayGridWeek').text).toBe('wiki');
                  expect(toolbarWrapper.getButtonInfo('dayGridDay').text).toBe('dei');
                  expect(toolbarWrapper.getButtonInfo('timeGridWeek').text).toBe('wiki');
              });
          });
      });
  });

  describe('allDaySlots', () => {
      describe('when allDaySlots is not set', () => {
          describe('in week', () => {
              it('should default to having an allDaySlots table', () => {
                  let calendar = initCalendar({
                      initialView: 'timeGridWeek',
                  });
                  let dayGrid = new TimeGridViewWrapper(calendar).dayGrid;
                  expect(dayGrid).toBeTruthy();
              });
          });
          describe('in day', () => {
              it('should default to having an allDaySlots table', () => {
                  let calendar = initCalendar({
                      initialView: 'timeGridDay',
                  });
                  let dayGrid = new TimeGridViewWrapper(calendar).dayGrid;
                  expect(dayGrid).toBeTruthy();
              });
          });
      });
      describe('when allDaySlots is set true', () => {
          describe('in week', () => {
              it('should default to having an allDaySlots table', () => {
                  let calendar = initCalendar({
                      initialView: 'timeGridWeek',
                      allDaySlot: true,
                  });
                  let dayGrid = new TimeGridViewWrapper(calendar).dayGrid;
                  expect(dayGrid).toBeTruthy();
              });
          });
          describe('in day', () => {
              it('should default to having an allDaySlots table', () => {
                  let calendar = initCalendar({
                      initialView: 'timeGridDay',
                      allDaySlot: true,
                  });
                  let dayGrid = new TimeGridViewWrapper(calendar).dayGrid;
                  expect(dayGrid).toBeTruthy();
              });
          });
      });
      describe('when allDaySlots is set false', () => {
          describe('in week', () => {
              it('should default to having an allDaySlots table', () => {
                  let calendar = initCalendar({
                      initialView: 'timeGridWeek',
                      allDaySlot: false,
                  });
                  let dayGrid = new TimeGridViewWrapper(calendar).dayGrid;
                  expect(dayGrid).toBeFalsy();
              });
          });
          describe('in day', () => {
              it('should default to having an allDaySlots table', () => {
                  let calendar = initCalendar({
                      initialView: 'timeGridDay',
                      allDaySlot: false,
                  });
                  let dayGrid = new TimeGridViewWrapper(calendar).dayGrid;
                  expect(dayGrid).toBeFalsy();
              });
          });
      });
  });

  describe('view-specific options', () => {
      pushOptions({
          headerToolbar: {
              left: 'prev,next',
              center: 'title',
              right: 'dayGridMonth,dayGridWeek,dayGridDay,timeGridWeek,timeGridDay',
          },
          initialView: 'dayGridMonth',
          titleFormat() { return 'default'; },
          views: {},
      });
      function testEachView(viewsAndVals) {
          $.each(viewsAndVals, (view, val) => {
              currentCalendar.changeView(view);
              expect($('h2')).toHaveText(val);
          });
      }
      it('can target a specific view (dayGridMonth)', () => {
          initCalendar({
              views: {
                  dayGridMonth: {
                      titleFormat() { return 'special!!!'; },
                  },
              },
          });
          testEachView({
              dayGridMonth: 'special!!!',
              dayGridWeek: 'default',
              dayGridDay: 'default',
              timeGridWeek: 'default',
              timeGridDay: 'default',
          });
      });
      it('can target a specific view (timeGridWeek)', () => {
          initCalendar({
              views: {
                  timeGridWeek: {
                      titleFormat() { return 'special!!!'; },
                  },
              },
          });
          testEachView({
              dayGridMonth: 'default',
              dayGridWeek: 'default',
              dayGridDay: 'default',
              timeGridWeek: 'special!!!',
              timeGridDay: 'default',
          });
      });
      it('can target dayGrid views', () => {
          initCalendar({
              views: {
                  dayGrid: {
                      titleFormat() { return 'special!!!'; },
                  },
              },
          });
          testEachView({
              dayGridMonth: 'special!!!',
              dayGridWeek: 'special!!!',
              dayGridDay: 'special!!!',
              timeGridWeek: 'default',
              timeGridDay: 'default',
          });
      });
      it('can target timeGrid views', () => {
          initCalendar({
              views: {
                  timeGrid: {
                      titleFormat() { return 'special!!!'; },
                  },
              },
          });
          testEachView({
              dayGridMonth: 'default',
              dayGridWeek: 'default',
              dayGridDay: 'default',
              timeGridWeek: 'special!!!',
              timeGridDay: 'special!!!',
          });
      });
      it('can target week views', () => {
          initCalendar({
              views: {
                  week: {
                      titleFormat() { return 'special!!!'; },
                  },
              },
          });
          testEachView({
              dayGridMonth: 'default',
              dayGridWeek: 'special!!!',
              dayGridDay: 'default',
              timeGridWeek: 'special!!!',
              timeGridDay: 'default',
          });
      });
      it('can target day views', () => {
          initCalendar({
              views: {
                  day: {
                      titleFormat() { return 'special!!!'; },
                  },
              },
          });
          testEachView({
              dayGridMonth: 'default',
              dayGridWeek: 'default',
              dayGridDay: 'special!!!',
              timeGridWeek: 'default',
              timeGridDay: 'special!!!',
          });
      });
      it('views that explicitly extend others inherit options', () => {
          initCalendar({
              plugins: [
                  index$a,
                  createPlugin({
                      name: 'test-plugin',
                      views: {
                          superBasic: {
                              type: 'dayGrid',
                              content: 'hello world',
                          },
                      },
                  }),
              ],
              views: {
                  dayGrid: {
                      titleFormat() { return 'special!!!'; },
                  },
              },
          });
          testEachView({
              superBasic: 'special!!!',
              dayGridMonth: 'special!!!',
              dayGridDay: 'special!!!',
          });
      });
  });

  describe('event feed params', () => {
      pushOptions({
          initialDate: '2014-05-01',
          initialView: 'dayGridMonth',
      });
      afterEach(() => {
          client.restore();
      });
      it('utilizes custom startParam, endParam, and timeZoneParam names', () => {
          const givenUrl = window.location.href + '/my-feed.php';
          client.get(/my-feed\.php/, { body: [] });
          initCalendar({
              events: givenUrl,
              timeZone: 'America/Los_Angeles',
              startParam: 'mystart',
              endParam: 'myend',
              timeZoneParam: 'currtz',
          });
          const [requestUrl] = client.lastCall();
          const requestParams = new URL(requestUrl).searchParams;
          expect(requestParams.get('mystart')).toBe('2014-04-27T00:00:00');
          expect(requestParams.get('myend')).toBe('2014-06-08T00:00:00');
          expect(requestParams.get('currtz')).toBe('America/Los_Angeles');
      });
      it('utilizes event-source-specific startParam, endParam, and timeZoneParam names', () => {
          const givenUrl = window.location.href + '/my-feed.php';
          client.get(/my-feed\.php/, { body: [] });
          initCalendar({
              timeZone: 'America/Los_Angeles',
              startParam: 'mystart',
              endParam: 'myend',
              timeZoneParam: 'currtz',
              eventSources: [
                  {
                      url: givenUrl,
                      startParam: 'feedstart',
                      endParam: 'feedend',
                      timeZoneParam: 'feedctz',
                  },
              ],
          });
          const [requestUrl] = client.lastCall();
          const requestParams = new URL(requestUrl).searchParams;
          expect(requestParams.get('feedstart')).toBe('2014-04-27T00:00:00');
          expect(requestParams.get('feedend')).toBe('2014-06-08T00:00:00');
          expect(requestParams.get('feedctz')).toBe('America/Los_Angeles');
      });
  });

  describe('scroll state', () => {
      let calendarEl;
      beforeEach(() => {
          calendarEl = $('<div id="calendar">').width(800).appendTo('body');
      });
      afterEach(() => {
          calendarEl.remove();
          calendarEl = null;
      });
      pushOptions({
          initialDate: '2015-02-20',
          contentHeight: 200,
          scrollTime: '00:00', // for timeGrid
      });
      describeOptions('initialView', {
          'when in month view': 'dayGridMonth',
          'when in week view': 'timeGridWeek',
      }, (viewName) => {
          let ViewWrapper = viewName.match(/^dayGrid/) ? DayGridViewWrapper : TimeGridViewWrapper;
          it('should be maintained when resizing window', (done) => {
              let scrollEl;
              let scroll0;
              let calendar = initCalendar({
                  windowResize() {
                      setTimeout(() => {
                          expect(scrollEl.scrollTop).toBe(scroll0);
                          done();
                      }, 0);
                  },
              }, calendarEl);
              scrollEl = new ViewWrapper(calendar).getScrollerEl();
              setTimeout(() => {
                  scrollEl.scrollTop = 9999; // all the way
                  scroll0 = scrollEl.scrollTop;
                  $(window).simulate('resize');
              }, 0);
          });
          it('should be maintained when after rerendering events', () => {
              let calendar = initCalendar({
                  events: [{
                          start: '2015-02-20',
                      }],
              }, calendarEl);
              let scrollEl = new ViewWrapper(calendar).getScrollerEl();
              let eventEl0 = new CalendarWrapper(calendar).getEventEls();
              expect(eventEl0.length).toBe(1);
              scrollEl.scrollTop = 9999; // all the way
              let scroll0 = scrollEl.scrollTop;
              currentCalendar.render();
              let eventEl1 = new CalendarWrapper(calendar).getEventEls();
              expect(eventEl1.length).toBe(1);
              expect(scrollEl.scrollTop).toBe(scroll0);
          });
      });
  });

  describe('getEventSources', () => {
      pushOptions({
          now: '2015-08-07',
          initialView: 'timeGridWeek',
          eventSources: [
              {
                  events: [
                      { id: '1', start: '2015-08-07T02:00:00', end: '2015-08-07T03:00:00', title: 'event A' },
                  ],
              },
              {
                  events: [
                      { id: '2', start: '2015-08-07T03:00:00', end: '2015-08-07T04:00:00', title: 'event B' },
                  ],
              },
              {
                  events: [
                      { id: '3', start: '2015-08-07T04:00:00', end: '2015-08-07T05:00:00', title: 'event C' },
                  ],
              },
          ],
      });
      it('does not mutate when removeEventSource is called', (done) => {
          initCalendar();
          let eventSources = currentCalendar.getEventSources();
          expect(eventSources.length).toBe(3);
          // prove that eventSources is a copy, and wasn't mutated
          eventSources[0].remove();
          expect(eventSources.length).toBe(3);
          done();
      });
  });

  describe('now indicator', () => {
      pushOptions({
          now: '2015-12-26T06:00:00',
          scrollTime: '00:00',
          initialView: 'timeGridWeek',
      });
      it('doesn\'t render by default', () => {
          let calendar = initCalendar();
          let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
          expect(timeGridWrapper.hasNowIndicator()).toBe(false);
      });
      describe('when activated', () => {
          pushOptions({
              nowIndicator: true,
          });
          describeOptions('direction', {
              'when LTR': 'ltr',
              'when RTL': 'rtl',
          }, () => {
              it('doesn\'t render when out of view', () => {
                  let calendar = initCalendar({
                      initialDate: '2015-12-27', // sun of next week
                  });
                  let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                  expect(timeGridWrapper.hasNowIndicator()).toBe(false);
              });
              it('renders on correct time', () => {
                  let calendar = initCalendar();
                  isNowIndicatorRenderedAt(calendar, '2015-12-26T06:00:00Z');
              });
              it('renders on correct time2', () => {
                  let calendar = initCalendar({
                      now: '2015-12-20T02:30:00',
                  });
                  isNowIndicatorRenderedAt(calendar, '2015-12-20T02:30:00Z');
              });
          });
      });
      function isNowIndicatorRenderedAt(calendar, date) {
          let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
          let line = timeGridWrapper.getLine(date);
          let lineEl = timeGridWrapper.getNowIndicatorLineEl();
          let arrowEl = timeGridWrapper.getNowIndicatorArrowEl();
          expect(lineEl).toBeTruthy();
          expect(arrowEl).toBeTruthy();
          let lineElRect = getBoundingRect(lineEl);
          let arrowElRect = getBoundingRect(arrowEl);
          expect(Math.abs((lineElRect.top + lineElRect.bottom) / 2 -
              line.top)).toBeLessThan(2);
          expect(Math.abs((arrowElRect.top + arrowElRect.bottom) / 2 -
              line.top)).toBeLessThan(2);
          let timeGridRect = getBoundingRect(timeGridWrapper.el);
          if (calendar.getOption('direction') === 'rtl') {
              expect(Math.abs(arrowElRect.right - timeGridRect.right)).toBeLessThan(2);
          }
          else {
              expect(Math.abs(arrowElRect.left - timeGridRect.left)).toBeLessThan(2);
          }
      }
  });

  describe('computeInnerRect', () => {
      let INNER_WIDTH = 150;
      let INNER_HEIGHT = 100;
      let BORDER_LEFT = 1;
      let BORDER_RIGHT = 2;
      let BORDER_TOP = 3;
      let BORDER_BOTTOM = 4;
      let PADDING_LEFT = 5;
      let PADDING_RIGHT = 6;
      let PADDING_TOP = 7;
      let PADDING_BOTTOM = 8;
      describeValues({
          'when LTR': 'ltr',
          'when RTL': 'rtl',
      }, (direction) => {
          let el;
          beforeEach(() => {
              el = $('<div/>')
                  .css({
                  direction,
                  position: 'absolute',
                  top: 0,
                  left: 0,
                  borderStyle: 'solid',
                  borderColor: 'black',
                  borderLeftWidth: BORDER_LEFT,
                  borderRightWidth: BORDER_RIGHT,
                  borderTopWidth: BORDER_TOP,
                  borderBottomWidth: BORDER_BOTTOM,
                  paddingLeft: PADDING_LEFT,
                  paddingRight: PADDING_RIGHT,
                  paddingTop: PADDING_TOP,
                  paddingBottom: PADDING_BOTTOM,
              })
                  .append($('<div/>').css({
                  width: INNER_WIDTH,
                  height: INNER_HEIGHT,
              }))
                  .appendTo('body');
          });
          afterEach(() => {
              el.remove();
          });
          describe('when no scrolling', () => {
              beforeEach(() => {
                  el.css('overflow', 'hidden');
              });
              it('goes within border', () => {
                  expect(computeInnerRect(el[0])).toEqual({
                      left: BORDER_LEFT,
                      right: BORDER_LEFT + PADDING_LEFT + INNER_WIDTH + PADDING_RIGHT,
                      top: BORDER_TOP,
                      bottom: BORDER_TOP + PADDING_TOP + INNER_HEIGHT + PADDING_BOTTOM,
                  });
              });
              it('can go within padding', () => {
                  expect(computeInnerRect(el[0], true)).toEqual({
                      left: BORDER_LEFT + PADDING_LEFT,
                      right: BORDER_LEFT + PADDING_LEFT + INNER_WIDTH,
                      top: BORDER_TOP + PADDING_TOP,
                      bottom: BORDER_TOP + PADDING_TOP + INNER_HEIGHT,
                  });
              });
          });
          describe('when scrolling', () => {
              beforeEach(() => {
                  el.css('overflow', 'scroll');
              });
              let stockScrollbars = getStockScrollbarWidths(direction);
              it('goes within border and scrollbars', () => {
                  expect(computeInnerRect(el[0])).toEqual({
                      left: BORDER_LEFT + stockScrollbars.left,
                      right: BORDER_LEFT + stockScrollbars.left + PADDING_LEFT + INNER_WIDTH + PADDING_RIGHT,
                      top: BORDER_TOP,
                      bottom: BORDER_TOP + PADDING_TOP + INNER_HEIGHT + PADDING_BOTTOM,
                  });
              });
              it('can go within padding', () => {
                  expect(computeInnerRect(el[0], true)).toEqual({
                      left: BORDER_LEFT + stockScrollbars.left + PADDING_LEFT,
                      right: BORDER_LEFT + stockScrollbars.left + PADDING_LEFT + INNER_WIDTH,
                      top: BORDER_TOP + PADDING_TOP,
                      bottom: BORDER_TOP + PADDING_TOP + INNER_HEIGHT,
                  });
              });
          });
      });
  });

  var l7 = {
      code: 'ar',
      week: {
          dow: 6,
          doy: 12, // The week that contains Jan 1st is the first week of the year.
      },
      direction: 'rtl',
      buttonText: {
          prev: 'السابق',
          next: 'التالي',
          today: 'اليوم',
          year: 'سنة',
          month: 'شهر',
          week: 'أسبوع',
          day: 'يوم',
          list: 'أجندة',
      },
      weekText: 'أسبوع',
      allDayText: 'اليوم كله',
      moreLinkText: 'أخرى',
      noEventsText: 'أي أحداث لعرض',
  };

  describe('locale', () => {
      pushOptions({
          locales: [l24, l31, l7],
      });
      it('works when certain locale has no FC settings defined', () => {
          let calendar = initCalendar({
              locale: 'en-asdf',
              initialView: 'timeGridWeek',
              initialDate: '2014-12-25',
              events: [
                  { title: 'Christmas', start: '2014-12-25T10:00:00' },
              ],
          });
          let headerWrapper = new TimeGridViewWrapper(calendar).header;
          expect(headerWrapper.getCellText(0)).toMatch(/^Sun\.? 12[-/ ]21$/);
          let calendarWrapper = new CalendarWrapper(calendar);
          let eventEl = calendarWrapper.getFirstEventEl();
          let eventInfo = calendarWrapper.getEventElInfo(eventEl);
          expect(eventInfo.timeText).toBe('10:00');
      });
      it('allows dynamic setting', () => {
          let calendar = initCalendar({
              locale: 'es',
              initialDate: '2016-07-10',
              initialView: 'dayGridMonth',
          });
          let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
          expect(toolbarWrapper.getTitleText()).toBe('julio de 2016');
          expect(calendar.getOption('direction')).toBe('ltr');
          currentCalendar.setOption('locale', 'fr');
          expect(toolbarWrapper.getTitleText()).toBe('juillet 2016');
          currentCalendar.setOption('locale', 'ar'); // NOTE: we had problems testing for RTL title text
          expect(calendar.getOption('direction')).toBe('rtl');
      });
  });

  describe('defaultAllDay', () => {
      describe('when undefined', () => {
          it('guesses false if T in ISO8601 start date', () => {
              initCalendar({
                  events: [
                      {
                          id: '1',
                          start: '2014-05-01T06:00:00',
                      },
                  ],
              });
              let eventObj = currentCalendar.getEventById('1');
              expect(eventObj.allDay).toEqual(false);
          });
          it('guesses false if T in ISO8601 end date', () => {
              initCalendar({
                  events: [
                      {
                          id: '1',
                          start: '2014-05-01',
                          end: '2014-05-01T08:00:00',
                      },
                  ],
              });
              let eventObj = currentCalendar.getEventById('1');
              expect(eventObj.allDay).toEqual(false);
          });
          it('guesses true if ISO8601 start date with no time and unspecified end date', () => {
              initCalendar({
                  events: [
                      {
                          id: '1',
                          start: '2014-05-01',
                      },
                  ],
              });
              let eventObj = currentCalendar.getEventById('1');
              expect(eventObj.allDay).toEqual(true);
          });
          it('guesses true if ISO8601 start and end date with no times', () => {
              initCalendar({
                  events: [
                      {
                          id: '1',
                          start: '2014-05-01',
                          end: '2014-05-03',
                      },
                  ],
              });
              let eventObj = currentCalendar.getEventById('1');
              expect(eventObj.allDay).toEqual(true);
          });
          it('guesses false if start is a unix timestamp (which implies it has a time)', () => {
              initCalendar({
                  events: [
                      {
                          id: '1',
                          start: 1398902400000,
                          end: '2014-05-03',
                      },
                  ],
              });
              let eventObj = currentCalendar.getEventById('1');
              expect(eventObj.allDay).toEqual(false);
          });
          it('guesses false if end is a unix timestamp (which implies it has a time)', () => {
              initCalendar({
                  events: [
                      {
                          id: '1',
                          start: '2014-05-01',
                          end: 1399075200000,
                      },
                  ],
              });
              let eventObj = currentCalendar.getEventById('1');
              expect(eventObj.allDay).toEqual(false);
          });
      });
      describe('when specified', () => {
          it('has an effect when an event\'s allDay is not specified', () => {
              initCalendar({
                  defaultAllDay: false,
                  events: [
                      {
                          id: '1',
                          start: '2014-05-01',
                      },
                  ],
              });
              let eventObj = currentCalendar.getEventById('1');
              expect(eventObj.allDay).toEqual(false);
          });
          it('has no effect when an event\'s allDay is specified', () => {
              initCalendar({
                  defaultAllDay: false,
                  events: [
                      {
                          id: '1',
                          start: '2014-05-01T00:00:00',
                          allDay: true,
                      },
                  ],
              });
              let eventObj = currentCalendar.getEventById('1');
              expect(eventObj.allDay).toEqual(true);
          });
      });
  });
  describe('source.defaultAllDay', () => {
      it('has an effect when an event\'s allDay is not specified', () => {
          initCalendar({
              eventSources: [
                  {
                      defaultAllDay: false,
                      events: [
                          {
                              id: '1',
                              start: '2014-05-01',
                          },
                      ],
                  },
              ],
          });
          let eventObj = currentCalendar.getEventById('1');
          expect(eventObj.allDay).toEqual(false);
      });
      it('a true value can override the global defaultAllDay', () => {
          initCalendar({
              defaultAllDay: false,
              eventSources: [
                  {
                      defaultAllDay: true,
                      events: [
                          {
                              id: '1',
                              start: '2014-05-01T06:00:00',
                          },
                      ],
                  },
              ],
          });
          let eventObj = currentCalendar.getEventById('1');
          expect(eventObj.allDay).toEqual(true);
      });
      it('a false value can override the global defaultAllDay', () => {
          initCalendar({
              defaultAllDay: true,
              eventSources: [
                  {
                      defaultAllDay: false,
                      events: [
                          {
                              id: '1',
                              start: '2014-05-01',
                          },
                      ],
                  },
              ],
          });
          let eventObj = currentCalendar.getEventById('1');
          expect(eventObj.allDay).toEqual(false);
      });
      it('has no effect when an event\'s allDay is specified', () => {
          initCalendar({
              eventSources: [
                  {
                      defaultAllDay: true,
                      events: [
                          {
                              id: '1',
                              start: '2014-05-01',
                              allDay: false,
                          },
                      ],
                  },
              ],
          });
          let eventObj = currentCalendar.getEventById('1');
          expect(eventObj.allDay).toEqual(false);
      });
  });

  ['height', 'contentHeight'].forEach((heightProp) => {
      describe(heightProp, () => {
          let $calendarEl;
          let heightEl; // HTMLElement
          let asAMethod;
          let heightPropDescriptions = [
              { description: 'as a number', height: 600 },
          ];
          if (heightProp === 'height') {
              heightPropDescriptions.push({ description: 'as "100%"', height: '100%', heightWrapper: true });
          }
          pushOptions({
              initialDate: '2014-08-01',
          });
          beforeEach(() => {
              $calendarEl = $('<div />').appendTo('body').width(900);
          });
          afterEach(() => {
              $calendarEl.remove();
          });
          // relies on asAMethod (boolean)
          // otherOptions: other calendar options to dynamically set (assumes asAMethod)
          function init(heightVal) {
              let calendar;
              if (asAMethod) {
                  calendar = initCalendar({}, $calendarEl[0]);
                  let calendarWrapper = new CalendarWrapper(calendar);
                  let dateEl = calendarWrapper.getFirstDateEl();
                  calendar.setOption(heightProp, heightVal);
                  expect(calendarWrapper.getFirstDateEl()).toBe(dateEl);
              }
              else {
                  calendar = initCalendar({ [heightProp]: heightVal }, $calendarEl[0]);
              }
              if (heightProp === 'height') {
                  heightEl = calendar.el;
              }
              else {
                  heightEl = new CalendarWrapper(calendar).getViewEl();
              }
              return calendar;
          }
          function expectHeight(heightVal) {
              let diff = Math.abs(heightEl.offsetHeight - heightVal);
              expect(diff).toBeLessThan(2); // off-by-one or exactly the same. for zoom, and firefox
          }
          $.each({
              'as an init option': false,
              'as a method': true,
          }, (desc, bool) => {
              describe(desc, () => {
                  beforeEach(() => {
                      asAMethod = bool;
                  });
                  describe('for ' + heightProp, () => {
                      describe('when in month view', () => {
                          pushOptions({
                              initialView: 'dayGridMonth',
                          });
                          heightPropDescriptions.forEach((testInfo) => {
                              describe(testInfo.description, () => {
                                  if (testInfo.heightWrapper) {
                                      beforeEach(() => {
                                          $calendarEl.wrap('<div id="calendar-container" style="height: 600px;" />');
                                      });
                                      afterEach(() => {
                                          $('#calendar-container').remove();
                                      });
                                  }
                                  describe('when there are no events', () => {
                                      it('should be the specified height, with no scrollbars', () => {
                                          let calendar = init(testInfo.height);
                                          let viewWrapper = new DayGridViewWrapper(calendar);
                                          let diff = Math.abs(heightEl.offsetHeight - 600);
                                          expect(diff).toBeLessThan(2);
                                          expect(viewWrapper.getScrollerEl()).not.toHaveScrollbars();
                                      });
                                  });
                                  describe('when there is one tall row of events', () => {
                                      pushOptions({
                                          events: repeatClone({ title: 'event', start: '2014-08-04' }, 9),
                                      });
                                      it('should take away height from other rows, but not do scrollbars', () => {
                                          let calendar = init(testInfo.height);
                                          let viewWrapper = new DayGridViewWrapper(calendar);
                                          let $rows = $(viewWrapper.dayGrid.getRowEls());
                                          let $tallRow = $rows.eq(1);
                                          let $shortRows = $rows.not($tallRow); // 0, 2, 3, 4, 5
                                          let shortHeight = $shortRows.eq(0).outerHeight();
                                          expectHeight(600);
                                          $shortRows.each((i, node) => {
                                              let rowHeight = $(node).outerHeight();
                                              let diff = Math.abs(rowHeight - shortHeight);
                                              expect(diff).toBeLessThan(10); // all roughly the same
                                          });
                                          expect($tallRow.outerHeight()).toBeGreaterThan(shortHeight * 2); // much taller
                                          expect(viewWrapper.getScrollerEl()).not.toHaveScrollbars();
                                      });
                                  });
                                  describe('when there are many tall rows of events', () => {
                                      pushOptions({
                                          events: [].concat(repeatClone({ title: 'event0', start: '2014-07-28' }, 9), repeatClone({ title: 'event1', start: '2014-08-04' }, 9), repeatClone({ title: 'event2', start: '2014-08-11' }, 9), repeatClone({ title: 'event3', start: '2014-08-18' }, 9), repeatClone({ title: 'event4', start: '2014-08-25' }, 9), repeatClone({ title: 'event5', start: '2014-09-01' }, 9)),
                                      });
                                      it('height is correct and scrollbars show up', () => {
                                          let calendar = init(testInfo.height);
                                          let viewWrapper = new DayGridViewWrapper(calendar);
                                          expectHeight(600);
                                          expect(viewWrapper.getScrollerEl()).toHaveScrollbars();
                                      });
                                  });
                              });
                          });
                          describe('as "auto", when there are many tall rows of events', () => {
                              pushOptions({
                                  events: [].concat(repeatClone({ title: 'event0', start: '2014-07-28' }, 9), repeatClone({ title: 'event1', start: '2014-08-04' }, 9), repeatClone({ title: 'event2', start: '2014-08-11' }, 9), repeatClone({ title: 'event3', start: '2014-08-18' }, 9), repeatClone({ title: 'event4', start: '2014-08-25' }, 9), repeatClone({ title: 'event5', start: '2014-09-01' }, 9)),
                              });
                              it('height is really tall and there are no scrollbars', () => {
                                  let calendar = init('auto');
                                  let viewWrapper = new DayGridViewWrapper(calendar);
                                  expect(heightEl.offsetHeight).toBeGreaterThan(1000); // pretty tall
                                  expect(viewWrapper.getScrollerEl()).not.toHaveScrollbars();
                              });
                          });
                      });
                      ['dayGridWeek', 'dayGridDay'].forEach((viewName) => {
                          describe('in ' + viewName + ' view', () => {
                              pushOptions({
                                  initialView: viewName,
                              });
                              heightPropDescriptions.forEach((testInfo) => {
                                  describe(testInfo.description, () => {
                                      if (testInfo.heightWrapper) {
                                          beforeEach(() => {
                                              $calendarEl.wrap('<div id="calendar-container" style="height: 600px;" />');
                                          });
                                          afterEach(() => {
                                              $('#calendar-container').remove();
                                          });
                                      }
                                      describe('when there are no events', () => {
                                          it('should be the specified height, with no scrollbars', () => {
                                              let calendar = init(testInfo.height);
                                              let viewWrapper = new DayGridViewWrapper(calendar);
                                              expectHeight(600);
                                              expect(viewWrapper.getScrollerEl()).not.toHaveScrollbars();
                                          });
                                      });
                                      describe('when there are many events', () => {
                                          pushOptions({
                                              events: repeatClone({ title: 'event', start: '2014-08-01' }, 100),
                                          });
                                          it('should have the correct height, with scrollbars', () => {
                                              let calendar = init(testInfo.height);
                                              let viewWrapper = new DayGridViewWrapper(calendar);
                                              expectHeight(600);
                                              expect(viewWrapper.getScrollerEl()).toHaveScrollbars();
                                          });
                                      });
                                  });
                              });
                              describe('as "auto", when there are many events', () => {
                                  pushOptions({
                                      events: repeatClone({ title: 'event', start: '2014-08-01' }, 100),
                                  });
                                  it('should be really tall with no scrollbars', () => {
                                      let calendar = init('auto');
                                      let viewWrapper = new DayGridViewWrapper(calendar);
                                      expect(heightEl.offsetHeight).toBeGreaterThan(1000); // pretty tall
                                      expect(viewWrapper.getScrollerEl()).not.toHaveScrollbars();
                                  });
                              });
                          });
                      });
                      ['timeGridWeek', 'timeGridDay'].forEach((viewName) => {
                          describe('in ' + viewName + ' view', () => {
                              pushOptions({
                                  initialView: viewName,
                              });
                              describeOptions({
                                  'with no all-day section': { allDaySlot: false },
                                  'with no all-day events': {},
                                  'with some all-day events': { events: repeatClone({ title: 'event', start: '2014-08-01' }, 6) },
                              }, () => {
                                  heightPropDescriptions.forEach((testInfo) => {
                                      describe(testInfo.description, () => {
                                          if (testInfo.heightWrapper) {
                                              beforeEach(() => {
                                                  $calendarEl.wrap('<div id="calendar-container" style="height: 600px;" />');
                                              });
                                              afterEach(() => {
                                                  $('#calendar-container').remove();
                                              });
                                          }
                                          describe('with many slots', () => {
                                              pushOptions({
                                                  slotMinTime: '00:00:00',
                                                  slotMaxTime: '24:00:00',
                                              });
                                              it('should be the correct height, with scrollbars', () => {
                                                  let calendar = init(testInfo.height);
                                                  let viewWrapper = new TimeGridViewWrapper(calendar);
                                                  expectHeight(600);
                                                  expect(viewWrapper.getScrollerEl()).toHaveScrollbars();
                                              });
                                          });
                                      });
                                  });
                                  describe('as "auto", with only a few slots', () => {
                                      pushOptions({
                                          slotMinTime: '06:00:00',
                                          slotMaxTime: '10:00:00',
                                      });
                                      it('should be really short with no scrollbars nor horizontal rule', () => {
                                          let calendar = init('auto');
                                          let viewWrapper = new TimeGridViewWrapper(calendar);
                                          expect(heightEl.offsetHeight).toBeLessThan(500); // pretty short
                                          expect(viewWrapper.getScrollerEl()).not.toHaveScrollbars();
                                      });
                                  });
                                  describe('as a "auto", with many slots', () => {
                                      pushOptions({
                                          slotMinTime: '00:00:00',
                                          slotMaxTime: '24:00:00',
                                      });
                                      it('should be really tall with no scrollbars nor horizontal rule', () => {
                                          let calendar = init('auto');
                                          let viewWrapper = new TimeGridViewWrapper(calendar);
                                          expect(heightEl.offsetHeight).toBeGreaterThan(900); // pretty tall
                                          expect(viewWrapper.getScrollerEl()).not.toHaveScrollbars();
                                      });
                                  });
                              });
                          });
                      });
                  });
              });
          });
      });
  });
  it('no height oscillation happens', () => {
      let $container = $('<div style="width:301px;height:300px;overflow-y:auto">' +
          '<div style="margin:0"></div>' +
          '</div>').appendTo('body');
      // will freeze browser if bug exists :)
      let calendar = initCalendar({
          headerToolbar: false,
          initialView: 'dayGridMonth',
          aspectRatio: 1,
      }, $container.find('div')[0]);
      calendar.destroy();
      $container.remove();
  });
  function repeatClone(srcObj, times) {
      let a = [];
      let i;
      for (i = 0; i < times; i += 1) {
          a.push($.extend({}, srcObj));
      }
      return a;
  }

  function testEventDrag(options, dropDate, expectSuccess, callback, eventClassName) {
      options.editable = true;
      options.viewDidMount = () => {
          setTimeout(() => {
              let calendar = currentCalendar;
              let isDraggingExternal = false;
              let $dayEl;
              let $eventEl;
              let $dragEl;
              let slatIndex;
              let $slatEl;
              let dx;
              let dy;
              let allowed;
              let dropDateMeta;
              let dropDateHasTime;
              if (typeof dropDate === 'string') {
                  dropDateMeta = parse$3(dropDate);
                  dropDateHasTime = !dropDateMeta.isTimeUnspecified;
                  dropDate = dropDateMeta.marker;
              }
              else {
                  dropDateHasTime = true;
              }
              let calendarWrapper = new CalendarWrapper(calendar);
              $eventEl = eventClassName ? $(`.${eventClassName}:first`) : $(calendarWrapper.getFirstEventEl());
              expect($eventEl.length).toBe(1);
              if (dropDateHasTime) {
                  let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                  $dragEl = $eventEl.find('.' + CalendarWrapper.EVENT_TIME_CLASSNAME);
                  $dayEl = $(timeGridWrapper.getDayEls(dropDate));
                  slatIndex = dropDate.getUTCHours() * 2 + (dropDate.getUTCMinutes() / 30); // assumes slotDuration:'30:00'
                  $slatEl = $(timeGridWrapper.getSlotElByIndex(slatIndex));
                  expect($slatEl.length).toBe(1);
                  dy = $slatEl.offset().top - $eventEl.offset().top;
              }
              else {
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  $dragEl = $eventEl.find('.' + CalendarWrapper.EVENT_TITLE_CLASSNAME);
                  $dayEl = $(dayGridWrapper.getDayEl(dropDate));
                  dy = $dayEl.offset().top - $eventEl.offset().top;
              }
              if (!$dragEl.length) {
                  isDraggingExternal = true;
                  $dragEl = $eventEl; // well, not really an "event" element anymore
              }
              expect($dragEl.length).toBe(1);
              expect($dayEl.length).toBe(1);
              dx = $dayEl.offset().left - $eventEl.offset().left;
              $dragEl.simulate('drag', {
                  dx,
                  dy,
                  onBeforeRelease() {
                      allowed = calendarWrapper.isAllowingDragging();
                      expect(allowed).toBe(expectSuccess);
                  },
                  onRelease() {
                      let eventObj;
                      let successfulDrop;
                      if (!isDraggingExternal) { // if dragging an event within the calendar, check dates
                          if (eventClassName) {
                              eventObj = calendar.getEvents().filter((o) => o.classNames.join(' ') === eventClassName)[0];
                          }
                          else {
                              eventObj = calendar.getEvents()[0];
                          }
                          if (dropDateHasTime) { // dropped on a slot
                              successfulDrop = eventObj.start.valueOf() === dropDate.valueOf(); // compare exact times
                          }
                          else { // dropped on a whole day
                              // only compare days
                              successfulDrop = formatIsoDay(eventObj.start) === formatIsoDay(dropDate);
                          }
                          expect(successfulDrop).toBe(allowed);
                          expect(successfulDrop).toBe(expectSuccess);
                      }
                      callback();
                  },
              });
          }, 0);
      };
      initCalendar(options);
  }
  function testEventResize(options, resizeDate, expectSuccess, callback, eventClassName) {
      options.editable = true;
      options.viewDidMount = () => {
          setTimeout(() => {
              let calendar = currentCalendar;
              let $lastDayEl;
              let lastSlatIndex;
              let $lastSlatEl;
              let $eventEl;
              let $dragEl;
              let dx;
              let dy;
              let allowed;
              let resizeDateMeta;
              let resizeDateHasTime;
              if (typeof resizeDate === 'string') {
                  resizeDateMeta = parse$3(resizeDate);
                  resizeDateHasTime = !resizeDateMeta.isTimeUnspecified;
                  resizeDate = resizeDateMeta.marker;
              }
              else {
                  resizeDateHasTime = true;
              }
              let calendarWrapper = new CalendarWrapper(calendar);
              $eventEl = eventClassName ? $(`.${eventClassName}:first`) : (() => {
                  let eventEls = calendarWrapper.getEventEls();
                  return $(eventEls[eventEls.length - 1]); // the last one
              })();
              $dragEl = $eventEl.find('.' + CalendarWrapper.EVENT_RESIZER_CLASSNAME)
                  .css('display', 'block'); // resizer usually only shows on hover. force-show it
              if (resizeDateHasTime) {
                  let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                  $lastDayEl = $(timeGridWrapper.getDayEls(resizeDate));
                  lastSlatIndex = resizeDate.getUTCHours() * 2 + (resizeDate.getUTCMinutes() / 30); // assumes slotDuration:'30:00'
                  $lastSlatEl = $(timeGridWrapper.getSlotElByIndex(lastSlatIndex - 1));
                  expect($lastSlatEl.length).toBe(1);
                  dy = $lastSlatEl.offset().top + $lastSlatEl.outerHeight() - ($eventEl.offset().top + $eventEl.outerHeight());
              }
              else {
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  $lastDayEl = $(dayGridWrapper.getDayEl(addDays(resizeDate, -1)));
                  dy = $lastDayEl.offset().top - $eventEl.offset().top;
              }
              expect($lastDayEl.length).toBe(1);
              expect($eventEl.length).toBe(1);
              expect($dragEl.length).toBe(1);
              dx = $lastDayEl.offset().left + $lastDayEl.outerWidth() - 2 - ($eventEl.offset().left + $eventEl.outerWidth());
              $dragEl.simulate('drag', {
                  dx,
                  dy,
                  onBeforeRelease() {
                      allowed = calendarWrapper.isAllowingDragging();
                  },
                  onRelease() {
                      let eventObj;
                      let successfulDrop;
                      if (eventClassName) {
                          eventObj = calendar.getEvents().filter((o) => o.classNames.join(' ') === eventClassName)[0];
                      }
                      else {
                          eventObj = calendar.getEvents()[0];
                      }
                      successfulDrop = eventObj.end && eventObj.end.valueOf() === resizeDate.valueOf();
                      expect(allowed).toBe(successfulDrop);
                      expect(allowed).toBe(expectSuccess);
                      expect(successfulDrop).toBe(expectSuccess);
                      callback();
                  },
              });
          }, 0);
      };
      initCalendar(options);
  }
  function testSelection(options, start, end, expectSuccess, callback) {
      let successfulSelection = false;
      let $firstDayEl;
      let $lastDayEl;
      let firstSlatIndex;
      let lastSlatIndex;
      let $firstSlatEl;
      let $lastSlatEl;
      let dx;
      let dy;
      let $dragEl;
      let allowed;
      let allDay = false;
      let meta;
      if (typeof start === 'string') {
          meta = parse$3(start);
          allDay = allDay || meta.isTimeUnspecified;
          start = meta.marker;
      }
      if (typeof end === 'string') {
          meta = parse$3(end);
          allDay = allDay || meta.isTimeUnspecified;
          end = meta.marker;
      }
      options.selectable = true;
      options.select = (arg) => {
          successfulSelection =
              arg.allDay === allDay &&
                  arg.start.valueOf() === start.valueOf() &&
                  arg.end.valueOf() === end.valueOf();
      };
      spyOn(options, 'select').and.callThrough();
      let calendar = initCalendar(options);
      let calendarWrapper = new CalendarWrapper(calendar);
      if (!allDay) {
          let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
          $firstDayEl = $(timeGridWrapper.getDayEls(start));
          $lastDayEl = $(timeGridWrapper.getDayEls(end));
          firstSlatIndex = start.getUTCHours() * 2 + (start.getUTCMinutes() / 30); // assumes slotDuration:'30:00'
          lastSlatIndex = end.getUTCHours() * 2 + (end.getUTCMinutes() / 30) - 1; // assumes slotDuration:'30:00'
          $firstSlatEl = $(timeGridWrapper.getSlotElByIndex(firstSlatIndex));
          $lastSlatEl = $(timeGridWrapper.getSlotElByIndex(lastSlatIndex));
          expect($firstSlatEl.length).toBe(1);
          expect($lastSlatEl.length).toBe(1);
          dy = $lastSlatEl.offset().top - $firstSlatEl.offset().top;
          $dragEl = $firstSlatEl;
      }
      else {
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          $firstDayEl = $(dayGridWrapper.getDayEl(start));
          $lastDayEl = $(dayGridWrapper.getDayEl(new Date(end.valueOf() - 1))); // inclusive
          dy = $lastDayEl.offset().top - $firstDayEl.offset().top;
          $dragEl = $firstDayEl;
      }
      expect($firstDayEl.length).toBe(1);
      expect($lastDayEl.length).toBe(1);
      dx = $lastDayEl.offset().left - $firstDayEl.offset().left;
      $dragEl.simulate('drag', {
          dx,
          dy,
          onBeforeRelease() {
              allowed = calendarWrapper.isAllowingDragging();
          },
          onRelease() {
              if (expectSuccess) {
                  expect(options.select).toHaveBeenCalled();
              }
              expect(expectSuccess).toBe(allowed);
              expect(expectSuccess).toBe(successfulSelection);
              expect(allowed).toBe(successfulSelection);
              callback();
          },
      });
  }

  describe('event overlap', () => {
      let options;
      beforeEach(() => {
          options = {
              initialDate: '2014-11-04',
              initialView: 'timeGridWeek',
              scrollTime: '00:00',
          };
      });
      describe('when other event overlap is false', () => {
          describe('when dragged adjacently before the other event', () => {
              describe('when subject event\'s end is explicit', () => {
                  it('allows dragging', (done) => {
                      options.events = [
                          {
                              title: 'Event A',
                              className: 'event-a',
                              start: '2014-11-04T01:00:00',
                              end: '2014-11-04T03:00:00',
                          },
                          {
                              title: 'Event B',
                              className: 'event-b',
                              start: '2014-11-04T05:00:00',
                              end: '2014-11-04T09:00:00',
                              overlap: false,
                          },
                      ];
                      testEventDrag(options, '2014-11-04T03:00:00', true, done, 'event-a');
                  });
              });
              describe('when subject event\'s end is implied', () => {
                  it('allows dragging', (done) => {
                      options.defaultTimedEventDuration = '01:30';
                      options.events = [
                          {
                              title: 'Event A',
                              className: 'event-a',
                              start: '2014-11-04T01:00:00',
                          },
                          {
                              title: 'Event B',
                              className: 'event-b',
                              start: '2014-11-04T05:00:00',
                              end: '2014-11-04T09:00:00',
                              overlap: false,
                          },
                      ];
                      testEventDrag(options, '2014-11-04T03:30:00', true, done, 'event-a');
                  });
              });
          });
          describe('when dragged adjacently after the other event', () => {
              it('allows dragging', (done) => {
                  options.events = [
                      {
                          title: 'Event A',
                          className: 'event-a',
                          start: '2014-11-04T01:00:00',
                          end: '2014-11-04T03:00:00',
                      },
                      {
                          title: 'Event B',
                          className: 'event-b',
                          start: '2014-11-04T05:00:00',
                          end: '2014-11-04T09:00:00',
                          overlap: false,
                      },
                  ];
                  testEventDrag(options, '2014-11-04T09:00:00', true, done, 'event-a');
              });
          });
          describe('when dragged intersecting the other event\'s start', () => {
              describe('when no timezone', () => {
                  describe('when subject event\'s end is explicit', () => {
                      it('does not allow dragging', (done) => {
                          options.events = [
                              {
                                  title: 'Event A',
                                  className: 'event-a',
                                  start: '2014-11-04T01:00:00',
                                  end: '2014-11-04T03:00:00',
                              },
                              {
                                  title: 'Event B',
                                  className: 'event-b',
                                  start: '2014-11-04T05:00:00',
                                  end: '2014-11-04T09:00:00',
                                  overlap: false,
                              },
                          ];
                          testEventDrag(options, '2014-11-04T04:00:00', false, done, 'event-a');
                      });
                  });
                  describe('when subject event\'s end is implied', () => {
                      it('does not allow dragging', (done) => {
                          options.defaultTimedEventDuration = '03:00';
                          options.events = [
                              {
                                  title: 'Event A',
                                  className: 'event-a',
                                  start: '2014-11-04T01:00:00',
                              },
                              {
                                  title: 'Event B',
                                  className: 'event-b',
                                  start: '2014-11-04T05:00:00',
                                  end: '2014-11-04T09:00:00',
                                  overlap: false,
                              },
                          ];
                          testEventDrag(options, '2014-11-04T03:00:00', false, done, 'event-a');
                      });
                  });
              });
              describe('when UTC timezone', () => {
                  it('does not allow dragging', (done) => {
                      options.timeZone = 'UTC';
                      options.events = [
                          {
                              title: 'Event A',
                              className: 'event-a',
                              start: '2014-11-04T01:00:00+00:00',
                              end: '2014-11-04T03:00:00+00:00',
                          },
                          {
                              title: 'Event B',
                              className: 'event-b',
                              start: '2014-11-04T05:00:00+00:00',
                              end: '2014-11-04T09:00:00+00:00',
                              overlap: false,
                          },
                      ];
                      testEventDrag(options, '2014-11-04T04:00:00+00:00', false, done, 'event-a');
                  });
              });
          });
          describe('when dragged intersecting the other event\'s end', () => {
              describe('when in week view with timed events', () => {
                  describe('when no timezone', () => {
                      it('does not allow dragging', (done) => {
                          options.events = [
                              {
                                  title: 'Event A',
                                  className: 'event-a',
                                  start: '2014-11-04T01:00:00',
                                  end: '2014-11-04T03:00:00',
                              },
                              {
                                  title: 'Event B',
                                  className: 'event-b',
                                  start: '2014-11-04T05:00:00',
                                  end: '2014-11-04T09:00:00',
                                  overlap: false,
                              },
                          ];
                          testEventDrag(options, '2014-11-04T08:00:00', false, done, 'event-a');
                      });
                  });
                  describe('when UTC timezone', () => {
                      it('does not allow dragging', (done) => {
                          options.timeZone = 'UTC';
                          options.events = [
                              {
                                  title: 'Event A',
                                  className: 'event-a',
                                  start: '2014-11-04T01:00:00+00:00',
                                  end: '2014-11-04T03:00:00+00:00',
                              },
                              {
                                  title: 'Event B',
                                  className: 'event-b',
                                  start: '2014-11-04T05:00:00+00:00',
                                  end: '2014-11-04T09:00:00+00:00',
                                  overlap: false,
                              },
                          ];
                          testEventDrag(options, '2014-11-04T08:00:00+00:00', false, done, 'event-a');
                      });
                  });
              });
              describe('when in month view', () => {
                  beforeEach(() => {
                      options.initialView = 'dayGridMonth';
                  });
                  describe('with all-day subject and all-day other', () => {
                      it('does not allow dragging', (done) => {
                          options.events = [
                              {
                                  title: 'Event A',
                                  className: 'event-a',
                                  start: '2014-11-04',
                                  end: '2014-11-05',
                              },
                              {
                                  title: 'Event B',
                                  className: 'event-b',
                                  start: '2014-11-07',
                                  end: '2014-11-09',
                                  overlap: false,
                              },
                          ];
                          testEventDrag(options, '2014-11-08', false, done, 'event-a');
                      });
                  });
                  describe('with all-day subject and timed other', () => {
                      it('does not allow dragging', (done) => {
                          options.events = [
                              {
                                  title: 'Event A',
                                  className: 'event-a',
                                  start: '2014-11-04',
                                  end: '2014-11-05',
                              },
                              {
                                  title: 'Event B',
                                  className: 'event-b',
                                  start: '2014-11-07T05:00:00',
                                  end: '2014-11-09T12:00:00',
                                  overlap: false,
                              },
                          ];
                          testEventDrag(options, '2014-11-08', false, done, 'event-a');
                      });
                  });
                  describe('with timed subject and all-day other', () => {
                      it('does not allow dragging', (done) => {
                          options.events = [
                              {
                                  title: 'Event A',
                                  className: 'event-a',
                                  start: '2014-11-04',
                              },
                              {
                                  title: 'Event B',
                                  className: 'event-b',
                                  start: '2014-11-07T05:00:00',
                                  overlap: false,
                              },
                          ];
                          testEventDrag(options, '2014-11-04', false, done, 'event-b');
                      });
                  });
              });
          });
          describe('when dragged to be encompassed by the other event', () => {
              it('does not allow dragging', (done) => {
                  options.events = [
                      {
                          title: 'Event A',
                          className: 'event-a',
                          start: '2014-11-04T01:00:00',
                          end: '2014-11-04T03:00:00',
                      },
                      {
                          title: 'Event B',
                          className: 'event-b',
                          start: '2014-11-04T05:00:00',
                          end: '2014-11-04T09:00:00',
                          overlap: false,
                      },
                  ];
                  testEventDrag(options, '2014-11-04T06:00:00', false, done, 'event-a');
              });
              describe('when both events have the same group ID', () => {
                  it('allows the drag', (done) => {
                      options.events = [
                          {
                              groupId: 'myid',
                              title: 'Event A',
                              className: 'event-a',
                              start: '2014-11-04T01:00:00',
                              end: '2014-11-04T03:00:00',
                          },
                          {
                              groupId: 'myid',
                              title: 'Event B',
                              className: 'event-b',
                              start: '2014-11-04T05:00:00',
                              end: '2014-11-04T09:00:00',
                              overlap: false,
                          },
                      ];
                      testEventDrag(options, '2014-11-04T06:00:00', true, done, 'event-a');
                  });
              });
          });
          describe('when resized to be adjacently before the other event', () => {
              it('allows resizing', (done) => {
                  options.events = [
                      {
                          title: 'Event A',
                          className: 'event-a',
                          start: '2014-11-04T01:00:00',
                          end: '2014-11-04T03:00:00',
                      },
                      {
                          title: 'Event B',
                          className: 'event-b',
                          start: '2014-11-04T05:00:00',
                          end: '2014-11-04T09:00:00',
                          overlap: false,
                      },
                  ];
                  testEventResize(options, '2014-11-04T05:00:00', true, done, 'event-a');
              });
          });
          describe('when resized to intersect the other event\'s start', () => {
              it('does not allow resizing', (done) => {
                  options.events = [
                      {
                          title: 'Event A',
                          className: 'event-a',
                          start: '2014-11-04T01:00:00',
                          end: '2014-11-04T03:00:00',
                      },
                      {
                          title: 'Event B',
                          className: 'event-b',
                          start: '2014-11-04T05:00:00',
                          end: '2014-11-04T09:00:00',
                          overlap: false,
                      },
                  ];
                  testEventResize(options, '2014-11-04T06:00:00', false, done, 'event-a');
              });
          });
      });
      describe('when both events\' overlap is true AND they intersect', () => {
          it('allows dragging', (done) => {
              options.events = [
                  {
                      title: 'Event A',
                      className: 'event-a',
                      start: '2014-11-04T01:00:00',
                      end: '2014-11-04T03:00:00',
                      overlap: true,
                  },
                  {
                      title: 'Event B',
                      className: 'event-b',
                      start: '2014-11-04T05:00:00',
                      end: '2014-11-04T09:00:00',
                      overlap: true,
                  },
              ];
              testEventDrag(options, '2014-11-04T04:00:00', true, done, 'event-a');
          });
      });
      describe('when other eventSource overlap is false', () => {
          describe('when dragged over the other event', () => {
              it('does not allow dragging', (done) => {
                  options.eventSources = [
                      {
                          events: [{
                                  title: 'Event A',
                                  className: 'event-a',
                                  start: '2014-11-04T01:00:00',
                                  end: '2014-11-04T03:00:00',
                              }],
                      },
                      {
                          overlap: false,
                          events: [{
                                  title: 'Event B',
                                  className: 'event-b',
                                  start: '2014-11-04T05:00:00',
                                  end: '2014-11-04T09:00:00',
                              }],
                      },
                  ];
                  testEventDrag(options, '2014-11-04T06:00:00', false, done, 'event-a');
              });
          });
      });
      describe('when subject event is false', () => {
          describe('when dragged adjacently after the other event', () => {
              it('allows dragging', (done) => {
                  options.events = [
                      {
                          title: 'Event A',
                          className: 'event-a',
                          start: '2014-11-04T01:00:00',
                          end: '2014-11-04T03:00:00',
                          overlap: false,
                      },
                      {
                          title: 'Event B',
                          className: 'event-b',
                          start: '2014-11-04T05:00:00',
                          end: '2014-11-04T09:00:00',
                      },
                  ];
                  testEventDrag(options, '2014-11-04T09:00:00', true, done, 'event-a');
              });
          });
          describe('when dragged intersecting the other event\'s end', () => {
              it('does not allow dragging', (done) => {
                  options.events = [
                      {
                          title: 'Event A',
                          className: 'event-a',
                          start: '2014-11-04T01:00:00',
                          end: '2014-11-04T03:00:00',
                          overlap: false,
                      },
                      {
                          title: 'Event B',
                          className: 'event-b',
                          start: '2014-11-04T05:00:00',
                          end: '2014-11-04T09:00:00',
                      },
                  ];
                  testEventDrag(options, '2014-11-04T04:00:00', false, done, 'event-a');
              });
          });
      });
      describe('when subject eventSource is false', () => {
          describe('when dragged after the other event', () => {
              it('allows dragging', (done) => {
                  options.eventSources = [
                      {
                          overlap: false,
                          events: [{
                                  title: 'Event A',
                                  className: 'event-a',
                                  start: '2014-11-04T01:00:00',
                                  end: '2014-11-04T03:00:00',
                              }],
                      },
                      {
                          events: [{
                                  title: 'Event B',
                                  className: 'event-b',
                                  start: '2014-11-04T05:00:00',
                                  end: '2014-11-04T09:00:00',
                              }],
                      },
                  ];
                  testEventDrag(options, '2014-11-04T09:00:00', true, done, 'event-a');
              });
          });
          describe('when dragged over the other event', () => {
              it('does not allow dragging', (done) => {
                  options.eventSources = [
                      {
                          overlap: false,
                          events: [{
                                  title: 'Event A',
                                  className: 'event-a',
                                  start: '2014-11-04T01:00:00',
                                  end: '2014-11-04T03:00:00',
                              }],
                      },
                      {
                          events: [{
                                  title: 'Event B',
                                  className: 'event-b',
                                  start: '2014-11-04T05:00:00',
                                  end: '2014-11-04T09:00:00',
                              }],
                      },
                  ];
                  testEventDrag(options, '2014-11-04T06:00:00', false, done, 'event-a');
              });
          });
      });
      describe('when eventOverlap is false', () => {
          describe('when dragged adjacently after another event', () => {
              it('allows dragging', (done) => {
                  options.eventOverlap = false;
                  options.events = [
                      {
                          title: 'Event A',
                          className: 'event-a',
                          start: '2014-11-04T01:00:00',
                          end: '2014-11-04T03:00:00',
                      },
                      {
                          title: 'Event B',
                          className: 'event-b',
                          start: '2014-11-04T05:00:00',
                          end: '2014-11-04T09:00:00',
                      },
                  ];
                  testEventDrag(options, '2014-11-04T09:00:00', true, done, 'event-a');
              });
          });
          describe('when dragged intersecting another event', () => {
              it('does not allow dragging', (done) => {
                  options.eventOverlap = false;
                  options.events = [
                      {
                          title: 'Event A',
                          className: 'event-a',
                          start: '2014-11-04T01:00:00',
                          end: '2014-11-04T03:00:00',
                      },
                      {
                          title: 'Event B',
                          className: 'event-b',
                          start: '2014-11-04T05:00:00',
                          end: '2014-11-04T09:00:00',
                      },
                  ];
                  testEventDrag(options, '2014-11-04T06:00:00', false, done, 'event-a');
              });
          });
      });
      describe('when eventOverlap is a function', () => {
          describe('when no intersecting events upon drag', () => {
              it('does not get called, allows dragging', (done) => {
                  options.eventOverlap = () => { };
                  options.events = [
                      {
                          title: 'Event A',
                          className: 'event-a',
                          start: '2014-11-04T01:00:00',
                          end: '2014-11-04T03:00:00',
                      },
                      {
                          title: 'Event B',
                          className: 'event-b',
                          start: '2014-11-04T03:00:00',
                          end: '2014-11-04T07:00:00',
                      },
                  ];
                  spyOn(options, 'eventOverlap').and.callThrough();
                  testEventDrag(options, '2014-11-04T06:00:00', true, () => {
                      expect(options.eventOverlap).not.toHaveBeenCalled();
                      done();
                  }, 'event-b');
              });
          });
          describe('when an intersection and returning true', () => {
              it('allows dragging AND gets called', (done) => {
                  options.eventOverlap = (stillEvent, movingEvent) => {
                      // checks arguments here
                      expect(stillEvent.title).toBe('Event B');
                      expect(movingEvent.title).toBe('Event A');
                      return true;
                  };
                  options.events = [
                      {
                          title: 'Event A',
                          className: 'event-a',
                          start: '2014-11-04T01:00:00',
                          end: '2014-11-04T03:00:00',
                      },
                      {
                          title: 'Event B',
                          className: 'event-b',
                          start: '2014-11-04T05:00:00',
                          end: '2014-11-04T09:00:00',
                      },
                  ];
                  spyOn(options, 'eventOverlap').and.callThrough();
                  testEventDrag(options, '2014-11-04T06:00:00', true, () => {
                      expect(options.eventOverlap).toHaveBeenCalled();
                      done();
                  }, 'event-a');
              });
          });
          describe('when an intersection and returning false', () => {
              it('disallows dragging AND gets called', (done) => {
                  options.eventOverlap = () => false;
                  options.events = [
                      {
                          title: 'Event A',
                          className: 'event-a',
                          start: '2014-11-04T01:00:00',
                          end: '2014-11-04T03:00:00',
                      },
                      {
                          title: 'Event B',
                          className: 'event-b',
                          start: '2014-11-04T05:00:00',
                          end: '2014-11-04T09:00:00',
                      },
                  ];
                  spyOn(options, 'eventOverlap').and.callThrough();
                  testEventDrag(options, '2014-11-04T06:00:00', false, () => {
                      expect(options.eventOverlap).toHaveBeenCalled();
                      done();
                  }, 'event-a');
              });
          });
      });
  });
  describe('selectOverlap', () => {
      let options;
      beforeEach(() => {
          options = {
              initialDate: '2014-11-12',
              initialView: 'timeGridWeek',
              scrollTime: '00:00',
          };
      });
      describe('as false', () => {
          beforeEach(() => {
              options.selectOverlap = false;
          });
          describe('when dragged adjacently before an event', () => {
              it('allows selection', (done) => {
                  options.events = [{
                          title: 'Event A',
                          start: '2014-11-12T04:00:00',
                          end: '2014-11-12T06:00:00',
                      }];
                  testSelection(options, '2014-11-12T01:00:00Z', '2014-11-12T04:00:00Z', true, done);
              });
          });
          describe('when dragged adjacently after an event', () => {
              it('allows selection', (done) => {
                  options.events = [{
                          title: 'Event A',
                          start: '2014-11-12T04:00:00',
                          end: '2014-11-12T06:00:00',
                      }];
                  testSelection(options, '2014-11-12T06:00:00Z', '2014-11-12T12:00:00Z', true, done);
              });
          });
          describe('when dragged intersecting an event\'s start', () => {
              describe('when UTC timezone', () => {
                  it('does not allow selection', (done) => {
                      options.timeZone = 'UTC';
                      options.events = [{
                              title: 'Event A',
                              start: '2014-11-12T04:00:00+00:00',
                              end: '2014-11-12T06:00:00+00:00',
                          }];
                      testSelection(options, '2014-11-12T01:00:00Z', '2014-11-12T05:00:00Z', false, done);
                  });
              });
              describe('when local timezone', () => {
                  it('does not allow selection', (done) => {
                      options.timeZone = 'local';
                      options.events = [{
                              title: 'Event A',
                              start: '2014-11-12T04:00:00',
                              end: '2014-11-12T06:00:00',
                          }];
                      testSelection(options, '2014-11-12T01:00:00', '2014-11-12T05:00:00', false, done);
                  });
              });
          });
          describe('when dragged intersecting an event\'s end', () => {
              describe('when in week view with timed events', () => {
                  describe('when no timezone', () => {
                      it('does not allow selection', (done) => {
                          options.events = [{
                                  title: 'Event A',
                                  start: '2014-11-12T04:00:00',
                                  end: '2014-11-12T06:00:00',
                              }];
                          testSelection(options, '2014-11-12T05:00:00Z', '2014-11-12T08:00:00Z', false, done);
                      });
                  });
                  describe('when UTC timezone', () => {
                      it('does not allow selection', (done) => {
                          options.timeZone = 'UTC';
                          options.events = [{
                                  title: 'Event A',
                                  start: '2014-11-12T04:00:00+00:00',
                                  end: '2014-11-12T06:00:00+00:00',
                              }];
                          testSelection(options, '2014-11-12T05:00:00Z', '2014-11-12T08:00:00Z', false, done);
                      });
                  });
                  describe('when local timezone', () => {
                      it('does not allow selection', (done) => {
                          options.timeZone = 'local';
                          options.events = [{
                                  title: 'Event A',
                                  start: '2014-11-12T04:00:00',
                                  end: '2014-11-12T06:00:00',
                              }];
                          testSelection(options, '2014-11-12T05:00:00', '2014-11-12T08:00:00', false, done);
                      });
                  });
              });
              describe('when in month view', () => {
                  beforeEach(() => {
                      options.initialView = 'dayGridMonth';
                  });
                  describe('with all-day event', () => {
                      it('does not allow selection', (done) => {
                          options.events = [{
                                  title: 'Event A',
                                  start: '2014-11-12',
                                  end: '2014-11-14',
                              }];
                          testSelection(options, '2014-11-12', '2014-11-13', false, done);
                      });
                  });
                  describe('with timed event', () => {
                      it('does not allow selection', (done) => {
                          options.events = [{
                                  title: 'Event A',
                                  start: '2014-11-12T05:00:00',
                                  end: '2014-11-14T20:00:00',
                              }];
                          testSelection(options, '2014-11-12', '2014-11-13', false, done);
                      });
                  });
              });
          });
          describe('when dragged to be encompassed by an event', () => {
              it('does not allow selection', (done) => {
                  options.events = [{
                          title: 'Event A',
                          start: '2014-11-12T04:00:00',
                          end: '2014-11-12T10:00:00',
                      }];
                  testSelection(options, '2014-11-12T05:00:00Z', '2014-11-12T08:00:00Z', false, done);
              });
          });
      });
      describe('as a function', () => {
          describe('when no intersecting events when selecting', () => {
              it('does not get called, allows selection', (done) => {
                  options.selectOverlap = () => { };
                  options.events = [{
                          title: 'Event A',
                          start: '2014-11-12T04:00:00',
                          end: '2014-11-12T06:00:00',
                      }];
                  spyOn(options, 'selectOverlap').and.callThrough();
                  testSelection(options, '2014-11-12T08:00:00Z', '2014-11-12T10:00:00Z', true, () => {
                      expect(options.selectOverlap).not.toHaveBeenCalled();
                      done();
                  });
              });
          });
          describe('when an intersection and returning true', () => {
              it('allows selection', (done) => {
                  options.selectOverlap = (arg0, arg1) => {
                      // checks arguments here
                      expect(arg0.title).toBe('Event A');
                      expect(arg1).toBeFalsy();
                      return true;
                  };
                  options.events = [{
                          title: 'Event A',
                          start: '2014-11-12T04:00:00',
                          end: '2014-11-12T06:00:00',
                      }];
                  spyOn(options, 'selectOverlap').and.callThrough();
                  testSelection(options, '2014-11-12T05:00:00Z', '2014-11-12T07:00:00Z', true, () => {
                      expect(options.selectOverlap).toHaveBeenCalled();
                      done();
                  });
              });
          });
          describe('when an intersection and returning false', () => {
              it('does not allow selection', (done) => {
                  options.selectOverlap = () => false;
                  options.events = [{
                          title: 'Event A',
                          start: '2014-11-12T04:00:00',
                          end: '2014-11-12T06:00:00',
                      }];
                  spyOn(options, 'selectOverlap').and.callThrough();
                  testSelection(options, '2014-11-12T05:00:00Z', '2014-11-12T07:00:00Z', false, () => {
                      expect(options.selectOverlap).toHaveBeenCalled();
                      done();
                  });
              });
          });
      });
      describe('as true and an event object\'s overlap is false', () => {
          it('is not affected AND allows the selection', (done) => {
              options.selectOverlap = true;
              options.events = [{
                      title: 'Event A',
                      start: '2014-11-12T04:00:00',
                      end: '2014-11-12T06:00:00',
                      overlap: false,
                  }];
              testSelection(options, '2014-11-12T05:00:00Z', '2014-11-12T07:00:00', true, done);
          });
      });
  });

  describe('weekViewRender', () => {
      const nowStr = '2018-05-28'; // is a Monday
      pushOptions({
          now: nowStr,
          initialView: 'timeGridWeek',
      });
      describe('verify th class for today', () => {
          it('should have today class only on "today"', () => {
              let calendar = initCalendar();
              let headerWrapper = new TimeGridViewWrapper(calendar).header;
              let cellInfo = headerWrapper.getCellInfo();
              expect(cellInfo[1].date).toEqualDate(nowStr);
              expect(cellInfo[1].isToday).toBe(true);
          });
      });
  });

  describe('buttonIcons', () => {
      pushOptions({
          plugins: [index$a, index$2],
          headerToolbar: {
              left: 'prev,next today',
              center: 'title',
              right: 'prevYear, nextYear',
          },
      });
      describe('when buttonIcons is not set', () => {
          it('should have default values', () => {
              let calendar = initCalendar();
              let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
              let prevBtn = toolbarWrapper.getButtonInfo('prev');
              let nextBtn = toolbarWrapper.getButtonInfo('next');
              let nextYearBtn = toolbarWrapper.getButtonInfo('nextYear');
              let prevYearBtn = toolbarWrapper.getButtonInfo('prevYear');
              expect(prevBtn.iconName).toBe('chevron-left');
              expect(nextBtn.iconName).toBe('chevron-right');
              expect(nextYearBtn.iconName).toBe('chevrons-right');
              expect(prevYearBtn.iconName).toBe('chevrons-left');
          });
      });
      describe('when buttonIcons is set and theme is falsy', () => {
          pushOptions({
              buttonIcons: {
                  prev: 'some-icon-left',
                  next: 'some-icon-right',
                  prevYear: 'some-icon-leftYear',
                  nextYear: 'some-icon-rightYear',
              },
          });
          it('should have the set values', () => {
              let calendar = initCalendar();
              let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
              let prevBtn = toolbarWrapper.getButtonInfo('prev');
              let nextYearBtn = toolbarWrapper.getButtonInfo('nextYear');
              let prevYearBtn = toolbarWrapper.getButtonInfo('prevYear');
              expect(prevBtn.iconName).toBe('some-icon-left');
              expect(prevBtn.iconName).toBe('some-icon-left');
              expect(prevYearBtn.iconName).toBe('some-icon-leftYear');
              expect(nextYearBtn.iconName).toBe('some-icon-rightYear');
          });
      });
      describe('when theme is set', () => {
          pushOptions({
              themeSystem: 'bootstrap',
          });
          it('buttonIcons is ignored', () => {
              let calendar = initCalendar();
              let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
              let prevButtonInfo = toolbarWrapper.getButtonInfo('prev'); // NOT called with 'fa'
              expect(prevButtonInfo.iconName).toBeFalsy();
          });
      });
  });

  describe('selectMirror', () => {
      pushOptions({
          initialDate: '2014-08-03',
          initialView: 'timeGridWeek',
          scrollTime: '00:00:00',
          selectMirror: true,
      });
      it('goes through eventDidMount', () => {
          let options = {
              eventDidMount(arg) {
                  expect(arg.isMirror).toBe(true);
              },
          };
          spyOn(options, 'eventDidMount').and.callThrough();
          let calendar = initCalendar(options);
          calendar.select('2014-08-04T01:00:00Z', '2014-08-04T04:00:00Z');
          let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
          let mirrorEls = timeGridWrapper.getMirrorEls();
          expect(mirrorEls.length).toBe(1);
          expect(options.eventDidMount).toHaveBeenCalled();
      });
  });

  describe('event coloring', () => {
      pushOptions({
          initialDate: '2014-11-04',
          allDaySlot: false,
      });
      describe('when in month view', () => {
          pushOptions({
              initialView: 'dayGridMonth',
          });
          defineViewTests(false);
      });
      describe('when in week view', () => {
          pushOptions({
              initialView: 'timeGridWeek',
          });
          defineViewTests(true);
      });
      function defineViewTests(eventHasTime) {
          describe('for foreground events', () => {
              testTextColor(eventHasTime);
              testBorderColor(eventHasTime);
              testBackgroundColor(eventHasTime);
          });
          describe('for background events', () => {
              testBackgroundColor(eventHasTime, 'background');
          });
      }
      function testTextColor(eventHasTime) {
          let eventOptions = getEventOptions(eventHasTime);
          it('should accept the global eventTextColor', () => {
              initCalendar({
                  eventTextColor: 'red',
                  events: [getTestEvent(eventOptions)],
              });
              expect(getEventCss('color')).toMatch(RED_REGEX);
          });
          it('should accept an event source\'s textColor', () => {
              initCalendar({
                  eventTextColor: 'blue',
                  eventSources: [{
                          textColor: 'red',
                          events: [getTestEvent(eventOptions)],
                      }],
              });
              expect(getEventCss('color')).toMatch(RED_REGEX);
          });
          it('should accept an event object\'s textColor', () => {
              let eventInput = getTestEvent(eventOptions, {
                  textColor: 'red',
              });
              initCalendar({
                  eventTextColor: 'blue',
                  events: [eventInput],
              });
              expect(getEventCss('color')).toMatch(RED_REGEX);
          });
      }
      function testBorderColor(eventHasTime) {
          let eventOptions = getEventOptions(eventHasTime);
          it('should accept the global eventColor for border color', () => {
              initCalendar({
                  eventColor: 'red',
                  events: [getTestEvent(eventOptions)],
              });
              expect(getEventCss('border-top-color')).toMatch(RED_REGEX);
          });
          it('should accept the global eventBorderColor', () => {
              initCalendar({
                  eventColor: 'blue',
                  eventBorderColor: 'red',
                  events: [getTestEvent(eventOptions)],
              });
              expect(getEventCss('border-top-color')).toMatch(RED_REGEX);
          });
          it('should accept an event source\'s color for the border', () => {
              initCalendar({
                  eventBorderColor: 'blue',
                  eventSources: [{
                          color: 'red',
                          events: [getTestEvent(eventOptions)],
                      }],
              });
              expect(getEventCss('border-top-color')).toMatch(RED_REGEX);
          });
          it('should accept an event source\'s borderColor', () => {
              initCalendar({
                  eventBorderColor: 'blue',
                  eventSources: [{
                          color: 'blue',
                          borderColor: 'red',
                          events: [getTestEvent(eventOptions)],
                      }],
              });
              expect(getEventCss('border-top-color')).toMatch(RED_REGEX);
          });
          it('should accept an event object\'s color for the border', () => {
              let eventInput = getTestEvent(eventOptions, {
                  color: 'red',
              });
              initCalendar({
                  eventSources: [{
                          borderColor: 'blue',
                          events: [eventInput],
                      }],
              });
              expect(getEventCss('border-top-color')).toMatch(RED_REGEX);
          });
          it('should accept an event object\'s borderColor', () => {
              let eventInput = getTestEvent(eventOptions, {
                  color: 'blue',
                  borderColor: 'red',
              });
              initCalendar({
                  eventSources: [{
                          events: [eventInput],
                      }],
              });
              expect(getEventCss('border-top-color')).toMatch(RED_REGEX);
          });
      }
      function testBackgroundColor(eventHasTime, display) {
          let eventOptions = getEventOptions(eventHasTime);
          if (typeof display !== 'undefined') {
              eventOptions.display = display;
          }
          it('should accept the global eventColor for background color', () => {
              initCalendar({
                  eventColor: 'red',
                  events: [getTestEvent(eventOptions)],
              });
              expect(getEventCss('background-color', display)).toMatch(RED_REGEX);
          });
          it('should accept the global eventBackgroundColor', () => {
              initCalendar({
                  eventColor: 'blue',
                  eventBackgroundColor: 'red',
                  events: [getTestEvent(eventOptions)],
              });
              expect(getEventCss('background-color', display)).toMatch(RED_REGEX);
          });
          it('should accept an event source\'s color for the background', () => {
              initCalendar({
                  eventBackgroundColor: 'blue',
                  eventSources: [{
                          color: 'red',
                          events: [getTestEvent(eventOptions)],
                      }],
              });
              expect(getEventCss('background-color', display)).toMatch(RED_REGEX);
          });
          it('should accept an event source\'s backgroundColor', () => {
              initCalendar({
                  eventSources: [{
                          color: 'blue',
                          backgroundColor: 'red',
                          events: [getTestEvent(eventOptions)],
                      }],
              });
              expect(getEventCss('background-color', display)).toMatch(RED_REGEX);
          });
          it('should accept an event object\'s color for the background', () => {
              let eventInput = getTestEvent(eventOptions);
              eventInput.color = 'red';
              initCalendar({
                  eventSources: [{
                          backgroundColor: 'blue',
                          events: [eventInput],
                      }],
              });
              expect(getEventCss('background-color', display)).toMatch(RED_REGEX);
          });
          it('should accept an event object\'s backgroundColor', () => {
              let eventInput = getTestEvent(eventOptions);
              eventInput.color = 'blue'; // even when there's a more general setting
              eventInput.backgroundColor = 'red';
              initCalendar({
                  eventSources: [{
                          events: [eventInput],
                      }],
              });
              expect(getEventCss('background-color', display)).toMatch(RED_REGEX);
          });
      }
      function getEventCss(prop, display) {
          let calendarWrapper = new CalendarWrapper(currentCalendar);
          let eventEl = display === 'background'
              ? calendarWrapper.getBgEventEls()[0]
              : calendarWrapper.getEventEls()[0];
          if (prop === 'color') {
              return $(eventEl).find('.fc-event-title').css(prop);
          }
          return $(eventEl).css(prop);
      }
      function getTestEvent(defaultOptions, extraOptions = {}) {
          let event = {};
          $.extend(event, defaultOptions);
          if (extraOptions) {
              $.extend(event, extraOptions);
          }
          return event;
      }
      function getEventOptions(eventHasTime) {
          let options = {
              start: '2014-11-04',
          };
          if (eventHasTime) {
              options.start += 'T01:00:00';
          }
          return options;
      }
  });

  describe('eventAllow', () => {
      pushOptions({
          now: '2016-09-04',
          initialView: 'timeGridWeek',
          scrollTime: '00:00',
          editable: true,
          events: [
              {
                  title: 'event 1',
                  start: '2016-09-04T01:00',
              },
          ],
      });
      it('disallows dragging when returning false', (done) => {
          let options = {
              eventAllow(dropInfo, event) {
                  expect(typeof dropInfo).toBe('object');
                  expect(dropInfo.start instanceof Date).toBe(true);
                  expect(dropInfo.end instanceof Date).toBe(true);
                  expect(typeof event).toBe('object');
                  expect(event.title).toBe('event 1');
                  return false;
              },
          };
          spyOn(options, 'eventAllow').and.callThrough();
          let calendar = initCalendar(options);
          let calendarWrapper = new CalendarWrapper(calendar);
          let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
          let dragging = timeGridWrapper.dragEventToDate(calendarWrapper.getFirstEventEl(), '2016-09-04T03:00:00');
          waitEventDrag(calendar, dragging).then((modifiedEvent) => {
              expect(modifiedEvent).toBeFalsy(); // drop failure?
              expect(options.eventAllow).toHaveBeenCalled();
              done();
          });
      });
      it('allows dragging when returning true', (done) => {
          let options = {
              eventAllow() {
                  return true;
              },
          };
          spyOn(options, 'eventAllow').and.callThrough();
          let calendar = initCalendar(options);
          let calendarWrapper = new CalendarWrapper(calendar);
          let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
          let dragging = timeGridWrapper.dragEventToDate(calendarWrapper.getFirstEventEl(), '2016-09-04T03:00:00Z');
          waitEventDrag(calendar, dragging).then((modifiedEvent) => {
              expect(modifiedEvent.start).toEqualDate('2016-09-04T03:00:00Z');
              expect(options.eventAllow).toHaveBeenCalled();
              done();
          });
      });
  });

  describe('custom view class', () => {
      it('calls all standard methods with correct parameters', () => {
          const CustomViewConfig = {
              classNames: 'awesome-view',
              didMount() { },
              willUnmount() { },
              content(props) {
                  expect(props.dateProfile.activeRange.start instanceof Date).toBe(true);
                  expect(props.dateProfile.activeRange.end instanceof Date).toBe(true);
                  let eventRanges = sliceEvents(props, true); // allDay=true
                  expect(Array.isArray(eventRanges)).toBe(true);
                  expect(eventRanges.length).toBe(1);
                  expect(typeof eventRanges[0].def).toBe('object');
                  expect(typeof eventRanges[0].ui).toBe('object');
                  expect(typeof eventRanges[0].instance).toBe('object');
                  expect(eventRanges[0].isStart).toBe(true);
                  expect(eventRanges[0].isEnd).toBe(true);
                  expect(eventRanges[0].range.start instanceof Date).toBe(true);
                  expect(eventRanges[0].range.end instanceof Date).toBe(true);
                  let dateSelection = props.dateSelection;
                  if (!dateSelection) {
                      expect(dateSelection).toBe(null);
                  }
                  else {
                      expect(typeof dateSelection).toBe('object');
                      expect(dateSelection.allDay).toBe(true);
                      expect(dateSelection.range.start instanceof Date).toBe(true);
                      expect(dateSelection.range.end instanceof Date).toBe(true);
                  }
                  return { html: '<div class="hello-world">hello world</div>' };
              },
          };
          spyOn(CustomViewConfig, 'didMount').and.callThrough();
          spyOn(CustomViewConfig, 'content').and.callThrough();
          spyOn(CustomViewConfig, 'willUnmount').and.callThrough();
          function resetCounts() {
              CustomViewConfig.didMount.calls.reset();
              CustomViewConfig.content.calls.reset();
              CustomViewConfig.willUnmount.calls.reset();
          }
          let calendar = initCalendar({
              plugins: [
                  createPlugin({
                      name: 'test-plugin',
                      views: {
                          custom: CustomViewConfig,
                      },
                  }),
              ],
              initialView: 'custom',
              initialDate: '2014-12-25',
              events: [
                  {
                      title: 'Holidays',
                      start: '2014-12-25T09:00:00',
                      end: '2014-12-25T11:00:00',
                  },
              ],
          });
          let calendarWrapper = new CalendarWrapper(calendar);
          let viewEl = calendarWrapper.getViewEl();
          expect(viewEl).toHaveClass('awesome-view');
          expect($(viewEl).find('.hello-world').length).toBe(1);
          expect(CustomViewConfig.didMount.calls.count()).toBe(1);
          expect(CustomViewConfig.content.calls.count()).toBe(1);
          expect(CustomViewConfig.willUnmount.calls.count()).toBe(0);
          resetCounts();
          calendar.select('2014-12-25', '2014-01-01');
          expect(CustomViewConfig.didMount.calls.count()).toBe(0);
          expect(CustomViewConfig.content.calls.count()).toBe(1);
          expect(CustomViewConfig.willUnmount.calls.count()).toBe(0);
          resetCounts();
          calendar.unselect();
          expect(CustomViewConfig.didMount.calls.count()).toBe(0);
          expect(CustomViewConfig.content.calls.count()).toBe(1);
          expect(CustomViewConfig.willUnmount.calls.count()).toBe(0);
          resetCounts();
          calendar.destroy();
          expect(CustomViewConfig.didMount.calls.count()).toBe(0);
          expect(CustomViewConfig.content.calls.count()).toBe(0);
          expect(CustomViewConfig.willUnmount.calls.count()).toBe(1);
      });
  });

  describe('nextDayThreshold', () => {
      // when a view object exposes its nextDayThreshold value (after some refactoring)...
      //   TODO: detect the default of 9am
      //   TODO: detect 2 or more different types of Duration-ish parsing
      it('renders an event before the threshold', () => {
          let calendar = initCalendar({
              nextDayThreshold: '10:00:00',
              initialDate: '2014-06',
              initialView: 'dayGridMonth',
              events: [
                  {
                      title: 'event1',
                      start: '2014-06-08T22:00:00',
                      end: '2014-06-10T09:00:00',
                  },
              ],
          });
          expect(renderedDayCount(calendar)).toBe(2);
      });
      it('renders an event equal to the threshold', () => {
          let calendar = initCalendar({
              nextDayThreshold: '10:00:00',
              initialDate: '2014-06',
              initialView: 'dayGridMonth',
              events: [
                  {
                      title: 'event1',
                      start: '2014-06-08T22:00:00',
                      end: '2014-06-10T10:00:00',
                  },
              ],
          });
          expect(renderedDayCount(calendar)).toBe(3);
      });
      it('renders an event after the threshold', () => {
          let calendar = initCalendar({
              nextDayThreshold: '10:00:00',
              initialDate: '2014-06',
              initialView: 'dayGridMonth',
              events: [
                  {
                      title: 'event1',
                      start: '2014-06-08T22:00:00',
                      end: '2014-06-10T11:00:00',
                  },
              ],
          });
          expect(renderedDayCount(calendar)).toBe(3);
      });
      it('won\'t render an event that ends before the first day\'s threshold', () => {
          let calendar = initCalendar({
              initialView: 'dayGridMonth',
              initialDate: '2017-10-01',
              nextDayThreshold: '09:00:00',
              events: [{
                      start: '2017-09-30T08:00:00',
                      end: '2017-10-01T08:00:00',
                  }],
          });
          let calendarWrapper = new CalendarWrapper(calendar);
          expect(calendarWrapper.getEventEls().length).toBe(0);
      });
      function renderedDayCount(calendar) {
          let headerWrapper = new DayGridViewWrapper(calendar).header;
          let dayEl = headerWrapper.getCellEl(0);
          let cellWidth = $(dayEl).outerWidth(); // works with dayGrid and timeGrid
          let totalWidth = 0;
          let eventEls = new CalendarWrapper(calendar).getEventEls();
          $(eventEls).each((i, eventEl) => {
              totalWidth += $(eventEl).outerWidth();
          });
          return Math.round(totalWidth / cellWidth);
      }
  });

  describe('firstDay', () => {
      describe('when using default settings', () => {
          it('should make Sunday the first day of the week', () => {
              let calendar = initCalendar();
              expectDowStartAt(calendar, 0);
          });
      });
      describe('when setting firstDay to 0', () => {
          pushOptions({
              firstDay: 0,
          });
          it('should make Sunday the first day of the week', () => {
              let calendar = initCalendar();
              expectDowStartAt(calendar, 0);
          });
      });
      describe('when setting firstDay to 1', () => {
          pushOptions({
              firstDay: 1,
          });
          it('should make Monday the first day of the week', () => {
              let calendar = initCalendar();
              expectDowStartAt(calendar, 1);
          });
      });
      describe('when setting weekNumberCalculation to ISO', () => {
          pushOptions({
              weekNumberCalculation: 'ISO',
          });
          it('should make Monday the first day of the week', () => {
              let calendar = initCalendar();
              expectDowStartAt(calendar, 1);
          });
      });
      describeOptions('direction', {
          'when LTR': 'ltr',
          'when RTL': 'rtl',
      }, () => {
          pushOptions({
              firstDay: 2,
          });
          it('should make Tuesday the first day of the week', () => {
              let calendar = initCalendar();
              expectDowStartAt(calendar, 2);
          });
      });
      describe('when setting firstDay to 2 and weekNumberCalculation to ISO', () => {
          pushOptions({
              firstDay: 2,
              weekNumberCalculation: 'ISO',
          });
          it('should make Tuesday the first day of the week', () => {
              let calendar = initCalendar();
              expectDowStartAt(calendar, 2);
          });
      });
      describe('when setting firstDay to 3', () => {
          pushOptions({
              firstDay: 3,
          });
          it('should make Wednesday the first day of the week', () => {
              let calendar = initCalendar();
              expectDowStartAt(calendar, 3);
          });
      });
      it('should have a different default value based on the locale', () => {
          let calendar = initCalendar({
              locale: l20,
          });
          // firstDay will be 1 (Monday) in Great Britain
          expectDowStartAt(calendar, 1);
      });
      const DOW_CLASSNAMES = CalendarWrapper.DOW_CLASSNAMES;
      function expectDowStartAt(calendar, dowNum) {
          let headerWrapper = new DayGridViewWrapper(calendar).header;
          let cellEls = headerWrapper.getCellEls();
          for (let i = 0; i < 7; i += 1) {
              expect(cellEls[i]).toHaveClass(DOW_CLASSNAMES[(i + dowNum) % 7]);
          }
      }
  });

  describe('more-link popover', () => {
      let testEvents = [
          { title: 'event1', start: '2014-07-28', end: '2014-07-30', className: 'event1' },
          { title: 'event2', start: '2014-07-29', end: '2014-07-31', className: 'event2' },
          { title: 'event3', start: '2014-07-29', className: 'event3' },
          { title: 'event4', start: '2014-07-29', className: 'event4' },
      ];
      pushOptions({
          initialView: 'dayGridMonth',
          initialDate: '2014-08-01',
          dayMaxEventRows: 3,
          events: testEvents,
          dragScroll: false,
          handleWindowResize: false, // because showing the popover causes scrollbars and fires resize
      });
      describeOptions('initialView', {
          'when in month view': 'dayGridMonth',
          'when in dayGridWeek view': 'dayGridWeek',
          'when in week view': 'timeGridWeek',
      }, (viewName) => {
          let ViewWrapper = viewName.match(/^dayGrid/) ? DayGridViewWrapper : TimeGridViewWrapper;
          it('aligns horizontally with left edge of cell if LTR', (done) => {
              let calendar = initCalendar({
                  direction: 'ltr',
              });
              setTimeout(() => {
                  let dayGridWrapper = new ViewWrapper(calendar).dayGrid;
                  dayGridWrapper.openMorePopover();
                  setTimeout(() => {
                      let cellLeft = dayGridWrapper.getDayEl('2014-07-29').getBoundingClientRect().left;
                      let popoverLeft = dayGridWrapper.getMorePopoverEl().getBoundingClientRect().left;
                      let diff = Math.abs(cellLeft - popoverLeft);
                      expect(diff).toBeLessThan(2);
                      done();
                  });
              });
          });
          it('aligns horizontally with left edge of cell if RTL', (done) => {
              let calendar = initCalendar({
                  direction: 'rtl',
              });
              setTimeout(() => {
                  let dayGridWrapper = new ViewWrapper(calendar).dayGrid;
                  dayGridWrapper.openMorePopover();
                  setTimeout(() => {
                      let cellRight = dayGridWrapper.getDayEl('2014-07-29').getBoundingClientRect().right;
                      let popoverRight = dayGridWrapper.getMorePopoverEl().getBoundingClientRect().right;
                      let diff = Math.abs(cellRight - popoverRight);
                      expect(diff).toBeLessThan(2);
                      done();
                  });
              });
          });
      });
      describe('when in month view', () => {
          pushOptions({
              initialView: 'dayGridMonth',
          });
          it('aligns with top of cell', (done) => {
              let calendar = initCalendar();
              setTimeout(() => {
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  dayGridWrapper.openMorePopover();
                  setTimeout(() => {
                      let cellTop = dayGridWrapper.getDayEl('2014-07-29').getBoundingClientRect().top;
                      let popoverTop = dayGridWrapper.getMorePopoverEl().getBoundingClientRect().top;
                      let diff = Math.abs(cellTop - popoverTop);
                      expect(diff).toBeLessThan(2);
                      done();
                  });
              });
          });
          it('works with background events', (done) => {
              let calendar = initCalendar({
                  events: testEvents.concat([
                      {
                          start: '2014-07-29',
                          display: 'background',
                      },
                  ]),
              });
              setTimeout(() => {
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  dayGridWrapper.openMorePopover();
                  setTimeout(() => {
                      expect(dayGridWrapper.getMorePopoverEventCnt()).toBeGreaterThan(1);
                      expect(dayGridWrapper.getMorePopoverBgEventCnt()).toBe(0);
                      done();
                  });
              });
          });
          it('works with events that have invalid end times', (done) => {
              let calendar = initCalendar({
                  events: [
                      { title: 'event1', start: '2014-07-29', end: '2014-07-29' },
                      { title: 'event2', start: '2014-07-29', end: '2014-07-28' },
                      { title: 'event3', start: '2014-07-29T00:00:00', end: '2014-07-29T00:00:00' },
                      { title: 'event4', start: '2014-07-29T00:00:00', end: '2014-07-28T23:00:00' },
                  ],
              });
              setTimeout(() => {
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  dayGridWrapper.openMorePopover();
                  setTimeout(() => {
                      expect(dayGridWrapper.getMorePopoverEventCnt()).toBe(4);
                      done();
                  });
              });
          });
          // issue 2385
          it('orders events correctly regardless of ID', (done) => {
              let calendar = initCalendar({
                  initialDate: '2012-03-22',
                  dayMaxEventRows: 3,
                  events: [
                      {
                          id: '39957',
                          title: 'event01',
                          start: '2012-03-22T11:00:00',
                          end: '2012-03-22T11:30:00',
                          allDay: false,
                      },
                      {
                          id: '40607',
                          title: 'event02',
                          start: '2012-03-22T16:15:00',
                          end: '2012-03-22T16:30:00',
                          allDay: false,
                      },
                      {
                          id: '40760',
                          title: 'event03',
                          start: '2012-03-22T16:00:00',
                          end: '2012-03-22T16:15:00',
                          allDay: false,
                      },
                      {
                          id: '41284',
                          title: 'event04',
                          start: '2012-03-22T19:00:00',
                          end: '2012-03-22T19:15:00',
                          allDay: false,
                      },
                      {
                          id: '41645',
                          title: 'event05',
                          start: '2012-03-22T11:30:00',
                          end: '2012-03-22T12:00:00',
                          allDay: false,
                      },
                      {
                          id: '41679',
                          title: 'event07',
                          start: '2012-03-22T12:00:00',
                          end: '2012-03-22T12:15:00',
                          allDay: false,
                      },
                      {
                          id: '42246',
                          title: 'event08',
                          start: '2012-03-22T16:45:00',
                          end: '2012-03-22T17:00:00',
                          allDay: false,
                      },
                  ],
              });
              setTimeout(() => {
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  dayGridWrapper.openMorePopover();
                  setTimeout(() => {
                      let titles = dayGridWrapper.getMorePopoverEventTitles();
                      expect(titles).toEqual([
                          'event01', 'event05', 'event07', 'event03', 'event02', 'event08', 'event04',
                      ]);
                      done();
                  });
              });
          });
          // https://github.com/fullcalendar/fullcalendar/issues/3856
          it('displays multi-day events only once', (done) => {
              let calendar = initCalendar({
                  initialDate: '2017-10-04',
                  events: [
                      {
                          title: 'Long event',
                          className: 'long-event',
                          start: '2017-10-03',
                          end: '2017-10-20',
                      },
                      {
                          title: 'Meeting',
                          className: 'meeting-event',
                          start: '2017-10-04T10:00:00',
                          end: '2017-10-04T12:00:00',
                      },
                      {
                          title: 'Lunch 1',
                          className: 'lunch1-event',
                          start: '2017-10-04T12:00:00',
                      },
                      {
                          title: 'Lunch 2',
                          className: 'lunch2-event',
                          start: '2017-10-04T14:00:00',
                      },
                  ],
              });
              let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
              dayGridWrapper.openMorePopover();
              setTimeout(() => {
                  let popoverEl = dayGridWrapper.getMorePopoverEl();
                  let eventEls = dayGridWrapper.getMorePopoverEventEls();
                  expect(eventEls.length).toBe(4);
                  let $longEventEl = $('.long-event', popoverEl);
                  let $meetingEventEl = $('.meeting-event', popoverEl);
                  let $lunch1EventEl = $('.lunch1-event', popoverEl);
                  let $lunch2EventEl = $('.lunch2-event', popoverEl);
                  expect($longEventEl).not.toHaveClass(CalendarWrapper.EVENT_IS_START_CLASSNAME);
                  expect($longEventEl).not.toHaveClass(CalendarWrapper.EVENT_IS_END_CLASSNAME);
                  [$meetingEventEl, $lunch1EventEl, $lunch2EventEl].forEach(($el) => {
                      expect($el).toHaveClass(CalendarWrapper.EVENT_IS_START_CLASSNAME);
                      expect($el).toHaveClass(CalendarWrapper.EVENT_IS_END_CLASSNAME);
                  });
                  done();
              });
          });
          // https://github.com/fullcalendar/fullcalendar/issues/4331
          it('displays events that were collapsed in previous days', (done) => {
              let calendar = initCalendar({
                  initialDate: '2018-10-01',
                  events: [
                      {
                          title: 'e1',
                          start: '2018-10-18',
                      },
                      {
                          title: 'e2',
                          start: '2018-10-18',
                      },
                      {
                          title: 'e3',
                          start: '2018-10-18T11:00:00',
                      },
                      {
                          title: 'e4',
                          start: '2018-10-18T12:00:00',
                          end: '2018-10-19T12:00:00',
                      },
                      {
                          title: 'e5',
                          start: '2018-10-19',
                          className: 'event-e5',
                      },
                  ],
              });
              let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
              dayGridWrapper.openMorePopover(1); // click the second +more link
              setTimeout(done);
          });
      });
      describeOptions('initialView', {
          'when in dayGridWeek view': 'dayGridWeek',
          'when in week view': 'timeGridWeek',
      }, (viewName) => {
          let ViewWrapper = viewName.match(/^dayGrid/) ? DayGridViewWrapper : TimeGridViewWrapper;
          it('aligns with top of header', (done) => {
              let calendar = initCalendar();
              let viewWrapper = new ViewWrapper(calendar);
              let dayGridWrapper = viewWrapper.dayGrid;
              dayGridWrapper.openMorePopover();
              setTimeout(() => {
                  let popoverTop = dayGridWrapper.getMorePopoverEl().getBoundingClientRect().top;
                  let headTop = viewWrapper.header.el.getBoundingClientRect().top;
                  let diff = Math.abs(popoverTop - headTop);
                  expect(diff).toBeLessThan(2);
                  done();
              });
          });
      });
      // TODO: somehow test how the popover does to the edge of any scroll container
      it('closes when user clicks the X', (done) => {
          let calendar = initCalendar();
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          dayGridWrapper.openMorePopover();
          setTimeout(() => {
              expect(dayGridWrapper.getMorePopoverEl()).toBeVisible();
              dayGridWrapper.closeMorePopover();
              setTimeout(() => {
                  expect(dayGridWrapper.getMorePopoverEl()).not.toBeVisible();
                  done();
              });
          });
      });
      // https://github.com/fullcalendar/fullcalendar/issues/4584
      it('doesn\'t fire a dateClick', (done) => {
          let dateClickCalled = false;
          spyOnCalendarCallback('dateClick', () => {
              dateClickCalled = true;
          });
          let calendar = initCalendar();
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          dayGridWrapper.openMorePopover();
          setTimeout(() => {
              $.simulateMouseClick(dayGridWrapper.getMorePopoverHeaderEl());
              setTimeout(() => {
                  expect(dateClickCalled).toBe(false);
                  done();
              }, 500);
          });
      });
      it('doesn\'t close when user clicks somewhere inside of the popover', (done) => {
          let calendar = initCalendar();
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          dayGridWrapper.openMorePopover();
          setTimeout(() => {
              let popoverEl = dayGridWrapper.getMorePopoverEl();
              let popoverHeaderEl = dayGridWrapper.getMorePopoverHeaderEl();
              expect(popoverEl).toBeVisible();
              expect(popoverHeaderEl).toBeInDOM();
              $(popoverHeaderEl).simulate('mousedown').simulate('click');
              setTimeout(() => {
                  expect(popoverEl).toBeVisible();
                  done();
              });
          });
      });
      it('closes when user clicks outside of the popover', (done) => {
          let calendar = initCalendar();
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          dayGridWrapper.openMorePopover();
          setTimeout(() => {
              let popoverEl = dayGridWrapper.getMorePopoverEl();
              expect(popoverEl).toBeVisible();
              $('body').simulate('mousedown').simulate('click');
              setTimeout(() => {
                  expect(popoverEl).not.toBeVisible();
                  done();
              });
          });
      });
      describe('when dragging events out', () => {
          pushOptions({
              editable: true,
          });
          describe('when dragging an all-day event to a different day', () => {
              it('should have the new day and remain all-day', (done) => {
                  let calendar = initCalendar({
                      eventDrop(arg) {
                          expect(arg.event.start).toEqualDate('2014-07-28');
                          expect(arg.event.allDay).toBe(true);
                          done();
                      },
                  });
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  dayGridWrapper.openMorePopover();
                  setTimeout(() => {
                      $('.event4', dayGridWrapper.getMorePopoverEl()).simulate('drag', {
                          end: dayGridWrapper.getDayEl('2014-07-28'),
                      });
                  }, 0);
              });
          });
          describe('when dragging a timed event to a whole day', () => {
              it('should move to new day but maintain its time', (done) => {
                  let calendar = initCalendar({
                      events: testEvents.concat([
                          {
                              title: 'event5',
                              start: '2014-07-29T13:00:00',
                              className: 'event5',
                          },
                      ]),
                      eventDrop(arg) {
                          expect(arg.event.start).toEqualDate('2014-07-28T13:00:00Z');
                          expect(arg.event.allDay).toBe(false);
                          done();
                      },
                  });
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  dayGridWrapper.openMorePopover();
                  setTimeout(() => {
                      $('.event5', dayGridWrapper.getMorePopoverEl()).simulate('drag', {
                          end: dayGridWrapper.getDayEl('2014-07-28T13:00:00'),
                      });
                  }, 0);
              });
          });
          describe('when dragging a whole day event to a timed slot', () => {
              it('should assume the new time, with a cleared end', (done) => {
                  let calendar = initCalendar({
                      initialView: 'timeGridWeek',
                      scrollTime: '00:00:00',
                      eventDrop(arg) {
                          expect(arg.event.start).toEqualDate('2014-07-30T03:00:00Z');
                          expect(arg.event.allDay).toBe(false);
                          done();
                      },
                  });
                  let viewWrapper = new TimeGridViewWrapper(calendar);
                  let dayGridWrapper = viewWrapper.dayGrid;
                  dayGridWrapper.openMorePopover();
                  setTimeout(() => {
                      $('.event4', dayGridWrapper.getMorePopoverEl()).simulate('drag', {
                          localPoint: { left: '0%', top: '50%' },
                          end: viewWrapper.timeGrid.getPoint('2014-07-30T03:00:00'),
                      });
                  }, 0);
              });
          });
          describe('when a single-day event isn\'t dragged out all the way', () => {
              it('shouldn\'t do anything', (done) => {
                  let dayGridWrapper;
                  let calendar = initCalendar({
                      eventDragStop() {
                          setTimeout(() => {
                              expect(dayGridWrapper.getMorePopoverEl()).toBeInDOM();
                              done();
                          }, 0);
                      },
                  });
                  let viewWrapper = new DayGridViewWrapper(calendar);
                  dayGridWrapper = viewWrapper.dayGrid;
                  dayGridWrapper.openMorePopover();
                  setTimeout(() => {
                      $('.event1', dayGridWrapper.getMorePopoverEl()).simulate('drag', {
                          localPoint: { left: '0%', top: '50%' },
                          dx: 20,
                      });
                  }, 0);
              });
          });
      });
      it('calls event render handlers', (done) => {
          let options = {
              events: [
                  { title: 'event1', start: '2014-07-28', end: '2014-07-30', className: 'event1' },
                  { title: 'event2', start: '2014-07-29', end: '2014-07-31', className: 'event2' },
                  { title: 'event3', start: '2014-07-29', className: 'event3' },
                  { title: 'event4', start: '2014-07-29', className: 'event4' },
              ],
              eventDidMount() { },
              eventContent() { },
              eventWillUnmount() { },
          };
          spyOn(options, 'eventDidMount');
          spyOn(options, 'eventContent');
          spyOn(options, 'eventWillUnmount');
          function resetCounts() {
              options.eventDidMount.calls.reset();
              options.eventContent.calls.reset();
              options.eventWillUnmount.calls.reset();
          }
          let calendar = initCalendar(options);
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          expect(options.eventDidMount.calls.count()).toBe(4);
          expect(options.eventContent.calls.count()).toBe(4);
          expect(options.eventWillUnmount.calls.count()).toBe(0);
          resetCounts();
          dayGridWrapper.openMorePopover();
          setTimeout(() => {
              expect(options.eventDidMount.calls.count()).toBe(4);
              expect(options.eventContent.calls.count()).toBe(4);
              expect(options.eventWillUnmount.calls.count()).toBe(0);
              resetCounts();
              dayGridWrapper.closeMorePopover();
              setTimeout(() => {
                  expect(options.eventDidMount.calls.count()).toBe(0);
                  expect(options.eventContent.calls.count()).toBe(0);
                  expect(options.eventWillUnmount.calls.count()).toBe(4);
                  done();
              });
          });
      });
      it('displays latest events after refetch', (done) => {
          let fetchCnt = 0;
          let newTitle = 'cool';
          let calendar = initCalendar({
              events(info, callback) {
                  fetchCnt += 1;
                  if (fetchCnt === 1) {
                      callback(testEvents);
                  }
                  else {
                      callback(testEvents.slice(0, -1).concat([
                          Object.assign(Object.assign({}, testEvents[testEvents.length - 1]), { title: newTitle }),
                      ]));
                  }
              },
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          dayGridWrapper.openMorePopover();
          setTimeout(() => {
              calendar.refetchEvents();
              let eventEls = dayGridWrapper.getMorePopoverEventEls();
              let eventInfo = DayGridWrapper.getEventElInfo(eventEls[2]);
              expect(eventInfo.title).toBe(newTitle);
              done();
          });
      });
  });

  describe('Agenda view rendering', () => {
      pushOptions({
          initialView: 'timeGridWeek',
      });
      describe('when LTR', () => {
          pushOptions({
              direction: 'ltr',
          });
          it('renders the axis on the left', () => {
              let calendar = initCalendar();
              let viewWrapper = new TimeGridViewWrapper(calendar);
              let headerWrapper = viewWrapper.header;
              let dayGridWrapper = viewWrapper.dayGrid;
              let timeGridWrapper = viewWrapper.timeGrid;
              expect(viewWrapper.getHeaderAxisEl())
                  .toBeLeftOf(headerWrapper.getCellEls()[0]);
              expect(viewWrapper.getAllDayAxisEl())
                  .toBeLeftOf(dayGridWrapper.getAllDayEls()[0]);
              expect(timeGridWrapper.getSlotAxisEls()[0])
                  .toBeLeftOf(timeGridWrapper.getSlotLaneEls()[0]);
          });
      });
      describe('when RTL', () => {
          pushOptions({
              direction: 'rtl',
          });
          it('renders the axis on the right', () => {
              let calendar = initCalendar();
              let viewWrapper = new TimeGridViewWrapper(calendar);
              let headerWrapper = viewWrapper.header;
              let dayGridWrapper = viewWrapper.dayGrid;
              let timeGridWrapper = viewWrapper.timeGrid;
              expect(viewWrapper.getHeaderAxisEl())
                  .toBeRightOf(headerWrapper.getCellEls()[0]);
              expect(viewWrapper.getAllDayAxisEl())
                  .toBeRightOf(dayGridWrapper.getAllDayEls()[0]);
              expect(timeGridWrapper.getSlotAxisEls()[0])
                  .toBeRightOf(timeGridWrapper.getSlotLaneEls()[0]);
          });
      });
  });

  describe('weekNumbers', () => {
      describe('when using month view', () => {
          pushOptions({
              initialView: 'dayGridMonth',
              fixedWeekCount: true, // will make 6 rows
          });
          describe('with default weekNumbers', () => {
              it('should not display week numbers at all', () => {
                  let calendar = initCalendar();
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  expect(dayGridWrapper.getWeekNumberEls().length).toEqual(0);
              });
          });
          describe('with weekNumbers to false', () => {
              pushOptions({
                  weekNumbers: false,
              });
              it('should not display week numbers at all', () => {
                  let calendar = initCalendar();
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  expect(dayGridWrapper.getWeekNumberEls().length).toEqual(0);
              });
          });
          describe('with weekNumbers to true', () => {
              pushOptions({
                  weekNumbers: true,
              });
              it('should display week numbers in the day cells only', () => {
                  let calendar = initCalendar();
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  expect(dayGridWrapper.getWeekNumberEls().length).toBeGreaterThan(0);
              });
          });
      });
      describe('when using an timeGrid view', () => {
          pushOptions({
              initialView: 'timeGridWeek',
          });
          describe('with default weekNumbers', () => {
              it('should not display week numbers at all', () => {
                  let calendar = initCalendar();
                  let viewWrapper = new TimeGridViewWrapper(calendar);
                  expect(viewWrapper.getHeaderWeekNumberLink()).toBeFalsy();
              });
          });
          describe('with weekNumbers to false', () => {
              pushOptions({
                  weekNumbers: false,
              });
              it('should not display week numbers at all', () => {
                  let calendar = initCalendar();
                  let viewWrapper = new TimeGridViewWrapper(calendar);
                  expect(viewWrapper.getHeaderWeekNumberLink()).toBeFalsy();
              });
          });
          describe('with weekNumbers to true', () => {
              pushOptions({
                  weekNumbers: true,
              });
              it('should display week numbers in the top left corner only', () => {
                  let calendar = initCalendar();
                  let viewWrapper = new TimeGridViewWrapper(calendar);
                  expect(viewWrapper.getHeaderWeekNumberLink()).toBeTruthy();
              });
          });
      });
      describe('when using in dayGrid view', () => {
          pushOptions({
              initialView: 'dayGridWeek',
          });
          // https://github.com/fullcalendar/fullcalendar/issues/5708
          it('displays events evenly', () => {
              let calendar = initCalendar({
                  weekNumbers: true,
                  initialDate: '2020-08-07',
                  events: [
                      { title: 'Event 1', start: '2020-08-02' },
                      { title: 'Event 2', start: '2020-08-03' },
                  ],
              });
              let gridWrapper = new DayGridViewWrapper(calendar).dayGrid;
              let eventEls = gridWrapper.getEventEls();
              expect(Math.abs(eventEls[0].getBoundingClientRect().top -
                  eventEls[1].getBoundingClientRect().top)).toBeLessThan(1);
          });
      });
  });

  describe('weekNumberCalculation', () => {
      pushOptions({
          weekNumbers: true,
      });
      describeOptions('initialView', {
          'when in day-grid': 'dayGridDay',
          'when in time-grid': 'timeGridDay',
      }, (viewName) => {
          let getWeekNumberText = viewName.match(/^dayGrid/)
              ? (calendar) => new DayGridViewWrapper(calendar).dayGrid.getWeekNumberText(0)
              : (calendar) => new TimeGridViewWrapper(calendar).getHeaderWeekText();
          it('should display the American standard when using \'local\'', () => {
              let calendar = initCalendar({
                  initialDate: '2013-11-23',
                  weekNumberCalculation: 'local',
              });
              expect(getWeekNumber(calendar)).toBe(47);
          });
          it('should display a locale-specific local week number', () => {
              let calendar = initCalendar({
                  initialDate: '2013-11-23',
                  locale: l7,
                  weekNumberCalculation: 'local',
              });
              expect(getWeekNumberText(calendar)).toMatch(/٤٨|48/);
          });
          // another local test, but to make sure it is different from ISO
          it('should display the American standard when using \'local\'', () => {
              let calendar = initCalendar({
                  initialDate: '2013-11-17',
                  weekNumberCalculation: 'local',
              });
              expect(getWeekNumber(calendar)).toBe(47);
          });
          it('should display ISO standard when using \'ISO\'', () => {
              let calendar = initCalendar({
                  initialDate: '2013-11-17',
                  weekNumberCalculation: 'ISO',
              });
              expect(getWeekNumber(calendar)).toBe(46);
          });
          it('should display the calculated number when a custom function', () => {
              let calendar = initCalendar({
                  weekNumberCalculation() {
                      return 4;
                  },
              });
              expect(getWeekNumber(calendar)).toBe(4);
          });
          function getWeekNumber(calendar) {
              let text = getWeekNumberText(calendar) || '';
              return parseInt(text.replace(/\D/g, ''), 10);
          }
      });
  });

  describe('slotDuration', () => {
      const minutesInADay = 1440;
      describe('when using the default settings', () => {
          describe('in week', () => {
              it('should have slots 1440/30 slots', () => {
                  let calendar = initCalendar({
                      initialView: 'timeGridWeek',
                  });
                  let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                  let slotCount = timeGridWrapper.getSlotEls().length;
                  expect(slotCount).toEqual(Math.ceil(minutesInADay / 30));
              });
          });
          describe('in day', () => {
              it('should have slots 1440/30 slots', () => {
                  let calendar = initCalendar({
                      initialView: 'timeGridDay',
                  });
                  let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                  let slotCount = timeGridWrapper.getSlotEls().length;
                  expect(slotCount).toEqual(Math.ceil(minutesInADay / 30));
              });
          });
      });
      describe('when slotMinutes is set to 30', () => {
          describe('in week', () => {
              it('should have slots 1440/30 slots', () => {
                  let calendar = initCalendar({
                      initialView: 'timeGridWeek',
                  });
                  let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                  let slotCount = timeGridWrapper.getSlotEls().length;
                  expect(slotCount).toEqual(Math.ceil(minutesInADay / 30));
              });
          });
          describe('in day', () => {
              it('should have slots 1440/30 slots', () => {
                  let calendar = initCalendar({
                      initialView: 'timeGridDay',
                  });
                  let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                  let slotCount = timeGridWrapper.getSlotEls().length;
                  expect(slotCount).toEqual(Math.ceil(minutesInADay / 30));
              });
          });
      });
      describe('when slotMinutes is set to a series of times', () => {
          const slotMinutesList = [10, 12, 15, 17, 20, 30, 35, 45, 60, 62, 120, 300];
          describe('in week', () => {
              slotMinutesList.forEach((slotMinutes) => {
                  it('should have slots 1440/x slots', () => {
                      let calendar = initCalendar({
                          initialView: 'timeGridWeek',
                          slotDuration: { minutes: slotMinutes },
                      });
                      let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                      let slotCount = timeGridWrapper.getSlotEls().length;
                      let expected = Math.ceil(minutesInADay / slotMinutes);
                      expect(slotCount).toEqual(expected);
                  });
              });
          });
          describe('in day', () => {
              slotMinutesList.forEach((slotMinutes) => {
                  it('should have slots 1440/x slots', () => {
                      let calendar = initCalendar({
                          initialView: 'timeGridDay',
                          slotDuration: { minutes: slotMinutes },
                      });
                      let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                      let slotCount = timeGridWrapper.getSlotEls().length;
                      let expected = Math.ceil(minutesInADay / slotMinutes);
                      expect(slotCount).toEqual(expected);
                  });
              });
          });
      });
  });

  describe('dayMaxEventRows', () => {
      pushOptions({
          initialDate: '2014-08-01',
          dayMaxEventRows: 3,
      });
      describe('as a number', () => {
          describeOptions('initialView', {
              'when in month view': 'dayGridMonth',
              'when in dayGridWeek view': 'dayGridWeek',
              'when in week view': 'timeGridWeek',
          }, (viewName) => {
              let ViewWrapper = viewName.match(/^dayGrid/) ? DayGridViewWrapper : TimeGridViewWrapper;
              it('doesn\'t display a more link when limit is more than the # of events', () => {
                  let calendar = initCalendar({
                      events: [
                          { title: 'event1', start: '2014-07-29' },
                          { title: 'event2', start: '2014-07-29' },
                      ],
                  });
                  let dayGridWrapper = new ViewWrapper(calendar).dayGrid;
                  expect(dayGridWrapper.getMoreEls().length).toBe(0);
              });
              it('doesn\'t display a more link when limit equal to the # of events', () => {
                  let calendar = initCalendar({
                      events: [
                          { title: 'event1', start: '2014-07-29' },
                          { title: 'event2', start: '2014-07-29' },
                          { title: 'event2', start: '2014-07-29' },
                      ],
                  });
                  let dayGridWrapper = new ViewWrapper(calendar).dayGrid;
                  expect(dayGridWrapper.getMoreEls().length).toBe(0);
              });
              it('displays a more link when limit is less than the # of events', () => {
                  let calendar = initCalendar({
                      events: [
                          { title: 'event1', start: '2014-07-29' },
                          { title: 'event2', start: '2014-07-29' },
                          { title: 'event2', start: '2014-07-29' },
                          { title: 'event2', start: '2014-07-29' },
                      ],
                  });
                  let dayGridWrapper = new ViewWrapper(calendar).dayGrid;
                  let moreEls = dayGridWrapper.getMoreEls();
                  expect(moreEls.length).toBe(1);
                  expect(moreEls[0]).toHaveText('+2 more');
              });
              it('displays one more per day, when a multi-day event is above', () => {
                  let calendar = initCalendar({
                      events: [
                          { title: 'event1', start: '2014-07-29', end: '2014-07-31' },
                          { title: 'event2', start: '2014-07-29', end: '2014-07-31' },
                          { title: 'event2', start: '2014-07-29', end: '2014-07-31' },
                          { title: 'event2', start: '2014-07-29', end: '2014-07-31' },
                      ],
                  });
                  let dayGridWrapper = new ViewWrapper(calendar).dayGrid;
                  let moreEls = dayGridWrapper.getMoreEls();
                  let cells = dayGridWrapper.getDayElsInRow(0);
                  expect(moreEls.length).toBe(2);
                  expect(moreEls[0]).toHaveText('+2 more');
                  expect(moreEls[0]).toBeBoundedBy(cells[2]);
                  expect(moreEls[1]).toHaveText('+2 more');
                  expect(moreEls[1]).toBeBoundedBy(cells[3]);
              });
              it('will render a pertially hidden single-day event', () => {
                  let calendar = initCalendar({
                      events: [
                          { title: 'event1', start: '2014-07-29', end: '2014-07-31' },
                          { title: 'event2', start: '2014-07-29', end: '2014-07-31' },
                          { title: 'event3', start: '2014-07-29', end: '2014-07-31' },
                          { title: 'event4', start: '2014-07-29' },
                      ],
                  });
                  let dayGridWrapper = new ViewWrapper(calendar).dayGrid;
                  let eventEls = dayGridWrapper.getEventEls();
                  let visibleEventEls = filterVisibleEls(eventEls);
                  let moreEls = dayGridWrapper.getMoreEls();
                  let cells = dayGridWrapper.getAllDayEls();
                  expect(visibleEventEls.length).toBe(3);
                  expect(moreEls.length).toBe(1);
                  expect(moreEls[0]).toHaveText('+2 more');
                  expect(moreEls[0]).toBeBoundedBy(cells[2]);
              });
              // https://github.com/fullcalendar/fullcalendar/issues/6187
              it('will render a partially multi-day hidden event', () => {
                  let calendar = initCalendar({
                      events: [
                          { title: 'event1', start: '2014-07-28', end: '2014-07-30' },
                          { title: 'event2', start: '2014-07-28', end: '2014-07-30' },
                          { title: 'event3', start: '2014-07-28', end: '2014-07-30' },
                          { title: 'event4', start: '2014-07-29', end: '2014-07-31' },
                      ],
                  });
                  let dayGridWrapper = new ViewWrapper(calendar).dayGrid;
                  let eventEls = dayGridWrapper.getEventEls();
                  let visibleEventEls = filterVisibleEls(eventEls);
                  let moreEls = dayGridWrapper.getMoreEls();
                  let cells = dayGridWrapper.getDayElsInRow(0);
                  expect(visibleEventEls.length).toBe(4);
                  expect(moreEls.length).toBe(1);
                  expect(moreEls[0]).toHaveText('+2 more');
                  expect(moreEls[0]).toBeBoundedBy(cells[2]);
              });
              it('will render a link in place of a hidden single day event, if covered by a multi-day', () => {
                  let calendar = initCalendar({
                      events: [
                          { title: 'event1', start: '2014-07-28', end: '2014-07-30' },
                          { title: 'event2', start: '2014-07-28', end: '2014-07-30' },
                          { title: 'event3', start: '2014-07-28' },
                          { title: 'event4', start: '2014-07-28' },
                      ],
                  });
                  let dayGridWrapper = new ViewWrapper(calendar).dayGrid;
                  let cells = dayGridWrapper.getDayElsInRow(0);
                  let moreEls = dayGridWrapper.getMoreEls();
                  expect(moreEls.length).toBe(1);
                  expect(moreEls[0]).toHaveText('+2 more');
                  expect(moreEls[0]).toBeBoundedBy(cells[1]);
              });
              it('will render a link in place of a hidden single day event, if covered by a multi-day ' +
                  'and in its second column', () => {
                  let calendar = initCalendar({
                      events: [
                          { title: 'event1', start: '2014-07-28', end: '2014-07-30' },
                          { title: 'event2', start: '2014-07-28', end: '2014-07-30' },
                          { title: 'event3', start: '2014-07-29' },
                          { title: 'event4', start: '2014-07-29' },
                      ],
                  });
                  let dayGridWrapper = new ViewWrapper(calendar).dayGrid;
                  let cells = dayGridWrapper.getDayElsInRow(0);
                  let moreEls = dayGridWrapper.getMoreEls();
                  expect(moreEls.length).toBe(1);
                  expect(moreEls[0]).toHaveText('+2 more');
                  expect(moreEls[0]).toBeBoundedBy(cells[2]);
              });
          });
      });
      describe('when auto', () => {
          pushOptions({
              dayMaxEvents: true,
          });
          describe('in month view', () => {
              pushOptions({
                  initialView: 'dayGridMonth',
                  events: [
                      { title: 'event1', start: '2014-07-28', end: '2014-07-30' },
                      { title: 'event2', start: '2014-07-28', end: '2014-07-30' },
                      { title: 'event2', start: '2014-07-29' },
                      { title: 'event2', start: '2014-07-29' },
                      { title: 'event2', start: '2014-07-29' },
                      { title: 'event2', start: '2014-07-29' },
                      { title: 'event2', start: '2014-07-29' },
                      { title: 'event2', start: '2014-07-29' },
                      { title: 'event2', start: '2014-07-29' },
                      { title: 'event2', start: '2014-07-29' },
                      { title: 'event2', start: '2014-07-29' },
                      { title: 'event2', start: '2014-07-29' },
                      { title: 'event2', start: '2014-07-29' },
                  ],
              });
              it('renders the heights of all the rows the same, regardless of # of events', () => {
                  let calendar = initCalendar();
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  let rowEls = dayGridWrapper.getRowEls();
                  expect(rowEls.length).toBeGreaterThan(0);
                  let rowHeights = rowEls.map((rowEl) => rowEl.getBoundingClientRect().height);
                  let totalHeight = rowHeights.reduce((prev, current) => prev + current, 0);
                  let aveHeight = totalHeight / rowHeights.length;
                  rowHeights.forEach((rowHeight) => {
                      let diff = Math.abs(rowHeight - aveHeight);
                      expect(diff).toBeLessThan(2);
                  });
              });
              it('renders a more link when there are obviously too many events', () => {
                  let $el = $('<div id="calendar">').appendTo('body').width(800);
                  let calendar = initCalendar({}, $el);
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  let moreEls = dayGridWrapper.getMoreEls();
                  expect(moreEls.length).toBe(1);
              });
          });
          describeOptions('initialView', {
              'when in month view': 'dayGridMonth',
              'when in dayGridWeek view': 'dayGridWeek',
          }, () => {
              it('doesn\'t render a more link where there should obviously not be a limit', () => {
                  let calendar = initCalendar({
                      events: [
                          { title: 'event1', start: '2014-07-28', end: '2014-07-30' },
                      ],
                  });
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  expect(dayGridWrapper.getMoreEls().length).toBe(0);
              });
          });
          describe('in week view', () => {
              pushOptions({
                  initialView: 'timeGridWeek',
              });
              it('behaves as if limit is 5', () => {
                  let calendar = initCalendar({
                      events: [
                          { title: 'event1', start: '2014-07-29' },
                          { title: 'event2', start: '2014-07-29' },
                          { title: 'event2', start: '2014-07-29' },
                          { title: 'event2', start: '2014-07-29' },
                          { title: 'event2', start: '2014-07-29' },
                          { title: 'event2', start: '2014-07-29' },
                          { title: 'event2', start: '2014-07-29' },
                      ],
                  });
                  let dayGridWrapper = new TimeGridViewWrapper(calendar).dayGrid;
                  let eventEls = filterVisibleEls(dayGridWrapper.getEventEls());
                  let moreEls = dayGridWrapper.getMoreEls();
                  expect(eventEls.length).toBe(4);
                  expect(moreEls.length).toBe(1);
                  expect(moreEls[0]).toHaveText('+3 more');
              });
          });
      });
  });

  describe('View object', () => {
      /*
      TODO: move tests from eventLimitClick.js about view.name/type into here
      */
      pushOptions({
          initialDate: '2015-01-01',
      });
      describe('title', () => {
          it('is a correctly defined string', () => {
              initCalendar();
              let view = currentCalendar.view;
              expect(view.title).toBe('January 2015');
          });
          it('is available in the viewDidMount callback', () => {
              let viewDidMountSpy = spyOnCalendarCallback('viewDidMount', (arg) => {
                  expect(arg.view.title).toBe('January 2015');
              });
              initCalendar();
              expect(viewDidMountSpy).toHaveBeenCalled();
          });
      });
  });

  describe('removeEventSources', () => {
      pushOptions({
          initialDate: '2014-08-01',
          initialView: 'timeGridDay',
          eventSources: [
              buildEventSource(1),
              buildEventSource(2),
              buildEventSource(3),
          ],
      });
      describe('when called with no arguments', () => {
          it('removes all sources', () => {
              let calendar = initCalendar();
              let calendarWrapper = new CalendarWrapper(calendar);
              expect(calendarWrapper.getEventEls().length).toBe(3);
              calendar.removeAllEventSources();
              expect(calendarWrapper.getEventEls().length).toBe(0);
          });
      });
      describe('when called with specific IDs', () => {
          it('removes only events with matching sources', () => {
              let calendar = initCalendar();
              let calendarWrapper = new CalendarWrapper(calendar);
              expect(calendarWrapper.getEventEls().length).toBe(3);
              calendar.getEventSourceById('1').remove();
              calendar.getEventSourceById('3').remove();
              expect(calendarWrapper.getEventEls().length).toBe(1);
              expect($('.event2').length).toBe(1);
          });
      });
      function buildEventSource(id) {
          return {
              id,
              events(arg, callback) {
                  callback([{
                          title: 'event' + id,
                          className: 'event' + id,
                          start: '2014-08-01T02:00:00',
                      }]);
              },
          };
      }
  });

  describe('addEventSource', () => {
      let eventArray = [
          { id: '0', title: 'event zero', start: '2014-06-24', classNames: 'event-zero' },
          { id: '1', title: 'event one', start: '2014-06-24', classNames: 'event-non-zero event-one' },
          { id: '2', title: 'event two', start: '2014-06-24', classNames: 'event-non-zero event-two' },
      ];
      pushOptions({
          initialDate: '2014-06-24',
          initialView: 'dayGridMonth',
      });
      it('correctly adds an array source', (done) => {
          go(() => {
              currentCalendar.addEventSource(eventArray);
          }, null, done);
      });
      it('correctly adds a function source', (done) => {
          go(() => {
              currentCalendar.addEventSource((arg, callback) => {
                  callback(eventArray);
              });
          }, null, done);
      });
      it('correctly adds an extended array source', (done) => {
          go(() => {
              currentCalendar.addEventSource({
                  classNames: 'arraysource',
                  events: eventArray,
              });
          }, () => {
              expect($('.arraysource').length).toEqual(3);
          }, done);
      });
      it('correctly adds an extended func source', (done) => {
          go(() => {
              currentCalendar.addEventSource({
                  classNames: 'funcsource',
                  events(arg, callback) {
                      callback(eventArray);
                  },
              });
          }, () => {
              expect($('.funcsource').length).toEqual(3);
          }, done);
      });
      function go(addFunc, extraTestFunc, doneFunc) {
          initCalendar();
          addFunc();
          checkAllEvents();
          if (extraTestFunc) {
              extraTestFunc();
          }
          // move the calendar back out of view, then back in (for issue 2191)
          currentCalendar.next();
          currentCalendar.prev();
          // otherwise, prev/next would be cancelled out by doneFunc's calendar destroy
          setTimeout(() => {
              checkAllEvents();
              if (extraTestFunc) {
                  extraTestFunc();
              }
              doneFunc();
          }, 0);
      }
      // Checks to make sure all events have been rendered and that the calendar
      // has internal info on all the events.
      function checkAllEvents() {
          expect(currentCalendar.getEvents().length).toEqual(3);
          let calendarWrapper = new CalendarWrapper(currentCalendar);
          expect(calendarWrapper.getEventEls().length).toEqual(3);
      }
  });

  describe('current date', () => {
      const TITLE_FORMAT = {
          month: 'long',
          day: 'numeric',
          year: 'numeric',
          separator: ' - ',
          isEndExclusive: true,
      };
      pushOptions({
          titleFormat: TITLE_FORMAT,
          titleRangeSeparator: ' - ',
          initialDate: '2014-06-01',
          timeZone: 'UTC',
      });
      describe('initialDate & getDate', () => {
          describeWhenInMonth(() => {
              it('should initialize at the date', () => {
                  let calendar = initCalendar({
                      initialDate: '2011-03-10',
                  });
                  expectViewDates(calendar, '2011-02-27', '2011-04-10', '2011-03-01', '2011-04-01');
                  let currentDate = calendar.getDate();
                  expect(currentDate instanceof Date).toEqual(true); // test the type, but only here
                  expect(currentDate).toEqualDate('2011-03-10');
              });
          });
          describeWhenInWeek(() => {
              it('should initialize at the date, given a date string', () => {
                  let calendar = initCalendar({
                      initialDate: '2011-03-10',
                  });
                  expectViewDates(calendar, '2011-03-06', '2011-03-13');
                  expect(calendar.getDate()).toEqualDate('2011-03-10');
              });
              it('should initialize at the date, given a Date object', () => {
                  let calendar = initCalendar({
                      initialDate: parseUtcDate('2011-03-10'),
                  });
                  expectViewDates(calendar, '2011-03-06', '2011-03-13');
                  expect(calendar.getDate()).toEqualDate('2011-03-10');
              });
          });
          describeWhenInDay(() => {
              it('should initialize at the date', () => {
                  let calendar = initCalendar({
                      initialDate: '2011-03-10',
                  });
                  expectViewDates(calendar, '2011-03-10');
                  expect(calendar.getDate()).toEqualDate('2011-03-10');
              });
          });
      });
      describe('gotoDate', () => {
          describeWhenInMonth(() => {
              it('should go to a date when given a date string', () => {
                  let calendar = initCalendar();
                  calendar.gotoDate('2015-04-01');
                  expectViewDates(calendar, '2015-03-29', '2015-05-10', '2015-04-01', '2015-05-01');
              });
          });
          describeWhenInWeek(() => {
              it('should go to a date when given a date string', () => {
                  let calendar = initCalendar();
                  calendar.gotoDate('2015-04-01');
                  expectViewDates(calendar, '2015-03-29', '2015-04-05');
              });
              it('should go to a date when given a date string with a time', () => {
                  let calendar = initCalendar();
                  calendar.gotoDate('2015-04-01T12:00:00');
                  expectViewDates(calendar, '2015-03-29', '2015-04-05');
              });
              it('should go to a date when given a Date object', () => {
                  let calendar = initCalendar();
                  calendar.gotoDate(parseUtcDate('2015-04-01'));
                  expectViewDates(calendar, '2015-03-29', '2015-04-05');
              });
          });
          describeWhenInDay(() => {
              it('should go to a date when given a date string', () => {
                  let calendar = initCalendar();
                  calendar.gotoDate('2015-04-01');
                  expectViewDates(calendar, '2015-04-01');
              });
          });
      });
      describe('incrementDate', () => {
          describeWhenInMonth(() => {
              it('should increment the date when given a Duration object', () => {
                  let calendar = initCalendar();
                  calendar.incrementDate({ months: -1 });
                  expectViewDates(calendar, '2014-04-27', '2014-06-08', '2014-05-01', '2014-06-01');
              });
          });
          describeWhenInWeek(() => {
              it('should increment the date when given a Duration object', () => {
                  let calendar = initCalendar();
                  calendar.incrementDate({ weeks: -2 });
                  expectViewDates(calendar, '2014-05-18', '2014-05-25');
              });
          });
          describeWhenInDay(() => {
              it('should increment the date when given a Duration object', () => {
                  let calendar = initCalendar();
                  calendar.incrementDate({ days: 2 });
                  expectViewDates(calendar, '2014-06-03');
              });
              it('should increment the date when given a Duration string', () => {
                  let calendar = initCalendar();
                  calendar.incrementDate('2.00:00:00');
                  expectViewDates(calendar, '2014-06-03');
              });
              it('should increment the date when given a Duration string with a time', () => {
                  let calendar = initCalendar();
                  calendar.incrementDate('2.05:30:00');
                  expectViewDates(calendar, '2014-06-03');
              });
          });
      });
      describe('prevYear', () => {
          describeWhenInMonth(() => {
              it('should move the calendar back a year', () => {
                  let calendar = initCalendar();
                  calendar.prevYear();
                  expectViewDates(calendar, '2013-05-26', '2013-07-07', '2013-06-01', '2013-07-01');
              });
          });
          describeWhenInWeek(() => {
              it('should move the calendar back a year', () => {
                  let calendar = initCalendar();
                  calendar.prevYear();
                  expectViewDates(calendar, '2013-05-26', '2013-06-02');
              });
          });
          describeWhenInDay(() => {
              it('should move the calendar back a year', () => {
                  let calendar = initCalendar();
                  calendar.prevYear();
                  expectViewDates(calendar, '2013-06-01');
              });
          });
      });
      describe('nextYear', () => {
          describeWhenInMonth(() => {
              it('should move the calendar forward a year', () => {
                  let calendar = initCalendar();
                  calendar.nextYear();
                  expectViewDates(calendar, '2015-05-31', '2015-07-12', '2015-06-01', '2015-07-01');
              });
          });
          describeWhenInWeek(() => {
              it('should move the calendar forward a year', () => {
                  let calendar = initCalendar();
                  calendar.nextYear();
                  expectViewDates(calendar, '2015-05-31', '2015-06-07');
              });
          });
          describeWhenInDay(() => {
              it('should move the calendar forward a year', () => {
                  let calendar = initCalendar();
                  calendar.nextYear();
                  expectViewDates(calendar, '2015-06-01');
              });
          });
      });
      describe('when current date is a hidden day', () => {
          describeWhenInMonth(() => {
              it('should display the current month even if first day of month', () => {
                  let calendar = initCalendar({
                      now: '2014-06-01',
                      initialDate: '2014-06-01',
                      weekends: false,
                  });
                  let view = calendar.view;
                  expect(view.activeStart).toEqualDate('2014-06-02');
                  expect(view.activeEnd).toEqualDate('2014-07-12');
                  expect(view.currentStart).toEqualDate('2014-06-01');
                  expect(view.currentEnd).toEqualDate('2014-07-01');
              });
              it('should display the current month', () => {
                  let calendar = initCalendar({
                      now: '2014-05-04',
                      initialDate: '2014-05-04',
                      weekends: false,
                  });
                  let view = calendar.view;
                  expect(view.activeStart).toEqualDate('2014-04-28');
                  expect(view.activeEnd).toEqualDate('2014-06-07');
                  expect(view.currentStart).toEqualDate('2014-05-01');
                  expect(view.currentEnd).toEqualDate('2014-06-01');
              });
              describe('when navigating back a month', () => {
                  it('should not skip months', () => {
                      let calendar = initCalendar({
                          initialDate: '2014-07-07',
                          weekends: false,
                      });
                      let view = calendar.view;
                      expect(view.currentStart).toEqualDate('2014-07-01');
                      expect(view.currentEnd).toEqualDate('2014-08-01');
                      calendar.prev(); // will move to Jun 1, which is a Sunday
                      view = calendar.view;
                      expect(view.currentStart).toEqualDate('2014-06-01');
                      expect(view.currentEnd).toEqualDate('2014-07-01');
                  });
              });
          });
          describeWhenInDay(() => {
              it('should display the next visible day', () => {
                  let calendar = initCalendar({
                      now: '2014-06-01',
                      initialDate: '2014-06-01',
                      weekends: false,
                  });
                  let view = calendar.view;
                  expect(view.activeStart).toEqualDate('2014-06-02');
                  expect(view.activeEnd).toEqualDate('2014-06-03');
                  expect(view.currentStart).toEqualDate('2014-06-02');
                  expect(view.currentEnd).toEqualDate('2014-06-03');
              });
          });
      });
      // UTILS
      // -----
      function describeWhenInMonth(func) {
          describeWhenIn('dayGridMonth', func);
      }
      function describeWhenInWeek(func) {
          describeWhenIn('dayGridWeek', func);
          describeWhenIn('timeGridWeek', func);
      }
      function describeWhenInDay(func) {
          describeWhenIn('dayGridDay', func);
          describeWhenIn('timeGridDay', func);
      }
      function describeWhenIn(viewName, func) {
          describe('when in ' + viewName, () => {
              pushOptions({ initialView: viewName });
              func();
          });
      }
      function expectViewDates(calendar, start, end, titleStart, titleEnd) {
          let view = calendar.view;
          let calculatedEnd;
          let title;
          if (typeof start === 'string') {
              start = new Date(start);
          }
          if (typeof end === 'string') {
              end = new Date(end);
          }
          if (typeof titleStart === 'string') {
              titleStart = new Date(titleStart);
          }
          if (typeof titleEnd === 'string') {
              titleEnd = new Date(titleEnd);
          }
          calculatedEnd = end || addDays(start, 1);
          expect(start).toEqualDate(view.activeStart);
          expect(calculatedEnd).toEqualDate(view.activeEnd);
          titleStart = titleStart || start;
          titleEnd = titleEnd || calculatedEnd;
          if (titleEnd) {
              title = calendar.formatRange(titleStart, titleEnd, TITLE_FORMAT);
          }
          else {
              title = calendar.formatDate(titleStart, TITLE_FORMAT);
          }
          let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
          expect(toolbarWrapper.getTitleText()).toBe(title);
      }
  });

  describe('dayPopoverFormat', () => {
      pushOptions({
          initialDate: '2014-08-01',
          dayMaxEventRows: 3,
          events: [
              { title: 'event1', start: '2014-07-28', end: '2014-07-30', className: 'event1' },
              { title: 'event2', start: '2014-07-29', end: '2014-07-31', className: 'event2' },
              { title: 'event3', start: '2014-07-29', className: 'event3' },
              { title: 'event4', start: '2014-07-29', className: 'event4' },
          ],
      });
      it('can be set to a custom value', (done) => {
          let calendar = initCalendar({
              dayPopoverFormat: { month: 'long', day: 'numeric' },
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          $(dayGridWrapper.getMoreEl()).simulate('click');
          setTimeout(() => {
              expect(dayGridWrapper.getMorePopoverTitle()).toBe('July 29');
              done();
          });
      });
      it('is affected by the current locale when the value is default', (done) => {
          let calendar = initCalendar({
              locale: l31,
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          $(dayGridWrapper.getMoreEl()).simulate('click');
          setTimeout(() => {
              expect(dayGridWrapper.getMorePopoverTitle()).toBe('29 juillet 2014');
              done();
          });
      });
      it('still maintains the same format when explicitly set, and there is a locale', (done) => {
          let calendar = initCalendar({
              locale: l31,
              dayPopoverFormat: { year: 'numeric' },
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          $(dayGridWrapper.getMoreEl()).simulate('click');
          setTimeout(() => {
              expect(dayGridWrapper.getMorePopoverTitle()).toBe('2014');
              done();
          });
      });
  });

  describe('aspectRatio', () => {
      function getCalendarElement(width) {
          return $('<div id="calendar" style="max-width:none">').appendTo('body').width(width)[0];
      }
      describe('when default settings are used', () => {
          const elementWidth = 675;
          it('view div should use the ratio 1:35 to set height', () => {
              let calendar = initCalendar({}, getCalendarElement(elementWidth));
              let viewContainerEl = new CalendarWrapper(calendar).getViewContainerEl();
              let rect = viewContainerEl.getBoundingClientRect();
              expect(Math.round(rect.height)).toEqual(500);
          });
          it('view div should have width of div', () => {
              let calendar = initCalendar({}, getCalendarElement(elementWidth));
              let viewContainerEl = new CalendarWrapper(calendar).getViewContainerEl();
              let rect = viewContainerEl.getBoundingClientRect();
              expect(Math.round(rect.width)).toEqual(elementWidth);
          });
      });
      describe('when initializing the aspectRatio', () => {
          const elementWidth = 1000;
          describe('to 2', () => {
              pushOptions({
                  aspectRatio: 2,
              });
              it('should not change the width', () => {
                  let calendar = initCalendar({}, getCalendarElement(elementWidth));
                  let viewContainerEl = new CalendarWrapper(calendar).getViewContainerEl();
                  let rect = viewContainerEl.getBoundingClientRect();
                  expect(Math.round(rect.width)).toEqual(elementWidth);
              });
              it('should set the height to width sizes very close to ratio of 2', () => {
                  let calendar = initCalendar({}, getCalendarElement(elementWidth));
                  let viewContainerEl = new CalendarWrapper(calendar).getViewContainerEl();
                  let rect = viewContainerEl.getBoundingClientRect();
                  let ratio = Math.round((rect.width / rect.height) * 100);
                  expect(Math.round(ratio)).toEqual(200);
              });
          });
          describe('to 1', () => {
              pushOptions({
                  aspectRatio: 1,
              });
              it('should not change the width', () => {
                  let calendar = initCalendar({}, getCalendarElement(elementWidth));
                  let viewContainerEl = new CalendarWrapper(calendar).getViewContainerEl();
                  let rect = viewContainerEl.getBoundingClientRect();
                  expect(Math.round(rect.width)).toEqual(elementWidth);
              });
              it('should set the height to width sizes very close to ratio of 2', () => {
                  let calendar = initCalendar({}, getCalendarElement(elementWidth));
                  let viewContainerEl = new CalendarWrapper(calendar).getViewContainerEl();
                  let rect = viewContainerEl.getBoundingClientRect();
                  let ratio = Math.round((rect.width / rect.height) * 100);
                  expect(Math.round(ratio)).toEqual(100);
              });
          });
          describe('to less than 0.5', () => {
              pushOptions({
                  aspectRatio: 0.4,
              });
              it('should not change the width', () => {
                  let calendar = initCalendar({}, getCalendarElement(elementWidth));
                  let viewContainerEl = new CalendarWrapper(calendar).getViewContainerEl();
                  let rect = viewContainerEl.getBoundingClientRect();
                  expect(Math.round(rect.width)).toEqual(elementWidth);
              });
              it('should set the height to width ratio to 0.5', () => {
                  let calendar = initCalendar({}, getCalendarElement(elementWidth));
                  let viewContainerEl = new CalendarWrapper(calendar).getViewContainerEl();
                  let rect = viewContainerEl.getBoundingClientRect();
                  let ratio = Math.round((rect.width / rect.height) * 100);
                  expect(Math.round(ratio)).toEqual(50);
              });
          });
          describe('to negative', () => {
              pushOptions({
                  aspectRatio: -2,
              });
              it('should not change the width', () => {
                  let calendar = initCalendar({}, getCalendarElement(elementWidth));
                  let viewContainerEl = new CalendarWrapper(calendar).getViewContainerEl();
                  let rect = viewContainerEl.getBoundingClientRect();
                  expect(Math.round(rect.width)).toEqual(elementWidth);
              });
              it('should set the height to width ratio to 0.5', () => {
                  let calendar = initCalendar({}, getCalendarElement(elementWidth));
                  let viewContainerEl = new CalendarWrapper(calendar).getViewContainerEl();
                  let rect = viewContainerEl.getBoundingClientRect();
                  let ratio = Math.round((rect.width / rect.height) * 100);
                  expect(Math.round(ratio)).toEqual(50);
              });
          });
          describe('to zero', () => {
              pushOptions({
                  aspectRatio: 0,
              });
              it('should not change the width', () => {
                  let calendar = initCalendar({}, getCalendarElement(elementWidth));
                  let viewContainerEl = new CalendarWrapper(calendar).getViewContainerEl();
                  let rect = viewContainerEl.getBoundingClientRect();
                  expect(Math.round(rect.width)).toEqual(elementWidth);
              });
              it('should set the height to width ratio to 0.5', () => {
                  let calendar = initCalendar({}, getCalendarElement(elementWidth));
                  let viewContainerEl = new CalendarWrapper(calendar).getViewContainerEl();
                  let rect = viewContainerEl.getBoundingClientRect();
                  let ratio = Math.round((rect.width / rect.height) * 100);
                  expect(Math.round(ratio)).toEqual(50);
              });
          });
          describe('to very large', () => {
              pushOptions({
                  aspectRatio: 4000,
              });
              it('should not change the width', () => {
                  let calendar = initCalendar({}, getCalendarElement(elementWidth));
                  let viewContainerEl = new CalendarWrapper(calendar).getViewContainerEl();
                  let rect = viewContainerEl.getBoundingClientRect();
                  expect(Math.round(rect.width)).toEqual(elementWidth);
              });
              it('should cause rows to be natural height', () => {
                  let calendar = initCalendar({}, getCalendarElement(elementWidth));
                  let viewContainerEl = new CalendarWrapper(calendar).getViewContainerEl();
                  let actualHeight = viewContainerEl.getBoundingClientRect().height;
                  let naturalHeight = viewContainerEl.getBoundingClientRect().height;
                  expect(Math.round(actualHeight)).toEqual(Math.round(naturalHeight));
              });
          });
      });
  });

  describe('displayEventEnd', () => {
      pushOptions({
          initialDate: '2014-06-13',
          timeZone: 'UTC',
          eventTimeFormat: { hour: 'numeric', minute: '2-digit' },
      });
      describeOptions('initialView', {
          'when in month view': 'dayGridMonth',
          'when in week view': 'timeGridWeek',
      }, () => {
          describe('when off', () => {
              pushOptions({
                  displayEventEnd: false,
              });
              describe('with an all-day event', () => {
                  it('displays no time text', () => {
                      let calendar = initCalendar({
                          events: [{
                                  title: 'timed event',
                                  start: '2014-06-13',
                                  end: '2014-06-13',
                                  allDay: true,
                              }],
                      });
                      expectEventTimeText(calendar, '');
                  });
              });
              describe('with a timed event with no end time', () => {
                  it('displays only the start time text', () => {
                      let calendar = initCalendar({
                          events: [{
                                  title: 'timed event',
                                  start: '2014-06-13T01:00:00',
                                  allDay: false,
                              }],
                      });
                      expectEventTimeText(calendar, '1:00 AM');
                  });
              });
              describe('with a timed event with an end time', () => {
                  it('displays only the start time text', () => {
                      let calendar = initCalendar({
                          events: [{
                                  title: 'timed event',
                                  start: '2014-06-13T01:00:00',
                                  end: '2014-06-13T02:00:00',
                                  allDay: false,
                              }],
                      });
                      expectEventTimeText(calendar, '1:00 AM');
                  });
              });
          });
          describe('when on', () => {
              pushOptions({
                  displayEventEnd: true,
              });
              describe('with an all-day event', () => {
                  it('displays no time text', () => {
                      let calendar = initCalendar({
                          events: [{
                                  title: 'timed event',
                                  start: '2014-06-13',
                                  end: '2014-06-13',
                                  allDay: true,
                              }],
                      });
                      expectEventTimeText(calendar, '');
                  });
              });
              describe('with a timed event with no end time', () => {
                  it('displays only the start time text', () => {
                      let calendar = initCalendar({
                          events: [{
                                  title: 'timed event',
                                  start: '2014-06-13T01:00:00',
                                  allDay: false,
                              }],
                      });
                      expectEventTimeText(calendar, '1:00 AM');
                  });
              });
              describe('with a timed event given an invalid end time', () => {
                  it('displays only the start time text', () => {
                      let calendar = initCalendar({
                          events: [{
                                  title: 'timed event',
                                  start: '2014-06-13T01:00:00',
                                  end: '2014-06-13T01:00:00',
                                  allDay: false,
                              }],
                      });
                      expectEventTimeText(calendar, '1:00 AM');
                  });
              });
              describe('with a timed event with an end time', () => {
                  it('displays both the start and end time text', () => {
                      let calendar = initCalendar({
                          events: [{
                                  title: 'timed event',
                                  start: '2014-06-13T01:00:00',
                                  end: '2014-06-13T02:00:00',
                                  allDay: false,
                              }],
                      });
                      expectEventTimeText(calendar, '1:00 AM - 2:00 AM');
                  });
              });
          });
      });
      function expectEventTimeText(calendar, timeText) {
          let calendarWrapper = new CalendarWrapper(calendar);
          let eventEl = calendarWrapper.getFirstEventEl();
          let eventInfo = calendarWrapper.getEventElInfo(eventEl);
          expect(eventInfo.timeText).toBe(timeText);
      }
  });

  describe('footerToolbar navigation', () => {
      pushOptions({
          now: '2010-02-01',
          headerToolbar: false,
          footerToolbar: {
              left: 'next,prev,prevYear,nextYear today',
              center: '',
              right: 'title',
          },
      });
      describe('and click next', () => {
          it('should change view to next month', (done) => {
              let calendar = initCalendar();
              let toolbarWrapper = new CalendarWrapper(calendar).footerToolbar;
              $(toolbarWrapper.getButtonEl('next')).simulate('click');
              setTimeout(() => {
                  let newDate = currentCalendar.getDate();
                  expect(newDate).toEqualDate('2010-03-01');
                  done();
              });
          });
      });
      describe('and click prev', () => {
          it('should change view to prev month', (done) => {
              let calendar = initCalendar();
              let toolbarWrapper = new CalendarWrapper(calendar).footerToolbar;
              $(toolbarWrapper.getButtonEl('prev')).simulate('click');
              setTimeout(() => {
                  let newDate = currentCalendar.getDate();
                  expect(newDate).toEqualDate('2010-01-01');
                  done();
              });
          });
      });
      describe('and click prevYear', () => {
          it('should change view to prev month', (done) => {
              let calendar = initCalendar();
              let toolbarWrapper = new CalendarWrapper(calendar).footerToolbar;
              $(toolbarWrapper.getButtonEl('prevYear')).simulate('click');
              setTimeout(() => {
                  let newDate = currentCalendar.getDate();
                  expect(newDate).toEqualDate('2009-02-01');
                  done();
              });
          });
      });
      describe('and click nextYear', () => {
          it('should change view to prev month', (done) => {
              let calendar = initCalendar();
              let toolbarWrapper = new CalendarWrapper(calendar).footerToolbar;
              $(toolbarWrapper.getButtonEl('nextYear')).simulate('click');
              setTimeout(() => {
                  let newDate = currentCalendar.getDate();
                  expect(newDate).toEqualDate('2011-02-01');
                  done();
              });
          });
      });
      describe('and click today', () => {
          it('should change view to prev month', (done) => {
              let calendar = initCalendar({
                  initialDate: '2010-03-15', // something other than the `now` date
              });
              let toolbarWrapper = new CalendarWrapper(calendar).footerToolbar;
              $(toolbarWrapper.getButtonEl('today')).simulate('click');
              setTimeout(() => {
                  let newDate = currentCalendar.getDate(); // will be ambig zone
                  expect(newDate).toEqualDate('2010-02-01');
                  done();
              });
          });
      });
  });

  describe('eventMouseEnter', () => {
      pushOptions({
          initialDate: '2014-08-01',
          scrollTime: '00:00:00',
      });
      ['dayGridMonth', 'timeGridWeek'].forEach((viewName) => {
          describe('for ' + viewName + ' view', () => {
              pushOptions({
                  initialView: viewName,
              });
              it('doesn\'t trigger a eventMouseLeave when updating an event', (done) => {
                  let options = {
                      events: [{
                              title: 'event',
                              start: '2014-08-02T01:00:00',
                              className: 'event',
                          }],
                      eventMouseEnter(arg) {
                          expect(typeof arg.event).toBe('object');
                          expect(typeof arg.jsEvent).toBe('object');
                          arg.event.setProp('title', 'YO');
                      },
                      eventMouseLeave(arg) { },
                  };
                  spyOn(options, 'eventMouseEnter');
                  spyOn(options, 'eventMouseLeave');
                  initCalendar(options);
                  $('.event').simulate('mouseover');
                  setTimeout(() => {
                      expect(options.eventMouseEnter).toHaveBeenCalled();
                      expect(options.eventMouseLeave).not.toHaveBeenCalled();
                      done();
                  }, 100);
              });
          });
      });
      it('gets fired for background events', (done) => {
          let mouseoverCalled = false;
          initCalendar({
              events: [{
                      start: '2014-08-02',
                      display: 'background',
                      className: 'event',
                  }],
              eventMouseEnter(arg) {
                  expect(arg.event.display).toBe('background');
                  mouseoverCalled = true;
              },
              eventMouseLeave() {
                  expect(mouseoverCalled).toBe(true);
                  done();
              },
          });
          $('.event')
              .simulate('mouseover')
              .simulate('mouseout')
              .simulate('mouseleave'); // helps out listenBySelector
      });
  });

  class ListViewWrapper extends ViewWrapper {
      constructor(calendar) {
          super(calendar, 'fc-list');
      }
      getEventEls() {
          return findElements(this.el, '.fc-list-event');
      }
      getEventInfo() {
          return this.getEventEls().map((eventEl) => ({
              title: $(eventEl).find('.fc-list-event-title').text(),
              timeText: $(eventEl).find('.fc-list-event-time').text(),
          }));
      }
      getDayInfo() {
          return this.getHeadingEls().map((el) => {
              let $el = $(el);
              return {
                  mainText: $el.find('.fc-list-day-text').text() || '',
                  altText: $el.find('.fc-list-day-side-text').text() || '',
                  date: new Date(el.getAttribute('data-date')),
              };
          });
      }
      getHeadingEls() {
          return findElements(this.el, '.fc-list-day');
      }
      getScrollerEl() {
          return this.el.querySelector('.fc-scroller');
      }
      hasEmptyMessage() {
          return Boolean(this.el.querySelector('.fc-list-empty'));
      }
      getNavLinkEl(dayDate) {
          if (typeof dayDate === 'string') {
              dayDate = new Date(dayDate);
          }
          return this.el.querySelector('.fc-list-day[data-date="' + formatIsoDay(dayDate) + '"] a.fc-list-day-text');
      }
      clickNavLink(dayDate) {
          $.simulateMouseClick(this.getNavLinkEl(dayDate));
      }
  }
  ListViewWrapper.EVENT_DOT_CLASSNAME = 'fc-list-event-dot';

  describe('ListView rendering', () => {
      pushOptions({
          initialView: 'listWeek',
          now: '2016-08-20',
      });
      describe('with all-day events', () => {
          describe('when single-day', () => {
              pushOptions({
                  events: [
                      {
                          title: 'event 1',
                          start: '2016-08-15',
                      },
                      {
                          title: 'event 2',
                          start: '2016-08-17',
                      },
                  ],
              });
              it('renders only days with events', () => {
                  let calendar = initCalendar();
                  let viewWrapper = new ListViewWrapper(calendar);
                  let days = viewWrapper.getDayInfo();
                  let events = viewWrapper.getEventInfo();
                  expect(days.length).toBe(2);
                  expect(days[0].date).toEqualDate('2016-08-15');
                  expect(days[1].date).toEqualDate('2016-08-17');
                  expect(events.length).toBe(2);
                  expect(events[0].title).toBe('event 1');
                  expect(events[0].timeText).toBe('all-day');
                  expect(events[1].title).toBe('event 2');
                  expect(events[1].timeText).toBe('all-day');
              });
              it('filters events through event hook', () => {
                  let eventMountCnt = 0;
                  initCalendar({
                      eventDidMount() {
                          eventMountCnt += 1;
                      },
                  });
                  expect(eventMountCnt).toBe(2);
              });
              it('filters events through eventWillUnmount', () => {
                  let callCnt = 0;
                  initCalendar({
                      eventWillUnmount() {
                          callCnt += 1;
                      },
                  });
                  currentCalendar.destroy();
                  expect(callCnt).toBe(2);
              });
          });
          describe('when multi-day', () => {
              pushOptions({
                  events: [
                      {
                          title: 'event 1',
                          start: '2016-08-15',
                          end: '2016-08-18', // 3 days
                      },
                  ],
              });
              it('renders all-day for every day', () => {
                  let calendar = initCalendar();
                  let viewWrapper = new ListViewWrapper(calendar);
                  let events = viewWrapper.getEventInfo();
                  expect(events.length).toBe(3);
                  expect(events[0].title).toBe('event 1');
                  expect(events[0].timeText).toBe('all-day');
                  expect(events[1].title).toBe('event 1');
                  expect(events[1].timeText).toBe('all-day');
                  expect(events[2].title).toBe('event 1');
                  expect(events[2].timeText).toBe('all-day');
              });
          });
      });
      describe('with timed events', () => {
          describe('when single-day', () => {
              pushOptions({
                  events: [
                      {
                          title: 'event 1',
                          start: '2016-08-15T07:00',
                      },
                      {
                          title: 'event 2',
                          start: '2016-08-17T09:00',
                          end: '2016-08-17T11:00',
                      },
                  ],
              });
              it('renders times', () => {
                  let calendar = initCalendar();
                  let viewWrapper = new ListViewWrapper(calendar);
                  let events = viewWrapper.getEventInfo();
                  expect(events.length).toBe(2);
                  expect(events[0].title).toBe('event 1');
                  expect(events[0].timeText).toBe('7:00am');
                  expect(events[1].title).toBe('event 2');
                  expect(events[1].timeText).toBe('9:00am - 11:00am');
              });
              it('doesn\'t render times when displayEventTime is false', () => {
                  let calendar = initCalendar({
                      displayEventTime: false,
                  });
                  let viewWrapper = new ListViewWrapper(calendar);
                  let events = viewWrapper.getEventInfo();
                  expect(events.length).toBe(2);
                  expect(events[0].title).toBe('event 1');
                  expect(events[0].timeText).toBe('');
                  expect(events[1].title).toBe('event 2');
                  expect(events[1].timeText).toBe('');
              });
              it('doesn\'t render end times when displayEventEnd is false', () => {
                  let calendar = initCalendar({
                      displayEventEnd: false,
                  });
                  let viewWrapper = new ListViewWrapper(calendar);
                  let events = viewWrapper.getEventInfo();
                  expect(events.length).toBe(2);
                  expect(events[0].title).toBe('event 1');
                  expect(events[0].timeText).toBe('7:00am');
                  expect(events[1].title).toBe('event 2');
                  expect(events[1].timeText).toBe('9:00am');
              });
              // regression test for when localized event dates get unlocalized and leak into view rendering
              it('renders dates and times in locale', () => {
                  let calendar = initCalendar({
                      locale: l31,
                  });
                  let viewWrapper = new ListViewWrapper(calendar);
                  let days = viewWrapper.getDayInfo();
                  let events = viewWrapper.getEventInfo();
                  expect(days.length).toBe(2);
                  expect(days[0].date).toEqualDate('2016-08-15');
                  expect(days[0].mainText).toEqual('lundi');
                  expect(days[0].altText).toEqual('15 août 2016');
                  expect(days[1].date).toEqualDate('2016-08-17');
                  expect(days[1].mainText).toEqual('mercredi');
                  expect(days[1].altText).toEqual('17 août 2016');
                  expect(events.length).toBe(2);
                  expect(events[0].title).toBe('event 1');
                  expect(events[0].timeText).toMatch(/^0?7:00$/);
                  expect(events[1].title).toBe('event 2');
                  expect(events[1].timeText).toMatch(/^0?9:00 - 11:00$/);
              });
          });
          describe('when multi-day', () => {
              pushOptions({
                  nextDayThreshold: '00:00',
              });
              it('renders partial and full days', () => {
                  let calendar = initCalendar({
                      events: [
                          {
                              title: 'event 1',
                              start: '2016-08-15T07:00',
                              end: '2016-08-17T11:00',
                          },
                      ],
                  });
                  let viewWrapper = new ListViewWrapper(calendar);
                  let events = viewWrapper.getEventInfo();
                  expect(events.length).toBe(3);
                  expect(events[0].title).toBe('event 1');
                  expect(events[0].timeText).toBe('7:00am - 12:00am');
                  expect(events[1].title).toBe('event 1');
                  expect(events[1].timeText).toBe('all-day');
                  expect(events[2].title).toBe('event 1');
                  expect(events[2].timeText).toBe('12:00am - 11:00am');
              });
              it('truncates an out-of-range start', () => {
                  let calendar = initCalendar({
                      events: [
                          {
                              title: 'event 1',
                              start: '2016-08-13T07:00',
                              end: '2016-08-16T11:00',
                          },
                      ],
                  });
                  let viewWrapper = new ListViewWrapper(calendar);
                  let events = viewWrapper.getEventInfo();
                  expect(events.length).toBe(3);
                  expect(events[0].title).toBe('event 1');
                  expect(events[0].timeText).toBe('all-day');
                  expect(events[1].title).toBe('event 1');
                  expect(events[1].timeText).toBe('all-day');
                  expect(events[2].title).toBe('event 1');
                  expect(events[2].timeText).toBe('12:00am - 11:00am');
              });
              it('truncates an out-of-range start', () => {
                  let calendar = initCalendar({
                      events: [
                          {
                              title: 'event 1',
                              start: '2016-08-18T07:00',
                              end: '2016-08-21T11:00',
                          },
                      ],
                  });
                  let viewWrapper = new ListViewWrapper(calendar);
                  let events = viewWrapper.getEventInfo();
                  expect(events.length).toBe(3);
                  expect(events[0].title).toBe('event 1');
                  expect(events[0].timeText).toBe('7:00am - 12:00am');
                  expect(events[1].title).toBe('event 1');
                  expect(events[1].timeText).toBe('all-day');
                  expect(events[2].title).toBe('event 1');
                  expect(events[2].timeText).toBe('all-day');
              });
          });
          it('renders same days when equal to nextDayThreshold', () => {
              let calendar = initCalendar({
                  nextDayThreshold: '09:00',
                  events: [
                      {
                          title: 'event 1',
                          start: '2016-08-15T07:00',
                          end: '2016-08-17T09:00',
                      },
                  ],
              });
              let viewWrapper = new ListViewWrapper(calendar);
              let events = viewWrapper.getEventInfo();
              expect(events.length).toBe(3);
              expect(events[0].title).toBe('event 1');
              expect(events[0].timeText).toBe('7:00am - 12:00am');
              expect(events[1].title).toBe('event 1');
              expect(events[1].timeText).toBe('all-day');
              expect(events[2].title).toBe('event 1');
              expect(events[2].timeText).toBe('12:00am - 9:00am');
          });
          it('renders fewer days when before nextDayThreshold', () => {
              let calendar = initCalendar({
                  nextDayThreshold: '09:00',
                  events: [
                      {
                          title: 'event 1',
                          start: '2016-08-15T07:00',
                          end: '2016-08-17T08:00',
                      },
                  ],
              });
              let viewWrapper = new ListViewWrapper(calendar);
              let events = viewWrapper.getEventInfo();
              expect(events.length).toBe(2);
              expect(events[0].title).toBe('event 1');
              expect(events[0].timeText).toBe('7:00am - 12:00am');
              expect(events[1].title).toBe('event 1');
              expect(events[1].timeText).toBe('12:00am - 8:00am');
          });
      });
      describe('when an event has no title', () => {
          it('renders no text for its title', () => {
              let calendar = initCalendar({
                  events: [
                      {
                          start: '2016-08-15',
                      },
                  ],
              });
              let viewWrapper = new ListViewWrapper(calendar);
              let events = viewWrapper.getEventInfo();
              expect(events.length).toBe(1);
              expect(events[0].title).toBe('');
              expect(events[0].timeText).toBe('all-day');
          });
      });
      describe('when no events', () => {
          it('renders an empty message', () => {
              let calendar = initCalendar();
              let viewWrapper = new ListViewWrapper(calendar);
              expect(viewWrapper.hasEmptyMessage()).toBe(true);
          });
      });
      describe('with lots of events', () => {
          pushOptions({
              now: '2016-08-29',
              events: [
                  {
                      title: 'All Day Event',
                      start: '2016-08-29',
                  },
                  {
                      title: 'Long Event',
                      start: '2016-08-28',
                      end: '2016-09-04',
                  },
                  {
                      title: 'Meeting',
                      start: '2016-08-29T10:30:00',
                  },
                  {
                      title: 'Lunch',
                      start: '2016-08-30T12:00:00',
                  },
                  {
                      title: 'Meeting',
                      start: '2016-08-30T14:30:00',
                  },
                  {
                      title: 'Happy Hour',
                      start: '2014-11-12T17:30:00',
                  },
                  {
                      title: 'Dinner',
                      start: '2014-11-12T20:00:00',
                  },
                  {
                      title: 'Birthday Party',
                      start: '2016-08-29T07:00:00',
                  },
                  {
                      title: 'Click for Google',
                      url: 'http://google.com/',
                      start: '2016-08-31',
                  },
              ],
          });
          it('sorts events correctly', () => {
              let calendar = initCalendar();
              let viewWrapper = new ListViewWrapper(calendar);
              let days = viewWrapper.getDayInfo();
              let events = viewWrapper.getEventInfo();
              expect(days.length).toBe(7);
              expect(days[0].date).toEqualDate('2016-08-28');
              expect(days[1].date).toEqualDate('2016-08-29');
              expect(days[2].date).toEqualDate('2016-08-30');
              expect(days[3].date).toEqualDate('2016-08-31');
              expect(days[4].date).toEqualDate('2016-09-01');
              expect(days[5].date).toEqualDate('2016-09-02');
              expect(days[6].date).toEqualDate('2016-09-03');
              expect(events.length).toBe(13);
              expect(events[0].title).toBe('Long Event');
              expect(events[0].timeText).toBe('all-day');
              expect(events[1].title).toBe('Long Event');
              expect(events[1].timeText).toBe('all-day');
              expect(events[2].title).toBe('All Day Event');
              expect(events[2].timeText).toBe('all-day');
              expect(events[3].title).toBe('Birthday Party');
              expect(events[3].timeText).toBe('7:00am');
              expect(events[4].title).toBe('Meeting');
              expect(events[4].timeText).toBe('10:30am');
              expect(events[5].title).toBe('Long Event');
              expect(events[5].timeText).toBe('all-day');
              expect(events[6].title).toBe('Lunch');
              expect(events[6].timeText).toBe('12:00pm');
              expect(events[7].title).toBe('Meeting');
              expect(events[7].timeText).toBe('2:30pm');
              expect(events[8].title).toBe('Long Event');
              expect(events[8].timeText).toBe('all-day');
              expect(events[9].title).toBe('Click for Google');
              expect(events[9].timeText).toBe('all-day');
              expect(events[10].title).toBe('Long Event');
              expect(events[10].timeText).toBe('all-day');
              expect(events[11].title).toBe('Long Event');
              expect(events[11].timeText).toBe('all-day');
              expect(events[12].title).toBe('Long Event');
              expect(events[12].timeText).toBe('all-day');
          });
          it('can sort events with non-date property first', () => {
              let calendar = initCalendar({
                  now: '2016-08-29',
                  eventOrder: 'title',
                  events: [
                      {
                          title: 'Sup',
                          start: '2016-08-29T00:00:00',
                      },
                      {
                          title: 'Dude',
                          start: '2016-08-29T10:30:00',
                      },
                      {
                          title: 'Hello',
                          start: '2016-08-30',
                      },
                  ],
              });
              let viewWrapper = new ListViewWrapper(calendar);
              let days = viewWrapper.getDayInfo();
              let events = viewWrapper.getEventInfo();
              expect(days.length).toBe(2);
              expect(days[0].date).toEqualDate('2016-08-29');
              expect(days[1].date).toEqualDate('2016-08-30');
              expect(events.length).toBe(3);
              expect(events[0].title).toBe('Dude');
              expect(events[1].title).toBe('Sup');
              expect(events[2].title).toBe('Hello');
          });
          it('makes scrollbars', () => {
              let $el = $('<div style="width:300px" />').appendTo('body');
              let calendar = initCalendar({ headerToolbar: false }, $el);
              let viewWrapper = new ListViewWrapper(calendar);
              let scrollEl = viewWrapper.getScrollerEl();
              expect(scrollEl.scrollHeight).toBeGreaterThan(scrollEl.clientHeight + 100);
              $el.remove();
          });
          it('doesn\'t have scrollbars when height is \'auto\'', () => {
              let $el = $('<div style="width:300px" />').appendTo('body');
              let calendar = initCalendar({
                  headerToolbar: false,
                  height: 'auto',
              }, $el);
              let viewWrapper = new ListViewWrapper(calendar);
              let scrollEl = viewWrapper.getScrollerEl();
              expect(Math.abs(scrollEl.scrollHeight - scrollEl.clientHeight)).toBeLessThan(2);
              $el.remove();
          });
      });
      it('updates rendered events despite fetch range being lazy', () => {
          let calendar = initCalendar({
              now: '2016-09-12',
              initialView: 'dayGridMonth',
              events: [
                  { title: 'event1', start: '2016-09-12' },
              ],
          });
          calendar.changeView('listWeek');
          let viewWrapper = new ListViewWrapper(calendar);
          expect(viewWrapper.getEventEls().length).toBe(1);
          calendar.prev();
          expect(viewWrapper.getEventEls().length).toBe(0);
      });
  });

  const IGNORED_EVENTS = {
      load: true, // ignore when jQuery detaches the load event from the window
  };
  class ListenerCounter {
      constructor(el) {
          this.delta = 0;
          this.jQueryStartCount = 0;
          this.el = el;
      }
      startWatching() {
          // eslint-disable-next-line @typescript-eslint/no-this-alias
          let t = this;
          let el = t.el;
          let origAddEventListened = el.addEventListener;
          let origRemoveEventListener = el.removeEventListener;
          el.addEventListener = (eventName, ...otherArgs) => {
              if (!IGNORED_EVENTS[eventName]) {
                  t.delta += 1;
              }
              return origAddEventListened.call(el, eventName, ...otherArgs);
          };
          el.removeEventListener = (eventName, ...otherArgs) => {
              if (!IGNORED_EVENTS[eventName]) {
                  t.delta -= 1;
              }
              return origRemoveEventListener.call(el, eventName, ...otherArgs);
          };
          this.jQueryStartCount = countJqueryListeners(el);
      }
      stopWatching() {
          delete this.el.addEventListener;
          delete this.el.removeEventListener;
          return this.computeDelta();
      }
      computeDelta() {
          return this.delta + (countJqueryListeners(this.el) - this.jQueryStartCount);
      }
  }
  function countJqueryListeners(el) {
      let hash = getJqueryHandlerHash(el);
      let cnt = 0;
      $.each(hash, (name, handlers) => {
          cnt += handlers.length;
      });
      return cnt;
  }
  function getJqueryHandlerHash(el) {
      return $._data($(el)[0], 'events') || {};
  }

  describe('external drag and drop with jquery UI', () => {
      pushOptions({
          plugins: [index$b, index$9, index$a],
          initialDate: '2014-08-23',
          initialView: 'dayGridMonth',
          droppable: true,
      });
      // TODO: fill out tests for droppable/drop, with RTL
      let thirdPartyDraggable;
      beforeEach(() => {
          $('body').append('<div id="sidebar" style="width:200px">' +
              `<a class="${CalendarWrapper.EVENT_CLASSNAME} event1">event 1</a>` +
              `<a class="${CalendarWrapper.EVENT_CLASSNAME} event2">event 2</a>` +
              '</div>' +
              '<div id="cal" style="width:600px;position:absolute;top:10px;left:220px" />');
          thirdPartyDraggable = new ThirdPartyDraggable({
              itemSelector: `#sidebar .${CalendarWrapper.EVENT_CLASSNAME}`,
          });
      });
      afterEach(() => {
          $('#sidebar').remove();
          $('#cal').remove();
          thirdPartyDraggable.destroy();
      });
      function initCalendarInContainer(options = {}) {
          return initCalendar(options, $('#cal')[0]);
      }
      describeValues({
          'with draggable': () => $('#sidebar a').draggable(),
          'with sortable': () => $('#sidebar').sortable(),
      }, (initDnd) => {
          describe('in month view', () => {
              pushOptions({
                  initialView: 'dayGridMonth',
              });
              it('works after the view is changed', (done) => {
                  let callCnt = 0;
                  let dayGridWrapper;
                  let calendar = initCalendarInContainer({
                      drop(arg) {
                          if (callCnt === 0) {
                              expect(arg.date).toEqualDate('2014-08-06');
                              calendar.next();
                              calendar.prev();
                              setTimeout(() => {
                                  $('#sidebar .event1').remove();
                                  $('#sidebar .event2').simulate('drag', {
                                      end: dayGridWrapper.getDayEl('2014-08-06'),
                                  });
                              }, 0);
                          }
                          else if (callCnt === 1) {
                              expect(arg.date).toEqualDate('2014-08-06');
                              setTimeout(done); // weird
                          }
                          callCnt += 1;
                      },
                  });
                  dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  initDnd();
                  setTimeout(() => {
                      $('#sidebar .event1').simulate('drag', {
                          end: dayGridWrapper.getDayEl('2014-08-06'),
                      });
                  });
              });
              describe('dropAccept', () => {
                  it('works with a className that does match', (done) => {
                      let options = {
                          dropAccept: '.event1',
                          drop() { },
                      };
                      spyOn(options, 'drop').and.callThrough();
                      let calendar = initCalendarInContainer(options);
                      let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                      initDnd();
                      setTimeout(() => {
                          $('#sidebar .event1').simulate('drag', {
                              end: dayGridWrapper.getDayEl('2014-08-06'),
                              callback() {
                                  expect(options.drop).toHaveBeenCalled();
                                  done();
                              },
                          });
                      });
                  });
                  it('prevents a classNames that doesn\'t match', (done) => {
                      let options = {
                          dropAccept: '.event2',
                          drop() { },
                      };
                      spyOn(options, 'drop').and.callThrough();
                      let calendar = initCalendarInContainer(options);
                      let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                      initDnd();
                      setTimeout(() => {
                          $('#sidebar .event1').simulate('drag', {
                              end: dayGridWrapper.getDayEl('2014-08-06'),
                              callback() {
                                  expect(options.drop).not.toHaveBeenCalled();
                                  done();
                              },
                          });
                      });
                  });
                  it('works with a filter function that returns true', (done) => {
                      let options = {
                          dropAccept(el) {
                              expect(el instanceof HTMLElement).toBe(true);
                              return true;
                          },
                          drop() { },
                      };
                      spyOn(options, 'drop').and.callThrough();
                      let calendar = initCalendarInContainer(options);
                      let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                      initDnd();
                      setTimeout(() => {
                          $('#sidebar .event1').simulate('drag', {
                              end: dayGridWrapper.getDayEl('2014-08-06'),
                              callback() {
                                  expect(options.drop).toHaveBeenCalled();
                                  done();
                              },
                          });
                      });
                  });
                  it('prevents a drop with a filter function that returns false', (done) => {
                      let options = {
                          dropAccept(el) {
                              expect(el instanceof HTMLElement).toBe(true);
                              return false;
                          },
                          drop() { },
                      };
                      spyOn(options, 'drop').and.callThrough();
                      let calendar = initCalendarInContainer(options);
                      let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                      initDnd();
                      setTimeout(() => {
                          $('#sidebar .event1').simulate('drag', {
                              end: dayGridWrapper.getDayEl('2014-08-06'),
                              callback() {
                                  expect(options.drop).not.toHaveBeenCalled();
                                  done();
                              },
                          });
                      });
                  });
              });
          });
          describe('in timeGrid view', () => {
              pushOptions({
                  initialView: 'timeGridWeek',
                  dragScroll: false,
                  scrollTime: '00:00:00',
              });
              it('works after the view is changed', (done) => {
                  let callCnt = 0;
                  let timeGridWrapper;
                  let calendar = initCalendarInContainer({
                      drop(arg) {
                          if (callCnt === 0) {
                              expect(arg.date).toEqualDate('2014-08-20T01:00:00Z');
                              currentCalendar.next();
                              currentCalendar.prev();
                              setTimeout(() => {
                                  $('#sidebar .event1').remove();
                                  $('#sidebar .event2').simulate('drag', {
                                      end: timeGridWrapper.getPoint('2014-08-20T01:00:00'),
                                  });
                              }, 0);
                          }
                          else if (callCnt === 1) {
                              expect(arg.date).toEqualDate('2014-08-20T01:00:00Z');
                              setTimeout(done); // weird
                          }
                          callCnt += 1;
                      },
                  });
                  timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                  initDnd();
                  setTimeout(() => {
                      $('#sidebar .event1').simulate('drag', {
                          end: timeGridWrapper.getPoint('2014-08-20T01:00:00'),
                      });
                  });
              });
              it('works with timezone as "local"', (done) => {
                  let calendar = initCalendarInContainer({
                      timeZone: 'local',
                      drop(arg) {
                          expect(arg.date).toEqualLocalDate('2014-08-20T01:00:00');
                          done();
                      },
                  });
                  let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                  initDnd();
                  setTimeout(() => {
                      $('#sidebar .event1').simulate('drag', {
                          end: timeGridWrapper.getPoint('2014-08-20T01:00:00'),
                      });
                  });
              });
              it('works with timezone as "UTC"', (done) => {
                  let calendar = initCalendarInContainer({
                      timeZone: 'UTC',
                      drop(arg) {
                          expect(arg.date).toEqualDate('2014-08-20T01:00:00Z');
                          done();
                      },
                  });
                  let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                  initDnd();
                  setTimeout(() => {
                      $('#sidebar .event1').simulate('drag', {
                          end: timeGridWrapper.getPoint('2014-08-20T01:00:00'),
                      });
                  });
              });
              describe('dropAccept', () => {
                  it('works with a className that does match', (done) => {
                      let options = {
                          dropAccept: '.event1',
                          drop() { },
                      };
                      spyOn(options, 'drop').and.callThrough();
                      let calendar = initCalendarInContainer(options);
                      let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                      initDnd();
                      setTimeout(() => {
                          $('#sidebar .event1').simulate('drag', {
                              end: timeGridWrapper.getPoint('2014-08-20T01:00:00'),
                              callback() {
                                  expect(options.drop).toHaveBeenCalled();
                                  done();
                              },
                          });
                      });
                  });
                  it('prevents a classNames that doesn\'t match', (done) => {
                      let options = {
                          dropAccept: '.event2',
                          drop() { },
                      };
                      spyOn(options, 'drop').and.callThrough();
                      let calendar = initCalendarInContainer(options);
                      let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                      initDnd();
                      setTimeout(() => {
                          $('#sidebar .event1').simulate('drag', {
                              end: timeGridWrapper.getPoint('2014-08-20T01:00:00'),
                              callback() {
                                  expect(options.drop).not.toHaveBeenCalled();
                                  done();
                              },
                          });
                      });
                  });
                  it('works with a filter function that returns true', (done) => {
                      let options = {
                          dropAccept(el) {
                              expect(el instanceof HTMLElement).toBe(true);
                              return true;
                          },
                          drop() { },
                      };
                      spyOn(options, 'drop').and.callThrough();
                      let calendar = initCalendarInContainer(options);
                      let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                      initDnd();
                      setTimeout(() => {
                          $('#sidebar .event1').simulate('drag', {
                              end: timeGridWrapper.getPoint('2014-08-20T01:00:00'),
                              callback() {
                                  expect(options.drop).toHaveBeenCalled();
                                  done();
                              },
                          });
                      });
                  });
                  it('prevents a drop with a filter function that returns false', (done) => {
                      let options = {
                          dropAccept(el) {
                              expect(el instanceof HTMLElement).toBe(true);
                              return false;
                          },
                          drop() { },
                      };
                      spyOn(options, 'drop').and.callThrough();
                      let calendar = initCalendarInContainer(options);
                      let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                      initDnd();
                      setTimeout(() => {
                          $('#sidebar .event1').simulate('drag', {
                              end: timeGridWrapper.getPoint('2014-08-20T01:00:00'),
                              callback() {
                                  expect(options.drop).not.toHaveBeenCalled();
                                  done();
                              },
                          });
                      });
                  });
              });
          });
          // Issue 2433
          it('should not have drag handlers cleared when other calendar navigates', () => {
              let calendar0 = initCalendarInContainer();
              initDnd();
              let el0 = calendar0.el;
              let $el1 = $('<div id="calendar2">').insertAfter(el0);
              let calendar1 = new Calendar($el1[0], getCurrentOptions());
              calendar1.render();
              let docListenerCounter = new ListenerCounter(document);
              docListenerCounter.startWatching();
              calendar0.next();
              expect(docListenerCounter.stopWatching()).toBe(0);
              calendar1.destroy();
              $el1.remove();
          });
      });
      // https://github.com/fullcalendar/fullcalendar/issues/2926
      it('gives a mouseup event to the drop handler', (done) => {
          let options = {
              drop(info) {
                  expect(info.jsEvent.type).toBe('mouseup');
              },
          };
          spyOn(options, 'drop').and.callThrough();
          let calendar = initCalendarInContainer(options);
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          setTimeout(() => {
              $('#sidebar .event1').draggable().simulate('drag', {
                  end: dayGridWrapper.getDayEl('2014-08-06'),
                  callback() {
                      expect(options.drop).toHaveBeenCalled();
                      done();
                  },
              });
          });
      });
  });

  describe('now', () => {
      pushOptions({
          initialDate: '2014-05-01',
      });
      describe('when month view', () => {
          pushOptions({
              initialView: 'dayGridMonth',
          });
          it('changes the highlighted day when customized', () => {
              let calendar = initCalendar({
                  now: '2014-05-06',
              });
              expectRenderedTodayDate(calendar, '2014-05-06');
          });
      });
      describe('when week view', () => {
          pushOptions({
              initialView: 'timeGridWeek',
          });
          it('changes the highlighted day when customized', () => {
              let calendar = initCalendar({
                  now: '2014-04-29T12:00:00',
              });
              expectRenderedTodayDate(calendar, '2014-04-29');
          });
      });
      it('accepts a function that returns a Date', () => {
          let calendar = initCalendar({
              initialView: 'dayGridMonth',
              now() {
                  return parseUtcDate('2014-05-01');
              },
          });
          expectRenderedTodayDate(calendar, '2014-05-01');
      });
      it('accepts a function that returns a date string', () => {
          let calendar = initCalendar({
              initialView: 'dayGridMonth',
              now() {
                  return '2014-05-01';
              },
          });
          expectRenderedTodayDate(calendar, '2014-05-01');
      });
      function expectRenderedTodayDate(calendar, expectedDate) {
          let calendarWrapper = new CalendarWrapper(calendar);
          let todayCell = calendarWrapper.getTodayEls()[0];
          let todayDate = todayCell.getAttribute('data-date');
          expect(todayDate).toEqual(expectedDate);
      }
  });

  describe('refetchEvents', () => {
      // there IS a similar test in automated-better, but does month view
      describe('when timeGrid events are rerendered', () => {
          it('keeps scroll after refetchEvents', (done) => {
              let calendar = initCalendar({
                  now: '2015-08-07',
                  scrollTime: '00:00',
                  height: 400,
                  initialView: 'timeGridDay',
                  events(arg, callback) {
                      setTimeout(() => {
                          callback([
                              { id: '1', resourceId: 'b', start: '2015-08-07T02:00:00', end: '2015-08-07T07:00:00', title: 'event 1' },
                              { id: '2', resourceId: 'c', start: '2015-08-07T05:00:00', end: '2015-08-07T22:00:00', title: 'event 2' },
                              { id: '3', resourceId: 'd', start: '2015-08-06', end: '2015-08-08', title: 'event 3' },
                              { id: '4', resourceId: 'e', start: '2015-08-07T03:00:00', end: '2015-08-07T08:00:00', title: 'event 4' },
                              { id: '5', resourceId: 'f', start: '2015-08-07T00:30:00', end: '2015-08-07T02:30:00', title: 'event 5' },
                          ]);
                      }, 100);
                  },
              });
              setTimeout(() => {
                  let viewWrapper = new TimeGridViewWrapper(calendar);
                  let scrollEl = viewWrapper.getScrollerEl();
                  scrollEl.scrollTop = 100;
                  setTimeout(() => {
                      currentCalendar.refetchEvents();
                      setTimeout(() => {
                          expect(scrollEl.scrollTop).toBe(100);
                          done();
                      }, 100);
                  }, 100);
              }, 101); // after the fetch
          });
      });
      describe('when there are multiple event sources', () => {
          let fetchCount; // affects events created in createEventGenerator
          let eventSources;
          pushOptions({
              now: '2015-08-07',
              initialView: 'timeGridWeek',
          });
          beforeEach(() => {
              fetchCount = 0;
              eventSources = [
                  {
                      events: createEventGenerator(),
                      color: 'green',
                      id: 'source1',
                  },
                  {
                      events: createEventGenerator(),
                      color: 'blue',
                      id: 'source2',
                  },
                  {
                      events: createEventGenerator(),
                      color: 'red',
                      id: 'source3',
                  },
              ];
          });
          describe('and all events are fetched synchronously', () => {
              it('all events are immediately updated', (done) => {
                  initCalendar({ eventSources });
                  fetchCount += 1;
                  currentCalendar.refetchEvents();
                  expect($('.fetch0').length).toEqual(0);
                  expect($('.fetch1').length).toEqual(3);
                  done();
              });
          });
          describe('and one event source is asynchronous', () => {
              it('original events remain on the calendar until all events have been refetched', (done) => {
                  // set a 100ms timeout on this event source
                  eventSources[0].events = (arg, callback) => {
                      let events = [
                          { id: '1',
                              start: '2015-08-07T02:00:00',
                              end: '2015-08-07T03:00:00',
                              title: 'event A',
                              className: 'fetch' + fetchCount },
                      ];
                      setTimeout(() => {
                          callback(events);
                      }, 100);
                  };
                  initCalendar({
                      eventSources,
                  });
                  setTimeout(() => {
                      fetchCount += 1;
                      currentCalendar.refetchEvents();
                      expect($('.fetch0').length).toEqual(3); // original events still on the calendar
                      expect($('.fetch1').length).toEqual(0); // new events not yet refetched
                      setTimeout(() => {
                          expect($('.fetch0').length).toEqual(0);
                          expect($('.fetch1').length).toEqual(3);
                          done();
                      }, 101);
                  }, 101);
              });
          });
          // relies on fetchCount
          function createEventGenerator() {
              return (arg, callback) => {
                  let events = [
                      {
                          id: 1,
                          start: '2015-08-07T02:00:00',
                          end: '2015-08-07T03:00:00',
                          title: 'event A',
                          className: 'fetch' + fetchCount,
                      },
                  ];
                  callback(events);
              };
          }
      });
  });

  describe('slotLabelFormat', () => {
      pushOptions({
          initialDate: '2014-06-04',
          initialView: 'timeGridWeek',
      });
      it('renders correctly when default', () => {
          let calendar = initCalendar();
          expectAxisText(calendar, '12am');
      });
      it('renders correctly when default and the locale is customized', () => {
          let calendar = initCalendar({
              locale: l20,
          });
          expectAxisText(calendar, '00');
      });
      it('renders correctly when customized', () => {
          let calendar = initCalendar({
              slotLabelFormat: { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false },
              locale: 'en-GB', // for 00:00 instead of 24:00
          });
          expectAxisText(calendar, '00:00:00');
      });
      function expectAxisText(calendar, expectedText) {
          let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
          let axisTexts = timeGridWrapper.getAxisTexts();
          expect(axisTexts[0]).toBe(expectedText);
      }
  });

  describe('forceEventDuration', () => {
      pushOptions({
          initialDate: '2014-05-01',
          initialView: 'dayGridMonth',
      });
      describe('when turned off', () => {
          pushOptions({
              forceEventDuration: false,
          });
          it('allows a null end date for all-day and timed events', () => {
              initCalendar({
                  events: [
                      {
                          id: '1',
                          start: '2014-05-10',
                      },
                      {
                          id: '2',
                          start: '2014-05-10T14:00:00',
                      },
                  ],
              });
              let events = currentCalendar.getEvents();
              expect(events[0].end).toBeNull();
              expect(events[1].end).toBeNull();
          });
      });
      describe('when turned on', () => {
          pushOptions({
              forceEventDuration: true,
          });
          it('allows a null end date for all-day and timed events', () => {
              initCalendar({
                  events: [
                      {
                          id: '1',
                          start: '2014-05-10',
                      },
                      {
                          id: '2',
                          start: '2014-05-10T14:00:00',
                      },
                  ],
              });
              let events = currentCalendar.getEvents();
              expect(events[0].id).toEqual('1');
              expect(events[0].end instanceof Date).toEqual(true);
              expect(events[1].id).toEqual('2');
              expect(events[1].end instanceof Date).toEqual(true);
          });
      });
      // NOTE: the actual verification of the correct calculation of the end
      // (using defaultTimedEventDuration and defaultAllDayEventDuration)
      // is done in those test files.
  });

  describe('eventResize', () => {
      pushOptions({
          initialDate: '2014-06-11',
          editable: true,
          longPressDelay: 100,
          scrollTime: 0,
      });
      describe('when in month view', () => {
          pushOptions({
              initialView: 'dayGridMonth',
          });
          describe('when resizing an all-day event with mouse', () => {
              it('should have correct arguments with a whole-day delta', (done) => {
                  let calendar = initCalendar({
                      events: [{
                              title: 'all-day event',
                              start: '2014-06-11',
                              allDay: true,
                          }],
                  });
                  checkCalendarTriggers(calendar);
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  let resizing = dayGridWrapper.resizeEvent(dayGridWrapper.getFirstEventEl(), '2014-06-11', '2014-06-16');
                  waitEventResize2(calendar, resizing).then((arg) => {
                      expect(arg.endDelta).toEqual(createDuration({ day: 5 }));
                      expect(arg.event.start).toEqualDate('2014-06-11');
                      expect(arg.event.end).toEqualDate('2014-06-17');
                      arg.revert();
                      let event = calendar.getEvents()[0];
                      expect(event.start).toEqualDate('2014-06-11');
                      expect(event.end).toBeNull();
                      done();
                  });
              });
          });
          describe('when resizing an all-day event via touch', () => {
              // for https://github.com/fullcalendar/fullcalendar/issues/3118
              [true, false].forEach((eventStartEditable) => {
                  describe('when eventStartEditable is ' + eventStartEditable, () => {
                      pushOptions({ eventStartEditable });
                      it('should have correct arguments with a whole-day delta', (done) => {
                          let calendar = initCalendar({
                              dragRevertDuration: 0,
                              events: [{
                                      title: 'all-day event',
                                      start: '2014-06-11',
                                      allDay: true,
                                  }],
                          });
                          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                          let resizing = dayGridWrapper.resizeEventTouch(dayGridWrapper.getFirstEventEl(), '2014-06-11', '2014-06-16');
                          waitEventResize2(calendar, resizing).then((arg) => {
                              expect(arg.endDelta).toEqual(createDuration({ day: 5 }));
                              expect(arg.event.start).toEqualDate('2014-06-11');
                              expect(arg.event.end).toEqualDate('2014-06-17');
                              arg.revert();
                              let event = calendar.getEvents()[0];
                              expect(event.start).toEqualDate('2014-06-11');
                              expect(event.end).toBeNull();
                              done();
                          });
                      });
                  });
              });
          });
          describe('when rendering a timed event', () => {
              it('should not have resize capabilities', () => {
                  initCalendar({
                      events: [{
                              title: 'timed event',
                              start: '2014-06-11T08:00:00',
                              allDay: false,
                          }],
                  });
                  expect($(`.${CalendarWrapper.EVENT_CLASSNAME} .${CalendarWrapper.EVENT_RESIZER_CLASSNAME}`)).not.toBeInDOM();
              });
          });
      });
      describe('when in timeGrid view', () => {
          pushOptions({
              initialView: 'timeGridWeek',
          });
          describe('when resizing an all-day event', () => {
              it('should have correct arguments with a whole-day delta', (done) => {
                  let calendar = initCalendar({
                      events: [{
                              title: 'all-day event',
                              start: '2014-06-11',
                              allDay: true,
                          }],
                  });
                  let dayGridWrapper = new TimeGridViewWrapper(calendar).dayGrid;
                  let resizing = dayGridWrapper.resizeEvent(dayGridWrapper.getFirstEventEl(), '2014-06-11', '2014-06-13');
                  waitEventResize2(calendar, resizing).then((arg) => {
                      expect(arg.endDelta).toEqual(createDuration({ day: 2 }));
                      expect(arg.event.start).toEqualDate('2014-06-11');
                      expect(arg.event.end).toEqualDate('2014-06-14');
                      arg.revert();
                      let event = calendar.getEvents()[0];
                      expect(event.start).toEqualDate('2014-06-11');
                      expect(event.end).toBeNull();
                      done();
                  });
              });
          });
          describe('when resizing a timed event with an end', () => {
              pushOptions({
                  events: [{
                          title: 'timed event event',
                          start: '2014-06-11T05:00:00',
                          end: '2014-06-11T07:00:00',
                          allDay: false,
                      }],
              });
              it('should have correct arguments with a timed delta', (done) => {
                  let calendar = initCalendar();
                  let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                  let resizing = timeGridWrapper.resizeEvent(timeGridWrapper.getFirstEventEl(), '2014-06-11T07:00:00', '2014-06-11T09:30:00');
                  waitEventResize2(calendar, resizing).then((arg) => {
                      expect(arg.endDelta).toEqual(createDuration({ hour: 2, minute: 30 }));
                      expect(arg.event.start).toEqualDate('2014-06-11T05:00:00Z');
                      expect(arg.event.end).toEqualDate('2014-06-11T09:30:00Z');
                      arg.revert();
                      let event = calendar.getEvents()[0];
                      expect(event.start).toEqualDate('2014-06-11T05:00:00Z');
                      expect(event.end).toEqualDate('2014-06-11T07:00:00Z');
                      done();
                  });
              });
              it('should have correct arguments with a timed delta via touch', (done) => {
                  let calendar = initCalendar({
                      dragRevertDuration: 0, // so that eventDragStop happens immediately after touchend
                  });
                  let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                  let resizing = timeGridWrapper.resizeEventTouch(timeGridWrapper.getFirstEventEl(), '2014-06-11T07:00:00Z', '2014-06-11T09:30:00Z');
                  waitEventResize2(calendar, resizing).then((arg) => {
                      expect(arg.endDelta).toEqual(createDuration({ hour: 2, minute: 30 }));
                      expect(arg.event.start).toEqualDate('2014-06-11T05:00:00Z');
                      expect(arg.event.end).toEqualDate('2014-06-11T09:30:00Z');
                      arg.revert();
                      let event = calendar.getEvents()[0];
                      expect(event.start).toEqualDate('2014-06-11T05:00:00Z');
                      expect(event.end).toEqualDate('2014-06-11T07:00:00Z');
                      done();
                  });
              });
              // TODO: test RTL
              it('should have correct arguments with a timed delta when resized to a different day', (done) => {
                  let calendar = initCalendar();
                  let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                  let resizing = timeGridWrapper.resizeEventTouch(timeGridWrapper.getFirstEventEl(), '2014-06-11T07:00:00Z', '2014-06-12T09:30:00Z');
                  waitEventResize2(calendar, resizing).then((arg) => {
                      expect(arg.endDelta).toEqual(createDuration({ day: 1, hour: 2, minute: 30 }));
                      expect(arg.event.start).toEqualDate('2014-06-11T05:00:00Z');
                      expect(arg.event.end).toEqualDate('2014-06-12T09:30:00Z');
                      arg.revert();
                      let event = calendar.getEvents()[0];
                      expect(event.start).toEqualDate('2014-06-11T05:00:00Z');
                      expect(event.end).toEqualDate('2014-06-11T07:00:00Z');
                      done();
                  });
              });
              it('should have correct arguments with a timed delta, when timezone is local', (done) => {
                  let calendar = initCalendar({
                      timeZone: 'local',
                  });
                  let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                  let resizing = timeGridWrapper.resizeEventTouch(timeGridWrapper.getFirstEventEl(), '2014-06-11T07:00:00', '2014-06-11T09:30:00');
                  waitEventResize2(calendar, resizing).then((arg) => {
                      expect(arg.endDelta).toEqual(createDuration({ hour: 2, minute: 30 }));
                      expect(arg.event.start).toEqualLocalDate('2014-06-11T05:00:00');
                      expect(arg.event.end).toEqualLocalDate('2014-06-11T09:30:00');
                      arg.revert();
                      let event = calendar.getEvents()[0];
                      expect(event.start).toEqualLocalDate('2014-06-11T05:00:00');
                      expect(event.end).toEqualLocalDate('2014-06-11T07:00:00');
                      done();
                  });
              });
              it('should have correct arguments with a timed delta, when timezone is UTC', (done) => {
                  let calendar = initCalendar({
                      timeZone: 'UTC',
                  });
                  let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                  let resizing = timeGridWrapper.resizeEventTouch(timeGridWrapper.getFirstEventEl(), '2014-06-11T07:00:00', '2014-06-11T09:30:00');
                  waitEventResize2(calendar, resizing).then((arg) => {
                      expect(arg.endDelta).toEqual(createDuration({ hour: 2, minute: 30 }));
                      expect(arg.event.start).toEqualDate('2014-06-11T05:00:00+00:00');
                      expect(arg.event.end).toEqualDate('2014-06-11T09:30:00+00:00');
                      arg.revert();
                      let event = calendar.getEvents()[0];
                      expect(event.start).toEqualDate('2014-06-11T05:00:00');
                      expect(event.end).toEqualDate('2014-06-11T07:00:00+00:00');
                      done();
                  });
              });
              it('should display the correct time text while resizing', (done) => {
                  let calendar = initCalendar();
                  let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                  let onBeforeReleaseCalled = false; // don't trust ourselves :(
                  timeGridWrapper.resizeEvent(timeGridWrapper.getFirstEventEl(), '2014-06-11T07:00:00Z', '2014-06-11T09:30:00Z', () => {
                      let $mirrorEls = $(timeGridWrapper.getMirrorEls());
                      expect($mirrorEls.length).toBe(1);
                      expect($mirrorEls.find('.' + CalendarWrapper.EVENT_TIME_CLASSNAME)).toHaveText('5:00 - 9:30');
                      onBeforeReleaseCalled = true;
                  }).then(() => {
                      expect(onBeforeReleaseCalled).toBe(true);
                      done();
                  });
              });
              it('should run the temporarily rendered event through eventDidMount', (done) => {
                  let calendar = initCalendar({
                      eventDidMount(arg) {
                          $(arg.el).addClass('eventDidRender');
                      },
                  });
                  let onBeforeReleaseCalled = false; // don't trust ourselves :(
                  let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                  timeGridWrapper.resizeEvent(timeGridWrapper.getFirstEventEl(), '2014-06-11T07:00:00Z', '2014-06-11T09:30:00Z', () => {
                      let $mirrorEls = $(timeGridWrapper.getMirrorEls());
                      expect($mirrorEls.length).toBe(1);
                      expect($mirrorEls).toHaveClass('eventDidRender');
                      onBeforeReleaseCalled = true;
                  }).then(() => {
                      expect(onBeforeReleaseCalled).toBe(true);
                      done();
                  });
              });
              it('should not fire the windowResize handler', (done) => {
                  // has to do this crap because PhantomJS was trigger false window resizes unrelated to the event resize
                  let isDragging = false;
                  let calledWhileDragging = false;
                  let calendar = initCalendar({
                      windowResizeDelay: 0,
                      windowResize(ev) {
                          if (isDragging) {
                              calledWhileDragging = true;
                          }
                      },
                  });
                  let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                  timeGridWrapper.resizeEvent(timeGridWrapper.getFirstEventEl(), '2014-06-11T07:00:00Z', '2014-06-11T09:30:00Z', () => {
                      isDragging = false;
                  }).then(() => {
                      expect(calledWhileDragging).toBe(false);
                      done();
                  });
              });
              // https://github.com/fullcalendar/fullcalendar/issues/7099
              it('should handle two consecutive resizes', (done) => {
                  let calendar = initCalendar();
                  let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                  timeGridWrapper.resizeEvent(timeGridWrapper.getFirstEventEl(), '2014-06-11T07:00:00Z', '2014-06-11T12:00:00Z').then(() => {
                      let event = calendar.getEvents()[0];
                      expect(event.end).toEqualDate('2014-06-11T12:00:00Z');
                      timeGridWrapper.resizeEvent(timeGridWrapper.getFirstEventEl(), '2014-06-11T12:00:00Z', '2014-06-11T09:00:00Z').then(() => {
                          event = calendar.getEvents()[0];
                          expect(event.end).toEqualDate('2014-06-11T09:00:00Z');
                          done();
                      });
                  });
              });
          });
          describe('when resizing a timed event without an end', () => {
              pushOptions({
                  defaultTimedEventDuration: '02:00',
                  events: [{
                          title: 'timed event event',
                          start: '2014-06-11T05:00:00',
                          allDay: false,
                      }],
              });
              // copied and pasted from other test :(
              it('should display the correct time text while resizing', (done) => {
                  let calendar = initCalendar();
                  let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                  let onBeforeReleaseCalled = false; // don't trust ourselves :(
                  timeGridWrapper.resizeEvent(timeGridWrapper.getFirstEventEl(), '2014-06-11T07:00:00Z', '2014-06-11T09:30:00Z', () => {
                      let $mirrorEls = $(timeGridWrapper.getMirrorEls());
                      expect($mirrorEls.length).toBe(1);
                      expect($mirrorEls.find('.' + CalendarWrapper.EVENT_TIME_CLASSNAME)).toHaveText('5:00 - 9:30');
                      onBeforeReleaseCalled = true;
                  }).then(() => {
                      expect(onBeforeReleaseCalled).toBe(true);
                      done();
                  });
              });
          });
      });
      function checkCalendarTriggers(calendar) {
          calendar.on('eventResizeStart', (arg) => {
              expect(arg.el instanceof Element).toBe(true);
              expect(typeof arg.event).toBe('object');
              expect(typeof arg.jsEvent).toBe('object');
              expect(typeof arg.view).toBe('object');
          });
          calendar.on('eventResizeStop', (arg) => {
              expect(arg.el instanceof Element).toBe(true);
              expect(typeof arg.event).toBe('object');
              expect(typeof arg.jsEvent).toBe('object');
              expect(typeof arg.view).toBe('object');
          });
          calendar.on('eventResize', (arg) => {
              expect(arg.el instanceof Element).toBe(true);
              expect(typeof arg.event).toBe('object');
              expect(typeof arg.startDelta).toBe('object');
              expect(typeof arg.endDelta).toBe('object');
              expect(typeof arg.revert).toBe('function');
              expect(typeof arg.jsEvent).toBe('object');
              expect(typeof arg.view).toBe('object');
          });
      }
  });

  describe('more-link popover', () => {
      pushOptions({
          initialView: 'dayGridMonth',
          initialDate: '2014-08-01',
          dayMaxEventRows: 3,
          events: [
              { title: 'event1', start: '2014-07-28', end: '2014-07-30', className: 'event1' },
              { title: 'event2', start: '2014-07-29', end: '2014-07-31', className: 'event2' },
              { title: 'event3', start: '2014-07-29', className: 'event3' },
              { title: 'event4', start: '2014-07-29', className: 'event4' },
          ],
          handleWindowResize: false, // because showing the popover causes scrollbars and fires resize
      });
      it('closes when user clicks the X and trigger eventWillUnmount for every render', (done) => {
          let eventsRendered = {};
          let renderCount = 0;
          let activated = false;
          let calendar = initCalendar({
              eventDidMount(arg) {
                  if (activated) {
                      eventsRendered[arg.event.title] = true;
                      renderCount += 1;
                  }
              },
              eventWillUnmount(arg) {
                  delete eventsRendered[arg.event.title];
                  renderCount -= 1;
              },
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          // Activate flags and pop event limit popover
          activated = true;
          dayGridWrapper.openMorePopover();
          setTimeout(() => {
              expect(dayGridWrapper.getMorePopoverEl()).toBeVisible();
              dayGridWrapper.closeMorePopover();
              setTimeout(() => {
                  expect(dayGridWrapper.getMorePopoverEl()).not.toBeVisible();
                  expect(Object.keys(eventsRendered).length).toEqual(0);
                  expect(renderCount).toEqual(0);
                  done();
              });
          });
      });
      it('closes when user clicks outside of the popover and trigger eventWillUnmount for every render', (done) => {
          let eventsRendered = {};
          let renderCount = 0;
          let activated = false;
          let calendar = initCalendar({
              eventDidMount(arg) {
                  if (activated) {
                      eventsRendered[arg.event.title] = true;
                      renderCount += 1;
                  }
              },
              eventWillUnmount(arg) {
                  delete eventsRendered[arg.event.title];
                  renderCount -= 1;
              },
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          // Activate flags and pop event limit popover
          activated = true;
          dayGridWrapper.openMorePopover();
          setTimeout(() => {
              expect(dayGridWrapper.getMorePopoverEl()).toBeVisible();
              $('body').simulate('mousedown').simulate('click');
              setTimeout(() => {
                  expect(dayGridWrapper.getMorePopoverEl()).not.toBeVisible();
                  expect(Object.keys(eventsRendered).length).toEqual(0);
                  expect(renderCount).toEqual(0);
                  done();
              });
          });
      });
  });

  describe('hiddenDays', () => {
      const DOW_CLASSNAMES = CalendarWrapper.DOW_CLASSNAMES;
      describe('when using default', () => {
          it('should show 7 days of the week', () => {
              let calendar = initCalendar();
              let headerWrapper = new DayGridViewWrapper(calendar).header;
              let daysCount = headerWrapper.getCellEls().length;
              expect(daysCount).toEqual(7);
          });
      });
      describe('when setting an empty hiddenDays', () => {
          pushOptions({
              hiddenDays: [],
          });
          it('should return 7 days of the week', () => {
              let calendar = initCalendar();
              let headerWrapper = new DayGridViewWrapper(calendar).header;
              let daysCount = headerWrapper.getCellEls().length;
              expect(daysCount).toEqual(7);
          });
      });
      describe('when setting hiddenDays with 1', () => {
          pushOptions({
              hiddenDays: [1],
          });
          it('should return 6 days', () => {
              let calendar = initCalendar();
              let headerWrapper = new DayGridViewWrapper(calendar).header;
              let daysCount = headerWrapper.getCellEls().length;
              expect(daysCount).toEqual(6);
          });
          it('should return sun,tue,wed,thu,fri,sat days', () => {
              let calendar = initCalendar();
              let headerWrapper = new DayGridViewWrapper(calendar).header;
              let dowEls = headerWrapper.getCellEls();
              expect(dowEls[0]).toHaveClass(DOW_CLASSNAMES[0]);
              expect(dowEls[1]).toHaveClass(DOW_CLASSNAMES[2]);
              expect(dowEls[2]).toHaveClass(DOW_CLASSNAMES[3]);
              expect(dowEls[3]).toHaveClass(DOW_CLASSNAMES[4]);
              expect(dowEls[4]).toHaveClass(DOW_CLASSNAMES[5]);
              expect(dowEls[5]).toHaveClass(DOW_CLASSNAMES[6]);
          });
          it('should expect 7th day to be undefined', () => {
              let calendar = initCalendar();
              let headerWrapper = new DayGridViewWrapper(calendar).header;
              let dowEls = headerWrapper.getCellEls();
              expect(dowEls[6]).toBeUndefined();
          });
      });
      describe('when setting hiddenDays with 3,5', () => {
          pushOptions({
              hiddenDays: [3, 5],
          });
          it('should return 6 days', () => {
              let calendar = initCalendar();
              let headerWrapper = new DayGridViewWrapper(calendar).header;
              let daysCount = headerWrapper.getCellEls().length;
              expect(daysCount).toEqual(5);
          });
          it('should return s,m,t,t,s ', () => {
              let calendar = initCalendar();
              let headerWrapper = new DayGridViewWrapper(calendar).header;
              let dowEls = headerWrapper.getCellEls();
              expect(dowEls[0]).toHaveClass(DOW_CLASSNAMES[0]);
              expect(dowEls[1]).toHaveClass(DOW_CLASSNAMES[1]);
              expect(dowEls[2]).toHaveClass(DOW_CLASSNAMES[2]);
              expect(dowEls[3]).toHaveClass(DOW_CLASSNAMES[4]);
              expect(dowEls[4]).toHaveClass(DOW_CLASSNAMES[6]);
          });
      });
      describe('when setting all hiddenDays', () => {
          it('should expect to throw an exception', () => {
              expect(() => {
                  initCalendar({
                      hiddenDays: [0, 1, 2, 3, 4, 5, 6],
                  });
              }).toThrow(new Error('invalid hiddenDays'));
          });
      });
  });

  describe('getEventSource', () => {
      pushOptions({
          now: '2015-08-07',
          initialView: 'timeGridWeek',
          eventSources: [
              {
                  events: [
                      { id: '1', start: '2015-08-07T02:00:00', end: '2015-08-07T03:00:00', title: 'event A' },
                  ],
                  id: 'source1',
              },
              {
                  events: [
                      { id: '2', start: '2015-08-07T03:00:00', end: '2015-08-07T04:00:00', title: 'event B' },
                  ],
                  id: 'source2',
              },
              {
                  events: [
                      { id: '3', start: '2015-08-07T04:00:00', end: '2015-08-07T05:00:00', title: 'event C' },
                  ],
                  id: 'source3',
              },
          ],
      });
      it('retreives the queried event source', (done) => {
          initCalendar();
          let eventSource1 = currentCalendar.getEventSourceById('source1');
          let eventSource2 = currentCalendar.getEventSourceById('source2');
          expect(eventSource1.id).toBe('source1');
          expect(eventSource2.id).toBe('source2');
          done();
      });
  });

  describe('moreLinkText', () => {
      pushOptions({
          initialDate: '2014-08-01',
          initialView: 'dayGridMonth',
          dayMaxEventRows: 3,
          events: [
              { title: 'event1', start: '2014-07-29' },
              { title: 'event2', start: '2014-07-29' },
              { title: 'event2', start: '2014-07-29' },
              { title: 'event2', start: '2014-07-29' },
          ],
      });
      it('allows a string', () => {
          let calendar = initCalendar({
              moreLinkText: 'extra',
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          expect(dayGridWrapper.getMoreEl()).toHaveText('+2 extra');
      });
      it('allows a function', () => {
          let calendar = initCalendar({
              moreLinkText(n) {
                  expect(typeof n).toBe('number');
                  return 'there are ' + n + ' more events!';
              },
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          expect(dayGridWrapper.getMoreEl()).toHaveText('there are 2 more events!');
      });
      it('has a default value that is affected by the custom locale', () => {
          let calendar = initCalendar({
              locale: l31,
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          expect(dayGridWrapper.getMoreEl()).toHaveText('+2 en plus');
      });
      it('is not affected by a custom locale when the value is explicitly specified', () => {
          let calendar = initCalendar({
              locale: l31,
              moreLinkText: 'extra',
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          expect(dayGridWrapper.getMoreEl()).toHaveText('+2 extra');
      });
  });

  describe('defaultTimedEventDuration', () => {
      pushOptions({
          initialDate: '2014-05-01',
          initialView: 'dayGridMonth',
          timeZone: 'UTC',
      });
      describe('when forceEventDuration is on', () => {
          pushOptions({
              forceEventDuration: true,
          });
          it('correctly calculates an unspecified end when using a Duration object input', () => {
              initCalendar({
                  defaultTimedEventDuration: { hours: 2, minutes: 30 },
                  events: [
                      {
                          allDay: false,
                          start: '2014-05-05T04:00:00',
                      },
                  ],
              });
              let event = currentCalendar.getEvents()[0];
              expect(event.end).toEqualDate('2014-05-05T06:30:00Z');
          });
          it('correctly calculates an unspecified end when using a string Duration input', () => {
              initCalendar({
                  defaultTimedEventDuration: '03:15:00',
                  events: [
                      {
                          allDay: false,
                          start: '2014-05-05T04:00:00',
                      },
                  ],
              });
              let event = currentCalendar.getEvents()[0];
              expect(event.end).toEqualDate('2014-05-05T07:15:00Z');
          });
      });
      describe('when forceEventDuration is off', () => {
          pushOptions({
              forceEventDuration: false,
          });
          describe('with week view', () => {
              pushOptions({
                  initialView: 'timeGridWeek',
              });
              it('renders a timed event with no `end` to appear to have the default duration', () => {
                  let calendar = initCalendar({
                      defaultTimedEventDuration: '01:15:00',
                      events: [
                          {
                              // a control. so we know how tall it should be
                              title: 'control event',
                              allDay: false,
                              start: '2014-05-01T04:00:00',
                              end: '2014-05-01T05:15:00',
                          },
                          {
                              // one day after the control. no specified end
                              title: 'test event',
                              allDay: false,
                              start: '2014-05-02T04:00:00',
                          },
                      ],
                  });
                  let calendarWrapper = new CalendarWrapper(calendar);
                  let eventElms = calendarWrapper.getEventEls();
                  let height0 = eventElms[0].offsetHeight;
                  let height1 = eventElms[1].offsetHeight;
                  expect(height0).toBeGreaterThan(0);
                  expect(height0).toEqual(height1);
              });
          });
          describe('with dayGridWeek view', () => {
              pushOptions({
                  initialView: 'dayGridWeek',
              });
              it('renders a timed event with no `end` to appear to have the default duration', () => {
                  let calendar = initCalendar({
                      defaultTimedEventDuration: { days: 2 },
                      events: [
                          {
                              // a control. so we know how wide it should be
                              title: 'control event',
                              allDay: false,
                              start: '2014-04-28T04:00:00',
                              end: '2014-04-30T04:00:00',
                          },
                          {
                              // one day after the control. no specified end
                              title: 'test event',
                              allDay: false,
                              start: '2014-04-28T04:00:00',
                          },
                      ],
                  });
                  let calendarWrapper = new CalendarWrapper(calendar);
                  let eventElms = calendarWrapper.getEventEls();
                  let width0 = eventElms[0].offsetWidth;
                  let width1 = eventElms[1].offsetWidth;
                  expect(width0).toBeGreaterThan(0);
                  expect(width0).toEqual(width1);
              });
          });
      });
  });

  describe('header navigation', () => {
      pushOptions({
          headerToolbar: {
              left: 'next,prev,prevYear,nextYear today',
              center: '',
              right: 'title',
          },
      });
      describe('and click next', () => {
          it('should change view to next month', (done) => {
              let calendar = initCalendar();
              calendar.gotoDate('2010-02-01');
              let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
              $(toolbarWrapper.getButtonEl('next')).simulate('click');
              setTimeout(() => {
                  let newDate = calendar.getDate();
                  expect(newDate).toEqualDate('2010-03-01');
                  done();
              });
          });
      });
      describe('and click prev', () => {
          it('should change view to prev month', (done) => {
              let calendar = initCalendar();
              calendar.gotoDate('2010-02-01');
              let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
              $(toolbarWrapper.getButtonEl('prev')).simulate('click');
              setTimeout(() => {
                  let newDate = calendar.getDate();
                  expect(newDate).toEqualDate('2010-01-01');
                  done();
              });
          });
      });
      describe('and click prevYear', () => {
          it('should change view to prev month', (done) => {
              let calendar = initCalendar();
              calendar.gotoDate('2010-02-01');
              let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
              $(toolbarWrapper.getButtonEl('prevYear')).simulate('click');
              setTimeout(() => {
                  let newDate = calendar.getDate();
                  expect(newDate).toEqualDate('2009-02-01');
                  done();
              });
          });
      });
      describe('and click nextYear', () => {
          it('should change view to prev month', (done) => {
              let calendar = initCalendar();
              calendar.gotoDate('2010-02-01');
              let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
              $(toolbarWrapper.getButtonEl('nextYear')).simulate('click');
              setTimeout(() => {
                  let newDate = calendar.getDate();
                  expect(newDate).toEqualDate('2011-02-01');
                  done();
              });
          });
      });
      describe('and click today', () => {
          it('should change view to prev month', (done) => {
              let calendar = initCalendar();
              calendar.gotoDate('2010-02-01');
              let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
              $(toolbarWrapper.getButtonEl('today')).simulate('click');
              setTimeout(() => {
                  let newDate = calendar.getDate(); // will be ambig zone
                  expect(newDate).toEqualNow();
                  done();
              });
          });
      });
  });

  describe('unselectAuto', () => {
      pushOptions({
          selectable: true,
          initialDate: '2014-12-25',
          initialView: 'dayGridMonth',
      });
      beforeEach(() => {
          $('<div id="otherthing" />').appendTo('body');
      });
      afterEach(() => {
          $('#otherthing').remove();
      });
      describe('when enabled', () => {
          pushOptions({
              unselectAuto: true,
          });
          describe('when clicking away', () => {
              it('unselects the current selection when clicking elsewhere in DOM', (done) => {
                  let isDone = false; // hack against dragging continuing after destroy
                  let dayGridWrapper;
                  let calendar = initCalendar({
                      unselect(arg) {
                          if (!isDone) {
                              expect(dayGridWrapper.getHighlightEls().length).toBe(0);
                              expect('currentTarget' in arg.jsEvent).toBe(true); // a JS event
                              expect(typeof arg.view).toBe('object');
                              isDone = true;
                              done();
                          }
                      },
                  });
                  dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  calendar.select('2014-12-01', '2014-12-03');
                  expect(dayGridWrapper.getHighlightEls().length).toBeGreaterThan(0);
                  $('#otherthing')
                      .simulate('mousedown')
                      .simulate('mouseup')
                      .simulate('click');
              });
          });
          describe('when clicking another date', () => {
              it('unselects the current selection when clicking elsewhere in DOM', (done) => {
                  let isDone = false; // hack against dragging continuing after destroy
                  let dayGridWrapper;
                  let calendar = initCalendar({
                      unselect(arg) {
                          if (!isDone) {
                              expect(dayGridWrapper.getHighlightEls().length).toBe(0);
                              expect('currentTarget' in arg.jsEvent).toBe(true); // a JS event
                              expect(typeof arg.view).toBe('object');
                              isDone = true;
                              done();
                          }
                      },
                  });
                  dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  calendar.select('2014-12-01', '2014-12-03');
                  expect(dayGridWrapper.getHighlightEls().length).toBeGreaterThan(0);
                  $(dayGridWrapper.getDayEl('2014-12-04')).simulate('drag');
              });
          });
      });
      describe('when disabled', () => {
          pushOptions({
              unselectAuto: false,
          });
          it('keeps current selection when clicking elsewhere in DOM', (done) => {
              let calendar = initCalendar();
              let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
              calendar.select('2014-12-01', '2014-12-03');
              expect(dayGridWrapper.getHighlightEls().length).toBeGreaterThan(0);
              $('#otherthing')
                  .simulate('mousedown')
                  .simulate('mouseup')
                  .simulate('click');
              setTimeout(() => {
                  expect(dayGridWrapper.getHighlightEls().length).toBeGreaterThan(0);
                  done();
              });
          });
      });
  });

  describe('slotMaxTime', () => {
      describe('when using the default settings', () => {
          describeOptions('initialView', {
              'in week': 'timeGridWeek',
              'in day': 'timeGridDay',
          }, () => {
              it('should start at 12am', () => {
                  let calendar = initCalendar({
                      initialView: 'timeGridWeek',
                  });
                  let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                  let lastMajor = timeGridWrapper.getLastMajorAxisInfo();
                  expect(lastMajor.text).toEqual('11pm');
              });
          });
      });
      describe('when using a whole number', () => {
          let hourNumbers = [12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24];
          describe('in week', () => {
              hourNumbers.forEach((hourNumber) => {
                  it('should end at ' + hourNumber, () => {
                      let calendar = initCalendar({
                          initialView: 'timeGridWeek',
                          slotMaxTime: { hours: hourNumber },
                      });
                      let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                      let lastMajor = timeGridWrapper.getLastMajorAxisInfo();
                      let expected = numToStringConverter(hourNumber - 1);
                      expect(lastMajor.text).toEqual(expected);
                  });
              });
          });
          describe('in day', () => {
              hourNumbers.forEach((hourNumber) => {
                  it('should end at ' + hourNumber, () => {
                      let calendar = initCalendar({
                          initialView: 'timeGridDay',
                          slotMaxTime: hourNumber + ':00', // in addition, test string duration input
                      });
                      let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                      let lastMajor = timeGridWrapper.getLastMajorAxisInfo();
                      let expected = numToStringConverter(hourNumber - 1);
                      expect(lastMajor.text).toEqual(expected);
                  });
              });
          });
      });
      describe('when using default slotInterval and \'uneven\' slotMaxTime', () => {
          let hourNumbers = [12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24];
          describe('in week', () => {
              hourNumbers.forEach((hourNumber) => {
                  it('should end at ' + hourNumber + ':20', () => {
                      let calendar = initCalendar({
                          initialView: 'timeGridWeek',
                          slotMaxTime: { hours: hourNumber, minutes: 20 },
                      });
                      let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                      let lastMajor = timeGridWrapper.getLastMajorAxisInfo();
                      // since exclusive end is :20, last slot will be on the current hour's 00:00
                      let expected = numToStringConverter(hourNumber);
                      expect(lastMajor.text).toEqual(expected);
                  });
              });
          });
          describe('in day', () => {
              hourNumbers.forEach((hourNumber) => {
                  it('should end at ' + hourNumber + ':20', () => {
                      let calendar = initCalendar({
                          initialView: 'timeGridDay',
                          slotMaxTime: { hours: hourNumber, minutes: 20 },
                      });
                      let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                      let lastMajor = timeGridWrapper.getLastMajorAxisInfo();
                      // since exclusive end is :20, last slot will be on the current hour's 00:00
                      let expected = numToStringConverter(hourNumber);
                      expect(lastMajor.text).toEqual(expected);
                  });
              });
          });
      });
      function numToStringConverter(timeIn) {
          let time = (timeIn % 12) || 12;
          let amPm = 'am';
          if ((timeIn % 24) > 11) {
              amPm = 'pm';
          }
          return time + amPm;
      }
  });

  describe('dayCellDidMount', () => {
      it('is triggered upon initialization of a view, with correct parameters', () => {
          let options = {
              initialView: 'dayGridMonth',
              fixedWeekCount: true,
              initialDate: '2014-05-01',
              dayCellDidMount(arg) {
                  expect(arg.date instanceof Date).toEqual(true);
                  expect(formatIsoDay(arg.date)).toEqual(arg.el.getAttribute('data-date'));
                  expect(arg.el instanceof HTMLElement).toBe(true);
              },
          };
          spyOn(options, 'dayCellDidMount').and.callThrough();
          initCalendar(options);
          expect(options.dayCellDidMount.calls.count()).toEqual(42);
      });
      it('is called when date range is changed', () => {
          let options = {
              initialView: 'dayGridWeek',
              initialDate: '2014-05-01',
              dayCellDidMount(arg) { },
          };
          spyOn(options, 'dayCellDidMount').and.callThrough();
          initCalendar(options);
          options.dayCellDidMount.calls.reset();
          currentCalendar.gotoDate('2014-05-04'); // a day in the next week
          expect(options.dayCellDidMount.calls.count()).toEqual(7);
      });
      it('won\'t be called when date is navigated but remains in the current visible range', () => {
          let options = {
              initialView: 'dayGridWeek',
              initialDate: '2014-05-01',
              dayCellDidMount(arg) { },
          };
          spyOn(options, 'dayCellDidMount').and.callThrough();
          initCalendar(options);
          options.dayCellDidMount.calls.reset();
          currentCalendar.gotoDate('2014-05-02'); // a day in the same week
          expect(options.dayCellDidMount.calls.count()).toEqual(0);
      });
      it('allows you to modify the element', () => {
          let options = {
              initialView: 'dayGridMonth',
              fixedWeekCount: true,
              initialDate: '2014-05-01',
              dayCellDidMount(arg) {
                  if (formatIsoDay(arg.date) === '2014-05-01') {
                      arg.el.classList.add('mycustomclass');
                  }
              },
          };
          let calendar = initCalendar(options);
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          let dayEl = dayGridWrapper.getDayEl('2014-05-01');
          expect(dayEl).toHaveClass('mycustomclass');
      });
      it('gets called for TimeGrid views', () => {
          let callCnt = 0;
          let options = {
              initialView: 'timeGridWeek',
              initialDate: '2014-05-01',
              allDaySlot: false,
              dayCellDidMount(arg) {
                  expect(arg.date instanceof Date).toBe(true);
                  expect(arg.el instanceof HTMLElement).toBe(true);
                  expect(typeof arg.view).toBe('object');
                  callCnt += 1;
              },
          };
          initCalendar(options);
          expect(callCnt).toBe(7);
      });
  });

  describe('weekText', () => {
      pushOptions({
          weekNumbers: true,
      });
      ['timeGridWeek'].forEach((viewName) => {
          describe('when views is ' + viewName, () => {
              pushOptions({
                  initialView: viewName,
              });
              it('renders correctly by default', () => {
                  let calendar = initCalendar();
                  expectWeekNumberTitle(calendar, 'W');
              });
              it('renders correctly when unspecified and when locale is customized', () => {
                  let calendar = initCalendar({
                      locale: l24,
                  });
                  expectWeekNumberTitle(calendar, 'Sm');
              });
              it('renders correctly when customized and LTR', () => {
                  let calendar = initCalendar({
                      direction: 'ltr',
                      weekText: 'YO',
                  });
                  expectWeekNumberTitle(calendar, 'YO');
              });
              it('renders correctly when customized and RTL', () => {
                  let calendar = initCalendar({
                      direction: 'rtl',
                      weekText: 'YO',
                  });
                  expectWeekNumberTitle(calendar, 'YO');
              });
          });
          function expectWeekNumberTitle(calendar, title) {
              let viewWrapper = new TimeGridViewWrapper(calendar);
              let text = viewWrapper.getHeaderWeekText()
                  .replace(/\d/g, '').trim(); // remove the number
              expect(text).toBe(title);
          }
      });
  });

  describe('timeGrid view rendering', () => {
      pushOptions({
          initialView: 'timeGridWeek',
      });
      it('should have have days ordered sun to sat', () => {
          let calendar = initCalendar();
          let viewWrapper = new TimeGridViewWrapper(calendar);
          let axisEl = viewWrapper.getHeaderAxisEl();
          let thEls = viewWrapper.header.getCellEls();
          expect(axisEl).toBeTruthy();
          let dowClassNames = CalendarWrapper.DOW_CLASSNAMES;
          for (let i = 0; i < dowClassNames.length; i += 1) {
              expect(thEls[i]).toHaveClass(dowClassNames[i]);
          }
      });
  });

  describe('constructor', () => {
      it('should not modify the options object', () => {
          let options = {
              initialView: 'timeGridWeek',
              scrollTime: '09:00:00',
              slotDuration: { minutes: 45 },
          };
          let optionsCopy = $.extend({}, options, true);
          initCalendar(options);
          expect(options).toEqual(optionsCopy);
      });
      it('should not modify the events array', () => {
          let options = {
              initialView: 'dayGridMonth',
              initialDate: '2014-05-27',
              events: [
                  {
                      title: 'mytitle',
                      start: '2014-05-27',
                  },
              ],
          };
          let optionsCopy = $.extend(true, {}, options); // recursive copy
          initCalendar(options);
          expect(options).toEqual(optionsCopy);
      });
      it('should not modify the eventSources array', () => {
          let options = {
              initialView: 'dayGridMonth',
              initialDate: '2014-05-27',
              eventSources: [
                  { events: [
                          {
                              title: 'mytitle',
                              start: '2014-05-27',
                          },
                      ] },
              ],
          };
          let optionsCopy = $.extend(true, {}, options); // recursive copy
          initCalendar(options);
          expect(options).toEqual(optionsCopy);
      });
      describe('when called on a div', () => {
          it('should contain a toolbar', () => {
              let calendar = initCalendar();
              let calendarWrapper = new CalendarWrapper(calendar);
              expect(calendarWrapper.toolbar).toBeTruthy();
          });
          it('should contain a view-container el', () => {
              let calendar = initCalendar();
              let calendarWrapper = new CalendarWrapper(calendar);
              expect(calendarWrapper.getViewContainerEl()).toBeTruthy();
          });
      });
  });

  let standardElListenerCount;
  function prepareStandardListeners() {
      if (standardElListenerCount === undefined) {
          standardElListenerCount = _prepareStandardListeners();
      }
      return standardElListenerCount;
  }
  function _prepareStandardListeners() {
      let el = document.createElement('div');
      document.body.appendChild(el);
      const elListenerCounter = new ListenerCounter(el);
      elListenerCounter.startWatching();
      flushSync(() => {
          D$1(y$1('div', {}), el);
      });
      return elListenerCounter.stopWatching();
  }

  describe('destroy', () => {
      describe('when calendar is LTR', () => {
          it('cleans up all classNames on the root element', () => {
              initCalendar({
                  direction: 'ltr',
              });
              currentCalendar.destroy();
              expect(currentCalendar.el.className).toBe('');
          });
      });
      describe('when calendar is RTL', () => {
          it('cleans up all classNames on the root element', () => {
              initCalendar({
                  direction: 'rtl',
              });
              currentCalendar.destroy();
              expect(currentCalendar.el.className).toBe('');
          });
      });
      describeOptions('themeSystem', {
          'when bootstrap theme': 'bootstrap',
      }, () => {
          it('cleans up all classNames on the root element', () => {
              initCalendar();
              currentCalendar.destroy();
              expect(currentCalendar.el.className).toBe('');
          });
      });
      pushOptions({
          initialDate: '2014-12-01',
          droppable: true,
          editable: true,
          events: [
              { title: 'event1', start: '2014-12-01' },
          ],
      });
      describeOptions('initialView', {
          'when in dayGridWeek view': 'dayGridWeek',
          'when in week view': 'timeGridWeek',
          'when in listWeek view': 'listWeek',
          'when in month view': 'dayGridMonth',
      }, (viewName) => {
          it('leaves no handlers attached to DOM', () => {
              const standardElListenerCount = prepareStandardListeners();
              let $el = $('<div>').appendTo('body');
              let elHandlerCounter = new ListenerCounter($el[0]);
              let docHandlerCounter = new ListenerCounter(document);
              elHandlerCounter.startWatching();
              docHandlerCounter.startWatching();
              initCalendar({}, $el);
              currentCalendar.destroy();
              if (viewName !== 'timeGridDay') { // hack for skipping 3rd one
                  expect(elHandlerCounter.stopWatching()).toBe(standardElListenerCount);
                  expect(docHandlerCounter.stopWatching()).toBe(0);
              }
              $el.remove();
          });
          // Issue 2432
          it('preserves existing window handlers when handleWindowResize is off', () => {
              let resizeHandler = () => { };
              let windowListenerCounter = new ListenerCounter(window);
              windowListenerCounter.startWatching();
              window.addEventListener('resize', resizeHandler);
              expect(windowListenerCounter.computeDelta()).toBe(1);
              initCalendar({
                  handleWindowResize: false,
              });
              currentCalendar.destroy();
              expect(windowListenerCounter.stopWatching()).toBe(1);
              window.removeEventListener('resize', resizeHandler);
          });
      });
  });

  describe('direction', () => {
      it('has it\'s default value computed differently based off of the locale', () => {
          initCalendar({
              locale: l7, // Arabic is RTL
          });
          expect(currentCalendar.getOption('direction')).toEqual('rtl');
      });
      // NOTE: don't put tests related to other options in here!
      // Put them in the test file for the individual option!
      it('adapts to dynamic option change', () => {
          initCalendar({
              direction: 'ltr',
          });
          let $el = $(currentCalendar.el);
          expect($el).toHaveClass(CalendarWrapper.LTR_CLASSNAME);
          expect($el).not.toHaveClass(CalendarWrapper.RTL_CLASSNAME);
          currentCalendar.setOption('direction', 'rtl');
          expect($el).toHaveClass(CalendarWrapper.RTL_CLASSNAME);
          expect($el).not.toHaveClass(CalendarWrapper.LTR_CLASSNAME);
      });
  });

  function removeLtrCharCodes(s) {
      return s.replace(/\u200e/g, '');
  }

  describe('day names', () => {
      let sundayDate = parseUtcDate('2019-03-17');
      let locales = ['es', 'fr', 'de', 'zh-cn', 'nl'];
      pushOptions({
          now: sundayDate,
      });
      describe('when view is dayGridDay', () => {
          pushOptions({
              initialView: 'dayGridDay',
          });
          describe('when locale is default', () => {
              pushOptions({
                  locale: 'en',
              });
              CalendarWrapper.DOW_CLASSNAMES.forEach((dowClassName, index) => {
                  let dayDate = addDays(sundayDate, index);
                  let dayText = removeLtrCharCodes(dayDate.toLocaleString('en', { weekday: 'long', timeZone: 'UTC' }));
                  it('should be ' + dayText, () => {
                      let calendar = initCalendar({
                          now: dayDate,
                      });
                      let headerWrapper = new DayGridViewWrapper(calendar).header;
                      expect(headerWrapper.el.querySelector(`.${dowClassName}`)).toHaveText(dayText);
                  });
              });
          });
          $.each(locales, (localeIndex, locale) => {
              describe('when locale is ' + locale, () => {
                  CalendarWrapper.DOW_CLASSNAMES.forEach((dowClassName, index) => {
                      let dayDate = addDays(sundayDate, index);
                      let dayText = removeLtrCharCodes(dayDate.toLocaleString(locale, { weekday: 'long', timeZone: 'UTC' }));
                      it('should be the translation for ' + dayText, () => {
                          let calendar = initCalendar({
                              locale,
                              now: dayDate,
                          });
                          let headerWrapper = new DayGridViewWrapper(calendar).header;
                          expect(headerWrapper.el.querySelector(`.${dowClassName}`)).toHaveText(dayText);
                      });
                  });
              });
          });
      });
  });

  describe('dateClick', () => {
      pushOptions({
          initialDate: '2014-05-27',
          selectable: false,
          timeZone: 'UTC',
      });
      describeOptions('direction', {
          'when LTR': 'ltr',
          'when RTL': 'rtl',
      }, () => {
          describeOptions('selectable', {
              'when NOT selectable': false,
              'when selectable': true,
          }, () => {
              describe('when in month view', () => {
                  pushOptions({
                      initialView: 'dayGridMonth',
                  });
                  it('fires correctly when clicking on a cell', (done) => {
                      let calendar = initCalendar({
                          dateClick(arg) {
                              expect(arg.date instanceof Date).toEqual(true);
                              expect(typeof arg.jsEvent).toEqual('object'); // TODO: more discrimination
                              expect(typeof arg.view).toEqual('object'); // "
                              expect(arg.allDay).toEqual(true);
                              expect(arg.date).toEqualDate('2014-05-07');
                              expect(arg.dateStr).toEqual('2014-05-07');
                              done();
                          },
                      });
                      let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                      dayGridWrapper.clickDate('2014-05-07');
                  });
              });
              describe('when in week view', () => {
                  pushOptions({
                      initialView: 'timeGridWeek',
                  });
                  it('fires correctly when clicking on an all-day slot', (done) => {
                      let calendar = initCalendar({
                          dateClick(arg) {
                              expect(arg.date instanceof Date).toEqual(true);
                              expect(typeof arg.jsEvent).toEqual('object'); // TODO: more discrimination
                              expect(typeof arg.view).toEqual('object'); // "
                              expect(arg.allDay).toEqual(true);
                              expect(arg.date).toEqualDate('2014-05-28');
                              expect(arg.dateStr).toEqual('2014-05-28');
                              done();
                          },
                      });
                      let dayGridWrapper = new TimeGridViewWrapper(calendar).dayGrid;
                      dayGridWrapper.clickDate('2014-05-28');
                  });
                  it('fires correctly when clicking on a timed slot', (done) => {
                      let calendar = initCalendar({
                          contentHeight: 500,
                          scrollTime: '07:00:00',
                          dateClick(arg) {
                              expect(arg.date instanceof Date).toEqual(true);
                              expect(typeof arg.jsEvent).toEqual('object'); // TODO: more discrimination
                              expect(typeof arg.view).toEqual('object'); // "
                              expect(arg.allDay).toEqual(false);
                              expect(arg.date).toEqualDate('2014-05-28T09:00:00Z');
                              expect(arg.dateStr).toEqual('2014-05-28T09:00:00Z');
                              done();
                          },
                      });
                      let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                      timeGridWrapper.clickDate('2014-05-28T09:00:00');
                  });
                  // issue 2217
                  it('fires correctly when clicking on a timed slot, with slotMinTime set', (done) => {
                      let calendar = initCalendar({
                          contentHeight: 500,
                          scrollTime: '07:00:00',
                          slotMinTime: '02:00:00',
                          dateClick(arg) {
                              expect(arg.date instanceof Date).toEqual(true);
                              expect(typeof arg.jsEvent).toEqual('object'); // TODO: more discrimination
                              expect(typeof arg.view).toEqual('object'); // "
                              expect(arg.allDay).toEqual(false);
                              expect(arg.date).toEqualDate('2014-05-28T11:00:00Z');
                              expect(arg.dateStr).toEqual('2014-05-28T11:00:00Z');
                              done();
                          },
                      });
                      let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                      timeGridWrapper.clickDate('2014-05-28T11:00:00');
                  });
                  // https://github.com/fullcalendar/fullcalendar/issues/4539
                  it('fires correctly when clicking on a timed slot NEAR END', (done) => {
                      let calendar = initCalendar({
                          contentHeight: 500,
                          scrollTime: '23:00:00',
                          dateClick(arg) {
                              expect(arg.date instanceof Date).toEqual(true);
                              expect(typeof arg.jsEvent).toEqual('object'); // TODO: more discrimination
                              expect(typeof arg.view).toEqual('object'); // "
                              expect(arg.allDay).toEqual(false);
                              expect(arg.date).toEqualDate('2014-05-28T23:30:00Z');
                              expect(arg.dateStr).toEqual('2014-05-28T23:30:00Z');
                              done();
                          },
                      });
                      let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                      timeGridWrapper.clickDate('2014-05-28T23:30:00');
                  });
              });
          });
      });
      it('will still fire if clicked on background event', (done) => {
          let calendar = initCalendar({
              initialView: 'dayGridMonth',
              events: [{
                      start: '2014-05-06',
                      display: 'background',
                  }],
              dateClick(info) {
                  expect(info.dateStr).toBe('2014-05-06');
                  done();
              },
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          $.simulateMouseClick(dayGridWrapper.getBgEventEls()[0]);
      });
      describe('when touch', () => {
          it('fires correctly when simulated short drag on a cell', (done) => {
              let calendar = initCalendar({
                  dateClick(arg) {
                      expect(arg.date instanceof Date).toEqual(true);
                      expect(typeof arg.jsEvent).toEqual('object'); // TODO: more discrimination
                      expect(typeof arg.view).toEqual('object'); // "
                      expect(arg.allDay).toEqual(true);
                      expect(arg.date).toEqualDate('2014-05-07');
                      expect(arg.dateStr).toEqual('2014-05-07');
                      done();
                  },
              });
              let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
              $.simulateTouchClick(dayGridWrapper.getDayEl('2014-05-07'));
          });
          it('won\'t fire if touch moves outside of date cell', (done) => {
              let dateClickSpy = spyOnCalendarCallback('dateClick');
              let calendar = initCalendar();
              let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
              let startCell = dayGridWrapper.getDayEl('2014-05-07');
              let endCell = dayGridWrapper.getDayEl('2014-05-08');
              $(startCell).simulate('drag', {
                  // FYI, when debug:true, not a good representation because the minimal  delay is required
                  // to recreate bug #3332
                  isTouch: true,
                  end: endCell,
                  callback() {
                      expect(dateClickSpy).not.toHaveBeenCalled();
                      done();
                  },
              });
          });
          it('fires correctly when simulated click on a cell', (done) => {
              let calendar = initCalendar({
                  dateClick(arg) {
                      expect(arg.date instanceof Date).toEqual(true);
                      expect(typeof arg.jsEvent).toEqual('object'); // TODO: more discrimination
                      expect(typeof arg.view).toEqual('object'); // "
                      expect(arg.allDay).toEqual(true);
                      expect(arg.date).toEqualDate('2014-05-07');
                      expect(arg.dateStr).toEqual('2014-05-07');
                      done();
                  },
              });
              let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
              let dayCell = dayGridWrapper.getDayEl('2014-05-07');
              $.simulateTouchClick(dayCell);
          });
      });
  });

  // TODO: Use the built-in Draggable for some of these tests
  describe('advanced external dnd', () => {
      let dragEl;
      let thirdPartyDraggable;
      beforeEach(() => {
          dragEl = $('<div class="drag">yo</div>')
              .css({
              width: 200,
              background: 'blue',
              color: 'white',
          })
              .appendTo('body')
              .draggable();
          thirdPartyDraggable = new ThirdPartyDraggable({
              itemSelector: '.drag',
          });
      });
      afterEach(() => {
          thirdPartyDraggable.destroy();
          dragEl.remove();
          dragEl = null;
      });
      pushOptions({
          initialDate: '2014-11-13',
          scrollTime: '00:00:00',
          droppable: true,
      });
      describe('in timeGrid slots', () => {
          pushOptions({
              initialView: 'timeGridWeek',
          });
          describe('when no element event data', () => {
              describe('when given duration through defaultTimedEventDuration', () => {
                  pushOptions({
                      defaultTimedEventDuration: '2:30',
                  });
                  defineTests();
              });
              describe('when given duration through data attribute', () => {
                  beforeEach(() => {
                      dragEl.attr('data-event', JSON.stringify({
                          duration: '2:30',
                          create: false, // only an external element, won't create or render as an event
                      }));
                  });
                  defineTests();
              });
              function defineTests() {
                  it('fires correctly', (done) => {
                      testExternalElDrag({}, '2014-11-13T03:00:00Z', '2014-11-13T03:00:00Z', true, done);
                  });
                  it('is not affected by eventOverlap:false', (done) => {
                      let options = {
                          eventOverlap: false,
                          events: [{
                                  start: '2014-11-13T01:00:00',
                                  end: '2014-11-13T05:00:00',
                              }],
                      };
                      testExternalElDrag(options, '2014-11-13T03:00:00Z', '2014-11-13T03:00:00Z', true, done);
                  });
                  it('is not affected by an event object\'s overlap:false', (done) => {
                      let options = {
                          events: [{
                                  start: '2014-11-13T01:00:00',
                                  end: '2014-11-13T05:00:00',
                                  overlap: false,
                              }],
                      };
                      testExternalElDrag(options, '2014-11-13T03:00:00Z', '2014-11-13T03:00:00Z', true, done);
                  });
                  it('is not affected by eventConstraint', (done) => {
                      let options = {
                          eventConstraint: {
                              start: '03:00',
                              end: '10:00',
                          },
                      };
                      testExternalElDrag(options, '2014-11-13T02:00:00Z', '2014-11-13T02:00:00Z', true, done);
                  });
                  describe('with selectOverlap:false', () => {
                      pushOptions({
                          selectOverlap: false,
                          events: [{
                                  start: '2014-11-13T04:00:00',
                                  end: '2014-11-13T08:00:00',
                              }],
                      });
                      it('is not allowed to overlap an event', (done) => {
                          testExternalElDrag({}, '2014-11-13T02:00:00Z', '2014-11-13T02:00:00Z', false, done);
                      });
                  });
                  describe('with a selectConstraint', () => {
                      pushOptions({
                          selectConstraint: {
                              startTime: '04:00',
                              endTime: '08:00',
                          },
                      });
                      it('can be dropped within', (done) => {
                          testExternalElDrag({}, '2014-11-13T05:30:00Z', '2014-11-13T05:30:00Z', true, done);
                      });
                      it('cannot be dropped when not fully contained', (done) => {
                          testExternalElDrag({}, '2014-11-13T06:00:00Z', '2014-11-13T06:00:00Z', false, done);
                      });
                  });
              }
          });
          describe('when event data is given', () => {
              it('fires correctly', (done) => {
                  dragEl.attr('data-event', JSON.stringify({
                      title: 'hey',
                  }));
                  testExternalEventDrag({}, '2014-11-13T02:00:00Z', '2014-11-13T02:00:00Z', true, done);
              });
              describe('when given a start time', () => {
                  describe('through the event object\'s time property', () => {
                      beforeEach(() => {
                          dragEl.attr('data-event', JSON.stringify({
                              startTime: '05:00',
                          }));
                      });
                      it('voids the given time when dropped on a timed slot', (done) => {
                          testExternalEventDrag({}, '2014-11-13T02:00:00Z', '2014-11-13T02:00:00Z', true, done);
                          // will test the resulting event object's start
                      });
                  });
              });
              describe('when given a duration', () => {
                  describe('through the event object\'s duration property', () => {
                      beforeEach(() => {
                          dragEl.attr('data-event', JSON.stringify({
                              duration: '05:00',
                          }));
                      });
                      it('accepts the given duration when dropped on a timed slot', (done) => {
                          testExternalEventDrag({}, '2014-11-13T02:00:00Z', '2014-11-13T02:00:00Z', true, () => {
                              let event = currentCalendar.getEvents()[0];
                              expect(event.start).toEqualDate('2014-11-13T02:00:00Z');
                              expect(event.end).toEqualDate('2014-11-13T07:00:00Z');
                              done();
                          });
                      });
                  });
              });
              describe('when given stick:true', () => {
                  describe('through the event object', () => {
                      beforeEach(() => {
                          dragEl.attr('data-event', JSON.stringify({
                              stick: true,
                          }));
                      });
                      it('keeps the event when navigating away and back', (done) => {
                          testExternalEventDrag({}, '2014-11-13T02:00:00Z', '2014-11-13T02:00:00Z', true, () => {
                              setTimeout(() => {
                                  let calendarWrapper = new CalendarWrapper(currentCalendar);
                                  expect(calendarWrapper.getEventEls().length).toBe(1);
                                  currentCalendar.next();
                                  expect(calendarWrapper.getEventEls().length).toBe(0);
                                  currentCalendar.prev();
                                  expect(calendarWrapper.getEventEls().length).toBe(1);
                                  done();
                              }, 0);
                          });
                      });
                  });
              });
              describe('when an overlap is specified', () => {
                  describe('via eventOverlap', () => {
                      pushOptions({
                          eventOverlap: false,
                          events: [{
                                  start: '2014-11-13T05:00:00',
                                  end: '2014-11-13T08:00:00',
                              }],
                      });
                      beforeEach(() => {
                          dragEl.attr('data-event', '{}');
                      });
                      defineTests();
                  });
                  describe('via an overlap on this event', () => {
                      pushOptions({
                          events: [{
                                  start: '2014-11-13T05:00:00',
                                  end: '2014-11-13T08:00:00',
                              }],
                      });
                      beforeEach(() => {
                          dragEl.attr('data-event', JSON.stringify({
                              overlap: false,
                          }));
                      });
                      defineTests();
                  });
                  describe('via an overlap on the other event', () => {
                      pushOptions({
                          events: [{
                                  start: '2014-11-13T05:00:00',
                                  end: '2014-11-13T08:00:00',
                                  overlap: false,
                              }],
                      });
                      beforeEach(() => {
                          dragEl.attr('data-event', '{}');
                      });
                      defineTests();
                  });
                  function defineTests() {
                      it('allows a drop when not colliding with the other event', (done) => {
                          testExternalEventDrag({}, '2014-11-13T08:00:00Z', '2014-11-13T08:00:00Z', true, done);
                      });
                      it('prevents a drop when colliding with the other event', (done) => {
                          testExternalEventDrag({}, '2014-11-13T06:00:00Z', '2014-11-13T06:00:00Z', false, done);
                      });
                  }
              });
              describe('when a constraint is specified', () => {
                  describe('via eventConstraint', () => {
                      pushOptions({
                          eventConstraint: {
                              startTime: '04:00',
                              endTime: '08:00',
                          },
                      });
                      beforeEach(() => {
                          dragEl.attr('data-event', JSON.stringify({
                              duration: '02:00',
                          }));
                      });
                      defineTests();
                  });
                  describe('via the event object\'s constraint property', () => {
                      beforeEach(() => {
                          dragEl.attr('data-event', JSON.stringify({
                              duration: '02:00',
                              constraint: {
                                  startTime: '04:00',
                                  endTime: '08:00',
                              },
                          }));
                      });
                      defineTests();
                  });
                  function defineTests() {
                      it('allows a drop when inside the constraint', (done) => {
                          testExternalEventDrag({}, '2014-11-13T05:00:00Z', '2014-11-13T05:00:00Z', true, done);
                      });
                      it('disallows a drop when partially outside of the constraint', (done) => {
                          testExternalEventDrag({}, '2014-11-13T07:00:00Z', '2014-11-13T07:00:00Z', false, done);
                      });
                  }
              });
          });
      });
      // TODO: write more tests for DayGrid!
      describe('in month whole-days', () => {
          pushOptions({
              initialView: 'dayGridMonth',
          });
          describe('when event data is given', () => {
              it('fires correctly', (done) => {
                  dragEl.attr('data-event', JSON.stringify({
                      title: 'hey',
                  }));
                  testExternalEventDrag({}, '2014-11-13', '2014-11-13', true, done);
              });
              describe('when given a start time', () => {
                  describe('through the event object\'s time property', () => {
                      beforeEach(() => {
                          dragEl.attr('data-event', JSON.stringify({
                              startTime: '05:00',
                          }));
                      });
                      it('accepts the given start time for the dropped day', (done) => {
                          testExternalEventDrag({}, '2014-11-13', '2014-11-13T05:00:00Z', true, () => {
                              // the whole-day start was already checked. we still need to check the exact time
                              let event = currentCalendar.getEvents()[0];
                              expect(event.start).toEqualDate('2014-11-13T05:00:00Z');
                              done();
                          });
                      });
                  });
              });
          });
      });
      function testExternalElDrag(options, dragToDate, expectedDate, expectSuccess, callback) {
          options.droppable = true;
          options.drop = (arg) => {
              expect(arg.date instanceof Date).toBe(true);
              expect(arg.date).toEqualDate(expectedDate);
              expect(typeof arg.jsEvent).toBe('object');
          };
          options.eventReceive = () => { };
          spyOn(options, 'drop').and.callThrough();
          spyOn(options, 'eventReceive').and.callThrough();
          testEventDrag(options, dragToDate, expectSuccess, () => {
              if (expectSuccess) {
                  expect(options.drop).toHaveBeenCalled();
              }
              else {
                  expect(options.drop).not.toHaveBeenCalled();
              }
              expect(options.eventReceive).not.toHaveBeenCalled();
              callback();
          }, 'drag'); // .drag className
      }
      function testExternalEventDrag(options, dragToDate, expectedDate, expectSuccess, callback) {
          let expectedAllDay = dragToDate.indexOf('T') === -1; // for the drop callback only!
          options.droppable = true;
          options.drop = (arg) => {
              expect(arg.date instanceof Date).toBe(true);
              expect(arg.date).toEqualDate(dragToDate);
              expect(arg.allDay).toBe(expectedAllDay);
              expect(typeof arg.jsEvent).toBe('object');
          };
          options.eventReceive = (arg) => {
              expect(arg.event.start).toEqualDate(expectedDate);
          };
          spyOn(options, 'drop').and.callThrough();
          spyOn(options, 'eventReceive').and.callThrough();
          testEventDrag(options, dragToDate, expectSuccess, () => {
              if (expectSuccess) {
                  expect(options.drop).toHaveBeenCalled();
                  expect(options.eventReceive).toHaveBeenCalled();
              }
              else {
                  expect(options.drop).not.toHaveBeenCalled();
                  expect(options.eventReceive).not.toHaveBeenCalled();
              }
              callback();
          }, 'drag'); // .drag className
      }
  });

  describe('eventWillUnmount', () => {
      pushOptions({
          initialDate: '2014-08-01',
      });
      function testSingleEvent(singleEventData, done) {
          let callCnt = 0;
          expect(singleEventData.id).toBeTruthy();
          let calendar = initCalendar({
              events: [singleEventData],
              eventWillUnmount(arg) {
                  callCnt += 1;
                  if (callCnt === 1) { // only care about the first call. gets called again when calendar is destroyed
                      expect(arg.event.id).toBe(singleEventData.id);
                      done();
                  }
              },
          });
          calendar.getEventById(singleEventData.id).remove();
      }
      describe('when in month view', () => {
          pushOptions({
              initialView: 'dayGridMonth',
          });
          it('gets called with removeEvents method', (done) => {
              setTimeout(() => {
                  testSingleEvent({
                      id: '1',
                      title: 'event1',
                      date: '2014-08-02',
                  }, done);
              }, 0);
          });
      });
      describe('when in week view', () => {
          pushOptions({
              initialView: 'timeGridWeek',
              scrollTime: '00:00:00',
          });
          it('gets called with removeEvents method', (done) => {
              setTimeout(() => {
                  testSingleEvent({
                      id: '1',
                      title: 'event1',
                      date: '2014-08-02T02:00:00',
                  }, done);
              }, 0);
          });
      });
  });

  describe('select method', () => {
      pushOptions({
          initialDate: '2014-05-25',
          selectable: true,
      });
      /*
      THINGS TO IMPLEMENT IN SRC (in addition to notes further down):
      - better date normalization (for both render and reporting to select callback)
        - if second date is the same or before the first
        - if given a mixture of timed/all-day
        - for dayGrid/month views, when given timed dates, should really be all-day
      */
      describeOptions('direction', {
          'when LTR': 'ltr',
          'when RTL': 'rtl',
      }, () => {
          describe('when in month view', () => {
              pushOptions({
                  initialView: 'dayGridMonth',
              });
              describe('when called with all-day date strings', () => {
                  describe('when in bounds', () => {
                      it('renders a selection', () => {
                          let calendar = initCalendar();
                          calendar.select('2014-05-07', '2014-05-09');
                          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                          expect(dayGridWrapper.getHighlightEls()).toBeVisible();
                      });
                      it('renders a selection when called with one argument', () => {
                          let calendar = initCalendar();
                          calendar.select('2014-05-07');
                          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                          expect(dayGridWrapper.getHighlightEls()).toBeVisible();
                      });
                      it('fires a selection event', () => {
                          let selectSpy = spyOnCalendarCallback('select', (arg) => {
                              expect(arg.allDay).toEqual(true);
                              expect(arg.start).toEqualDate('2014-05-07');
                              expect(arg.end).toEqualDate('2014-05-09');
                          });
                          let calendar = initCalendar();
                          calendar.select('2014-05-07', '2014-05-09');
                          expect(selectSpy).toHaveBeenCalled();
                      });
                  });
                  describe('when out of bounds', () => {
                      it('doesn\'t render a selection', () => {
                          let calendar = initCalendar();
                          calendar.select('2015-05-07', '2015-05-09');
                          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                          expect(dayGridWrapper.getHighlightEls()).not.toBeVisible();
                      });
                      /*
                      TODO: implement this behavior
                      it('doesn\'t fire a selection event', function() {
                        options.select = function(arg) {
                          expect(arg.start).toEqualDate('2014-05-07');
                          expect(arg.end).toEqualDate('2014-05-09');
                        };
                        spyOn(options, 'select').and.callThrough();
                        let calendar = initCalendar(options);
                        calendar.select('2015-05-07', '2015-05-09');
                        expect(options.select).not.toHaveBeenCalled();
                      });
                      */
                  });
              });
              describe('when called with timed date strings', () => {
                  it('renders a selection', () => {
                      let calendar = initCalendar();
                      calendar.select('2014-05-07T06:00:00', '2014-05-09T07:00:00');
                      let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                      expect(dayGridWrapper.getHighlightEls()).toBeVisible();
                  });
                  it('fires a selection event', () => {
                      let selectSpy = spyOnCalendarCallback('select', (arg) => {
                          expect(arg.allDay).toEqual(false);
                          expect(arg.start).toEqualDate('2014-05-07T06:00:00Z');
                          expect(arg.end).toEqualDate('2014-05-09T06:00:00Z');
                      });
                      let calendar = initCalendar();
                      calendar.select('2014-05-07T06:00:00', '2014-05-09T06:00:00');
                      expect(selectSpy).toHaveBeenCalled();
                  });
              });
          });
          describe('when in week view', () => {
              pushOptions({
                  initialView: 'timeGridWeek',
                  scrollTime: '01:00:00',
                  height: 400, // short enought to make scrolling happen
              });
              describe('when called with timed date strings', () => {
                  describe('when in bounds', () => {
                      it('renders a selection when called with one argument', () => {
                          let calendar = initCalendar();
                          calendar.select('2014-05-26T06:00:00');
                          let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                          expect(timeGridWrapper.getHighlightEls()).toBeVisible();
                      });
                      it('renders a selection over the slot area', () => {
                          let calendar = initCalendar();
                          calendar.select('2014-05-26T06:00:00', '2014-05-26T08:00:00');
                          let viewWrapper = new TimeGridViewWrapper(calendar);
                          let highlightEls = viewWrapper.timeGrid.getHighlightEls();
                          expect(highlightEls).toBeVisible();
                          let slotAreaTop = $(viewWrapper.getScrollerEl()).offset().top;
                          let overlayTop = $(highlightEls[0]).offset().top;
                          expect(overlayTop).toBeGreaterThan(slotAreaTop);
                      });
                  });
                  describe('when out of bounds', () => {
                      it('doesn\'t render a selection', () => {
                          let calendar = initCalendar();
                          calendar.select('2015-05-26T06:00:00', '2015-05-26T07:00:00');
                          let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                          expect(timeGridWrapper.getHighlightEls()).not.toBeVisible();
                      });
                      /*
                      TODO: implement this behavior
                      it('doesn\'t fire a selection event', function() {
                        options.select = function(arg) {
                          expect(arg.start).toEqualDate('2015-05-07T06:00:00Z');
                          expect(arg.end).toEqualDate('2015-05-09T07:00:00Z');
                        };
                        spyOn(options, 'select').and.callThrough();
                        let calendar = initCalendar(options);
                        calendar.select('2015-05-07T06:00:00', '2015-05-09T07:00:00');
                        expect(options.select).not.toHaveBeenCalled();
                      });
                      */
                  });
              });
              describe('when called with all-day date strings', () => {
                  describe('when allDaySlot is on', () => {
                      pushOptions({
                          allDaySlot: true,
                      });
                      it('renders a selection over the day area', () => {
                          let calendar = initCalendar();
                          calendar.select('2014-05-26', '2014-05-28');
                          let viewWrapper = new TimeGridViewWrapper(calendar);
                          let highlightEls = viewWrapper.dayGrid.getHighlightEls();
                          expect(highlightEls).toBeVisible();
                          let slotAreaTop = $(viewWrapper.getScrollerEl()).offset().top;
                          let overlayTop = $(highlightEls[0]).offset().top;
                          expect(overlayTop).toBeLessThan(slotAreaTop);
                      });
                      it('fires a selection event', () => {
                          let selectSpy = spyOnCalendarCallback('select', (arg) => {
                              expect(arg.allDay).toEqual(true);
                              expect(arg.start).toEqualDate('2014-05-26');
                              expect(arg.end).toEqualDate('2014-05-28');
                          });
                          let calendar = initCalendar();
                          calendar.select('2014-05-26', '2014-05-28');
                          expect(selectSpy).toHaveBeenCalled();
                      });
                  });
                  describe('when allDaySlot is off', () => {
                      pushOptions({
                          allDaySlot: false,
                      });
                      it('doesn\'t render the all-day selection over time area', () => {
                          let calendar = initCalendar();
                          calendar.select('2014-05-26', '2014-05-28');
                          let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                          expect(timeGridWrapper.getHighlightEls()).not.toBeVisible();
                      });
                      /*
                      TODO: implement
                      it('doesn\'t fire a selection event', function() {
                        options.select = function(arg) {
                          expect(arg.allDay).toEqual(true);
                          expect(arg.start).toEqualDate('2014-05-26');
                          expect(arg.end).toEqualDate('2014-05-28');
                        };
                        spyOn(options, 'select').and.callThrough();
                        let calendar = initCalendar(options);
                        calendar.select('2014-05-26', '2014-05-28');
                        expect(options.select).not.toHaveBeenCalled();
                      });
                      */
                  });
              });
          });
      });
  });

  describe('event object creation', () => {
      /*
    
      NOTE: Where possible, if there is a specific option that affects event object creation
      behavior, write your tests in the individual file for that option, instead of here.
      Examples of this:
        defaultAllDay (tests allDay guessing behavior too)
        eventDataTransform
        forceEventDuration
    
      */
      function init(singleEventData) {
          initCalendar({
              events: [singleEventData],
          });
          return currentCalendar.getEvents()[0];
      }
      it('accepts `date` property as alias for `start`', () => {
          let event = init({
              date: '2014-05-05',
          });
          expect(event.start instanceof Date).toEqual(true);
          expect(event.start).toEqualDate('2014-05-05');
      });
      it('doesn\'t produce an event when an invalid start Date object', () => {
          let event = init({
              start: new Date('asdf'),
          });
          expect(event).toBeUndefined();
      });
      it('doesn\'t produce an event when an invalid start string', () => {
          let event = init({
              start: 'asdfasdfasdf',
          });
          expect(event).toBeUndefined();
      });
      it('produces null end when given an invalid Date object', () => {
          let event = init({
              start: '2014-05-01',
              end: new Date('asdf'),
          });
          expect(event.start).toEqualDate('2014-05-01');
          expect(event.end).toBe(null);
      });
      it('produces null end when given an invalid string', () => {
          let event = init({
              start: '2014-05-01',
              end: 'asdfasdfasdf',
          });
          expect(event.start).toEqualDate('2014-05-01');
          expect(event.end).toBe(null);
      });
      it('produces null end when given a timed end before the start', () => {
          let event = init({
              start: '2014-05-02T00:00:00',
              end: '2014-05-01T23:00:00',
          });
          expect(event.start).toEqualDate('2014-05-02T00:00:00Z');
          expect(event.end).toBe(null);
      });
      it('produces null end when given a timed end equal to the start', () => {
          let event = init({
              start: '2014-05-02T00:00:00',
              end: '2014-05-01T00:00:00',
          });
          expect(event.start).toEqualDate('2014-05-02T00:00:00Z');
          expect(event.end).toBe(null);
      });
      it('produces null end when given an all-day end before the start', () => {
          let event = init({
              start: '2014-05-02',
              end: '2014-05-02',
          });
          expect(event.start).toEqualDate('2014-05-02');
          expect(event.end).toBe(null);
      });
      it('produces null end when given an all-day end equal to the start', () => {
          let event = init({
              start: '2014-05-02T00:00:00',
              end: '2014-05-02T00:00:00',
          });
          expect(event.start).toEqualDate('2014-05-02T00:00:00Z');
          expect(event.end).toBe(null);
      });
      it('strips times of dates when event is all-day', () => {
          let event = init({
              start: '2014-05-01T01:00:00-12:00',
              end: '2014-05-02T01:00:00-12:00',
              allDay: true,
          });
          expect(event.allDay).toEqual(true);
          expect(event.start).toEqualDate('2014-05-01');
          expect(event.end).toEqualDate('2014-05-02');
      });
      it('gives 00:00 times to ambiguously-timed dates when event is timed', () => {
          let event = init({
              start: '2014-05-01',
              end: '2014-05-03',
              allDay: false,
          });
          expect(event.allDay).toEqual(false);
          expect(event.start).toEqualDate('2014-05-01T00:00:00Z');
          expect(event.end).toEqualDate('2014-05-03T00:00:00Z');
      });
      it('accepts an array `className`', () => {
          let event = init({
              start: '2014-05-01',
              className: ['class1', 'class2'],
          });
          expect($.isArray(event.classNames)).toEqual(true);
          expect(event.classNames).toEqual(['class1', 'class2']);
      });
      it('accepts a string `className`', () => {
          let event = init({
              start: '2014-05-01',
              className: 'class1 class2',
          });
          expect($.isArray(event.classNames)).toEqual(true);
          expect(event.classNames).toEqual(['class1', 'class2']);
      });
      it('accepts extended properties', () => {
          let event = init({
              start: '2014-05-01',
              prop1: 'prop1val',
              prop2: ['a', 'b'],
          });
          expect(event.extendedProps.prop1).toEqual('prop1val');
          expect(event.extendedProps.prop2).toEqual(['a', 'b']);
      });
  });

  // UNFORTUNATELY, these tests are affected by the window height b/c of autoscrolling
  describe('select callback', () => {
      pushOptions({
          initialDate: '2014-05-25',
          selectable: true,
          longPressDelay: 100,
      });
      describeOptions('direction', {
          'when LTR': 'ltr',
          'when RTL': 'rtl',
      }, () => {
          describe('when in month view', () => {
              pushOptions({
                  initialView: 'dayGridMonth',
              });
              it('gets fired correctly when the user selects cells', (done) => {
                  let options = {
                      select(arg) {
                          expect(arg.start instanceof Date).toEqual(true);
                          expect(arg.end instanceof Date).toEqual(true);
                          expect(typeof arg.jsEvent).toEqual('object'); // TODO: more discrimination
                          expect(typeof arg.view).toEqual('object'); // "
                          expect(arg.allDay).toEqual(true);
                          expect(arg.start).toEqualDate('2014-04-28');
                          expect(arg.startStr).toEqual('2014-04-28');
                          expect(arg.end).toEqualDate('2014-05-07');
                          expect(arg.endStr).toEqual('2014-05-07');
                      },
                  };
                  spyOn(options, 'select').and.callThrough();
                  let calendar = initCalendar(options);
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  dayGridWrapper.selectDates('2014-04-28', '2014-05-06').then(() => {
                      expect(options.select).toHaveBeenCalled();
                      done();
                  });
              });
              it('gets fired correctly when the user selects cells via touch', (done) => {
                  let options = {
                      select(arg) {
                          expect(arg.start instanceof Date).toEqual(true);
                          expect(arg.end instanceof Date).toEqual(true);
                          expect(typeof arg.jsEvent).toEqual('object'); // TODO: more discrimination
                          expect(typeof arg.view).toEqual('object'); // "
                          expect(arg.allDay).toEqual(true);
                          expect(arg.start).toEqualDate('2014-04-28');
                          expect(arg.startStr).toEqual('2014-04-28');
                          expect(arg.end).toEqualDate('2014-05-07');
                          expect(arg.endStr).toEqual('2014-05-07');
                      },
                  };
                  spyOn(options, 'select').and.callThrough();
                  let calendar = initCalendar(options);
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  dayGridWrapper.selectDatesTouch('2014-04-28', '2014-05-06', true).then(() => {
                      expect(options.select).toHaveBeenCalled();
                      done();
                  });
              });
              it('gets fired correctly when the user selects just one cell', (done) => {
                  let options = {
                      select(arg) {
                          expect(arg.start instanceof Date).toEqual(true);
                          expect(arg.end instanceof Date).toEqual(true);
                          expect(typeof arg.jsEvent).toEqual('object'); // TODO: more discrimination
                          expect(typeof arg.view).toEqual('object'); // "
                          expect(arg.allDay).toEqual(true);
                          expect(arg.start).toEqualDate('2014-04-28');
                          expect(arg.startStr).toEqual('2014-04-28');
                          expect(arg.end).toEqualDate('2014-04-29');
                          expect(arg.endStr).toEqual('2014-04-29');
                      },
                  };
                  spyOn(options, 'select').and.callThrough();
                  let calendar = initCalendar(options);
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  dayGridWrapper.selectDates('2014-04-28', '2014-04-28').then(() => {
                      expect(options.select).toHaveBeenCalled();
                      done();
                  });
              });
          });
          describe('when in week view', () => {
              pushOptions({
                  initialView: 'timeGridWeek',
              });
              describe('when selecting all-day slots', () => {
                  it('gets fired correctly when the user selects cells', (done) => {
                      let options = {
                          select(arg) {
                              expect(arg.start instanceof Date).toEqual(true);
                              expect(arg.end instanceof Date).toEqual(true);
                              expect(typeof arg.jsEvent).toEqual('object'); // TODO: more discrimination
                              expect(typeof arg.view).toEqual('object'); // "
                              expect(arg.allDay).toEqual(true);
                              expect(arg.start).toEqualDate('2014-05-28');
                              expect(arg.startStr).toEqual('2014-05-28');
                              expect(arg.end).toEqualDate('2014-05-30');
                              expect(arg.endStr).toEqual('2014-05-30');
                          },
                      };
                      spyOn(options, 'select').and.callThrough();
                      let calendar = initCalendar(options);
                      let dayGridWrapper = new TimeGridViewWrapper(calendar).dayGrid;
                      dayGridWrapper.selectDates('2014-05-28', '2014-05-29').then(() => {
                          expect(options.select).toHaveBeenCalled();
                          done();
                      });
                  });
                  it('gets fired correctly when the user selects a single cell', (done) => {
                      let options = {
                          select(arg) {
                              expect(arg.start instanceof Date).toEqual(true);
                              expect(arg.end instanceof Date).toEqual(true);
                              expect(typeof arg.jsEvent).toEqual('object'); // TODO: more discrimination
                              expect(typeof arg.view).toEqual('object'); // "
                              expect(arg.allDay).toEqual(true);
                              expect(arg.start).toEqualDate('2014-05-28');
                              expect(arg.startStr).toEqual('2014-05-28');
                              expect(arg.end).toEqualDate('2014-05-29');
                              expect(arg.endStr).toEqual('2014-05-29');
                          },
                      };
                      spyOn(options, 'select').and.callThrough();
                      let calendar = initCalendar(options);
                      let dayGridWrapper = new TimeGridViewWrapper(calendar).dayGrid;
                      dayGridWrapper.selectDates('2014-05-28', '2014-05-28').then(() => {
                          expect(options.select).toHaveBeenCalled();
                          done();
                      });
                  });
              });
              describe('when selecting timed slots', () => {
                  it('gets fired correctly when the user selects slots', (done) => {
                      let options = {
                          select(arg) {
                              expect(arg.start instanceof Date).toEqual(true);
                              expect(arg.end instanceof Date).toEqual(true);
                              expect(typeof arg.jsEvent).toEqual('object'); // TODO: more discrimination
                              expect(typeof arg.view).toEqual('object'); // "
                              expect(arg.allDay).toEqual(false);
                              expect(arg.start).toEqualDate('2014-05-28T09:00:00Z');
                              expect(arg.startStr).toEqual('2014-05-28T09:00:00Z');
                              expect(arg.end).toEqualDate('2014-05-28T10:30:00Z');
                              expect(arg.endStr).toEqual('2014-05-28T10:30:00Z');
                          },
                      };
                      spyOn(options, 'select').and.callThrough();
                      let calendar = initCalendar(options);
                      let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                      timeGridWrapper.selectDates('2014-05-28T09:00:00', '2014-05-28T10:30:00').then(() => {
                          expect(options.select).toHaveBeenCalled();
                          done();
                      });
                  });
                  // https://github.com/fullcalendar/fullcalendar/issues/4505
                  it('gets fired correctly when the user selects slots NEAR THE END', (done) => {
                      let options = {
                          scrollTime: '24:00',
                          select(arg) {
                              expect(arg.start).toEqualDate('2014-05-28T16:00:00Z');
                              expect(arg.end).toEqualDate('2014-05-29T00:00:00Z');
                          },
                      };
                      spyOn(options, 'select').and.callThrough();
                      let calendar = initCalendar(options);
                      let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                      timeGridWrapper.selectDates('2014-05-28T16:00:00', '2014-05-29T00:00:00').then(() => {
                          expect(options.select).toHaveBeenCalled();
                          done();
                      });
                  });
                  it('gets fired correctly when the user selects slots via touch', (done) => {
                      let options = {
                          select(arg) {
                              expect(arg.start instanceof Date).toEqual(true);
                              expect(arg.end instanceof Date).toEqual(true);
                              expect(typeof arg.jsEvent).toEqual('object'); // TODO: more discrimination
                              expect(typeof arg.view).toEqual('object'); // "
                              expect(arg.allDay).toEqual(false);
                              expect(arg.start).toEqualDate('2014-05-28T09:00:00Z');
                              expect(arg.startStr).toEqual('2014-05-28T09:00:00Z');
                              expect(arg.end).toEqualDate('2014-05-28T10:30:00Z');
                              expect(arg.endStr).toEqual('2014-05-28T10:30:00Z');
                          },
                      };
                      spyOn(options, 'select').and.callThrough();
                      let calendar = initCalendar(options);
                      let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                      setTimeout(() => {
                          timeGridWrapper.selectDatesTouch('2014-05-28T09:00:00', '2014-05-28T10:30:00', true).then(() => {
                              expect(options.select).toHaveBeenCalled();
                              done();
                          });
                      }, 100);
                  });
                  it('gets fired correctly when the user selects slots in a different day', (done) => {
                      let options = {
                          select(arg) {
                              expect(arg.start instanceof Date).toEqual(true);
                              expect(arg.end instanceof Date).toEqual(true);
                              expect(typeof arg.jsEvent).toEqual('object'); // TODO: more discrimination
                              expect(typeof arg.view).toEqual('object'); // "
                              expect(arg.allDay).toEqual(false);
                              expect(arg.start).toEqualDate('2014-05-28T09:00:00Z');
                              expect(arg.startStr).toEqual('2014-05-28T09:00:00Z');
                              expect(arg.end).toEqualDate('2014-05-29T10:30:00Z');
                              expect(arg.endStr).toEqual('2014-05-29T10:30:00Z');
                          },
                      };
                      spyOn(options, 'select').and.callThrough();
                      let calendar = initCalendar(options);
                      let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                      timeGridWrapper.selectDates('2014-05-28T09:00:00', '2014-05-29T10:30:00').then(() => {
                          expect(options.select).toHaveBeenCalled();
                          done();
                      });
                  });
                  it('gets fired correctly when the user selects a single slot', (done) => {
                      let options = {
                          select(arg) {
                              expect(arg.start instanceof Date).toEqual(true);
                              expect(arg.end instanceof Date).toEqual(true);
                              expect(typeof arg.jsEvent).toEqual('object'); // TODO: more discrimination
                              expect(typeof arg.view).toEqual('object'); // "
                              expect(arg.allDay).toEqual(false);
                              expect(arg.start).toEqualDate('2014-05-28T09:00:00Z');
                              expect(arg.startStr).toEqual('2014-05-28T09:00:00Z');
                              expect(arg.end).toEqualDate('2014-05-28T09:30:00Z');
                              expect(arg.endStr).toEqual('2014-05-28T09:30:00Z');
                          },
                      };
                      spyOn(options, 'select').and.callThrough();
                      let calendar = initCalendar(options);
                      let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                      timeGridWrapper.selectDates('2014-05-28T09:00:00', '2014-05-28T09:30:00').then(() => {
                          expect(options.select).toHaveBeenCalled();
                          done();
                      });
                  });
              });
          });
      });
      describe('when selectMinDistance', () => {
          pushOptions({
              selectMinDistance: 10,
          });
          it('will fire when dragged beyond distance', (done) => {
              let options = {
                  select() { },
              };
              spyOn(options, 'select').and.callThrough();
              let calendar = initCalendar(options);
              let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
              $(dayGridWrapper.getDayEl('2014-04-28')).simulate('drag', {
                  dx: 12,
                  dy: 0,
                  callback() {
                      expect(options.select).toHaveBeenCalled();
                      done();
                  },
              });
          });
          it('will not fire when not dragged beyond distance', (done) => {
              let options = {
                  select() { },
              };
              spyOn(options, 'select').and.callThrough();
              let calendar = initCalendar(options);
              let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
              $(dayGridWrapper.getDayEl('2014-04-28')).simulate('drag', {
                  dx: 8,
                  dy: 0,
                  callback() {
                      expect(options.select).not.toHaveBeenCalled();
                      done();
                  },
              });
          });
      });
      it('will fire on a calendar that hasn\'t been rendered yet', (done) => {
          let calendar = new Calendar(document.createElement('div'), {
              plugins: [index$b, index$a],
              now: '2018-12-25',
              select(info) {
                  expect(info.startStr).toBe('2018-12-20');
                  expect(info.endStr).toBe('2018-12-23');
                  done();
              },
          });
          calendar.select('2018-12-20', '2018-12-23');
      });
  });

  function doElsMatchSegs(els, segs, segToRectFunc) {
      let elRect;
      let found;
      let i;
      let j;
      let k;
      let len;
      let len1;
      let seg;
      let segRect;
      let unmatchedRects = getBoundingRects(els);
      if (unmatchedRects.length !== segs.length) {
          return false;
      }
      for (j = 0, len = segs.length; j < len; j += 1) {
          seg = segs[j];
          segRect = segToRectFunc(seg);
          found = false;
          for (i = k = 0, len1 = unmatchedRects.length; k < len1; i = (k += 1)) {
              elRect = unmatchedRects[i];
              if (isRectsSimilar(elRect, segRect)) {
                  unmatchedRects.splice(i, 1); // remove
                  found = true;
                  break;
              }
          }
          if (!found) {
              return false;
          }
      }
      return !unmatchedRects.length;
  }

  // most other businessHours tests are in background-events.js
  describe('businessHours', () => {
      pushOptions({
          timeZone: 'UTC',
          initialDate: '2014-11-25',
          initialView: 'dayGridMonth',
          businessHours: true,
      });
      it('doesn\'t break when starting out in a larger month time range', () => {
          let calendar = initCalendar(); // start out in the month range
          currentCalendar.changeView('timeGridWeek');
          currentCalendar.next(); // move out of the original month range...
          currentCalendar.next(); // ... out. should render correctly.
          // whole days
          let dayGridWrapper = new TimeGridViewWrapper(calendar).dayGrid;
          expect(dayGridWrapper.getNonBusinessDayEls().length).toBe(2); // each multi-day stretch is one element
          // timed area
          expect(isTimeGridNonBusinessSegsRendered(calendar, [
              // sun
              { start: '2014-12-07T00:00', end: '2014-12-08T00:00' },
              // mon
              { start: '2014-12-08T00:00', end: '2014-12-08T09:00' },
              { start: '2014-12-08T17:00', end: '2014-12-09T00:00' },
              // tue
              { start: '2014-12-09T00:00', end: '2014-12-09T09:00' },
              { start: '2014-12-09T17:00', end: '2014-12-10T00:00' },
              // wed
              { start: '2014-12-10T00:00', end: '2014-12-10T09:00' },
              { start: '2014-12-10T17:00', end: '2014-12-11T00:00' },
              // thu
              { start: '2014-12-11T00:00', end: '2014-12-11T09:00' },
              { start: '2014-12-11T17:00', end: '2014-12-12T00:00' },
              // fri
              { start: '2014-12-12T00:00', end: '2014-12-12T09:00' },
              { start: '2014-12-12T17:00', end: '2014-12-13T00:00' },
              // sat
              { start: '2014-12-13T00:00', end: '2014-12-14T00:00' },
          ])).toBe(true);
      });
      describe('when used as a dynamic option', () => {
          ['timeGridWeek', 'dayGridMonth'].forEach((viewName) => {
              it('allows dynamic turning on', () => {
                  let calendar = initCalendar({
                      initialView: viewName,
                      businessHours: false,
                  });
                  let calendarWrapper = new CalendarWrapper(calendar);
                  expect(calendarWrapper.getNonBusinessDayEls().length).toBe(0);
                  currentCalendar.setOption('businessHours', true);
                  expect(calendarWrapper.getNonBusinessDayEls().length).toBeGreaterThan(0);
              });
              it('allows dynamic turning off', () => {
                  let calendar = initCalendar({
                      initialView: viewName,
                      businessHours: true,
                  });
                  let calendarWrapper = new CalendarWrapper(calendar);
                  expect(calendarWrapper.getNonBusinessDayEls().length).toBeGreaterThan(0);
                  currentCalendar.setOption('businessHours', false);
                  expect(calendarWrapper.getNonBusinessDayEls().length).toBe(0);
              });
          });
      });
      describe('for multiple day-of-week definitions', () => {
          it('rendes two day-of-week groups', () => {
              let calendar = initCalendar({
                  initialDate: '2014-12-07',
                  initialView: 'timeGridWeek',
                  businessHours: [
                      {
                          daysOfWeek: [1, 2, 3],
                          startTime: '08:00',
                          endTime: '18:00',
                      },
                      {
                          daysOfWeek: [4, 5],
                          startTime: '10:00',
                          endTime: '16:00',
                      },
                  ],
              });
              // timed area
              expect(isTimeGridNonBusinessSegsRendered(calendar, [
                  // sun
                  { start: '2014-12-07T00:00', end: '2014-12-08T00:00' },
                  // mon
                  { start: '2014-12-08T00:00', end: '2014-12-08T08:00' },
                  { start: '2014-12-08T18:00', end: '2014-12-09T00:00' },
                  // tue
                  { start: '2014-12-09T00:00', end: '2014-12-09T08:00' },
                  { start: '2014-12-09T18:00', end: '2014-12-10T00:00' },
                  // wed
                  { start: '2014-12-10T00:00', end: '2014-12-10T08:00' },
                  { start: '2014-12-10T18:00', end: '2014-12-11T00:00' },
                  // thu
                  { start: '2014-12-11T00:00', end: '2014-12-11T10:00' },
                  { start: '2014-12-11T16:00', end: '2014-12-12T00:00' },
                  // fri
                  { start: '2014-12-12T00:00', end: '2014-12-12T10:00' },
                  { start: '2014-12-12T16:00', end: '2014-12-13T00:00' },
                  // sat
                  { start: '2014-12-13T00:00', end: '2014-12-14T00:00' },
              ])).toBe(true);
          });
          it('wont\'t process businessHour items that omit dow', () => {
              let calendar = initCalendar({
                  initialDate: '2014-12-07',
                  initialView: 'timeGridWeek',
                  businessHours: [
                      {
                          // invalid
                          startTime: '08:00',
                          endTime: '18:00',
                      },
                      {
                          daysOfWeek: [4, 5],
                          startTime: '10:00',
                          endTime: '16:00',
                      },
                  ],
              });
              // timed area
              expect(isTimeGridNonBusinessSegsRendered(calendar, [
                  // sun
                  { start: '2014-12-07T00:00', end: '2014-12-08T00:00' },
                  // mon
                  { start: '2014-12-08T00:00', end: '2014-12-09T00:00' },
                  // tue
                  { start: '2014-12-09T00:00', end: '2014-12-10T00:00' },
                  // wed
                  { start: '2014-12-10T00:00', end: '2014-12-11T00:00' },
                  // thu
                  { start: '2014-12-11T00:00', end: '2014-12-11T10:00' },
                  { start: '2014-12-11T16:00', end: '2014-12-12T00:00' },
                  // fri
                  { start: '2014-12-12T00:00', end: '2014-12-12T10:00' },
                  { start: '2014-12-12T16:00', end: '2014-12-13T00:00' },
                  // sat
                  { start: '2014-12-13T00:00', end: '2014-12-14T00:00' },
              ])).toBe(true);
          });
      });
      it('will grey-out a totally non-business-hour view', () => {
          let calendar = initCalendar({
              initialDate: '2016-07-23',
              initialView: 'timeGridDay',
              businessHours: true,
          });
          // timed area
          expect(isTimeGridNonBusinessSegsRendered(calendar, [
              { start: '2016-07-23T00:00', end: '2016-07-24T00:00' },
          ])).toBe(true);
      });
      function isTimeGridNonBusinessSegsRendered(calendar, segs) {
          let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
          return doElsMatchSegs(timeGridWrapper.getNonBusinessDayEls(), segs, timeGridWrapper.getRect.bind(timeGridWrapper));
      }
  });

  describe('titleFormat', () => {
      describe('when default', () => {
          pushOptions({
              initialDate: '2014-06-12',
              titleRangeSeparator: ' - ',
          });
          const VIEWS_WITH_FORMATS = [
              { view: 'dayGridMonth', expected: 'June 2014' },
              { view: 'dayGridWeek', expected: /Jun 8 - 14,? 2014/ },
              { view: 'timeGridWeek', expected: /Jun 8 - 14,? 2014/ },
              { view: 'dayGridDay', expected: /June 12,? 2014/ },
              { view: 'timeGridDay', expected: /June 12,? 2014/ },
          ];
          it('should have default values', () => {
              let calendar = initCalendar();
              let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
              for (let viewWithFormat of VIEWS_WITH_FORMATS) {
                  calendar.changeView(viewWithFormat.view);
                  expect(toolbarWrapper.getTitleText()).toMatch(viewWithFormat.expected);
              }
          });
      });
      describe('when set on a per-view basis', () => {
          pushOptions({
              initialDate: '2014-06-12',
              titleRangeSeparator: ' - ',
              views: {
                  month: { titleFormat: { year: 'numeric', month: 'long' } },
                  dayGridWeek: { titleFormat: { day: 'numeric', month: 'short', year: 'numeric' } },
                  week: { titleFormat: { day: 'numeric', month: 'long', year: 'numeric' } },
                  dayGridDay: { titleFormat: { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' } },
              },
          });
          const VIEWS_WITH_FORMATS = [
              { view: 'dayGridMonth', expected: 'June 2014' },
              { view: 'dayGridWeek', expected: 'Jun 8 - 14, 2014' },
              { view: 'timeGridWeek', expected: 'June 8 - 14, 2014' },
              { view: 'dayGridDay', expected: 'Thursday, June 12, 2014' },
          ];
          it('should have the correct values', () => {
              let calendar = initCalendar();
              let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
              for (let viewWithFormat of VIEWS_WITH_FORMATS) {
                  calendar.changeView(viewWithFormat.view);
                  expect(toolbarWrapper.getTitleText()).toMatch(viewWithFormat.expected);
              }
          });
      });
      describe('when default and locale is French', () => {
          pushOptions({
              initialDate: '2014-06-12',
              titleRangeSeparator: ' - ',
              locale: l31,
          });
          const VIEWS_WITH_FORMATS = [
              { view: 'dayGridMonth', expected: 'juin 2014' },
              { view: 'dayGridWeek', expected: '9 - 15 juin 2014' },
              { view: 'timeGridWeek', expected: '9 - 15 juin 2014' },
              { view: 'dayGridDay', expected: '12 juin 2014' },
              { view: 'timeGridDay', expected: '12 juin 2014' },
          ];
          it('should have the translated dates', () => {
              let calendar = initCalendar();
              let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
              for (let viewWithFormat of VIEWS_WITH_FORMATS) {
                  calendar.changeView(viewWithFormat.view);
                  expect(toolbarWrapper.getTitleText()).toMatch(viewWithFormat.expected);
              }
          });
      });
      describe('using custom views', () => {
          it('multi-year default only displays year', () => {
              let calendar = initCalendar({
                  views: {
                      multiYear: {
                          type: 'dayGrid',
                          duration: { years: 2 },
                      },
                  },
                  initialView: 'multiYear',
                  initialDate: '2014-12-25',
                  titleRangeSeparator: ' - ',
              });
              let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
              expect(toolbarWrapper.getTitleText()).toBe('2014 - 2015');
          });
          it('multi-month default only displays month/year', () => {
              let calendar = initCalendar({
                  views: {
                      multiMonth: {
                          type: 'dayGrid',
                          duration: { months: 2 },
                      },
                  },
                  initialView: 'multiMonth',
                  initialDate: '2014-12-25',
                  titleRangeSeparator: ' - ',
              });
              let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
              expect(toolbarWrapper.getTitleText()).toBe('December 2014 - January 2015');
          });
          it('multi-week default displays short full date', () => {
              let calendar = initCalendar({
                  views: {
                      multiWeek: {
                          type: 'dayGrid',
                          duration: { weeks: 2 },
                      },
                  },
                  initialView: 'multiWeek',
                  initialDate: '2014-12-25',
                  titleRangeSeparator: ' - ',
              });
              let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
              expect(toolbarWrapper.getTitleText()).toMatch(/Dec 21,? 2014 - Jan 3,? 2015/);
          });
          it('multi-day default displays short full date', () => {
              let calendar = initCalendar({
                  views: {
                      multiDay: {
                          type: 'dayGrid',
                          duration: { days: 2 },
                      },
                  },
                  initialView: 'multiDay',
                  initialDate: '2014-12-25',
                  titleRangeSeparator: ' - ',
              });
              let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
              expect(toolbarWrapper.getTitleText()).toMatch(/Dec 25 - 26,? 2014/);
          });
      });
      describe('when not all days are shown', () => {
          it('doesn\'t include hidden days in the title', () => {
              let calendar = initCalendar({
                  initialView: 'timeGridWeek',
                  initialDate: '2017-02-13',
                  weekends: false,
                  titleRangeSeparator: ' - ',
              });
              let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
              expect(toolbarWrapper.getTitleText()).toBe('Feb 13 - 17, 2017'); // does not include Sunday
          });
      });
  });

  describe('scrollTime', () => {
      pushOptions({
          initialView: 'timeGridWeek',
      });
      it('accepts a string Duration', () => {
          let calendar = initCalendar({
              scrollTime: '02:00:00',
              height: 400, // short enough to make scrolling happen
          });
          let viewWrapper = new TimeGridViewWrapper(calendar);
          let timeGridWrapper = viewWrapper.timeGrid;
          let slotTop = viewWrapper.timeGrid.getTimeTop('02:00:00') - $(timeGridWrapper.el).offset().top;
          let scrollTop = viewWrapper.getScrollerEl().scrollTop;
          let diff = Math.abs(slotTop - scrollTop);
          expect(slotTop).toBeGreaterThan(0);
          expect(scrollTop).toBeGreaterThan(0);
          expect(diff).toBeLessThan(3);
      });
      it('accepts a Duration object', () => {
          let calendar = initCalendar({
              scrollTime: { hours: 2 },
              height: 400, // short enough to make scrolling happen
          });
          let viewWrapper = new TimeGridViewWrapper(calendar);
          let timeGridWrapper = viewWrapper.timeGrid;
          let slotTop = timeGridWrapper.getTimeTop('02:00:00') - $(timeGridWrapper.el).offset().top;
          let scrollTop = viewWrapper.getScrollerEl().scrollTop;
          let diff = Math.abs(slotTop - scrollTop);
          expect(slotTop).toBeGreaterThan(0);
          expect(scrollTop).toBeGreaterThan(0);
          expect(diff).toBeLessThan(3);
      });
      it('doesn\'t get applied on navigation when scrollTimeReset is false', () => {
          let calendar = initCalendar({
              scrollTime: '02:00:00',
              scrollTimeReset: false,
              height: 400, // short enough to make scrolling happen
          });
          let viewWrapper = new TimeGridViewWrapper(calendar);
          let scrollEl = viewWrapper.getScrollerEl();
          scrollEl.scrollTop = 99999;
          let scrollTop = scrollEl.scrollTop;
          calendar.next();
          expect(scrollEl.scrollTop).toBe(scrollTop); // stays the same
      });
  });

  describe('removeEvents', () => {
      pushOptions({
          initialDate: '2014-06-24',
          initialView: 'dayGridMonth',
      });
      function buildEventsWithoutIds() {
          return [
              { title: 'event zero', start: '2014-06-24', className: 'event-zero' },
              { title: 'event one', start: '2014-06-24', className: 'event-non-zero event-one' },
              { title: 'event two', start: '2014-06-24', className: 'event-non-zero event-two' },
          ];
      }
      function buildEventsWithIds() {
          let events = buildEventsWithoutIds();
          let i;
          for (i = 0; i < events.length; i += 1) {
              events[i].id = i;
          }
          return events;
      }
      $.each({
          'when events without IDs': buildEventsWithoutIds,
          'when events with IDs': buildEventsWithIds,
      }, (desc, eventGenerator) => {
          describe(desc, () => {
              it('can remove all events if no args specified', (done) => {
                  go(eventGenerator(), () => {
                      currentCalendar.removeAllEvents();
                  }, () => {
                      expect(currentCalendar.getEvents().length).toEqual(0);
                      let calendarWrapper = new CalendarWrapper(currentCalendar);
                      expect(calendarWrapper.getEventEls().length).toEqual(0);
                  }, done);
              });
              it('can remove events individually', (done) => {
                  go(eventGenerator(), () => {
                      currentCalendar.getEvents().forEach((event) => {
                          if ($.inArray('event-one', event.classNames) !== -1) {
                              event.remove();
                          }
                      });
                  }, () => {
                      expect(currentCalendar.getEvents().length).toEqual(2);
                      let calendarWrapper = new CalendarWrapper(currentCalendar);
                      expect(calendarWrapper.getEventEls().length).toEqual(2);
                      expect($('.event-zero').length).toEqual(1);
                      expect($('.event-two').length).toEqual(1);
                  }, done);
              });
          });
      });
      it('can remove events with a numeric ID', (done) => {
          go(buildEventsWithIds(), () => {
              currentCalendar.getEventById(1).remove();
          }, () => {
              expect(currentCalendar.getEvents().length).toEqual(2);
              let calendarWrapper = new CalendarWrapper(currentCalendar);
              expect(calendarWrapper.getEventEls().length).toEqual(2);
              expect($('.event-zero').length).toEqual(1);
              expect($('.event-two').length).toEqual(1);
          }, done);
      });
      it('can remove events with a string ID', (done) => {
          go(buildEventsWithIds(), () => {
              currentCalendar.getEventById('1').remove();
          }, () => {
              expect(currentCalendar.getEvents().length).toEqual(2);
              let calendarWrapper = new CalendarWrapper(currentCalendar);
              expect(calendarWrapper.getEventEls().length).toEqual(2);
              expect($('.event-zero').length).toEqual(1);
              expect($('.event-two').length).toEqual(1);
          }, done);
      });
      it('can remove an event with ID 0', (done) => {
          go(buildEventsWithIds(), () => {
              currentCalendar.getEventById(0).remove();
          }, () => {
              expect(currentCalendar.getEvents().length).toEqual(2);
              let calendarWrapper = new CalendarWrapper(currentCalendar);
              expect(calendarWrapper.getEventEls().length).toEqual(2);
              expect($('.event-zero').length).toEqual(0);
              expect($('.event-non-zero').length).toEqual(2);
          }, done);
      });
      // Verifies the actions in removeFunc executed correctly by calling checkFunc.
      function go(events, removeFunc, checkFunc, doneFunc) {
          initCalendar({
              events,
          });
          checkAllEvents(); // make sure all events initially rendered correctly
          removeFunc(); // remove the events
          setTimeout(() => {
              checkFunc(); // check correctness
              // move the calendar back out of view, then back in
              currentCalendar.next();
              currentCalendar.prev();
              // array event sources should maintain the same state
              // whereas "dynamic" event sources should refetch and reset the state
              if ($.isArray(events)) {
                  checkFunc(); // for issue 2187
              }
              else {
                  checkAllEvents();
              }
              doneFunc();
          }, 0);
      }
      // Checks to make sure all events have been rendered and that the calendar
      // has internal info on all the events.
      function checkAllEvents() {
          expect(currentCalendar.getEvents().length).toEqual(3);
          let calendarWrapper = new CalendarWrapper(currentCalendar);
          expect(calendarWrapper.getEventEls().length).toEqual(3);
      }
  });

  describe('navLinks', () => {
      pushOptions({
          now: '2016-08-20',
          navLinks: true,
          headerToolbar: {
              left: 'prev,next today',
              center: 'title',
              right: 'dayGridMonth,timeGridWeek,timeGridDay,listWeek', // affects which view is jumped to by default
          },
      });
      describeTimeZones((tz) => {
          describe('in month view', () => {
              pushOptions({
                  initialView: 'dayGridMonth',
              });
              it('moves to day', () => {
                  let dateClickSpy = spyOnCalendarCallback('dateClick');
                  let calendar = initCalendar();
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  dayGridWrapper.clickNavLink('2016-08-09');
                  expectDayView(calendar, 'timeGridDay', tz.parseDate('2016-08-09'));
                  expect(dateClickSpy).not.toHaveBeenCalled();
              });
              // https://github.com/fullcalendar/fullcalendar/issues/4619
              it('moves to day when no toolbars', () => {
                  let dateClickSpy = spyOnCalendarCallback('dateClick');
                  let calendar = initCalendar({
                      headerToolbar: null,
                  });
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  dayGridWrapper.clickNavLink('2016-08-09');
                  expectDayView(calendar, 'dayGridDay', tz.parseDate('2016-08-09')); // is hash-key order-dependent I think :(
                  expect(dateClickSpy).not.toHaveBeenCalled();
              });
              // https://github.com/fullcalendar/fullcalendar/issues/3869
              it('moves to two different days', () => {
                  let dateClickSpy = spyOnCalendarCallback('dateClick');
                  let calendar = initCalendar();
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  dayGridWrapper.clickNavLink('2016-08-09');
                  expectDayView(calendar, 'timeGridDay', tz.parseDate('2016-08-09'));
                  expect(dateClickSpy).not.toHaveBeenCalled();
                  calendar.changeView('dayGridMonth');
                  let dayGridWrapper2 = new DayGridViewWrapper(calendar).dayGrid;
                  dayGridWrapper2.clickNavLink('2016-08-10');
                  expectDayView(calendar, 'timeGridDay', tz.parseDate('2016-08-10'));
              });
              it('moves to day specifically', () => {
                  let dateClickSpy = spyOnCalendarCallback('dateClick');
                  let calendar = initCalendar({
                      navLinkDayClick: 'day',
                  });
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  dayGridWrapper.clickNavLink('2016-08-09');
                  expectDayView(calendar, 'timeGridDay', tz.parseDate('2016-08-09'));
                  expect(dateClickSpy).not.toHaveBeenCalled();
              });
              it('moves to dayGridDay specifically', () => {
                  let dateClickSpy = spyOnCalendarCallback('dateClick');
                  let calendar = initCalendar({
                      navLinkDayClick: 'dayGridDay',
                  });
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  dayGridWrapper.clickNavLink('2016-08-09');
                  expectDayView(calendar, 'dayGridDay', tz.parseDate('2016-08-09'));
                  expect(dateClickSpy).not.toHaveBeenCalled();
              });
              it('executes a custom handler', () => {
                  let dateClickSpy = spyOnCalendarCallback('dateClick');
                  let navLinkDayClickSpy = spyOnCalendarCallback('navLinkDayClick', (date, ev) => {
                      expect(date).toEqualDate(tz.parseDate('2016-08-09'));
                      expect(typeof ev).toBe('object');
                  });
                  let calendar = initCalendar();
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  dayGridWrapper.clickNavLink('2016-08-09');
                  expect(dateClickSpy).not.toHaveBeenCalled();
                  expect(navLinkDayClickSpy).toHaveBeenCalled();
              });
              describe('with weekNumbers', () => {
                  pushOptions({
                      weekNumbers: true,
                  });
                  it('moves to week', () => {
                      let dateClickSpy = spyOnCalendarCallback('dateClick');
                      let calendar = initCalendar();
                      let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                      $.simulateMouseClick(dayGridWrapper.getWeekNavLinkEls()[1]);
                      expectWeekView(calendar, 'timeGridWeek', tz.parseDate('2016-08-07'));
                      expect(dateClickSpy).not.toHaveBeenCalled();
                  });
              });
              it('does not have clickable day header', () => {
                  let calendar = initCalendar();
                  let headerWrapper = new DayGridViewWrapper(calendar).header;
                  expect(headerWrapper.getNavLinkEls().length).toBe(0);
              });
          });
      });
      describe('in week view', () => {
          pushOptions({
              initialView: 'timeGridWeek',
          });
          it('moves to day view', () => {
              let dateClickSpy = spyOnCalendarCallback('dateClick');
              let calendar = initCalendar();
              let headerWrapper = new TimeGridViewWrapper(calendar).header;
              headerWrapper.clickNavLink('2016-08-15');
              expectDayView(calendar, 'timeGridDay', '2016-08-15');
              expect(dateClickSpy).not.toHaveBeenCalled();
          });
      });
      describe('in listWeek', () => {
          pushOptions({
              initialView: 'listWeek',
              events: [
                  {
                      title: 'event 1',
                      start: '2016-08-20',
                  },
              ],
          });
          it('moves to day view', () => {
              let dateClickSpy = spyOnCalendarCallback('dateClick');
              let calendar = initCalendar();
              let listWrapper = new ListViewWrapper(calendar);
              listWrapper.clickNavLink('2016-08-20');
              expectDayView(calendar, 'timeGridDay', '2016-08-20');
              expect(dateClickSpy).not.toHaveBeenCalled();
          });
      });
      describe('in day view', () => {
          pushOptions({
              initialView: 'timeGridDay',
          });
          it('moves to week view', () => {
              let dateClickSpy = spyOnCalendarCallback('dateClick');
              let calendar = initCalendar({
                  weekNumbers: true,
              });
              let viewWrapper = new TimeGridViewWrapper(calendar);
              $.simulateMouseClick(viewWrapper.getHeaderWeekNumberLink());
              expectWeekView(calendar, 'timeGridWeek', '2016-08-14');
              expect(dateClickSpy).not.toHaveBeenCalled();
          });
          it('does not have a clickable day header', () => {
              let calendar = initCalendar();
              let headerWrapper = new TimeGridViewWrapper(calendar).header;
              expect(headerWrapper.getNavLinkEls().length).toBe(0);
          });
      });
      function expectDayView(calendar, viewName, dayDate) {
          let calendarWrapper = new CalendarWrapper(calendar);
          let start = calendar.view.activeStart;
          let end = calendar.view.activeEnd;
          expect(calendarWrapper.getViewName()).toBe(viewName);
          expect(start).toEqualDate(dayDate);
          expect(addDays(end, -1)).toEqualDate(dayDate);
      }
      function expectWeekView(calendar, viewName, firstDayDate) {
          let calendarWrapper = new CalendarWrapper(calendar);
          let start = calendar.view.activeStart;
          let end = calendar.view.activeEnd;
          expect(calendarWrapper.getViewName()).toBe(viewName);
          expect(start).toEqualDate(firstDayDate);
          expect(addDays(end, -7)).toEqualDate(firstDayDate);
      }
  });

  describe('rerenderDelay', () => {
      it('batches together many event renders', (done) => {
          let eventSource1 = [
              { title: 'event1', start: '2016-12-04T01:00:00', className: 'event1' },
              { title: 'event2', start: '2016-12-04T02:00:00', className: 'event2' },
          ];
          let eventSource2 = [
              { title: 'event3', start: '2016-12-04T03:00:00', className: 'event3' },
              { title: 'event4', start: '2016-12-04T04:00:00', className: 'event4' },
          ];
          let extraEvent1 = { title: 'event5', start: '2016-12-04T05:00:00', className: 'event5', id: '5' };
          let extraEvent2 = { title: 'event6', start: '2016-12-04T06:00:00', className: 'event6', id: '6' };
          let calendar = initCalendar({
              initialDate: '2016-12-04',
              initialView: 'timeGridDay',
              events: eventSource1,
              rerenderDelay: 0, // will still debounce despite being zero
          });
          let calendarWrapper = new CalendarWrapper(calendar);
          expect(calendarWrapper.getEventEls().length).toBe(2);
          currentCalendar.addEventSource(eventSource2);
          expect(calendarWrapper.getEventEls().length).toBe(2);
          currentCalendar.addEvent(extraEvent1);
          expect(calendarWrapper.getEventEls().length).toBe(2);
          let refined2 = currentCalendar.addEvent(extraEvent2);
          expect(calendarWrapper.getEventEls().length).toBe(2);
          refined2.remove();
          expect(calendarWrapper.getEventEls().length).toBe(2);
          setTimeout(() => {
              expect($('.event1').length).toBe(1);
              expect($('.event2').length).toBe(1);
              expect($('.event3').length).toBe(1);
              expect($('.event4').length).toBe(1);
              expect($('.event5').length).toBe(1);
              expect($('.event6').length).toBe(0); // got removed
              done();
          }, 1);
      });
  });

  describe('event constraint', () => {
      pushOptions({
          initialDate: '2014-11-10',
          initialView: 'timeGridWeek',
          scrollTime: '00:00',
      });
      describe('when used with a specific date range', () => {
          describe('when an event is being dragged', () => {
              describe('to the middle of the constraint range', () => {
                  it('allows a drag', (done) => {
                      let options = {
                          events: [{
                                  start: '2014-11-10T01:00:00',
                                  end: '2014-11-10T02:00:00',
                                  constraint: {
                                      start: '2014-11-10T03:00:00',
                                      end: '2014-11-10T06:00:00',
                                  },
                              }],
                      };
                      testEventDrag(options, '2014-11-10T04:00:00', true, done);
                  });
                  describe('when in month view with timed event', () => {
                      it('allows a drag, respects time of day', (done) => {
                          let options = {
                              initialView: 'dayGridMonth',
                              events: [{
                                      start: '2014-11-10T05:00:00',
                                      end: '2014-11-10T07:00:00',
                                      constraint: {
                                          start: '04:00',
                                          end: '20:00',
                                      },
                                  }],
                          };
                          testEventDrag(options, '2014-11-14', true, () => {
                              let event = currentCalendar.getEvents()[0];
                              expect(event.start).toEqualDate('2014-11-14T05:00:00Z');
                              expect(event.end).toEqualDate('2014-11-14T07:00:00Z');
                              done();
                          });
                      });
                  });
              });
              describe('to the start of the constraint range', () => {
                  it('allows a drag', (done) => {
                      let options = {
                          events: [{
                                  start: '2014-11-10T01:00:00',
                                  end: '2014-11-10T02:00:00',
                                  constraint: {
                                      start: '2014-11-10T03:00:00',
                                      end: '2014-11-10T06:00:00',
                                  },
                              }],
                      };
                      testEventDrag(options, '2014-11-10T03:00:00', true, done);
                  });
              });
              describe('to the end of the constraint range', () => {
                  describe('when the event has an explicit end', () => {
                      it('allows a drag', (done) => {
                          let options = {
                              events: [{
                                      start: '2014-11-10T01:00:00',
                                      end: '2014-11-10T02:00:00',
                                      constraint: {
                                          start: '2014-11-10T03:00:00',
                                          end: '2014-11-10T06:00:00',
                                      },
                                  }],
                          };
                          testEventDrag(options, '2014-11-10T05:00:00', true, done);
                      });
                  });
                  describe('when the event has an implied end', () => {
                      it('allows a drag', (done) => {
                          let options = {
                              defaultTimedEventDuration: '01:30:00',
                              events: [{
                                      start: '2014-11-10T01:00:00',
                                      constraint: {
                                          start: '2014-11-10T03:00:00',
                                          end: '2014-11-10T06:00:00',
                                      },
                                  }],
                          };
                          testEventDrag(options, '2014-11-10T04:30:00', true, done);
                      });
                  });
              });
              describe('before a constraint range', () => {
                  it('does not allow a drag', (done) => {
                      let options = {
                          events: [{
                                  start: '2014-11-10T01:00:00',
                                  end: '2014-11-10T02:00:00',
                                  constraint: {
                                      start: '2014-11-10T03:00:00',
                                      end: '2014-11-10T06:00:00',
                                  },
                              }],
                      };
                      testEventDrag(options, '2014-11-10T02:00:00', false, done);
                  });
              });
              describe('after a constraint range', () => {
                  describe('using an event object\'s constraint', () => {
                      describe('when in week view with timed events', () => {
                          it('does not allow a drag', (done) => {
                              let options = {
                                  events: [{
                                          start: '2014-11-10T01:00:00',
                                          end: '2014-11-10T02:00:00',
                                          constraint: {
                                              start: '2014-11-10T03:00:00',
                                              end: '2014-11-10T06:00:00',
                                          },
                                      }],
                              };
                              testEventDrag(options, '2014-11-10T06:00:00', false, done);
                          });
                      });
                      describe('when in month view', () => {
                          pushOptions({ initialView: 'dayGridMonth' });
                          describe('with timed event and all-day constraint', () => {
                              it('does not allow a drag', (done) => {
                                  let options = {
                                      events: [{
                                              start: '2014-11-10T01:00:00',
                                              end: '2014-11-10T02:00:00',
                                              constraint: {
                                                  start: '2014-11-10',
                                                  end: '2014-11-11',
                                              },
                                          }],
                                  };
                                  testEventDrag(options, '2014-11-12', false, done);
                              });
                          });
                          describe('with timed event and timed constraint', () => {
                              it('does not allow a drag', (done) => {
                                  let options = {
                                      events: [{
                                              start: '2014-11-10T01:00:00',
                                              end: '2014-11-10T02:00:00',
                                              constraint: {
                                                  start: '2014-11-10T00:00:00',
                                                  end: '2014-11-11T12:00:00',
                                              },
                                          }],
                                  };
                                  testEventDrag(options, '2014-11-12', false, done);
                              });
                          });
                          describe('with all-day event and all-day constraint', () => {
                              it('does not allow a drag', (done) => {
                                  let options = {
                                      events: [{
                                              start: '2014-11-10',
                                              end: '2014-11-12',
                                              constraint: {
                                                  start: '2014-11-09',
                                                  end: '2014-11-13',
                                              },
                                          }],
                                  };
                                  testEventDrag(options, '2014-11-13', false, done);
                              });
                          });
                          describe('with all-day event and timed constraint', () => {
                              it('does not allow a drag', (done) => {
                                  let options = {
                                      events: [{
                                              start: '2014-11-10',
                                              end: '2014-11-12',
                                              constraint: {
                                                  start: '2014-11-09T01:00:00',
                                                  end: '2014-11-12T23:00:00',
                                              },
                                          }],
                                  };
                                  testEventDrag(options, '2014-11-13', false, done);
                              });
                          });
                      });
                  });
                  describe('using an event source\'s constraint', () => {
                      it('does not allow a drag', (done) => {
                          let options = {
                              eventSources: [{
                                      events: [{
                                              start: '2014-11-10T01:00:00',
                                              end: '2014-11-10T02:00:00',
                                          }],
                                      constraint: {
                                          start: '2014-11-10T03:00:00',
                                          end: '2014-11-10T06:00:00',
                                      },
                                  }],
                          };
                          testEventDrag(options, '2014-11-10T06:00:00', false, done);
                      });
                  });
                  describe('using eventConstraint', () => {
                      it('does not allow a drag and doesnt call eventDataTransform', (done) => {
                          let options = {
                              events: [{
                                      start: '2014-11-10T01:00:00',
                                      end: '2014-11-10T02:00:00',
                                  }],
                              eventConstraint: {
                                  start: '2014-11-10T03:00:00',
                                  end: '2014-11-10T06:00:00',
                              },
                              eventDataTransform(inData) {
                                  return inData;
                              },
                          };
                          spyOn(options, 'eventDataTransform').and.callThrough();
                          testEventDrag(options, '2014-11-10T06:00:00', false, () => {
                              expect(options.eventDataTransform.calls.count()).toBe(1); // only initial parse
                              done();
                          });
                      });
                  });
              });
              describe('intersecting the constraint start', () => {
                  describe('with no timezone', () => {
                      it('does not allow a drag', (done) => {
                          let options = {
                              events: [{
                                      start: '2014-11-10T03:00:00',
                                      end: '2014-11-10T05:00:00',
                                      constraint: {
                                          start: '2014-11-10T03:00:00',
                                          end: '2014-11-10T06:00:00',
                                      },
                                  }],
                          };
                          testEventDrag(options, '2014-11-10T02:00:00', false, done);
                      });
                  });
                  describe('with UTC timezone', () => {
                      it('does not allow a drag', (done) => {
                          let options = {
                              timeZone: 'UTC',
                              events: [{
                                      start: '2014-11-10T03:00:00+00:00',
                                      end: '2014-11-10T05:00:00+00:00',
                                      constraint: {
                                          start: '2014-11-10T03:00:00+00:00',
                                          end: '2014-11-10T06:00:00+00:00',
                                      },
                                  }],
                          };
                          testEventDrag(options, '2014-11-10T02:00:00+00:00', false, done);
                      });
                  });
              });
              describe('intersecting the constraint end', () => {
                  describe('when the event has an explicit end', () => {
                      it('does not allow a drag', (done) => {
                          let options = {
                              events: [{
                                      start: '2014-11-10T03:00:00',
                                      end: '2014-11-10T05:00:00',
                                      constraint: {
                                          start: '2014-11-10T03:00:00',
                                          end: '2014-11-10T06:00:00',
                                      },
                                  }],
                          };
                          testEventDrag(options, '2014-11-10T05:00:00', false, done);
                      });
                  });
                  describe('when the event has an implied end', () => {
                      it('does not allow a drag', (done) => {
                          let options = {
                              defaultTimedEventDuration: '02:30',
                              events: [{
                                      start: '2014-11-10T03:00:00',
                                      constraint: {
                                          start: '2014-11-10T03:00:00',
                                          end: '2014-11-10T12:00:00',
                                      },
                                  }],
                          };
                          testEventDrag(options, '2014-11-10T10:00:00', false, done);
                      });
                  });
                  describe('with UTC timezone', () => {
                      it('does not allow a drag', (done) => {
                          let options = {
                              timeZone: 'UTC',
                              events: [{
                                      start: '2014-11-10T03:00:00+00:00',
                                      end: '2014-11-10T05:00:00+00:00',
                                      constraint: {
                                          start: '2014-11-10T03:00:00+00:00',
                                          end: '2014-11-10T06:00:00+00:00',
                                      },
                                  }],
                          };
                          testEventDrag(options, '2014-11-10T05:00:00+00:00', false, done);
                      });
                  });
              });
              describe('into a constraint it encompasses', () => {
                  it('does not allow a drag', (done) => {
                      let options = {
                          events: [{
                                  start: '2014-11-10T01:00:00',
                                  end: '2014-11-10T05:00:00',
                                  constraint: {
                                      start: '2014-11-10T12:00:00',
                                      end: '2014-11-10T14:00:00',
                                  },
                              }],
                      };
                      testEventDrag(options, '2014-11-10T10:00:00', false, done);
                  });
              });
          });
          describe('when an event is being resized', () => {
              describe('when the start is already outside the constraint', () => {
                  it('does not allow a resize', (done) => {
                      let options = {
                          events: [{
                                  start: '2014-11-12T01:00:00',
                                  end: '2014-11-12T03:00:00',
                                  constraint: {
                                      start: '2014-11-12T02:00:00',
                                      end: '2014-11-12T22:00:00',
                                  },
                              }],
                      };
                      testEventResize(options, '2014-11-12T10:00:00', false, done);
                  });
              });
              describe('when resized well within the constraint', () => {
                  it('allows a resize', (done) => {
                      let options = {
                          events: [{
                                  start: '2014-11-12T02:00:00',
                                  end: '2014-11-12T04:00:00',
                                  constraint: {
                                      start: '2014-11-12T01:00:00',
                                      end: '2014-11-12T22:00:00',
                                  },
                              }],
                      };
                      testEventResize(options, '2014-11-12T10:00:00', true, done);
                  });
              });
              describe('when resized to the end of the constraint', () => {
                  it('allows a resize', (done) => {
                      let options = {
                          events: [{
                                  start: '2014-11-12T02:00:00',
                                  end: '2014-11-12T04:00:00',
                                  constraint: {
                                      start: '2014-11-12T01:00:00',
                                      end: '2014-11-12T06:00:00',
                                  },
                              }],
                      };
                      testEventResize(options, '2014-11-12T06:00:00', true, done);
                  });
              });
              describe('when resized past the end of the constraint', () => {
                  it('does not allow a resize', (done) => {
                      let options = {
                          events: [{
                                  start: '2014-11-12T02:00:00',
                                  end: '2014-11-12T04:00:00',
                                  constraint: {
                                      start: '2014-11-12T01:00:00',
                                      end: '2014-11-12T06:00:00',
                                  },
                              }],
                      };
                      testEventResize(options, '2014-11-12T07:00:00', false, done);
                  });
              });
          });
      });
      describe('when used with a recurring date range', () => {
          describe('when an event is being dragged', () => {
              describe('to the middle of the constraint range', () => {
                  it('allows a drag', (done) => {
                      let options = {
                          events: [{
                                  start: '2014-11-12T01:00:00',
                                  end: '2014-11-12T03:00:00',
                                  constraint: {
                                      startTime: '04:00:00',
                                      endTime: '08:00:00',
                                  },
                              }],
                      };
                      testEventDrag(options, '2014-11-12T05:00:00', true, done);
                  });
              });
              describe('outside of a constraint range', () => {
                  it('does not allow a drag', (done) => {
                      let options = {
                          events: [{
                                  start: '2014-11-12T01:00:00',
                                  end: '2014-11-12T03:00:00',
                                  constraint: {
                                      startTime: '04:00:00',
                                      endTime: '08:00:00',
                                  },
                              }],
                      };
                      testEventDrag(options, '2014-11-12T07:00:00', false, done);
                  });
              });
              describe('on an off-day of a constraint range', () => {
                  it('does not allow a drag', (done) => {
                      let options = {
                          events: [{
                                  start: '2014-11-12T01:00:00',
                                  end: '2014-11-12T03:00:00',
                                  constraint: {
                                      startTime: '04:00:00',
                                      endTime: '08:00:00',
                                      daysOfWeek: [0, 1, 2, 3, 5, 6], // except Thursday
                                  },
                              }],
                      };
                      testEventDrag(options, '2014-11-13T05:00:00', false, done); // drag to Thursday
                  });
              });
          });
      });
      describe('when used with businessHours', () => {
          describe('when an event is being dragged', () => {
              describe('to the middle of the constraint range', () => {
                  it('allows a drag', (done) => {
                      let options = {
                          businessHours: {
                              startTime: '02:00',
                              endTime: '06:00',
                          },
                          events: [{
                                  start: '2014-11-12T01:00:00',
                                  end: '2014-11-12T02:00:00',
                                  constraint: 'businessHours',
                              }],
                      };
                      testEventDrag(options, '2014-11-12T03:00:00', true, done);
                  });
              });
              describe('outside of a constraint range', () => {
                  it('does not allow a drag', (done) => {
                      let options = {
                          businessHours: {
                              startTime: '02:00',
                              endTime: '06:00',
                          },
                          events: [{
                                  start: '2014-11-12T01:00:00',
                                  end: '2014-11-12T02:30:00',
                                  constraint: 'businessHours',
                              }],
                      };
                      testEventDrag(options, '2014-11-12T05:00:00', false, done);
                  });
              });
              describe('on an off-day of a constraint range', () => {
                  it('does not allow a drag', (done) => {
                      let options = {
                          businessHours: {
                              startTime: '02:00',
                              endTime: '06:00',
                              daysOfWeek: [1, 2, 3, 4], // Mon - Thurs
                          },
                          events: [{
                                  start: '2014-11-12T01:00:00',
                                  end: '2014-11-12T02:30:00',
                                  constraint: 'businessHours',
                              }],
                      };
                      testEventDrag(options, '2014-11-14T03:00:00', false, done); // Friday
                  });
              });
          });
      });
      describe('when used with an event group ID', () => {
          describe('when an event is being dragged', () => {
              describe('to the middle of the constraint range', () => {
                  it('allows a drag', (done) => {
                      let options = {
                          events: [
                              {
                                  start: '2014-11-12T01:00:00',
                                  end: '2014-11-12T03:00:00',
                                  className: 'dragging-event',
                                  constraint: 'yo',
                              },
                              {
                                  groupId: 'yo',
                                  start: '2014-11-13T01:00:00',
                                  end: '2014-11-13T05:00:00',
                              },
                          ],
                      };
                      testEventDrag(options, '2014-11-13T02:00:00', true, done, 'dragging-event');
                  });
              });
              describe('outside of a foreground event constraint', () => {
                  describe('with an explicit end time', () => {
                      it('does not allow a drag', (done) => {
                          let options = {
                              events: [
                                  {
                                      start: '2014-11-12T01:00:00',
                                      end: '2014-11-12T03:00:00',
                                      constraint: 'yo',
                                      className: 'dragging-event',
                                  },
                                  {
                                      id: 'yo',
                                      start: '2014-11-13T01:00:00',
                                      end: '2014-11-13T04:00:00',
                                  },
                              ],
                          };
                          testEventDrag(options, '2014-11-13T04:00:00', false, done, 'dragging-event');
                      });
                  });
                  describe('when an implied end time', () => {
                      it('does not allow a drag', (done) => {
                          let options = {
                              defaultTimedEventDuration: '01:00:00',
                              events: [
                                  {
                                      start: '2014-11-12T01:00:00',
                                      end: '2014-11-12T03:00:00',
                                      constraint: 'yo',
                                      className: 'dragging-event',
                                  },
                                  {
                                      id: 'yo',
                                      start: '2014-11-13T01:00:00',
                                  },
                              ],
                          };
                          testEventDrag(options, '2014-11-13T01:00:00', false, done, 'dragging-event');
                      });
                  });
              });
              describe('outside of a background-event constraint', () => {
                  it('does not allow a drag', (done) => {
                      let options = {
                          events: [
                              {
                                  start: '2014-11-12T01:00:00',
                                  end: '2014-11-12T03:00:00',
                                  constraint: 'yo',
                                  className: 'dragging-event',
                              },
                              {
                                  id: 'yo',
                                  start: '2014-11-13T01:00:00',
                                  end: '2014-11-13T04:00:00',
                                  display: 'background',
                              },
                          ],
                      };
                      testEventDrag(options, '2014-11-13T04:00:00', false, done, 'dragging-event');
                  });
              });
              describe('when the event ID constraint matches no events', () => {
                  it('does not allow a drag', (done) => {
                      let options = {
                          events: [
                              {
                                  start: '2014-11-12T01:00:00',
                                  end: '2014-11-12T03:00:00',
                                  constraint: 'yo',
                              },
                          ],
                      };
                      testEventDrag(options, '2014-11-13T04:00:00', false, done);
                  });
              });
              describe('when in month view', () => {
                  pushOptions({ initialView: 'dayGridMonth' });
                  describe('when the event ID constraint matches no events', () => {
                      it('does not allow a drag', (done) => {
                          let options = {
                              events: [
                                  {
                                      start: '2014-11-12',
                                      end: '2014-11-12',
                                      constraint: 'yo',
                                  },
                              ],
                          };
                          testEventDrag(options, '2014-11-13', false, done);
                      });
                  });
              });
          });
      });
  });
  describe('selectConstraint', () => {
      pushOptions({
          initialDate: '2014-11-10',
          initialView: 'timeGridWeek',
          scrollTime: '00:00',
      });
      describe('when used with a specific date range', () => {
          describe('when dragged clearly within', () => {
              it('allows a selection', (done) => {
                  let options = {
                      selectConstraint: {
                          start: '2014-11-12T01:00:00',
                          end: '2014-11-12T20:00:00',
                      },
                  };
                  testSelection(options, '2014-11-12T03:00:00Z', '2014-11-12T10:00:00Z', true, done);
              });
          });
          describe('when dragged within, starting with the constraint start', () => {
              it('allows a selection', (done) => {
                  let options = {
                      selectConstraint: {
                          start: '2014-11-12T01:00:00',
                          end: '2014-11-12T20:00:00',
                      },
                  };
                  testSelection(options, '2014-11-12T01:00:00Z', '2014-11-12T05:00:00Z', true, done);
              });
          });
          describe('when dragged within, ending with the constraint end', () => {
              it('allows a selection', (done) => {
                  let options = {
                      selectConstraint: {
                          start: '2014-11-12T01:00:00',
                          end: '2014-11-12T05:00:00',
                      },
                  };
                  testSelection(options, '2014-11-12T03:00:00Z', '2014-11-12T05:00:00Z', true, done);
              });
          });
          describe('when dragged intersecting the constraint start', () => {
              it('does not allow a selection', (done) => {
                  let options = {
                      selectConstraint: {
                          start: '2014-11-12T03:00:00',
                          end: '2014-11-12T20:00:00',
                      },
                  };
                  testSelection(options, '2014-11-12T02:00:00Z', '2014-11-12T04:00:00Z', false, done);
              });
          });
          describe('when dragged intersecting the constraint end', () => {
              it('does not allow a selection', (done) => {
                  let options = {
                      selectConstraint: {
                          start: '2014-11-12T03:00:00',
                          end: '2014-11-12T07:00:00',
                      },
                  };
                  testSelection(options, '2014-11-12T04:00:00Z', '2014-11-12T08:00:00Z', false, done);
              });
          });
          describe('when dragged after the constraint', () => {
              describe('when in week view with timed events', () => {
                  it('does not allow a selection', (done) => {
                      let options = {
                          selectConstraint: {
                              start: '2014-11-12T03:00:00',
                              end: '2014-11-12T05:00:00',
                          },
                      };
                      testSelection(options, '2014-11-12T05:00:00Z', '2014-11-12T07:00:00Z', false, done);
                  });
              });
              describe('when in month view', () => {
                  pushOptions({ initialView: 'dayGridMonth' });
                  describe('when an all-day constraint', () => {
                      it('does not allow a selection', (done) => {
                          let options = {
                              selectConstraint: {
                                  start: '2014-11-13',
                                  end: '2014-11-14',
                              },
                          };
                          testSelection(options, '2014-11-12', '2014-11-14', false, done);
                      });
                  });
                  describe('when a timed constraint, out of bounds', () => {
                      it('does not allow a selection', (done) => {
                          let options = {
                              selectConstraint: {
                                  start: '2014-11-12T01:00:00',
                                  end: '2014-11-14T00:00:00',
                              },
                          };
                          testSelection(options, '2014-11-12', '2014-11-14', false, done);
                      });
                  });
                  describe('when a timed constraint, in bounds', () => {
                      it('allows a selection', (done) => {
                          let options = {
                              selectConstraint: {
                                  start: '2014-11-12T00:00:00',
                                  end: '2014-11-14T00:00:00',
                              },
                          };
                          testSelection(options, '2014-11-12', '2014-11-14', true, done);
                      });
                  });
              });
          });
      });
      describe('when used with a recurring date range', () => {
          describe('to the middle of the constraint range', () => {
              it('allows a selection when in bounds', (done) => {
                  let options = {
                      selectConstraint: {
                          startTime: '01:00:00',
                          endTime: '05:00:00',
                      },
                  };
                  testSelection(options, '2014-11-12T02:00:00Z', '2014-11-12T04:00:00Z', true, done);
              });
          });
          describe('outside of a constraint range', () => {
              it('does not allow a selection when single day', (done) => {
                  let options = {
                      selectConstraint: {
                          startTime: '01:00:00',
                          endTime: '05:00:00',
                      },
                  };
                  testSelection(options, '2014-11-12T02:00:00Z', '2014-11-12T06:00:00Z', false, done);
              });
              it('does not allow a selection when multiday', (done) => {
                  let options = {
                      selectConstraint: {
                          startTime: '01:00:00',
                          endTime: '05:00:00',
                      },
                  };
                  testSelection(options, '2014-11-12T02:00:00Z', '2014-11-14T04:00:00Z', false, done);
              });
          });
      });
      describe('when used with businessHours', () => {
          describe('to the middle of the constraint range', () => {
              it('allows a selection', (done) => {
                  let options = {
                      businessHours: {
                          startTime: '01:00:00',
                          endTime: '05:00:00',
                      },
                      selectConstraint: 'businessHours',
                  };
                  testSelection(options, '2014-11-12T02:00:00Z', '2014-11-12T04:00:00Z', true, done);
              });
          });
          describe('outside of a constraint range', () => {
              it('does not allow a selection', (done) => {
                  let options = {
                      businessHours: {
                          startTime: '01:00:00',
                          endTime: '05:00:00',
                      },
                      selectConstraint: 'businessHours',
                  };
                  testSelection(options, '2014-11-12T02:00:00Z', '2014-11-12T06:00:00Z', false, done);
              });
          });
          describe('with a custom dow when dragged to a dead day', () => {
              it('does not allow a selection', (done) => {
                  let options = {
                      businessHours: {
                          startTime: '01:00:00',
                          endTime: '05:00:00',
                          daysOfWeek: [1, 2, 4, 5], // Mon,Tue,Thu,Fri
                      },
                      selectConstraint: 'businessHours',
                  };
                  testSelection(options, '2014-11-12T02:00:00Z', '2014-11-12T04:00:00Z', false, done); // Wed
              });
          });
      });
      describe('when used with an event group ID', () => {
          describe('to the middle of the constraint range', () => {
              it('allows a selection', (done) => {
                  let options = {
                      events: [{
                              groupId: 'yo',
                              start: '2014-11-12T02:00:00',
                              end: '2014-11-12T05:00:00',
                              display: 'background',
                          }],
                      selectConstraint: 'yo',
                  };
                  testSelection(options, '2014-11-12T03:00:00Z', '2014-11-12T04:00:00Z', true, done);
              });
          });
          describe('outside of a constraint range', () => {
              it('does not allow a selection', (done) => {
                  let options = {
                      events: [{
                              groupId: 'yo',
                              start: '2014-11-12T02:00:00',
                              end: '2014-11-12T05:00:00',
                              display: 'background',
                          }],
                      selectConstraint: 'yo',
                  };
                  testSelection(options, '2014-11-12T03:00:00Z', '2014-11-12T06:00:00Z', false, done);
              });
          });
          describe('when event ID does not match any events', () => {
              describe('when in week view', () => {
                  it('does not allow a selection', (done) => {
                      let options = {
                          selectConstraint: 'yooo',
                      };
                      testSelection(options, '2014-11-12T03:00:00Z', '2014-11-12T06:00:00Z', false, done);
                  });
              });
              describe('when in month view', () => {
                  it('does not allow a selection', (done) => {
                      let options = {
                          initialView: 'dayGridMonth',
                          selectConstraint: 'yooo',
                      };
                      testSelection(options, '2014-11-12', '2014-11-15', false, done);
                  });
              });
          });
      });
  });

  var l57 = {
      code: 'pt-br',
      buttonText: {
          prev: 'Anterior',
          next: 'Próximo',
          prevYear: 'Ano anterior',
          nextYear: 'Próximo ano',
          year: 'Ano',
          today: 'Hoje',
          month: 'Mês',
          week: 'Semana',
          day: 'Dia',
          list: 'Lista',
      },
      buttonHints: {
          prev: '$0 Anterior',
          next: 'Próximo $0',
          today(buttonText) {
              return (buttonText === 'Dia') ? 'Hoje' :
                  ((buttonText === 'Semana') ? 'Esta' : 'Este') + ' ' + buttonText.toLocaleLowerCase();
          },
      },
      viewHint(buttonText) {
          return 'Visualizar ' + (buttonText === 'Semana' ? 'a' : 'o') + ' ' + buttonText.toLocaleLowerCase();
      },
      weekText: 'Sm',
      weekTextLong: 'Semana',
      allDayText: 'dia inteiro',
      moreLinkText(n) {
          return 'mais +' + n;
      },
      moreLinkHint(eventCnt) {
          return `Mostrar mais ${eventCnt} eventos`;
      },
      noEventsText: 'Não há eventos para mostrar',
      navLinkHint: 'Ir para $0',
      closeHint: 'Fechar',
      timeHint: 'A hora',
      eventHint: 'Evento',
  };

  describe('allDayText', () => {
      describe('when allDaySlots is not set', () => {
          describe('in week', () => {
              it('should default allDayText to using \'all-day\'', () => {
                  let calendar = initCalendar({
                      initialView: 'timeGridWeek',
                  });
                  expectAllDayTextToBe(calendar, 'all-day');
              });
          });
          describe('in day', () => {
              it('should default allDayText to using \'all-day\'', () => {
                  let calendar = initCalendar({
                      initialView: 'timeGridDay',
                  });
                  expectAllDayTextToBe(calendar, 'all-day');
              });
          });
      });
      describe('when allDaySlots is set true', () => {
          describe('in week', () => {
              it('should default allDayText to using \'all-day\'', () => {
                  let calendar = initCalendar({
                      initialView: 'timeGridWeek',
                      allDaySlot: true,
                  });
                  expectAllDayTextToBe(calendar, 'all-day');
              });
          });
          describe('in day', () => {
              it('should default allDayText to using \'all-day\'', () => {
                  let calendar = initCalendar({
                      initialView: 'timeGridDay',
                      allDaySlot: true,
                  });
                  expectAllDayTextToBe(calendar, 'all-day');
              });
          });
      });
      describe('when allDaySlots is set true and locale is not default', () => {
          describe('in week', () => {
              it('should use the locale\'s all-day value', () => {
                  let calendar = initCalendar({
                      initialView: 'timeGridWeek',
                      allDaySlot: true,
                      locale: l57,
                  });
                  expectAllDayTextToBe(calendar, 'dia inteiro');
              });
          });
          describe('in day', () => {
              it('should use the locale\'s all-day value', () => {
                  let calendar = initCalendar({
                      initialView: 'timeGridDay',
                      allDaySlot: true,
                      locale: l57,
                  });
                  expectAllDayTextToBe(calendar, 'dia inteiro');
              });
          });
      });
      describe('when allDaySlots is set true and allDayText is specified', () => {
          describe('in week', () => {
              it('should show specified all day text', () => {
                  let calendar = initCalendar({
                      initialView: 'timeGridWeek',
                      allDaySlot: true,
                      allDayText: 'axis-phosy',
                  });
                  expectAllDayTextToBe(calendar, 'axis-phosy');
              });
          });
          describe('in day', () => {
              it('should show specified all day text', () => {
                  let calendar = initCalendar({
                      initialView: 'timeGridDay',
                      allDayText: 'axis-phosy',
                  });
                  expectAllDayTextToBe(calendar, 'axis-phosy');
              });
          });
      });
      function expectAllDayTextToBe(calendar, text) {
          let viewWrapper = new TimeGridViewWrapper(calendar);
          let allDayText = viewWrapper.getAllDayAxisElText();
          expect(allDayText).toBe(text);
      }
  });

  var l45 = {
      code: 'ko',
      buttonText: {
          prev: '이전달',
          next: '다음달',
          today: '오늘',
          year: '년도',
          month: '월',
          week: '주',
          day: '일',
          list: '일정목록',
      },
      weekText: '주',
      allDayText: '종일',
      moreLinkText: '개',
      noEventsText: '일정이 없습니다',
  };

  describe('dayHeaderFormat', () => {
      describe('when not set', () => {
          pushOptions({
              initialDate: '2014-05-11',
          });
          const VIEWS_WITH_FORMAT = [
              { view: 'dayGridMonth', expected: /^Sun$/ },
              { view: 'dayGridWeek', expected: /^Sun 5[/ ]11$/ },
              { view: 'timeGridWeek', expected: /^Sun 5[/ ]11$/ },
              { view: 'dayGridDay', expected: /^Sunday$/ },
              { view: 'timeGridDay', expected: /^Sunday$/ },
          ];
          it('should have default values', () => {
              let calendar = initCalendar();
              for (let viewWithFormat of VIEWS_WITH_FORMAT) {
                  calendar.changeView(viewWithFormat.view);
                  let header = new (viewWithFormat.view.match(/^dayGrid/) ? DayGridViewWrapper : TimeGridViewWrapper)(calendar).header;
                  expect(header.getCellText(0)).toMatch(viewWithFormat.expected);
              }
          });
      });
      describe('when dayHeaderFormat is set on a per-view basis', () => {
          pushOptions({
              initialDate: '2014-05-11',
              views: {
                  month: { dayHeaderFormat: { weekday: 'long' } },
                  day: { dayHeaderFormat: { weekday: 'long', month: 'long', day: 'numeric' } },
                  dayGridWeek: { dayHeaderFormat: { weekday: 'long', month: 'numeric', day: 'numeric' } },
              },
          });
          const VIEWS_WITH_FORMAT = [
              { view: 'dayGridMonth', expected: /^Sunday$/ },
              { view: 'timeGridDay', expected: /^Sunday, May 11$/ },
              { view: 'dayGridWeek', expected: /^Sunday, 5[/ ]11$/ },
          ];
          it('should have the correct values', () => {
              let calendar = initCalendar();
              for (let viewWithFormat of VIEWS_WITH_FORMAT) {
                  calendar.changeView(viewWithFormat.view);
                  let header = new (viewWithFormat.view.match(/^dayGrid/) ? DayGridViewWrapper : TimeGridViewWrapper)(calendar).header;
                  expect(header.getCellText(0)).toMatch(viewWithFormat.expected);
              }
          });
      });
      describe('when locale is French', () => {
          pushOptions({
              initialDate: '2014-05-11',
              locale: l31,
          });
          const VIEWS_WITH_FORMAT = [
              { view: 'dayGridMonth', expected: /^dim\.$/ },
              { view: 'dayGridWeek', expected: /^dim\. 11[/ ]0?5$/ },
              { view: 'timeGridWeek', expected: /^dim\. 11[/ ]0?5$/ },
              { view: 'dayGridDay', expected: /^dimanche$/ },
              { view: 'timeGridDay', expected: /^dimanche$/ },
          ];
          it('should have the translated dates', () => {
              let calendar = initCalendar();
              for (let viewWithFormat of VIEWS_WITH_FORMAT) {
                  calendar.changeView(viewWithFormat.view);
                  let header = new (viewWithFormat.view.match(/^dayGrid/) ? DayGridViewWrapper : TimeGridViewWrapper)(calendar).header;
                  expect(header.getCellText(0)).toMatch(viewWithFormat.expected);
              }
          });
      });
      describe('when locale is en-gb', () => {
          pushOptions({
              initialDate: '2014-05-11',
              locale: l20,
          });
          const VIEWS_WITH_FORMAT = [
              { view: 'dayGridMonth', expected: /^Sun$/ },
              { view: 'dayGridWeek', expected: /^Sun 11[/ ]0?5$/ },
              { view: 'timeGridWeek', expected: /^Sun 11[/ ]0?5$/ },
              { view: 'dayGridDay', expected: /^Sunday$/ },
              { view: 'timeGridDay', expected: /^Sunday$/ },
          ];
          it('should have the translated dates', () => {
              let calendar = initCalendar();
              for (let viewWithFormat of VIEWS_WITH_FORMAT) {
                  calendar.changeView(viewWithFormat.view);
                  let header = new (viewWithFormat.view.match(/^dayGrid/) ? DayGridViewWrapper : TimeGridViewWrapper)(calendar).header;
                  expect(header.getCellText(0)).toMatch(viewWithFormat.expected);
              }
          });
      });
      describe('when locale is Korean', () => {
          pushOptions({
              initialDate: '2014-05-11',
              locale: l45,
          });
          const VIEWS_WITH_FORMAT = [
              { view: 'dayGridMonth', expected: /^일$/ },
              { view: 'dayGridWeek', expected: /^5[.월] 11[.일] \(?일\)?$/ },
              { view: 'timeGridWeek', expected: /^5[.월] 11[.일] \(?일\)?$/ },
              { view: 'dayGridDay', expected: /^일요일$/ },
              { view: 'timeGridDay', expected: /^일요일$/ },
          ];
          it('should have the translated dates and dayHeaderFormat should be computed differently', () => {
              let calendar = initCalendar();
              for (let viewWithFormat of VIEWS_WITH_FORMAT) {
                  calendar.changeView(viewWithFormat.view);
                  let header = new (viewWithFormat.view.match(/^dayGrid/) ? DayGridViewWrapper : TimeGridViewWrapper)(calendar).header;
                  expect(header.getCellText(0)).toMatch(viewWithFormat.expected);
              }
          });
      });
      describe('using custom views', () => {
          it('multi-year default only displays day-of-week', () => {
              let calendar = initCalendar({
                  views: {
                      dayGridTwoYear: {
                          type: 'dayGrid',
                          duration: { years: 2 },
                      },
                  },
                  initialView: 'dayGridTwoYear',
                  initialDate: '2014-12-25',
              });
              let header = new DayGridViewWrapper(calendar).header;
              expect(header.getCellText(0)).toBe('Sun');
          });
          it('multi-month default only displays day-of-week', () => {
              let calendar = initCalendar({
                  views: {
                      dayGridTwoMonth: {
                          type: 'dayGrid',
                          duration: { months: 2 },
                      },
                  },
                  initialView: 'dayGridTwoMonth',
                  initialDate: '2014-12-25',
              });
              let header = new DayGridViewWrapper(calendar).header;
              expect(header.getCellText(0)).toBe('Sun');
          });
          it('multi-week default only displays day-of-week', () => {
              let calendar = initCalendar({
                  views: {
                      dayGridTwoWeek: {
                          type: 'dayGrid',
                          duration: { weeks: 2 },
                      },
                  },
                  initialView: 'dayGridTwoWeek',
                  initialDate: '2014-12-25',
              });
              let header = new DayGridViewWrapper(calendar).header;
              expect(header.getCellText(0)).toBe('Sun');
          });
          it('multi-day default displays short full date', () => {
              let calendar = initCalendar({
                  views: {
                      multiDay: {
                          type: 'dayGrid',
                          duration: { days: 2 },
                      },
                  },
                  initialView: 'multiDay',
                  initialDate: '2014-12-25',
              });
              let header = new DayGridViewWrapper(calendar).header;
              expect(header.getCellText('2014-12-25')).toMatch(/^Thu 12[/ ]25$/);
          });
      });
  });

  describe('moreLinkClick', () => {
      pushOptions({
          initialDate: '2014-08-01',
          initialView: 'dayGridMonth',
          dayMaxEventRows: 3,
          events: [
              { title: 'event1', start: '2014-07-29' },
              { title: 'event2', start: '2014-07-29' },
              { title: 'event2', start: '2014-07-29' },
              { title: 'event2', start: '2014-07-29' },
          ],
      });
      describe('when set to "popover"', () => {
          pushOptions({
              moreLinkClick: 'popover',
          });
          it('renders a popover upon click', (done) => {
              let calendar = initCalendar();
              let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
              dayGridWrapper.openMorePopover();
              setTimeout(() => {
                  expect(dayGridWrapper.getMorePopoverEl()).toBeVisible();
                  done();
              });
          });
          // more popover tests are done in *-popover.js
      });
      describe('when set to "week"', () => {
          pushOptions({
              moreLinkClick: 'week',
          });
          it('should go to dayGridWeek if it is one of the available views', (done) => {
              let calendar = initCalendar({
                  headerToolbar: {
                      left: 'prev,next today',
                      center: 'title',
                      right: 'dayGridMonth,dayGridWeek,dayGridDay',
                  },
              });
              let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
              dayGridWrapper.openMorePopover();
              setTimeout(() => {
                  let view = currentCalendar.view;
                  expect(view.type).toBe('dayGridWeek');
                  done();
              });
          });
          it('should go to week if it is one of the available views', (done) => {
              let calendar = initCalendar({
                  headerToolbar: {
                      left: 'prev,next today',
                      center: 'title',
                      right: 'dayGridMonth,timeGridWeek,timeGridDay',
                  },
              });
              let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
              dayGridWrapper.openMorePopover();
              setTimeout(() => {
                  let view = currentCalendar.view;
                  expect(view.type).toBe('timeGridWeek');
                  done();
              });
          });
      });
      describe('when set to "day"', () => {
          pushOptions({
              moreLinkClick: 'day',
          });
          it('should go to dayGridDay if it is one of the available views', (done) => {
              let calendar = initCalendar({
                  headerToolbar: {
                      left: 'prev,next today',
                      center: 'title',
                      right: 'dayGridMonth,dayGridWeek,dayGridDay',
                  },
              });
              let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
              dayGridWrapper.openMorePopover();
              setTimeout(() => {
                  let view = currentCalendar.view;
                  expect(view.type).toBe('dayGridDay');
                  done();
              });
          });
          it('should go to day if it is one of the available views', (done) => {
              let calendar = initCalendar({
                  headerToolbar: {
                      left: 'prev,next today',
                      center: 'title',
                      right: 'dayGridMonth,timeGridWeek,timeGridDay',
                  },
              });
              let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
              dayGridWrapper.openMorePopover();
              setTimeout(() => {
                  let view = currentCalendar.view;
                  expect(view.type).toBe('timeGridDay');
                  done();
              });
          });
      });
      it('works with an explicit view name', (done) => {
          let calendar = initCalendar({
              moreLinkClick: 'timeGridWeek',
              headerToolbar: {
                  left: 'prev,next today',
                  center: 'title',
                  right: 'dayGridMonth,dayGridWeek,dayGridDay',
              },
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          dayGridWrapper.openMorePopover();
          setTimeout(() => {
              let view = currentCalendar.view;
              expect(view.type).toBe('timeGridWeek');
              done();
          });
      });
      it('works with custom function and all the arguments are correct', (done) => {
          let calendar = initCalendar({
              moreLinkClick(arg) {
                  expect(typeof arg).toBe('object');
                  expect(arg.date).toEqualDate('2014-07-29');
                  expect(arg.hiddenSegs.length).toBe(2);
                  expect(arg.allSegs.length).toBe(4);
                  expect(typeof arg.jsEvent).toBe('object');
              },
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          dayGridWrapper.openMorePopover();
          setTimeout(done);
      });
      it('works with custom function, and can return a view name', (done) => {
          let calendar = initCalendar({
              moreLinkClick() {
                  return 'timeGridDay';
              },
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          dayGridWrapper.openMorePopover();
          setTimeout(() => {
              let view = currentCalendar.view;
              expect(view.type).toBe('timeGridDay');
              done();
          });
      });
  });

  describe('event resize mirror', () => {
      pushOptions({
          editable: true,
          initialDate: '2018-12-25',
          eventDragMinDistance: 0, // so mirror will render immediately upon mousedown
      });
      describe('in month view', () => {
          pushOptions({
              initialView: 'dayGridMonth',
              events: [
                  { start: '2018-12-03', title: 'all day event' },
              ],
          });
          it('gets passed through render hooks', (done) => {
              let mirrorMountCalls = 0;
              let mirrorContentCalls = 0;
              let mirrorUnmountCalls = 0;
              let calendar = initCalendar({
                  eventDidMount(info) {
                      if (info.isMirror) {
                          mirrorMountCalls += 1;
                      }
                  },
                  eventContent(info) {
                      if (info.isMirror) {
                          mirrorContentCalls += 1;
                      }
                  },
                  eventWillUnmount(info) {
                      if (info.isMirror) {
                          mirrorUnmountCalls += 1;
                      }
                  },
              });
              let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
              let resizing = dayGridWrapper.resizeEvent(// drag TWO days
              dayGridWrapper.getEventEls()[0], '2018-12-03', '2018-12-05');
              waitEventResize(calendar, resizing).then(() => {
                  expect(mirrorMountCalls).toBe(1);
                  expect(mirrorContentCalls).toBe(3);
                  expect(mirrorUnmountCalls).toBe(1);
                  done();
              });
          });
      });
      describe('in timeGrid view', () => {
          pushOptions({
              initialView: 'timeGridWeek',
              scrollTime: '00:00',
              slotDuration: '01:00',
              snapDuration: '01:00',
              events: [
                  { start: '2018-12-25T01:00:00', end: '2018-12-25T02:00:00', title: 'timed event' },
              ],
          });
          it('gets passed through eventWillUnmount', (done) => {
              let mirrorMountCalls = 0;
              let mirrorContentCalls = 0;
              let mirrorUnmountCalls = 0;
              let calendar = initCalendar({
                  eventDidMount(info) {
                      if (info.isMirror) {
                          mirrorMountCalls += 1;
                      }
                  },
                  eventContent(info) {
                      if (info.isMirror) {
                          mirrorContentCalls += 1;
                      }
                  },
                  eventWillUnmount(info) {
                      if (info.isMirror) {
                          mirrorUnmountCalls += 1;
                      }
                  },
              });
              let eventEl = new CalendarWrapper(calendar).getFirstEventEl();
              let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
              let resizing = timeGridWrapper.resizeEvent(eventEl, '2018-12-25T02:00:00', '2018-12-25T04:00:00');
              waitEventResize(calendar, resizing).then(() => {
                  expect(mirrorMountCalls).toBe(1);
                  expect(mirrorContentCalls).toBe(3);
                  expect(mirrorUnmountCalls).toBe(1);
                  done();
              });
          });
      });
  });

  describe('event mirror rendering', () => {
      pushOptions({
          editable: true,
      });
      it('maintains vertical position while dragging', (done) => {
          let calendar = initCalendar({
              initialDate: '2019-08-26',
              initialView: 'dayGridMonth',
              eventOrder: 'title',
              events: [
                  { start: '2019-08-27', title: 'event0' },
                  { start: '2019-08-27', title: 'event1' },
              ],
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          let eventEls = dayGridWrapper.getEventEls();
          let resizing = dayGridWrapper.resizeEvent(eventEls[1], '2019-08-27', '2019-08-28', false, // resize-from-start
          () => {
              let mirrorEls = dayGridWrapper.getMirrorEls();
              expect(mirrorEls[0].getBoundingClientRect().top).toBe(eventEls[1].getBoundingClientRect().top);
          });
          waitEventResize(calendar, resizing).then(() => done());
      });
  });

  function resize(point0, point1, fromStart, debug) {
      let eventEl = new CalendarWrapper(currentCalendar).getFirstEventEl();
      let $resizerEl = $(eventEl).find('.' + (fromStart ? CalendarWrapper.EVENT_START_RESIZER_CLASSNAME : CalendarWrapper.EVENT_END_RESIZER_CLASSNAME)).css('display', 'block'); // usually only displays on hover. force display
      let resizerRect = $resizerEl[0].getBoundingClientRect();
      let resizerCenter = getRectCenter(resizerRect);
      let vector = subtractPoints(resizerCenter, point0);
      let endPoint = addPoints(point1, vector);
      let deferred = $.Deferred();
      $resizerEl.simulate('drag', {
          point: resizerCenter,
          end: endPoint,
          debug,
      });
      currentCalendar.on('eventResize', (arg) => {
          deferred.resolve(arg);
      });
      currentCalendar.on('_noEventResize', () => {
          deferred.resolve(false);
      });
      return deferred.promise();
  }

  describe('validRange event resizing', () => {
      describe('when in month view', () => {
          pushOptions({
              initialView: 'dayGridMonth',
              initialDate: '2017-06-01',
              validRange: { end: '2017-06-09' },
              events: [
                  { start: '2017-06-04', end: '2017-06-07' },
              ],
              editable: true,
          });
          it('won\'t go after validRange', (done) => {
              let calendar = initCalendar();
              let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
              resize(dayGridWrapper.getDayEl('2017-06-06').getBoundingClientRect(), dayGridWrapper.getDisabledDayEls()[0].getBoundingClientRect()).then((res) => {
                  expect(res).toBe(false);
              }).then(() => done());
          });
      });
  });

  describe('eventResizableFromStart', () => {
      pushOptions({
          editable: true,
          eventResizableFromStart: true,
      });
      describe('for DayGrid', () => {
          pushOptions({
              initialDate: '2019-08-26',
              initialView: 'dayGridMonth',
              events: [
                  { start: '2019-08-27', title: 'all day event' },
              ],
          });
          it('allows resizing from start', (done) => {
              let calendar = initCalendar();
              let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
              let resizing = dayGridWrapper.resizeEvent(dayGridWrapper.getEventEls()[0], '2019-08-27', '2019-08-26', true);
              waitEventResize(calendar, resizing).then(() => {
                  let event = calendar.getEvents()[0];
                  expect(event.start).toEqualDate('2019-08-26');
                  expect(event.end).toEqualDate('2019-08-28');
                  done();
              });
          });
      });
  });

  describe('eventClick', () => {
      pushOptions({
          initialDate: '2018-08-31',
          initialView: 'dayGridMonth',
      });
      it('receives correct args', (done) => {
          let calendar = initCalendar({
              events: [
                  { start: '2018-08-31' },
              ],
              eventClick(arg) {
                  expect(arg.el instanceof HTMLElement).toBe(true);
                  expect(typeof arg.event).toBe('object');
                  expect(arg.event.start instanceof Date).toBe(true);
                  expect(arg.jsEvent instanceof UIEvent).toBe(true);
                  expect(typeof arg.view).toBe('object');
                  done();
              },
          });
          let eventEls = new CalendarWrapper(calendar).getEventEls();
          expect(eventEls.length).toBe(1);
          $(eventEls[0]).simulate('click');
      });
      it('fires on a background event', (done) => {
          let calendar = initCalendar({
              events: [
                  { start: '2018-08-31', display: 'background' },
              ],
              eventClick(arg) {
                  expect(arg.event.display).toBe('background');
                  done();
              },
          });
          let bgEventEls = new CalendarWrapper(calendar).getBgEventEls();
          expect(bgEventEls.length).toBe(1);
          $(bgEventEls[0]).simulate('click');
      });
      it('works via touch', (done) => {
          let calendar = initCalendar({
              events: [
                  { start: '2018-08-31' },
              ],
              eventClick() {
                  done();
              },
          });
          let eventEls = new CalendarWrapper(calendar).getEventEls();
          expect(eventEls.length).toBe(1);
          $(eventEls[0]).simulate('click');
      });
  });

  describe('external event dragging', () => {
      let $dragEl;
      let thirdPartyDraggable;
      beforeEach(() => {
          $dragEl = $('<div class="drag">yo</div>')
              .css({
              width: 200,
              background: 'blue',
              color: 'white',
          })
              .appendTo('body');
      });
      afterEach(() => {
          if (thirdPartyDraggable) {
              thirdPartyDraggable.destroy();
          }
          $dragEl.remove();
          $dragEl = null;
      });
      describe('with forceEventDuration', () => {
          pushOptions({
              forceEventDuration: true,
              defaultTimedEventDuration: '1:30',
          });
          // https://github.com/fullcalendar/fullcalendar/issues/4597
          it('should yield an event with an end', (done) => {
              let calendar = initCalendar({
                  initialView: 'dayGridMonth',
                  initialDate: '2019-04-01',
                  droppable: true,
                  defaultAllDayEventDuration: { days: 2 },
                  eventReceive(arg) {
                      expect(arg.event.end).toEqualDate('2019-04-04');
                      done();
                  },
              });
              let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
              thirdPartyDraggable = new ExternalDraggable($dragEl[0], {
                  eventData: {},
              });
              $dragEl.simulate('drag', {
                  end: dayGridWrapper.getDayEl('2019-04-02'),
              });
          });
      });
      // https://github.com/fullcalendar/fullcalendar/issues/4575
      it('provides eventAllow with a valid event with null start/end', (done) => {
          let called = false;
          let calendar = initCalendar({
              initialView: 'dayGridMonth',
              initialDate: '2019-04-01',
              droppable: true,
              defaultAllDayEventDuration: { days: 2 },
              eventAllow(dropInfo, draggedEvent) {
                  expect(draggedEvent.id).toBe('a');
                  expect(draggedEvent.title).toBe('hey');
                  expect(draggedEvent.start).toBe(null);
                  expect(draggedEvent.end).toBe(null);
                  called = true;
                  return true;
              },
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          thirdPartyDraggable = new ExternalDraggable($dragEl[0], {
              eventData: {
                  id: 'a',
                  title: 'hey',
              },
          });
          $dragEl.simulate('drag', {
              end: dayGridWrapper.getDayEl('2019-04-02'),
              callback() {
                  expect(called).toBe(true);
                  done();
              },
          });
      });
  });

  /*
  TODO: Don't rely on legacy simulateDrag
  Given the rectangles of the origin and destination
  slot or day area.
  */
  function drag(rect0, rect1, debug, eventEl) {
      if (!eventEl) {
          eventEl = new CalendarWrapper(currentCalendar).getFirstEventEl();
      }
      let eventRect = eventEl.getBoundingClientRect();
      let point0 = getRectCenter(intersectRects(eventRect, rect0));
      let point1 = getRectCenter(rect1);
      let deferred = $.Deferred();
      $(eventEl).simulate('drag', {
          point: point0,
          end: point1,
          debug,
      });
      currentCalendar.on('eventDrop', (arg) => {
          deferred.resolve(arg);
      });
      currentCalendar.on('_noEventDrop', () => {
          deferred.resolve(false);
      });
      return deferred.promise();
  }
  // makes the setTimeout's work.
  // also makes the tests faster.
  pushOptions({
      dragRevertDuration: 0,
  });

  describe('allDay change', () => {
      pushOptions({
          timeZone: 'UTC',
          initialView: 'timeGridWeek',
          now: '2018-09-03',
          scrollTime: 0,
          editable: true,
          dragScroll: false,
      });
      describe('when dragged from all-day to timed', () => {
          pushOptions({
              events: [
                  { id: '1', start: '2018-09-03', end: '2018-09-05' },
              ],
          });
          function doDrag() {
              let viewWrapper = new TimeGridViewWrapper(currentCalendar);
              let dayGridWrapper = viewWrapper.dayGrid;
              let timeGridWrapper = viewWrapper.timeGrid;
              let startRect = intersectRects(dayGridWrapper.getDayEls('2018-09-03')[0].getBoundingClientRect(), dayGridWrapper.getEventEls()[0].getBoundingClientRect());
              let endDate = parse$3('2018-09-03T02:00:00').marker;
              let endRect = timeGridWrapper.computeSpanRects(endDate, addMs(endDate, 1000 * 60 * 30))[0];
              return drag(startRect, endRect, false); // debug=false
          }
          it('discards duration when allDayMaintainDuration:false', (done) => {
              initCalendar({
                  allDayMaintainDuration: false,
              });
              doDrag().then(() => {
                  let event = currentCalendar.getEventById('1');
                  expect(event.start).toEqualDate('2018-09-03T02:00:00Z');
                  expect(event.end).toBe(null);
              }).then(() => done());
          });
          it('keeps duration when allDayMaintainDuration:true', (done) => {
              initCalendar({
                  allDayMaintainDuration: true,
              });
              doDrag().then(() => {
                  let event = currentCalendar.getEventById('1');
                  expect(event.start).toEqualDate('2018-09-03T02:00:00Z');
                  expect(event.end).toEqualDate('2018-09-05T02:00:00Z');
              }).then(() => done());
          });
          it('sets a default duration when forceEventDuration:true', (done) => {
              initCalendar({
                  forceEventDuration: true,
                  defaultTimedEventDuration: '04:00',
              });
              doDrag().then(() => {
                  let event = currentCalendar.getEventById('1');
                  expect(event.start).toEqualDate('2018-09-03T02:00:00Z');
                  expect(event.end).toEqualDate('2018-09-03T06:00:00Z');
              }).then(() => done());
          });
      });
      describe('when dragging from timed to all-day', () => {
          it('sets a default duration when forceEventDuration:true', (done) => {
              initCalendar({
                  forceEventDuration: true,
                  defaultAllDayEventDuration: { days: 2 },
                  events: [
                      { id: '1', start: '2018-09-03T01:00:00', end: '2018-09-03T02:00:00' },
                  ],
              });
              let viewWrapper = new TimeGridViewWrapper(currentCalendar);
              let dayGridWrapper = viewWrapper.dayGrid;
              let timeGridWrapper = viewWrapper.timeGrid;
              let startRect = timeGridWrapper.getEventEls()[0].getBoundingClientRect();
              let endRect = dayGridWrapper.getDayEls('2018-09-03')[0].getBoundingClientRect();
              drag(startRect, endRect, false).then(() => {
                  let event = currentCalendar.getEventById('1');
                  expect(event.start).toEqualDate('2018-09-03T00:00:00Z');
                  expect(event.end).toEqualDate('2018-09-05T00:00:00Z');
                  done();
              });
          });
          // https://github.com/fullcalendar/fullcalendar/issues/7222
          it('from more-popover', (done) => {
              initCalendar({
                  eventMaxStack: 1,
                  events: [
                      { id: '1', start: '2018-09-03T01:00:00', end: '2018-09-03T02:00:00' },
                      { id: '2', start: '2018-09-03T01:00:00', end: '2018-09-03T02:00:00' }, // in popover
                  ],
              });
              let viewWrapper = new TimeGridViewWrapper(currentCalendar);
              let dayGridWrapper = viewWrapper.dayGrid;
              let timeGridWrapper = viewWrapper.timeGrid;
              timeGridWrapper.openMorePopover();
              setTimeout(() => {
                  let popoverEventEl = timeGridWrapper.getMorePopoverEventEls()[0];
                  let startRect = popoverEventEl.getBoundingClientRect();
                  let endRect = dayGridWrapper.getDayEls('2018-09-03')[0].getBoundingClientRect();
                  drag(startRect, endRect, false, popoverEventEl).then(() => {
                      let event = currentCalendar.getEventById('2');
                      expect(event.start).toEqualDate('2018-09-03T00:00:00Z');
                      expect(event.end).toBe(null);
                      expect(event.allDay).toBe(true);
                      done();
                  });
              });
          });
      });
  });

  describe('event touch dragging', () => {
      // https://github.com/fullcalendar/fullcalendar/issues/5706
      it('keeps event selected when initiated on custom element', (done) => {
          let calendar = initCalendar({
              initialDate: '2020-08-12',
              editable: true,
              longPressDelay: 100,
              events: [
                  { title: 'event', start: '2020-08-12' },
              ],
              eventContent: { html: '<i>the text</i>' },
          });
          let gridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          let eventEl = gridWrapper.getEventEls()[0];
          let dragging = gridWrapper.dragEventToDate(eventEl.querySelector('i'), null, // don't specify start date. start drag on center of given element
          '2020-08-13', true);
          waitEventDrag(calendar, dragging).then((event) => {
              expect(event.startStr).toBe('2020-08-13');
              done();
          });
      });
  });

  describe('dragging events between calendars', () => {
      let DEFAULT_DATE = '2019-01-01';
      let el0;
      let el1;
      let calendar0;
      let calendar1;
      beforeEach(() => {
          el0 = document.createElement('div');
          el1 = document.createElement('div');
          el0.style.width = el1.style.width = '50%';
          el0.style.cssFloat = el1.style.cssFloat = 'left';
          document.body.appendChild(el0);
          document.body.appendChild(el1);
      });
      afterEach(() => {
          if (calendar0) {
              calendar0.destroy();
          }
          if (calendar1) {
              calendar1.destroy();
          }
          document.body.removeChild(el0);
          document.body.removeChild(el1);
      });
      it('fires all triggers', (done) => {
          let triggerNames = [];
          let eventAllowCalled = false;
          let eventEl;
          calendar0 = new Calendar(el0, {
              plugins: [index$b, index$a],
              timeZone: 'UTC',
              initialDate: DEFAULT_DATE,
              initialView: 'dayGridMonth',
              editable: true,
              events: [
                  { start: '2019-01-01', id: 'a' },
              ],
              eventLeave(info) {
                  triggerNames.push('eventLeave');
                  expect(info.draggedEl).toBe(eventEl);
                  expect(info.event.id).toBe('a');
                  expect(typeof info.revert).toBe('function');
                  expect(Array.isArray(info.relatedEvents)).toBe(true);
              },
          });
          calendar1 = new Calendar(el1, {
              plugins: [index$b, index$a],
              timeZone: 'UTC',
              initialDate: DEFAULT_DATE,
              initialView: 'dayGridMonth',
              editable: true,
              droppable: true,
              drop(info) {
                  triggerNames.push('drop');
                  expect(info.draggedEl).toBe(eventEl);
                  expect(info.date).toEqualDate('2019-01-05');
                  expect(info.dateStr).toBe('2019-01-05');
                  expect(info.allDay).toBe(true);
              },
              eventAllow() {
                  eventAllowCalled = true;
                  return true;
              },
              eventReceive(info) {
                  triggerNames.push('eventReceive');
                  expect(info.draggedEl).toBe(eventEl);
                  expect(info.event.start).toEqualDate('2019-01-05');
                  expect(typeof info.revert).toBe('function');
                  expect(Array.isArray(info.relatedEvents)).toBe(true);
              },
          });
          calendar0.render();
          calendar1.render();
          let dayGridWrapper0 = new DayGridViewWrapper(calendar0).dayGrid;
          let dayGridWrapper1 = new DayGridViewWrapper(calendar1).dayGrid;
          eventEl = dayGridWrapper0.getEventEls()[0];
          let dayEl = dayGridWrapper1.getDayEls('2019-01-05')[0];
          let point1 = getRectCenter(dayEl.getBoundingClientRect());
          $(eventEl).simulate('drag', {
              end: point1,
              callback() {
                  expect(triggerNames).toEqual(['eventLeave', 'drop', 'eventReceive']);
                  expect(eventAllowCalled).toBe(true);
                  done();
              },
          });
      });
      it('works between timeGrid views', (done) => {
          calendar0 = new Calendar(el0, {
              plugins: [index$b, index$9],
              scrollTime: '00:00',
              timeZone: 'UTC',
              initialDate: DEFAULT_DATE,
              initialView: 'timeGridDay',
              editable: true,
              events: [
                  { start: '2019-01-01T00:00:00', id: 'a' },
              ],
          });
          calendar1 = new Calendar(el1, {
              plugins: [index$b, index$9],
              scrollTime: '00:00',
              timeZone: 'UTC',
              initialDate: DEFAULT_DATE,
              initialView: 'timeGridDay',
              editable: true,
              droppable: true,
              eventReceive(info) {
                  done();
              },
          });
          calendar0.render();
          calendar1.render();
          let eventEl = new CalendarWrapper(calendar0).getEventEls()[0]; // of the source calendar
          let destViewWrapper = new TimeGridViewWrapper(calendar1);
          let point1 = getRectCenter(destViewWrapper.getScrollerEl().getBoundingClientRect());
          $(eventEl).simulate('drag', {
              end: point1,
          });
      });
  });

  describe('showNonCurrentDates event dragging', () => {
      pushOptions({
          initialView: 'dayGridMonth',
          initialDate: '2017-06-01',
          showNonCurrentDates: false,
          events: [
              { start: '2017-06-07', end: '2017-06-10' },
          ],
          editable: true,
      });
      describe('when dragging pointer into disabled region', () => {
          it('won\'t allow the drop', (done) => {
              let calendar = initCalendar();
              let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
              drag(dayGridWrapper.getDayEl('2017-06-08').getBoundingClientRect(), dayGridWrapper.getDisabledDayEls()[3].getBoundingClientRect())
                  .then((res) => {
                  expect(res).toBe(false);
              })
                  .then(() => done());
          });
      });
      describe('when dragging an event\'s start into a disabled region', () => {
          it('allow the drop if the cursor stays over non-disabled cells', (done) => {
              let calendar = initCalendar();
              let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
              let dragging = dayGridWrapper.dragEventToDate(dayGridWrapper.getEventEls()[0], '2017-06-08', '2017-06-01');
              waitEventDrag(calendar, dragging).then((res) => {
                  expect(typeof res).toBe('object');
                  done();
              });
          });
      });
  });

  describe('fixedMirrorParent', () => {
      pushOptions({
          initialView: 'dayGridMonth',
          initialDate: '2020-10-26',
      });
      it('changes the mirror\'s parent element', (done) => {
          let calendar = initCalendar({
              editable: true,
              fixedMirrorParent: document.body,
              events: [
                  { start: '2020-10-04' },
              ],
          });
          let wrapper = new DayGridViewWrapper(calendar).dayGrid;
          let eventEls = wrapper.getEventEls();
          $(eventEls[0]).simulate('drag', {
              dx: -100,
              onBeforeRelease() {
                  let $mirrorEl = $('body').find('> .' + CalendarWrapper.EVENT_CLASSNAME); // direct child
                  expect($mirrorEl.length).toBe(1);
              },
              onRelease() {
                  done();
              },
          });
      });
  });

  describe('event dragging on repeating events', () => {
      pushOptions({
          initialView: 'dayGridMonth',
          initialDate: '2017-02-12',
          editable: true,
          events: [
              {
                  groupId: '999',
                  title: 'Repeating Event',
                  start: '2017-02-09T16:00:00',
              },
              {
                  groupId: '999',
                  title: 'Repeating Event',
                  start: '2017-02-16T16:00:00',
              },
          ],
      });
      // bug where offscreen instance of a repeating event was being incorrectly dragged
      it('drags correct instance of event', (done) => {
          let calendar = initCalendar();
          // event range needs out large (month) then scope down (week)
          // so that the new view receives out-of-range events.
          currentCalendar.changeView('timeGridWeek');
          let eventEl = new CalendarWrapper(calendar).getFirstEventEl();
          let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
          let dragging = timeGridWrapper.dragEventToDate(eventEl, '2017-02-16T12:00:00');
          waitEventDrag(calendar, dragging).then((res) => {
              expect(typeof res).toBe('object');
              done();
          });
      });
      it('hides other repeating events when dragging', (done) => {
          let dayGridWrapper;
          let calendar = initCalendar({
              eventDragStart() {
                  setTimeout(() => {
                      let visibleEventEls = filterVisibleEls(dayGridWrapper.getEventEls());
                      expect(visibleEventEls.length).toBe(0);
                  }, 0);
              },
              eventDrop() {
                  setTimeout(() => {
                      done();
                  }, 10);
              },
          });
          dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          $(dayGridWrapper.getFirstEventEl()).simulate('drag', {
              dx: 100,
              duration: 100, // ample time for separate eventDragStart/eventDrop
          });
      });
      // inverse of above test
      it('doesnt accidentally hide all non-id events when dragging', (done) => {
          let dayGridWrapper;
          let calendar = initCalendar({
              events: [
                  {
                      title: 'Regular Event',
                      start: '2017-02-09T16:00:00',
                  },
                  {
                      title: 'Other Regular Event',
                      start: '2017-02-16T16:00:00',
                  },
              ],
              eventDragStart() {
                  setTimeout(() => {
                      let visibleEventEls = filterVisibleEls(dayGridWrapper.getEventEls());
                      expect(visibleEventEls.length).toBe(1); // the dragging event AND the other regular event
                  }, 0);
              },
              eventDrop() {
                  setTimeout(() => {
                      done();
                  }, 10);
              },
          });
          dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          $(dayGridWrapper.getFirstEventEl()).simulate('drag', {
              dx: 100,
              duration: 100, // ample time for separate eventDragStart/eventDrop
          });
      });
  });

  describe('validRange event dragging', () => {
      describe('when start constraint', () => {
          describe('when in month view', () => {
              pushOptions({
                  initialView: 'dayGridMonth',
                  initialDate: '2017-06-01',
                  validRange: { start: '2017-06-06' },
                  events: [
                      { start: '2017-06-07', end: '2017-06-10' },
                  ],
                  editable: true,
              });
              it('won\'t go before validRange', (done) => {
                  let modifiedEvent = false;
                  let calendar = initCalendar({
                      eventDrop(arg) {
                          modifiedEvent = arg.event;
                      },
                  });
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  $(dayGridWrapper.getEventEls()).simulate('drag', {
                      end: dayGridWrapper.getDayEl('2017-06-06').previousElementSibling,
                      callback() {
                          expect(modifiedEvent).toBe(false);
                          done();
                      },
                  });
              });
          });
      });
      describe('when end constraint', () => {
          describe('when in month view', () => {
              pushOptions({
                  initialView: 'dayGridMonth',
                  initialDate: '2017-06-01',
                  validRange: { end: '2017-06-09' },
                  events: [
                      { start: '2017-06-04', end: '2017-06-07' },
                  ],
                  editable: true,
              });
              it('won\'t go after validRange', (done) => {
                  let modifiedEvent = false;
                  let calendar = initCalendar({
                      eventDrop(arg) {
                          modifiedEvent = arg.event;
                      },
                  });
                  let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
                  $(dayGridWrapper.getEventEls()).simulate('drag', {
                      end: dayGridWrapper.getDayEl('2017-06-08').nextElementSibling,
                      callback() {
                          expect(modifiedEvent).toBe(false);
                          done();
                      },
                  });
              });
          });
      });
  });

  describe('dayHeaderContent as html', () => {
      pushOptions({
          initialDate: '2014-05-11',
      });
      describeOptions('initialView', {
          'when month view': 'dayGridMonth',
          'when timeGrid view': 'timeGridDay',
          'when dayGrid view': 'dayGridDay',
      }, (viewName) => {
          let ViewWrapper = viewName.match(/^dayGrid/) ? DayGridViewWrapper : TimeGridViewWrapper;
          it('should contain custom HTML', () => {
              let calendar = initCalendar({
                  dayHeaderContent(arg) {
                      return { html: '<div class="test">' + currentCalendar.formatDate(arg.date, { weekday: 'long' }) + '</div>' };
                  },
              });
              let headerWrapper = new ViewWrapper(calendar).header;
              let $firstCellEl = $(headerWrapper.getCellEls()[0]);
              expect($firstCellEl.find('.test').length).toBe(1);
              expect($firstCellEl.text()).toBe('Sunday');
          });
      });
      describeTimeZones((tz) => {
          it('receives correct date', () => {
              let dates = [];
              initCalendar({
                  initialView: 'timeGridDay',
                  dayHeaderContent(arg) {
                      dates.push(arg.date);
                  },
              });
              expect(dates.length).toBe(1);
              expect(dates[0]).toEqualDate(tz.parseDate('2014-05-11'));
          });
      });
  });

  describe('dayHeaders', () => {
      pushOptions({
          initialDate: '2014-05-11',
      });
      describeOptions('initialView', {
          'when month view': 'dayGridMonth',
          'when timeGrid view': 'timeGridDay',
          'when dayGrid view': 'dayGridDay',
      }, (viewName) => {
          let ViewWrapper = viewName.match(/^dayGrid/) ? DayGridViewWrapper : TimeGridViewWrapper;
          describe('when on', () => {
              pushOptions({
                  dayHeaders: true,
              });
              it('should show header', () => {
                  let calendar = initCalendar();
                  let viewWrapper = new ViewWrapper(calendar);
                  expect(viewWrapper.header).toBeTruthy();
              });
          });
          describe('when off', () => {
              pushOptions({
                  dayHeaders: false,
              });
              it('should not show header', () => {
                  let calendar = initCalendar();
                  let viewWrapper = new ViewWrapper(calendar);
                  expect(viewWrapper.header).toBeFalsy();
              });
          });
      });
  });

  describe('rerendering a calendar', () => {
      it('keeps sizing', () => {
          let calendar = initCalendar({
              initialView: 'dayGridMonth',
              initialDate: '2019-08-08',
              dayMaxEventRows: 3,
              events: [
                  { date: '2019-08-08', title: 'event' },
                  { date: '2019-08-08', title: 'event' },
                  { date: '2019-08-08', title: 'event' },
                  { date: '2019-08-08', title: 'event' },
              ],
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          expect(dayGridWrapper.getMoreEls().length).toBe(1);
          calendar.render();
          expect(dayGridWrapper.getMoreEls().length).toBe(1); // good way to test that sizing is maintained
      });
  });

  describe('scrollToTime method', () => {
      it('accepts a object duration input', () => {
          let calendar = initCalendar({
              scrollTime: 0,
              initialView: 'timeGridWeek',
          });
          let viewWrapper = new TimeGridViewWrapper(calendar);
          calendar.scrollToTime({ hours: 2 });
          // NOTE: c&p'd from scrollTime tests
          let slotTop = viewWrapper.timeGrid.getTimeTop('02:00:00') - viewWrapper.timeGrid.el.getBoundingClientRect().top;
          let scrollEl = viewWrapper.getScrollerEl();
          let scrollTop = scrollEl.scrollTop;
          let diff = Math.abs(slotTop - scrollTop);
          expect(slotTop).toBeGreaterThan(0);
          expect(scrollTop).toBeGreaterThan(0);
          expect(diff).toBeLessThan(3);
      });
  });

  describe('slotDuration', () => {
      pushOptions({
          initialDate: '2017-07-17',
          initialView: 'timeGridDay',
          scrollTime: 0,
          locale: 'en-GB',
          slotLabelFormat: { hour: '2-digit', minute: '2-digit', hour12: false },
      });
      describe('when only major slots', () => {
          pushOptions({
              slotDuration: '01:00',
              slotLabelInterval: '01:00',
          });
          describe('when in alignment with slotMinTime', () => {
              pushOptions({
                  slotMinTime: '00:00',
                  slotMaxTime: '03:00',
              });
              it('render slots correctly', () => {
                  let calendar = initCalendar();
                  let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                  expect(timeGridWrapper.getTimeAxisInfo()).toEqual([
                      { text: '00:00', isMajor: true },
                      { text: '01:00', isMajor: true },
                      { text: '02:00', isMajor: true },
                  ]);
              });
          });
          describe('when out of alignment with slotMinTime', () => {
              pushOptions({
                  slotMinTime: '00:20',
                  slotMaxTime: '03:20',
              });
              it('render slots correctly', () => {
                  let calendar = initCalendar();
                  let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                  expect(timeGridWrapper.getTimeAxisInfo()).toEqual([
                      { text: '00:20', isMajor: true },
                      { text: '01:20', isMajor: true },
                      { text: '02:20', isMajor: true },
                  ]);
              });
          });
      });
      describe('when major and minor slots', () => {
          pushOptions({
              slotDuration: '00:30',
              slotLabelInterval: '01:00',
          });
          describe('when in alignment with slotMinTime', () => {
              pushOptions({
                  slotMinTime: '00:00',
                  slotMaxTime: '03:00',
              });
              it('render slots correctly', () => {
                  let calendar = initCalendar();
                  let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                  expect(timeGridWrapper.getTimeAxisInfo()).toEqual([
                      { text: '00:00', isMajor: true },
                      { text: '', isMajor: false },
                      { text: '01:00', isMajor: true },
                      { text: '', isMajor: false },
                      { text: '02:00', isMajor: true },
                      { text: '', isMajor: false },
                  ]);
              });
          });
          describe('when out of alignment with slotMinTime', () => {
              pushOptions({
                  slotMinTime: '00:20',
                  slotMaxTime: '03:20',
              });
              it('render slots correctly', () => {
                  let calendar = initCalendar();
                  let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                  expect(timeGridWrapper.getTimeAxisInfo()).toEqual([
                      { text: '00:20', isMajor: true },
                      { text: '', isMajor: false },
                      { text: '01:20', isMajor: true },
                      { text: '', isMajor: false },
                      { text: '02:20', isMajor: true },
                      { text: '', isMajor: false },
                  ]);
              });
          });
      });
  });

  describe('showNonCurrentDates', () => {
      pushOptions({
          showNonCurrentDates: false,
      });
      describe('when in month view', () => {
          pushOptions({
              initialView: 'dayGridMonth',
              initialDate: '2017-06-01',
          });
          it('does not render other months\' dates', () => {
              initCalendar();
              expectDayRange('2017-06-01', '2017-07-01');
          });
      });
      describe('when in week view', () => {
          pushOptions({
              initialView: 'timeGridWeek',
              initialDate: '2017-06-01',
          });
          it('has no effect', () => {
              initCalendar();
              expectDayRange('2017-05-28', '2017-06-04');
          });
      });
      it('works when disabling weekends and switching views', () => {
          initCalendar({
              weekends: false,
              initialView: 'dayGridMonth',
              initialDate: '2019-06-07', // only shows problem when start date is a weekend!
          });
          currentCalendar.next();
          currentCalendar.setOption('weekends', true);
          // no errors thrown, yay
      });
      it('works when switching views with same formal duration but different rendered duration', () => {
          initCalendar({
              initialView: 'listMonth',
              initialDate: '2019-01-01',
          });
          currentCalendar.changeView('dayGridMonth');
          expectDayRange('2019-01-01', '2019-02-01');
      });
  });

  describe('timegrid slots', () => {
      // https://github.com/fullcalendar/fullcalendar/issues/5952
      it('can render a single big slot without error', () => {
          initCalendar({
              initialView: 'timeGridDay',
              slotDuration: '24:00',
          });
      });
  });

  describe('view height', () => {
      // https://github.com/fullcalendar/fullcalendar/issues/6034
      xit('does not squish view-specific height:auto in timegrid view', () => {
          let calendar = initCalendar({
              initialView: 'timeGridWeek',
              aspectRatio: 1.8,
              views: {
                  timeGrid: {
                      height: 'auto',
                  },
              },
          });
          let viewWrapper = new TimeGridViewWrapper(calendar);
          let scrollerEl = viewWrapper.getScrollerEl();
          expect(scrollerEl.getBoundingClientRect().height).toBeGreaterThan(10);
      });
  });

  describe('timegrid all-day slot', () => {
      pushOptions({
          initialDate: '2019-04-23',
          initialView: 'timeGridWeek',
          editable: true,
      });
      // https://github.com/fullcalendar/fullcalendar/issues/4616
      it('allows dragging after dynamic event adding', (done) => {
          let calendar = initCalendar({
              eventDrop(arg) {
                  expect(arg.event.start).toEqualDate('2019-04-24');
                  done();
              },
          });
          calendar.batchRendering(() => {
              calendar.addEvent({ start: '2019-04-23' });
              calendar.addEvent({ start: '2019-04-23' });
              calendar.addEvent({ start: '2019-04-23' });
          });
          let dayGridWrapper = new TimeGridViewWrapper(calendar).dayGrid;
          let dayWidth = $(dayGridWrapper.getDayEls('2019-04-23')).width();
          let lastEventEl = dayGridWrapper.getEventEls()[2];
          $(lastEventEl).simulate('drag', {
              localPoint: { left: '50%', top: '99%' },
              dx: dayWidth,
          });
      });
  });

  describe('daygrid view with updated dimensions', () => {
      it('reports correct dateClick after resize', (done) => {
          let $wrapper = $('<div><div style="width:auto"></div></div>').appendTo('body');
          $wrapper.width(200);
          let calendar = initCalendar({
              initialDate: '2019-04-01',
              initialView: 'dayGridMonth',
              dateClick(arg) {
                  expect(arg.date).toEqualDate('2019-04-02'); // a Tues
                  $wrapper.remove();
                  done();
              },
          }, $wrapper.children().get(0));
          $wrapper.width(400);
          calendar.updateSize();
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          $(dayGridWrapper.getDayEl('2019-04-02')).simulate('drag'); // a click
      });
  });

  class MultiMonthViewWrapper extends ViewWrapper {
      constructor(calendar) {
          super(calendar, 'fc-multimonth');
      }
      getMonths() {
          const monthEls = findElements(this.el, '.fc-multimonth-month');
          return monthEls.map((monthEl) => ({
              el: monthEl,
              title: monthEl.querySelector('.fc-multimonth-title').innerText,
              columnCnt: monthEl.querySelectorAll('th').length,
          }));
      }
      getEventEls() {
          return findElements(this.el, '.fc-daygrid-event');
      }
      getScrollerEl() {
          return this.el; // the view itself
      }
  }

  describe('multimonth view', () => {
      it('computes start/end for multiMonthYear', () => {
          const calendar = initCalendar({
              initialDate: '2023-06-01',
              initialView: 'multiMonthYear',
          });
          expect(calendar.view.currentStart).toEqualDate('2023-01-01');
          expect(calendar.view.currentEnd).toEqualDate('2024-01-01');
      });
      it('can have custom duration', () => {
          const calendar = initCalendar({
              initialDate: '2023-06-01',
              initialView: 'multiMonth',
              duration: { months: 2 },
          });
          expect(calendar.view.currentStart).toEqualDate('2023-06-01');
          expect(calendar.view.currentEnd).toEqualDate('2023-08-01');
      });
      it('having small multiMonthMinWidth results in side-by-side months', () => {
          const calendar = initCalendar({
              initialDate: '2023-06-01',
              initialView: 'multiMonthYear',
              multiMonthMinWidth: 100,
          });
          const monthWrappers = new MultiMonthViewWrapper(calendar).getMonths();
          expect(monthWrappers.length).toBe(12);
          expect(monthWrappers[0].el).toBeLeftOf(monthWrappers[1].el);
      });
      it('having large multiMonthMinWidth results in stacking months', () => {
          const calendar = initCalendar({
              initialDate: '2023-06-01',
              initialView: 'multiMonthYear',
              multiMonthMinWidth: 600,
          });
          const monthWrappers = new MultiMonthViewWrapper(calendar).getMonths();
          expect(monthWrappers.length).toBe(12);
          expect(monthWrappers[0].el).not.toBeLeftOf(monthWrappers[1].el);
          expect(monthWrappers[0].el).toBeAbove(monthWrappers[1].el);
      });
      it('can have forced single column with multiMonthMaxColumns', () => {
          const calendar = initCalendar({
              initialDate: '2023-06-01',
              initialView: 'multiMonthYear',
              multiMonthMaxColumns: 1,
          });
          const monthWrappers = new MultiMonthViewWrapper(calendar).getMonths();
          expect(monthWrappers[0].el).not.toBeLeftOf(monthWrappers[1].el);
          expect(monthWrappers[0].el).toBeAbove(monthWrappers[1].el);
      });
      it('is scrolled to current date initially', () => {
          const calendar = initCalendar({
              initialDate: '2023-06-01',
              initialView: 'multiMonthYear',
              multiMonthMaxColumns: 1,
          });
          const viewWrapper = new MultiMonthViewWrapper(calendar);
          const monthWrappers = viewWrapper.getMonths();
          const scrollerEl = viewWrapper.getScrollerEl();
          expect(Math.abs(scrollerEl.getBoundingClientRect().top -
              monthWrappers[5].el.getBoundingClientRect().top)).toBeLessThan(2);
          expect(scrollerEl.scrollTop).not.toBe(0);
          calendar.next();
          calendar.prev();
          expect(scrollerEl.scrollTop).toBe(0);
      });
      it('renders events when weekends: false', () => {
          const calendar = initCalendar({
              initialDate: '2023-01-25',
              initialView: 'multiMonthYear',
              weekends: false,
              events: [
                  {
                      title: 'Conference',
                      start: '2023-01-11',
                      end: '2023-01-13',
                  },
              ],
          });
          const viewWrapper = new MultiMonthViewWrapper(calendar);
          const monthWrappers = viewWrapper.getMonths();
          expect(monthWrappers.length).toBe(12);
          expect(monthWrappers[0].columnCnt).toBe(5);
          expect(viewWrapper.getEventEls().length).toBe(1);
      });
      it('has customizable multiMonthTitleFormat', () => {
          const calendar = initCalendar({
              initialDate: '2023-06-01',
              initialView: 'multiMonthYear',
              multiMonthTitleFormat: { month: 'short', year: 'numeric' },
          });
          const monthWrappers = new MultiMonthViewWrapper(calendar).getMonths();
          expect(monthWrappers[0].title).toBe('Jan 2023');
      });
      it('does not accidentally render month-start within cells', () => {
          const calendar = initCalendar({
              initialDate: '2023-06-01',
              initialView: 'multiMonthYear',
              multiMonthTitleFormat: { month: 'short', year: 'numeric' },
          });
          const viewWrapper = new MultiMonthViewWrapper(calendar);
          expect(viewWrapper.el.querySelectorAll('.fc-daygrid-month-start').length).toBe(0);
      });
  });

  describe('updateSize method', () => {
      it('updates size of a previously hidden element', () => {
          let $el = $('<div style="display:none" />').appendTo('body');
          let calendar = initCalendar({
              initialView: 'dayGridMonth',
              contentHeight: 600,
          }, $el);
          let calendarWrapper = new CalendarWrapper(calendar);
          $el.show();
          calendar.updateSize();
          expect(calendarWrapper.getViewContainerEl().offsetHeight).toBeCloseTo(600, 0);
          $el.remove();
      });
  });

  describe('dayHeaderContent as text', () => {
      pushOptions({
          initialDate: '2014-05-11',
      });
      describeOptions('initialView', {
          'when month view': 'dayGridMonth',
          'when timeGrid view': 'timeGridDay',
          'when dayGrid view': 'dayGridDay',
      }, (viewName) => {
          let ViewWrapper = viewName.match(/^dayGrid/) ? DayGridViewWrapper : TimeGridViewWrapper;
          it('should contain custom HTML escaped text', () => {
              let calendar = initCalendar({
                  dayHeaderContent(arg) {
                      return '<div>Custom ' + currentCalendar.formatDate(arg.date, { weekday: 'long' }) + '</div>';
                  },
              });
              let headerWrapper = new ViewWrapper(calendar).header;
              let $firstCell = $(headerWrapper.getCellEls()[0]);
              expect($firstCell.text()).toBe('<div>Custom Sunday</div>');
          });
      });
      describeTimeZones((tz) => {
          it('receives correct date', () => {
              let dates = [];
              initCalendar({
                  initialView: 'timeGridDay',
                  dayHeaderContent(arg) {
                      dates.push(arg.date);
                  },
              });
              expect(dates.length).toBe(1);
              expect(dates[0]).toEqualDate(tz.parseDate('2014-05-11'));
          });
      });
  });

  describe('DayGrid w/ multiple weeks/days', () => {
      it('dayGridYear has correct start/end dates', () => {
          const calendar = initCalendar({
              initialDate: '2023-06-25',
              initialView: 'dayGridYear',
          });
          expect(calendar.view.currentStart).toEqualDate('2023-01-01');
          expect(calendar.view.currentEnd).toEqualDate('2024-01-01');
      });
      it('renders scrollbars when 7 weeks', () => {
          const calendar = initCalendar({
              initialDate: '2023-01-25',
              initialView: 'dayGrid',
              duration: { weeks: 7 },
          });
          const dayGridView = new DayGridViewWrapper(calendar);
          expect(dayGridView.getScrollerEl()).toHaveScrollbars();
      });
      it('does NOT render scrollbars when 6 weeks', () => {
          const calendar = initCalendar({
              initialDate: '2023-01-25',
              initialView: 'dayGrid',
              duration: { weeks: 6 },
          });
          const dayGridView = new DayGridViewWrapper(calendar);
          expect(dayGridView.getScrollerEl()).not.toHaveScrollbars();
      });
      it('displays month-start text at two points when month break', () => {
          const calendar = initCalendar({
              initialDate: '2023-01-30',
              initialView: 'dayGrid',
              duration: { weeks: 2 },
          });
          const dayGrid = new DayGridViewWrapper(calendar).dayGrid;
          const monthStartEls = dayGrid.getMonthStartEls();
          expect(monthStartEls.length).toBe(2);
          expect(monthStartEls[0].innerText).toBe('January 29');
          expect(monthStartEls[1].innerText).toBe('February 1');
      });
      it('scrolls to initialDate', () => {
          const calendar = initCalendar({
              initialDate: '2023-06-25',
              initialView: 'dayGridYear',
          });
          const viewWrapper = new DayGridViewWrapper(calendar);
          const scrollerEl = viewWrapper.getScrollerEl();
          const dayGridWrapper = viewWrapper.dayGrid;
          const initialDayEl = dayGridWrapper.getDayEl('2023-06-25');
          expect(Math.abs(initialDayEl.getBoundingClientRect().top -
              scrollerEl.getBoundingClientRect().top) < 1);
      });
      it('has customizable monthStartFormat', () => {
          const calendar = initCalendar({
              initialDate: '2023-01-30',
              initialView: 'dayGrid',
              duration: { weeks: 2 },
              monthStartFormat: { year: 'numeric', month: 'short', day: '2-digit' },
          });
          const dayGrid = new DayGridViewWrapper(calendar).dayGrid;
          const monthStartEls = dayGrid.getMonthStartEls();
          expect(monthStartEls.length).toBe(2);
          expect(monthStartEls[0].innerText).toBe('Jan 29, 2023');
          expect(monthStartEls[1].innerText).toBe('Feb 01, 2023');
      });
      // https://github.com/fullcalendar/fullcalendar/issues/7197
      it('has month-titles for each month in custom 6-month calendar', () => {
          const calendar = initCalendar({
              initialDate: '2023-01-30',
              initialView: 'dayGrid',
              duration: { months: 6 },
              monthStartFormat: { year: 'numeric', month: 'short', day: '2-digit' },
          });
          const dayGrid = new DayGridViewWrapper(calendar).dayGrid;
          const monthStartEls = dayGrid.getMonthStartEls();
          expect(monthStartEls.length).toBe(6);
          expect(monthStartEls[0].innerText).toBe('Jan 01, 2023');
          expect(monthStartEls[1].innerText).toBe('Feb 01, 2023');
      });
  });

  describe('validRange rendering', () => {
      describe('with hardcoded start constraint', () => {
          describe('when month view', () => {
              pushOptions({
                  initialView: 'dayGridMonth',
                  initialDate: '2017-06-01',
                  validRange: { start: '2017-06-07' },
              });
              it('does not render days before', () => {
                  initCalendar();
                  expectDayRange('2017-06-07', '2017-07-09');
              });
          });
          describe('when in week view', () => {
              pushOptions({
                  initialView: 'timeGridWeek',
                  initialDate: '2017-06-08',
                  validRange: { start: '2017-06-06' },
              });
              it('does not render days before', () => {
                  initCalendar();
                  expectDayRange('2017-06-06', '2017-06-11');
              });
          });
      });
      describe('with hardcoded end constraint', () => {
          describe('when month view', () => {
              pushOptions({
                  initialView: 'dayGridMonth',
                  initialDate: '2017-06-01',
                  validRange: { end: '2017-06-07' },
              });
              it('does not render days on or after', () => {
                  initCalendar();
                  expectDayRange('2017-05-28', '2017-06-07');
              });
          });
          describe('when in week view', () => {
              pushOptions({
                  initialView: 'timeGridWeek',
                  initialDate: '2017-06-08',
                  validRange: { end: '2017-06-06' },
              });
              it('does not render days on or after', () => {
                  initCalendar();
                  expectDayRange('2017-06-04', '2017-06-06');
              });
          });
      });
  });

  describe('bootstrap theme', () => {
      pushOptions({
          plugins: [index$2, index$a],
          themeSystem: 'bootstrap',
      });
      describe('fa', () => {
          pushOptions({
              headerToolbar: { left: '', center: '', right: 'next' },
          });
          it('renders default', () => {
              let calendar = initCalendar();
              let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
              let buttonInfo = toolbarWrapper.getButtonInfo('next', 'fa');
              expect(buttonInfo.iconName).toBe('chevron-right');
          });
          it('renders a customized icon', () => {
              let calendar = initCalendar({
                  bootstrapFontAwesome: {
                      next: 'asdf',
                  },
              });
              let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
              let buttonInfo = toolbarWrapper.getButtonInfo('next', 'fa');
              expect(buttonInfo.iconName).toBe('asdf');
          });
          it('renders text when specified as false', () => {
              let calendar = initCalendar({
                  bootstrapFontAwesome: false,
              });
              let toolbarWrapper = new CalendarWrapper(calendar).toolbar;
              expect(toolbarWrapper.getButtonInfo('next', 'fa').iconName).toBeFalsy();
          });
      });
  });

  describe('theme switching', () => {
      pushOptions({
          plugins: [index$2, index$a],
      });
      it('can switch from standard to bootstrap', () => {
          let calendar = initCalendar();
          verifyStandardTheme(calendar);
          currentCalendar.setOption('themeSystem', 'bootstrap');
          verifyBootstrapTheme(calendar);
      });
      it('can switch from bootstrap to standard', () => {
          let calendar = initCalendar({ themeSystem: 'bootstrap' });
          verifyBootstrapTheme(calendar);
          currentCalendar.setOption('themeSystem', 'standard');
          verifyStandardTheme(calendar);
      });
      function verifyStandardTheme(calendar) {
          expect(calendar.el).toHaveClass(CalendarWrapper.UNTHEMED_CLASSNAME);
      }
      function verifyBootstrapTheme(calendar) {
          expect(calendar.el).toHaveClass(CalendarWrapper.BOOTSTRAP_CLASSNAME);
      }
  });

  describe('implicit unselection', () => {
      pushOptions({
          initialView: 'dayGridMonth',
          fixedWeekCount: true,
          now: '2018-09-11',
      });
      it('happens when dates change', () => {
          let selectFired = 0;
          let unselectFired = 0;
          initCalendar({
              select() {
                  selectFired += 1;
              },
              unselect() {
                  unselectFired += 1;
              },
          });
          currentCalendar.select('2018-09-24', '2018-10-03'); // will still be visible after .next()
          expect(selectFired).toBe(1);
          expect(unselectFired).toBe(0);
          currentCalendar.next();
          expect(selectFired).toBe(1);
          expect(unselectFired).toBe(1); // unselected
      });
      it('happens when view changes', () => {
          let selectFired = 0;
          let unselectFired = 0;
          initCalendar({
              select() {
                  selectFired += 1;
              },
              unselect() {
                  unselectFired += 1;
              },
          });
          currentCalendar.select('2018-09-09', '2018-09-14'); // will still be visible after view switch
          expect(selectFired).toBe(1);
          expect(unselectFired).toBe(0);
          currentCalendar.changeView('dayGridWeek');
          expect(selectFired).toBe(1);
          expect(unselectFired).toBe(1); // unselected
      });
  });

  describe('timeGrid event rendering', () => {
      // https://github.com/fullcalendar/fullcalendar/issues/6019
      it('renders without intersecting when sorted by title', () => {
          let calendar = initCalendar({
              initialView: 'timeGridWeek',
              initialDate: '2020-12-15',
              scrollTime: '05:00',
              eventOrder: 'title,-allDay,start,-duration',
              slotEventOverlap: false,
              events: [
                  {
                      title: 'a',
                      start: '2020-12-15 15:00:00',
                      end: '2020-12-15 18:00:00',
                  },
                  {
                      title: 'b',
                      start: '2020-12-15 05:00:00',
                      end: '2020-12-15 08:00:00',
                  },
                  {
                      title: 'c',
                      start: '2020-12-15 09:00:00',
                      end: '2020-12-15 12:00:00',
                  },
                  {
                      title: 'd',
                      start: '2020-12-15 05:00:00',
                      end: '2020-12-15 09:00:00',
                  },
                  {
                      title: 'e',
                      start: '2020-12-15 05:00:00',
                      end: '2020-12-15 08:00:00',
                  },
                  {
                      color: 'red',
                      title: 'f',
                      start: '2020-12-15 08:00:00',
                      end: '2020-12-15 12:00:00',
                  },
                  {
                      title: 'g',
                      start: '2020-12-15 08:00:00',
                      end: '2020-12-15 17:30:00',
                  },
              ],
          });
          let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
          let eventEls = timeGridWrapper.getEventEls();
          let obscured = anyElsObscured(eventEls);
          expect(obscured).toBe(false);
      });
      // https://github.com/fullcalendar/fullcalendar/issues/2758
      it('renders without intersecting for certain arrangement', () => {
          let calendar = initCalendar({
              initialDate: '2015-04-22',
              initialView: 'timeGridDay',
              scrollTime: '09:00',
              slotEventOverlap: false,
              editable: true,
              events: [
                  {
                      title: 'A',
                      start: '2015-04-22 10:00:00',
                      end: '2015-04-22 13:00:00',
                  },
                  {
                      title: 'B',
                      start: '2015-04-22 13:00:00',
                      end: '2015-04-22 13:30:00',
                  },
                  {
                      title: 'C',
                      start: '2015-04-22 10:00:00',
                      end: '2015-04-22 11:00:00',
                  },
                  {
                      title: 'D',
                      start: '2015-04-22 22:00:00',
                      end: '2015-04-22 23:00:00',
                  },
                  {
                      title: 'E',
                      start: '2015-04-22 10:00:00',
                      end: '2015-04-22 14:00:00',
                  },
                  {
                      title: 'F',
                      start: '2015-04-22 14:00:00',
                      end: '2015-04-22 15:30:00',
                  },
                  {
                      title: 'G',
                      start: '2015-04-22 22:00:00',
                      end: '2015-04-22 23:00:00',
                  },
                  {
                      title: 'H',
                      start: '2015-04-22 22:00:00',
                      end: '2015-04-22 23:00:00',
                  },
                  {
                      title: 'I',
                      start: '2015-04-22 15:00:00',
                      end: '2015-04-22 23:30:00',
                  },
                  {
                      title: 'J',
                      start: '2015-04-22 10:00:00',
                      end: '2015-04-22 15:30:00',
                  },
                  {
                      title: 'K',
                      start: '2015-04-22 22:00:00',
                      end: '2015-04-22 23:00:00',
                  },
                  {
                      title: 'L',
                      start: '2015-04-22 12:00:00',
                      end: '2015-04-22 15:00:00',
                  },
              ],
          });
          let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
          let eventEls = timeGridWrapper.getEventEls();
          let obscured = anyElsObscured(eventEls);
          expect(obscured).toBe(false);
      });
      // https://github.com/fullcalendar/fullcalendar/issues/5004
      it('renders event widths somewhat equally', () => {
          let calendar = initCalendar({
              initialView: 'timeGridDay',
              initialDate: '2019-08-01',
              slotDuration: '00:15:00',
              slotEventOverlap: false,
              events: [
                  { start: '2019-08-01 08:00', end: '2019-08-01 09:00' },
                  { start: '2019-08-01 08:00', end: '2019-08-01 09:00' },
                  { start: '2019-08-01 08:30', end: '2019-08-01 09:30' },
                  { start: '2019-08-01 09:00', end: '2019-08-01 10:00' },
                  { start: '2019-08-01 09:00', end: '2019-08-01 10:00' },
                  { start: '2019-08-01 09:30', end: '2019-08-01 10:30' },
                  { start: '2019-08-01 09:30', end: '2019-08-01 10:30' },
                  { start: '2019-08-01 10:00', end: '2019-08-01 11:00' },
                  { start: '2019-08-01 10:00', end: '2019-08-01 11:00' },
                  { start: '2019-08-01 10:00', end: '2019-08-01 11:00' },
                  { start: '2019-08-01 10:00', end: '2019-08-01 11:00' },
                  { start: '2019-08-01 10:00', end: '2019-08-01 11:00' },
                  { start: '2019-08-01 10:00', end: '2019-08-01 11:00' },
                  { start: '2019-08-01 10:00', end: '2019-08-01 11:00' },
              ],
          });
          let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
          let eventEls = timeGridWrapper.getEventEls();
          let eventWidths = eventEls.map((eventEl) => eventEl.getBoundingClientRect().width);
          eventWidths.sort(); // sorts highest to lowest
          eventWidths.splice(0, 1); // remove first item, which is exceptionally wide event
          expect(Math.abs(eventWidths[0] - eventWidths[eventWidths.length - 1])).toBeLessThan(1);
      });
  });

  describe('the time text on events', () => {
      describe('in week', () => {
          pushOptions({
              initialView: 'timeGridWeek',
              initialDate: '2017-07-03',
              scrollTime: '00:00',
          });
          it('renders segs with correct local timezone', () => {
              const FORMAT = {
                  hour: 'numeric',
                  minute: '2-digit',
                  timeZoneName: 'short',
              };
              let calendar = initCalendar({
                  timeZone: 'local',
                  eventTimeFormat: FORMAT,
                  events: [
                      { start: '2017-07-03T23:00:00', end: '2017-07-04T13:00:00' },
                  ],
              });
              let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
              let timeText = timeGridWrapper.getEventTimeTexts();
              expect(timeText).toEqual([
                  currentCalendar.formatRange(parseLocalDate('2017-07-03T23:00:00'), parseLocalDate('2017-07-04T00:00:00'), FORMAT),
                  currentCalendar.formatRange(parseLocalDate('2017-07-04T00:00:00'), parseLocalDate('2017-07-04T13:00:00'), FORMAT),
              ]);
          });
      });
  });

  describe('dayGrid advanced event rendering', () => {
      pushOptions({
          initialDate: '2020-05-01',
      });
      // https://github.com/fullcalendar/fullcalendar/issues/5408
      it('renders without intersecting', () => {
          let calendar = initCalendar({
              initialView: 'dayGridMonth',
              initialDate: '2020-05-01',
              events: [
                  { start: '2020-05-02', end: '2020-05-04', title: 'event a' },
                  { start: '2020-05-02', end: '2020-05-04', title: 'event b' },
                  { start: '2020-05-03', end: '2020-05-05', title: 'event c' },
                  { start: '2020-05-04', title: 'event d' },
                  { start: '2020-05-04', title: 'event e' },
              ],
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          let eventEls = dayGridWrapper.getEventEls();
          expect(anyElsIntersect(eventEls)).toBe(false);
      });
      // https://github.com/fullcalendar/fullcalendar/issues/5771
      it('renders more-links correctly when first obscured event is longer than event before it', () => {
          let calendar = initCalendar({
              initialView: 'dayGridMonth',
              initialDate: '2020-08-01',
              dayMaxEventRows: 3,
              events: [
                  { title: 'big1', start: '2020-07-23', end: '2020-07-28' },
                  { title: 'small1', start: '2020-07-24', end: '2020-07-27' },
                  { title: 'small2', start: '2020-07-24', end: '2020-07-27' },
                  { title: 'big2', start: '2020-07-25', end: '2020-07-28' },
              ],
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          let eventEls = dayGridWrapper.getEventEls();
          let visibleEventEls = filterVisibleEls(eventEls);
          let moreLinkEls = dayGridWrapper.getMoreEls();
          expect(visibleEventEls.length).toBe(3);
          expect(moreLinkEls.length).toBe(1);
          expect(anyElsIntersect(visibleEventEls.concat(moreLinkEls))).toBe(false);
      });
      // https://github.com/fullcalendar/fullcalendar/issues/5790
      it('positions more-links correctly in columns that have empty space', () => {
          let calendar = initCalendar({
              initialView: 'dayGridMonth',
              initialDate: '2020-09-01',
              dayMaxEventRows: 4,
              events: [
                  { start: '2020-08-30', end: '2020-09-04' },
                  { start: '2020-08-31', end: '2020-09-03' },
                  { start: '2020-09-01', end: '2020-09-04' },
                  { start: '2020-09-02', end: '2020-09-04' },
                  { start: '2020-09-02', end: '2020-09-04' },
              ],
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          let eventEls = dayGridWrapper.getEventEls();
          let visibleEventEls = filterVisibleEls(eventEls);
          let moreLinkEls = dayGridWrapper.getMoreEls();
          expect(visibleEventEls.length).toBe(3);
          expect(moreLinkEls.length).toBe(2);
          expect(anyElsIntersect(visibleEventEls.concat(moreLinkEls))).toBe(false);
          expect(Math.abs(moreLinkEls[0].getBoundingClientRect().top -
              moreLinkEls[1].getBoundingClientRect().top)).toBeLessThan(1);
      });
      // https://github.com/fullcalendar/fullcalendar/issues/5883
      it('it renders without gaps when ordered by title', () => {
          let calendar = initCalendar({
              initialDate: '2020-10-01',
              eventOrder: 'title',
              dayMaxEventRows: 3,
              events: [
                  {
                      title: 'b1',
                      start: '2020-10-20',
                      end: '2020-10-22',
                  },
                  {
                      title: 'b2',
                      start: '2020-10-21',
                      end: '2020-10-22',
                  },
                  {
                      title: 'b3',
                      start: '2020-10-20',
                      end: '2020-10-23',
                  },
                  {
                      title: 'b4',
                      start: '2020-10-20',
                      end: '2020-10-23',
                  },
              ],
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          let eventEls = dayGridWrapper.getEventEls();
          let visibleEventEls = filterVisibleEls(eventEls);
          let moreLinkEls = dayGridWrapper.getMoreEls();
          expect(visibleEventEls.length).toBe(2);
          expect(moreLinkEls.length).toBe(3);
          expect(anyElsIntersect(visibleEventEls.concat(moreLinkEls))).toBe(false);
      });
      it('won\'t intersect when doing custom rendering', () => {
          let calendar = initCalendar({
              initialView: 'dayGridMonth',
              initialDate: '2020-06-01',
              events: [
                  { start: '2020-06-04', end: '2020-06-08', title: 'event a' },
                  { start: '2020-06-05', end: '2020-06-09', title: 'event b' },
                  { start: '2020-06-08T12:00:00', title: 'event c' },
              ],
              eventContent(arg) {
                  return {
                      html: `
            <b>${arg.timeText}</b>
            <i>${arg.event.title}</i>
          `,
                  };
              },
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          let eventEls = dayGridWrapper.getEventEls();
          expect(anyElsIntersect(eventEls)).toBe(false);
      });
      it('renders single-day timed event as list-item', () => {
          let calendar = initCalendar({
              initialView: 'dayGridMonth',
              initialDate: '2020-05-01',
              eventDisplay: 'auto',
              events: [
                  {
                      title: 'event 1',
                      start: '2020-05-11T22:00:00',
                  },
              ],
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          let eventEl = dayGridWrapper.getEventEls()[0];
          expect(dayGridWrapper.isEventListItem(eventEl)).toBe(true);
      });
      it('does not render multi-day event as list-item', () => {
          let calendar = initCalendar({
              initialView: 'dayGridMonth',
              initialDate: '2020-05-01',
              eventDisplay: 'auto',
              events: [
                  {
                      title: 'event 1',
                      start: '2020-05-11T22:00:00',
                      end: '2020-05-12T06:00:00',
                  },
              ],
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          let eventEl = dayGridWrapper.getEventEls()[0];
          expect(dayGridWrapper.isEventListItem(eventEl)).toBe(false);
      });
      // https://github.com/fullcalendar/fullcalendar/issues/5634
      it('does not render split multi-day event as list-item', () => {
          let calendar = initCalendar({
              initialView: 'dayGridMonth',
              initialDate: '2020-05-01',
              eventDisplay: 'auto',
              events: [
                  {
                      title: 'event',
                      start: '2020-05-09T12:00:00',
                      end: '2020-05-10T12:00:00',
                  },
              ],
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          let eventEls = dayGridWrapper.getEventEls();
          expect(eventEls.length).toBe(2);
          expect(dayGridWrapper.isEventListItem(eventEls[0])).toBe(false);
          expect(dayGridWrapper.isEventListItem(eventEls[0])).toBe(false);
      });
      it('render only block when eventDislay:block', () => {
          let calendar = initCalendar({
              eventDisplay: 'block',
              events: [
                  { start: '2020-05-02T02:00:00', title: 'event a' },
              ],
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          let eventEl = dayGridWrapper.getEventEls()[0];
          expect(dayGridWrapper.isEventListItem(eventEl)).toBe(false);
      });
      it('adjusts more link when getting bigger then smaller with liquid height', () => {
          const LARGE_HEIGHT = 800;
          const SMALL_HEIGHT = 500;
          let $container = $(`<div style="height:${LARGE_HEIGHT}px"><div></div></div>`).appendTo('body');
          let calendar = initCalendar({
              height: '100%',
              dayMaxEvents: true,
              events: [
                  { start: '2020-05-02', end: '2020-05-03', title: 'event a' },
                  { start: '2020-05-02', end: '2020-05-03', title: 'event b' },
                  { start: '2020-05-02', end: '2020-05-03', title: 'event c' },
                  { start: '2020-05-02', end: '2020-05-03', title: 'event d' },
                  { start: '2020-05-02', end: '2020-05-03', title: 'event e' },
                  { start: '2020-05-02', end: '2020-05-03', title: 'event f' },
              ],
          }, $container.find('div'));
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          let origEventCnt = filterVisibleEls(dayGridWrapper.getEventEls()).length;
          $container.css('height', SMALL_HEIGHT);
          calendar.updateSize();
          let smallEventCnt = filterVisibleEls(dayGridWrapper.getEventEls()).length;
          expect(smallEventCnt).not.toBe(origEventCnt);
          $container.css('height', LARGE_HEIGHT);
          calendar.updateSize();
          let largeEventCnt = filterVisibleEls(dayGridWrapper.getEventEls()).length;
          expect(largeEventCnt).toBe(origEventCnt);
          $container.remove();
      });
      // https://github.com/fullcalendar/fullcalendar/issues/5850
      it('does not have JS error when dayMaxEventRows and almost no height', () => {
          initCalendar({
              height: '100%',
              eventDisplay: 'block',
              dayMaxEventRows: true,
              events: [
                  { start: '2020-05-02T02:00:00', title: 'event a' },
              ],
          });
      });
      // https://github.com/fullcalendar/fullcalendar/issues/5863
      it('does not have JS error when dayMaxEventRows and almost no height', () => {
          let $container = $('<div style="width:100px" />').appendTo('body');
          initCalendar({
              height: '100%',
              eventDisplay: 'block',
              dayMaxEventRows: true,
              events: [
                  { start: '2020-05-02T02:00:00', title: 'event a' },
              ],
          }, $container[0]);
          $container.remove();
      });
      it('doesn\'t create more-link while positioning events with temporary unknown dimensions', () => {
          let renderedMoreLink = false;
          initCalendar({
              initialView: 'dayGridMonth',
              moreLinkDidMount() {
                  renderedMoreLink = true;
              },
              events: [
                  { id: '1', start: '2020-05-05' },
              ],
          });
          expect(renderedMoreLink).toBe(false);
      });
      it('can render events with strict ordering', () => {
          let calendar = initCalendar({
              initialView: 'dayGridMonth',
              eventOrder: 'id',
              eventOrderStrict: true,
              events: [
                  { id: '1', start: '2020-05-05' },
                  { id: '2', start: '2020-05-03', end: '2020-05-08' },
                  { id: '3', start: '2020-05-04' },
              ],
              eventDidMount(arg) {
                  arg.el.setAttribute('data-event-id', arg.event.id); // TODO: more formal system for this
              },
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          let eventEls = dayGridWrapper.getEventEls();
          let visibleEventEls = filterVisibleEls(eventEls);
          expect(anyElsIntersect(visibleEventEls)).toBe(false);
          let el1 = document.querySelector('[data-event-id="1"]');
          let el2 = document.querySelector('[data-event-id="2"]');
          let el3 = document.querySelector('[data-event-id="3"]');
          let top1 = el1.getBoundingClientRect().top;
          let top2 = el2.getBoundingClientRect().top;
          let top3 = el3.getBoundingClientRect().top;
          expect(top1).toBeLessThan(top2);
          expect(top2).toBeLessThan(top3);
      });
      // https://github.com/fullcalendar/fullcalendar/issues/5767
      it('consumes empty gaps in space when strict ordering', () => {
          let calendar = initCalendar({
              initialDate: '2020-08-23',
              initialView: 'dayGridWeek',
              eventOrder: 'title',
              eventOrderStrict: true,
              dayMaxEventRows: 4,
              eventDidMount(arg) {
                  arg.el.setAttribute('data-event-id', arg.event.id); // TODO: more formal system for this
              },
              events: [
                  {
                      title: 'a',
                      id: 'a',
                      start: '2020-08-24',
                      end: '2020-08-27',
                  },
                  {
                      title: 'b',
                      id: 'b',
                      start: '2020-08-24',
                      end: '2020-08-27',
                  },
                  {
                      title: 'c',
                      id: 'c',
                      start: '2020-08-28',
                      end: '2020-08-29',
                  },
                  {
                      title: 'd',
                      id: 'd',
                      start: '2020-08-24',
                      end: '2020-08-29',
                  },
                  {
                      title: 'e',
                      id: 'e',
                      start: '2020-08-27',
                      end: '2020-08-29',
                  },
                  {
                      title: 'f',
                      id: 'f',
                      start: '2020-08-24',
                      end: '2020-08-29',
                  },
              ],
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          let eventEls = dayGridWrapper.getEventEls();
          let visibleEventEls = filterVisibleEls(eventEls);
          expect(anyElsIntersect(visibleEventEls)).toBe(false);
          let rect0 = document.querySelector('[data-event-id="d"]').getBoundingClientRect();
          let rect1 = document.querySelector('[data-event-id="f"]').getBoundingClientRect();
          expect(rect1.top - rect0.bottom).toBeLessThan(2);
      });
      // https://github.com/fullcalendar/fullcalendar/issues/6393
      it('doesn\'t overlap with eventOrderStrict', () => {
          let calendar = initCalendar({
              initialDate: '2021-06-21',
              initialView: 'dayGridWeek',
              eventOrderStrict: true,
              events: [
                  {
                      title: 'Busy1',
                      start: '2021-06-21T10:00:00Z',
                      end: '2021-06-21T11:00:00Z',
                  },
                  {
                      title: 'Busy2',
                      start: '2021-06-21T08:00:00Z',
                      end: '2021-06-21T10:00:00Z',
                  },
                  {
                      title: 'Busy3',
                      start: '2021-06-22T11:00:00Z',
                      end: '2021-06-22T12:00:00Z',
                  },
                  {
                      title: 'Busy4',
                      start: '2021-06-24T08:30:00Z',
                      end: '2021-06-24T11:00:00Z',
                  },
                  {
                      title: 'Busy5',
                      start: '2021-06-24T16:00:00Z',
                      end: '2021-06-24T16:30:00Z',
                  },
              ],
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          let eventEls = dayGridWrapper.getEventEls();
          let visibleEventEls = filterVisibleEls(eventEls);
          expect(anyElsIntersect(visibleEventEls)).toBe(false);
      });
      // https://github.com/fullcalendar/fullcalendar/issues/6397
      it('doesn\'t show duplicate events in popover when eventOrder by start date', (done) => {
          let calendar = initCalendar({
              initialView: 'dayGridMonth',
              initialDate: '2021-07-07',
              eventOrder: 'start',
              dayMaxEventRows: 4,
              events: [
                  {
                      title: 'Ariana Florescu',
                      start: '2021-07-02',
                      end: '2021-07-03',
                  },
                  {
                      title: 'Alan Leaclaire',
                      start: '2021-07-02',
                      end: '2021-07-10',
                  },
                  {
                      title: 'Divya Sundavaridevelu',
                      start: '2021-07-05',
                      end: '2021-07-06',
                  },
                  {
                      title: 'Phyllis Benoussan',
                      start: '2021-07-05',
                      end: '2021-07-06',
                  },
                  {
                      title: 'Allison Olsen',
                      start: '2021-07-05',
                      end: '2021-07-10',
                  },
                  {
                      title: 'Justin Sinnaeve',
                      start: '2021-07-05',
                      end: '2021-07-10',
                  },
                  {
                      title: 'Sylwia Pitel',
                      start: '2021-07-07',
                      end: '2021-07-08',
                  },
                  {
                      title: 'Derrick Leach',
                      start: '2021-07-07',
                      end: '2021-07-10',
                  },
                  {
                      title: 'Sebastien Pillon',
                      start: '2021-07-08',
                      end: '2021-07-13',
                  },
                  {
                      title: 'Nishat Ayub',
                      start: '2021-07-08',
                      end: '2021-07-10',
                  },
                  {
                      title: 'Ognjen Stoisavljevic',
                      start: '2021-07-09',
                      end: '2021-07-10',
                  },
                  {
                      title: 'Slobodan Stojanovic',
                      start: '2021-07-09',
                      end: '2021-07-10',
                  },
                  {
                      title: 'Phyllis Benoussan',
                      start: '2021-07-09',
                      end: '2021-07-10',
                  },
              ],
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          dayGridWrapper.openMorePopover(4); // on July 9th
          setTimeout(() => {
              let eventEls = dayGridWrapper.getMorePopoverEventEls();
              expect(eventEls.length).toBe(9);
              done();
          });
      });
      // https://github.com/fullcalendar/fullcalendar/issues/7447
      it('Doesn\'t error or overlap event positions when white-space:normal', () => {
          let calendar = initCalendar({
              initialView: 'dayGridWeek',
              initialDate: '2023-04-09',
              dayMaxEvents: 4,
              eventContent() {
                  return {
                      html: '<div style="white-space: normal">' +
                          '<strong>AAAAAAAAAA</strong> <strong>BBBBBBBBB</strong></div>',
                  };
              },
              events: [
                  {
                      id: 'a',
                      start: '2023-04-14',
                      end: '2023-04-21',
                  },
                  {
                      id: 'b',
                      start: '2023-04-13',
                      end: '2023-04-22',
                  },
                  {
                      id: 'c',
                      start: '2023-04-06',
                      end: '2023-04-15',
                  },
                  {
                      id: 'd',
                      start: '2023-04-11',
                      end: '2023-04-14',
                  },
                  {
                      id: 'e',
                      start: '2023-04-14',
                      end: '2023-04-19',
                  },
                  {
                      id: 'f',
                      start: '2023-04-13',
                      end: '2023-04-19',
                  },
                  {
                      id: 'g',
                      start: '2023-04-05',
                      end: '2023-04-14',
                  },
                  {
                      id: 'h',
                      start: '2023-04-06',
                      end: '2023-04-15',
                  },
                  {
                      id: 'i',
                      start: '2023-04-13',
                      end: '2023-04-15',
                  },
                  {
                      id: 'j',
                      start: '2023-04-12',
                      end: '2023-04-15',
                  },
              ],
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          let eventEls = dayGridWrapper.getEventEls();
          let visibleEventEls = filterVisibleEls(eventEls);
          expect(anyElsIntersect(visibleEventEls)).toBe(false);
      });
  });

  describe('background event', () => {
      pushOptions({
          initialDate: '2020-06-23',
      });
      describe('that are timed', () => {
          pushOptions({
              events: [
                  {
                      start: '2020-06-23T12:00:00',
                      end: '2020-06-23T14:00:00',
                      display: 'background',
                  },
              ],
          });
          it('won\'t appear in daygrid', () => {
              let calendar = initCalendar();
              let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
              let eventEls = dayGridWrapper.getBgEventEls();
              expect(eventEls.length).toBe(0);
          });
      });
  });

  describe('eventMinHeight', () => {
      pushOptions({
          initialView: 'timeGridWeek',
          initialDate: '2017-08-10',
          events: [
              { start: '2017-08-10T10:30:00', end: '2017-08-10T10:31:00' },
          ],
      });
      it('has a non-zero default', () => {
          let calendar = initCalendar();
          let eventEl = new CalendarWrapper(calendar).getFirstEventEl();
          expect(eventEl.offsetHeight).toBeGreaterThan(5);
      });
      it('can be set and rendered', () => {
          let calendar = initCalendar({
              eventMinHeight: 40,
          });
          let eventEl = new CalendarWrapper(calendar).getFirstEventEl();
          expect(eventEl.offsetHeight).toBeGreaterThanOrEqual(39);
      });
      it('will ignore temporal non-collision and render side-by-side', () => {
          let calendar = initCalendar({
              eventMinHeight: 40,
              events: [
                  { start: '2017-08-10T10:30:00', end: '2017-08-10T10:31:00', title: 'event a' },
                  { start: '2017-08-10T10:31:20', end: '2017-08-10T10:31:40', title: 'event b' },
              ],
          });
          let eventEls = new CalendarWrapper(calendar).getEventEls();
          expect(eventEls[0].getBoundingClientRect().left)
              .toBeLessThan(eventEls[1].getBoundingClientRect().left);
      });
  });

  describe('short timegrid events', () => {
      it('gets corrected className when short, by default', () => {
          let calendar = initCalendar({
              initialView: 'timeGridWeek',
              initialDate: '2017-08-10',
              events: [
                  { start: '2017-08-10T10:30:00', end: '2017-08-10T10:31:00', title: 'event a' },
              ],
          });
          let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
          let eventEls = timeGridWrapper.getEventEls();
          expect(queryEventElInfo(eventEls[0]).isShort).toBe(true);
      });
      it('can apply short className when customized to be larger', () => {
          let calendar = initCalendar({
              initialView: 'timeGridWeek',
              initialDate: '2017-08-10',
              eventShortHeight: 200,
              events: [
                  { start: '2017-08-10T10:30:00', end: '2017-08-10T12:30:00', title: 'event a' },
              ],
          });
          let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
          let eventEls = timeGridWrapper.getEventEls();
          expect(queryEventElInfo(eventEls[0]).isShort).toBe(true);
      });
  });

  describe('print preview', () => {
      pushOptions({
          initialDate: '2019-04-08',
          scrollTime: '00:00',
          events: [
              { id: '2', start: '2019-04-08T05:00:00' },
              { id: '1', start: '2019-04-08T01:00:00' },
          ],
          eventDidMount(arg) {
              arg.el.setAttribute('data-id', arg.event.id);
          },
      });
      describeOptions('initialView', {
          'with timeGrid view': 'timeGridDay',
          'with dayGrid view': 'dayGridDay',
      }, () => {
          it('orders events in DOM by start time', () => {
              let calendar = initCalendar();
              let calendarWrapper = new CalendarWrapper(calendar);
              let eventEls = calendarWrapper.getEventEls();
              let ids = eventEls.map((el) => el.getAttribute('data-id'));
              expect(ids).toEqual(['1', '2']);
          });
      });
      describeOptions('initialView', {
          'with timeGrid view': 'timeGridWeek',
          'with dayGrid view': 'dayGridDay',
      }, () => {
          // https://github.com/fullcalendar/fullcalendar/issues/5709
          it('orders by start time when in actually printing', (done) => {
              let calendar = initCalendar();
              calendar.trigger('_beforeprint');
              setTimeout(() => {
                  let calendarWrapper = new CalendarWrapper(calendar);
                  let eventEls = calendarWrapper.getEventEls();
                  let ids = eventEls.map((el) => el.getAttribute('data-id'));
                  expect(ids).toEqual(['1', '2']);
                  done();
              });
          });
      });
  });

  describe('eventOrder', () => {
      pushOptions({
          initialDate: '2018-01-01',
          initialView: 'dayGridMonth',
          eventDidMount(arg) {
              arg.el.setAttribute('data-event-id', arg.event.id);
          },
      });
      describe('when all different start times', () => {
          pushOptions({
              events: [
                  { id: 'z', title: 'a', start: '2018-01-01T10:00:00' },
                  { id: 'y', title: 'b', start: '2018-01-01T09:00:00' },
                  { id: 'x', title: 'c', start: '2018-01-01T08:00:00' },
              ],
          });
          it('will sort by start time by default', () => {
              initCalendar();
              expect(getEventOrder()).toEqual(['x', 'y', 'z']);
          });
      });
      describe('when all the same date', () => {
          pushOptions({
              events: [
                  { id: 'z', title: 'a', start: '2018-01-01T09:00:00', myOrder: 3 },
                  { id: 'y', title: 'b', start: '2018-01-01T09:00:00', myOrder: 1 },
                  { id: 'x', title: 'c', start: '2018-01-01T09:00:00', myOrder: 2 },
              ],
          });
          it('sorts by title by default', () => {
              initCalendar();
              expect(getEventOrder()).toEqual(['z', 'y', 'x']);
          });
          it('can sort by a standard prop', () => {
              initCalendar({
                  eventOrder: 'id',
              });
              expect(getEventOrder()).toEqual(['x', 'y', 'z']);
          });
          it('can sort by a non-standard prop', () => {
              initCalendar({
                  eventOrder: 'myOrder',
              });
              expect(getEventOrder()).toEqual(['y', 'x', 'z']);
          });
      });
      describe('when different dates', () => {
          pushOptions({
              events: [
                  { id: 'z', title: 'a', start: '2018-01-03T09:00:00', end: '2018-01-06T09:00:00', myOrder: 3 },
                  { id: 'y', title: 'b', start: '2018-01-02T09:00:00', end: '2018-01-06T09:00:00', myOrder: 1 },
                  { id: 'x', title: 'c', start: '2018-01-01T09:00:00', end: '2018-01-06T09:00:00', myOrder: 2 },
              ],
          });
          it('sorting by a prop will override date-determined order', () => {
              initCalendar({
                  eventOrder: 'myOrder',
              });
              expect(getEventOrder()).toEqual(['y', 'x', 'z']);
          });
      });
      describe('when different durations', () => {
          pushOptions({
              events: [
                  { id: 'z', title: 'a', start: '2018-01-01T09:00:00', end: '2018-01-04T09:00:00', myOrder: 3 },
                  { id: 'y', title: 'b', start: '2018-01-01T09:00:00', end: '2018-01-02T09:00:00', myOrder: 1 },
                  { id: 'x', title: 'c', start: '2018-01-01T09:00:00', end: '2018-01-03T09:00:00', myOrder: 2 }, // 2 day
              ],
          });
          it('sorting by a prop will override duration-determined order', () => {
              initCalendar({
                  eventOrder: 'myOrder',
              });
              expect(getEventOrder()).toEqual(['y', 'x', 'z']);
          });
      });
      describe('when long event split across weeks', () => {
          pushOptions({
              events: [
                  { id: 'x', start: '2018-01-06', end: '2018-01-08' },
                  { id: 'y', start: '2018-01-06', end: '2018-01-07' },
                  { id: 'z', start: '2018-01-07', end: '2018-01-08' },
              ],
          });
          it('should prioritize eventOrder duration', () => {
              let calendar = initCalendar({
                  eventOrder: '-duration',
              });
              let dayGrid = new DayGridViewWrapper(calendar).dayGrid;
              let rowEls = dayGrid.getRowEls();
              let xEvent0 = rowEls[0].querySelector('[data-event-id="x"]');
              let xEvent1 = rowEls[1].querySelector('[data-event-id="x"]');
              let yEvent = rowEls[0].querySelector('[data-event-id="y"]');
              let zEvent = rowEls[1].querySelector('[data-event-id="z"]');
              expect(xEvent0.getBoundingClientRect().top)
                  .toBeLessThan(yEvent.getBoundingClientRect().top);
              expect(xEvent1.getBoundingClientRect().top)
                  .toBeLessThan(zEvent.getBoundingClientRect().top);
          });
      });
      function getEventOrder() {
          let objs = new CalendarWrapper(currentCalendar).getEventEls().map((el) => ({
              id: el.getAttribute('data-event-id'),
              top: el.getBoundingClientRect().top,
          }));
          objs.sort((a, b) => a.top - b.top);
          return objs.map((obj) => obj.id);
      }
  });

  describe('eventContent', () => {
      pushOptions({
          initialView: 'dayGridMonth',
          initialDate: '2020-06-01',
          events: [
              { title: 'my event', start: '2020-06-01T01:00:00' },
          ],
      });
      it('can inject vdom nodes', () => {
          let calendar = initCalendar({
              eventContent(info, createElement) {
                  return (createElement('span', {}, [
                      createElement('b', {}, info.timeText),
                      createElement('i', {}, info.event.title),
                  ]));
              },
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          let eventEl = dayGridWrapper.getEventEls()[0];
          expect(eventEl.querySelector('b').innerHTML).toBe('1a');
          expect(eventEl.querySelector('i').innerHTML).toBe('my event');
      });
      it('can inject html content', () => {
          let calendar = initCalendar({
              eventContent(info) {
                  return {
                      html: `<b>${info.timeText}</b><i>${info.event.title}</i>`,
                  };
              },
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          let eventEl = dayGridWrapper.getEventEls()[0];
          expect(eventEl.querySelector('b').innerHTML).toBe('1a');
          expect(eventEl.querySelector('i').innerHTML).toBe('my event');
      });
      it('can inject text content', () => {
          let calendar = initCalendar({
              eventContent(info) {
                  return info.timeText + ' - ' + info.event.title;
              },
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          let eventEl = dayGridWrapper.getEventEls()[0];
          expect(eventEl.innerHTML).toBe('1a - my event');
      });
      it('will render blank content if nothing returned', () => {
          let calendar = initCalendar({
              eventContent() {
              },
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          let eventEl = dayGridWrapper.getEventEls()[0];
          expect($(eventEl).text()).toBe('');
      });
      it('can return true to render default content', () => {
          let calendar = initCalendar({
              eventContent() {
                  return true;
              },
          });
          let dayGridWrapper = new DayGridViewWrapper(calendar).dayGrid;
          let eventEl = dayGridWrapper.getEventEls()[0];
          expect($(eventEl).text()).toMatch('my event');
      });
      // https://github.com/fullcalendar/fullcalendar/issues/5916
      xit('can render multiple appearance changes in eventDidMount', () => {
          let calendar = initCalendar({
              initialView: 'timeGridWeek',
              initialDate: '2020-12-13',
              eventDidMount(arg) {
                  arg.event.setProp('backgroundColor', 'red');
                  arg.event.setProp('title', 'name changed');
              },
              events: [
                  {
                      id: 'a',
                      title: 'a',
                      start: '2020-12-15T09:30:00',
                  },
                  {
                      id: 'b',
                      title: 'b',
                      start: '2020-12-22T09:30:00',
                  },
              ],
          });
          function expectEventDataChanged(id) {
              let event = calendar.getEventById(id);
              expect(event.title).toBe('name changed');
              expect(event.backgroundColor).toBe('red');
          }
          let viewWrapper = new TimeGridViewWrapper(calendar).timeGrid;
          let eventEl = viewWrapper.getEventEls()[0];
          expect($(eventEl).css('background-color')).toMatch(RED_REGEX);
          expectEventDataChanged('a');
          calendar.next();
          eventEl = viewWrapper.getEventEls()[0];
          expect($(eventEl).css('background-color')).toMatch(RED_REGEX);
          expectEventDataChanged('b');
      });
      // https://github.com/fullcalendar/fullcalendar/issues/6079
      it('can handle view-specific custom content generators', () => {
          let calendar = initCalendar({
              initialView: 'dayGridWeek',
              initialDate: '2021-01-07',
              views: {
                  dayGridWeek: {
                      eventContent() {
                          let eventWrapper = document.createElement('div');
                          eventWrapper.innerText = 'test dayGridWeek';
                          let arrayOfDomNodes = [eventWrapper];
                          return { domNodes: arrayOfDomNodes };
                      },
                  },
              },
              events: [
                  { start: '2021-01-07', title: 'default title' },
              ],
          });
          let dayGrid = new DayGridViewWrapper(calendar).dayGrid;
          let eventEl = dayGrid.getEventEls()[0];
          expect(eventEl.innerText.trim()).toBe('test dayGridWeek');
          calendar.changeView('dayGridMonth');
          dayGrid = new DayGridViewWrapper(calendar).dayGrid;
          eventEl = dayGrid.getEventEls()[0];
          expect(eventEl.innerText.trim()).toBe('default title');
      });
  });

  describe('slotMinTime', () => {
      pushOptions({
          initialView: 'timeGridWeek',
          initialDate: '2017-03-22',
          scrollTime: '00:00',
      });
      describe('event rendering', () => {
          describe('when event is within negative slotMinTime', () => {
              pushOptions({
                  slotMinTime: { hours: -2 },
                  events: [
                      { start: '2017-03-22T22:00:00', end: '2017-03-23T00:00:00' },
                  ],
              });
              it('renders two event elements in the correct places', () => {
                  let calendar = initCalendar();
                  let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                  let res = timeGridWrapper.checkEventRendering('2017-03-22T22:00:00Z', '2017-03-23T00:00:00Z');
                  expect(res.length).toBe(2);
                  expect(res.isMatch).toBe(true);
              });
          });
          describe('when event start cut off by positive slotMinTime', () => {
              pushOptions({
                  slotMinTime: { hours: 12 },
                  events: [
                      { start: '2017-03-22T10:00:00', end: '2017-03-22T14:00:00' },
                  ],
              });
              it('shows time-text as original event start time', () => {
                  let calendar = initCalendar();
                  let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
                  let timeTexts = timeGridWrapper.getEventTimeTexts();
                  expect(timeTexts[0]).toBe('10:00 - 2:00');
              });
          });
      });
      it('can be changed dynamically', () => {
          let calendar = initCalendar();
          currentCalendar.setOption('slotMinTime', '09:00');
          let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
          expect(timeGridWrapper.getTimeAxisInfo()[0].text).toBe('9am');
      });
  });

  describe('event rendering with slotMaxTime', () => {
      pushOptions({
          initialView: 'timeGridWeek',
          initialDate: '2017-03-22',
          scrollTime: '00:00',
      });
      describe('when event is within extended slotMaxTime', () => {
          pushOptions({
              slotMaxTime: '26:00',
              events: [
                  { start: '2017-03-22T00:00:00', end: '2017-03-22T02:00:00' },
              ],
          });
          it('renders two event elements in the correct places', () => {
              let calendar = initCalendar();
              let timeGridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
              let res = timeGridWrapper.checkEventRendering('2017-03-22T00:00:00Z', '2017-03-22T02:00:00Z');
              expect(res.length).toBe(2);
              expect(res.isMatch).toBe(true);
          });
      });
      // https://github.com/fullcalendar/fullcalendar/issues/4483
      it('displays events on the last day', () => {
          initCalendar({
              initialView: 'dayGridWeek',
              slotMaxTime: '20:00',
              events: [
                  { start: '2017-03-19', end: '2017-03-26' },
              ],
          });
          directionallyTestSeg({
              firstCol: 0,
              lastCol: 6,
              isStart: true,
              isEnd: true,
          });
      });
  });

  describe('validRange event rendering', () => {
      describe('with start constraint', () => {
          describe('when month view', () => {
              pushOptions({
                  initialView: 'dayGridMonth',
                  initialDate: '2017-06-01',
                  validRange: { start: '2017-06-07' },
              });
              describe('when event is partially before', () => {
                  pushOptions({
                      events: [
                          { start: '2017-06-05', end: '2017-06-09' },
                      ],
                  });
                  it('truncates the event\'s beginning', () => {
                      let calendar = initCalendar();
                      let calendarWrapper = new CalendarWrapper(calendar);
                      let eventEl = calendarWrapper.getFirstEventEl();
                      let eventInfo = calendarWrapper.getEventElInfo(eventEl);
                      expect(eventInfo.isStart).toBe(false);
                      expect(eventInfo.isEnd).toBe(true);
                      // TODO: more test about positioning
                  });
              });
          });
      });
      describe('with end constraint', () => {
          describe('when month view', () => {
              pushOptions({
                  initialView: 'dayGridMonth',
                  initialDate: '2017-06-01',
                  validRange: { end: '2017-06-07' },
              });
              describe('when event is partially before', () => {
                  pushOptions({
                      events: [
                          { start: '2017-06-05', end: '2017-06-09' },
                      ],
                  });
                  it('truncates the event\'s end', () => {
                      let calendar = initCalendar();
                      let calendarWrapper = new CalendarWrapper(calendar);
                      let eventEl = calendarWrapper.getFirstEventEl();
                      let eventInfo = calendarWrapper.getEventElInfo(eventEl);
                      expect(eventInfo.isStart).toBe(true);
                      expect(eventInfo.isEnd).toBe(false);
                      // TODO: more test about positioning
                  });
              });
          });
      });
  });

  describe('dayNumbers', () => {
      pushOptions({
          initialDate: '2018-01-01',
      });
      it('respects locale in month view', () => {
          let calendar = initCalendar({
              initialView: 'dayGridMonth',
              locale: l7,
          });
          let dayGridViewWrapper = new DayGridViewWrapper(calendar).dayGrid;
          expect(dayGridViewWrapper.getDayNumberText('2018-01-01')).toMatch(/1|١٤?/); // normal 1, or an Arabic 1
      });
  });

  describe('slotMinTime', () => {
      // root cause of https://github.com/fullcalendar/fullcalendar-vue/issues/88
      it('gets rerendered when changing via resetOptions', () => {
          let calendar = initCalendar({
              initialView: 'timeGridDay',
              slotMinTime: '01:00',
          });
          let gridWrapper = new TimeGridViewWrapper(calendar).timeGrid;
          expect(gridWrapper.getAxisTexts()[0]).toBe('1am');
          calendar.setOption('slotMinTime', '09:00');
          expect(gridWrapper.getAxisTexts()[0]).toBe('9am');
      });
  });

  it('daygrid view rerenders well', (done) => {
      let dayHeaderRenderCnt = 0;
      let dayCellRenderCnt = 0;
      let eventRenderCnt = 0;
      let calendar = initCalendar({
          initialView: 'dayGridMonth',
          initialDate: '2017-10-04',
          windowResizeDelay: 0,
          events: [
              { title: 'event 0', start: '2017-10-04' },
          ],
          dayHeaderContent() {
              dayHeaderRenderCnt += 1;
          },
          dayCellContent() {
              dayCellRenderCnt += 1;
          },
          eventContent() {
              eventRenderCnt += 1;
          },
      });
      function resetCounts() {
          dayHeaderRenderCnt = 0;
          dayCellRenderCnt = 0;
          eventRenderCnt = 0;
      }
      expect(dayHeaderRenderCnt).toBe(7);
      expect(dayCellRenderCnt).toBe(42);
      expect(eventRenderCnt).toBe(1);
      resetCounts();
      calendar.next();
      expect(dayHeaderRenderCnt).toBe(0); // same day-of-week headers
      expect(dayCellRenderCnt).toBe(42);
      expect(eventRenderCnt).toBe(0); // event will be out of view
      calendar.changeView('listWeek'); // switch away
      resetCounts();
      calendar.changeView('dayGridMonth'); // return to view
      expect(dayHeaderRenderCnt).toBe(7);
      expect(dayCellRenderCnt).toBe(42);
      expect(eventRenderCnt).toBe(0); // event still out of view
      resetCounts();
      $(window).simulate('resize');
      setTimeout(() => {
          expect(dayHeaderRenderCnt).toBe(0);
          expect(dayCellRenderCnt).toBe(0);
          expect(eventRenderCnt).toBe(0);
          done();
      }, 1); // more than windowResizeDelay
  });

  function buildOptions() {
      return {
          plugins: [index$9],
          initialView: 'timeGridWeek',
          initialDate: '2019-04-01',
          scrollTime: '00:00',
          allDaySlot: true,
          events: [
              { start: '2019-04-01T00:00:00' },
              { start: '2019-04-01T02:00:00' },
          ],
      };
  }
  describe('mutateOptions', () => {
      let $calendarEl;
      let calendar;
      beforeEach(() => {
          $calendarEl = $('<div>').appendTo('body');
      });
      afterEach(() => {
          if (calendar) {
              calendar.destroy();
          }
          $calendarEl.remove();
      });
      it('will react to a single option and keep scroll', () => {
          calendar = new Calendar($calendarEl[0], buildOptions());
          calendar.render();
          let viewWrapper = new TimeGridViewWrapper(calendar);
          let scrollEl = viewWrapper.getScrollerEl();
          scrollEl.scrollTop = 100;
          let scrollTop = scrollEl.scrollTop;
          expect(scrollTop).toBeGreaterThan(0);
          calendar.setOption('allDaySlot', false);
          expect(calendar.getOption('allDaySlot')).toBe(false);
          expect(viewWrapper.dayGrid).toBeFalsy();
          expect(scrollEl.scrollTop).toBe(scrollTop);
      });
      it('rerenders events without rerendering view', () => {
          calendar = new Calendar($calendarEl[0], buildOptions());
          calendar.render();
          let calendarWrapper = new CalendarWrapper(calendar);
          let dateEl = calendarWrapper.getFirstDateEl();
          calendar.setOption('events', [
              { start: '2019-04-01T00:00:00' },
          ]);
          expect(calendarWrapper.getEventEls().length).toBe(1);
          expect(calendarWrapper.getFirstDateEl()).toBe(dateEl);
      });
      it('doesn\'t rerender anything for a initialView change', () => {
          calendar = new Calendar($calendarEl[0], buildOptions());
          calendar.render();
          let calendarWrapper = new CalendarWrapper(calendar);
          let dateEl = calendarWrapper.getFirstDateEl();
          calendar.setOption('initialView', 'timeGridDay');
          expect(calendar.view.type).toBe('timeGridWeek');
          expect(calendarWrapper.getFirstDateEl()).toBe(dateEl);
      });
  });

  it('list view rerenders well', (done) => {
      let dayRenderCnt = 0;
      let eventRenderCnt = 0;
      let noEventsRenderCnt = 0;
      let calendar = initCalendar({
          initialView: 'listWeek',
          initialDate: '2017-10-04',
          windowResizeDelay: 0,
          events: [
              { title: 'event 0', start: '2017-10-04' },
          ],
          dayHeaderContent() {
              dayRenderCnt += 1;
          },
          eventContent() {
              eventRenderCnt += 1;
          },
          noEventsContent() {
              noEventsRenderCnt += 1;
          },
      });
      function resetCounts() {
          dayRenderCnt = 0;
          eventRenderCnt = 0;
          noEventsRenderCnt = 0;
      }
      expect(dayRenderCnt).toBe(1);
      expect(eventRenderCnt).toBe(1);
      expect(noEventsRenderCnt).toBe(0);
      resetCounts();
      calendar.next();
      expect(dayRenderCnt).toBe(0); // no days
      expect(eventRenderCnt).toBe(0); // event will be out of view
      expect(noEventsRenderCnt).toBe(1);
      calendar.changeView('dayGridWeek'); // switch away
      resetCounts();
      calendar.changeView('listWeek'); // return to view
      expect(dayRenderCnt).toBe(0);
      expect(eventRenderCnt).toBe(0);
      expect(noEventsRenderCnt).toBe(1);
      resetCounts();
      $(window).simulate('resize');
      setTimeout(() => {
          expect(dayRenderCnt).toBe(0);
          expect(eventRenderCnt).toBe(0);
          expect(noEventsRenderCnt).toBe(0);
          done();
      }, 1); // more than windowResizeDelay
  });

  it('timegrid view rerenders well', (done) => {
      let dayHeaderRenderCnt = 0;
      let dayCellRenderCnt = 0;
      let slotLabelRenderCnt = 0;
      let slotLaneRenderCnt = 0;
      let eventRenderCnt = 0;
      let calendar = initCalendar({
          initialView: 'timeGridWeek',
          initialDate: '2017-10-04',
          windowResizeDelay: 0,
          events: [
              { title: 'event 0', start: '2017-10-04T00:00:00' },
          ],
          dayHeaderContent() {
              dayHeaderRenderCnt += 1;
          },
          dayCellContent() {
              dayCellRenderCnt += 1;
          },
          slotLabelContent() {
              slotLabelRenderCnt += 1;
          },
          slotLaneContent() {
              slotLaneRenderCnt += 1;
          },
          eventContent() {
              eventRenderCnt += 1;
          },
      });
      function resetCounts() {
          dayHeaderRenderCnt = 0;
          dayCellRenderCnt = 0;
          slotLabelRenderCnt = 0;
          slotLaneRenderCnt = 0;
          eventRenderCnt = 0;
      }
      expect(dayHeaderRenderCnt).toBe(7);
      expect(dayCellRenderCnt).toBe(14); // all-day row AND time cols
      expect(slotLabelRenderCnt).toBe(24); // one slot per every 2 lanes
      expect(slotLaneRenderCnt).toBe(48);
      expect(eventRenderCnt).toBe(1);
      resetCounts();
      calendar.next();
      expect(dayHeaderRenderCnt).toBe(7);
      expect(dayCellRenderCnt).toBe(14);
      expect(slotLabelRenderCnt).toBe(0);
      expect(slotLaneRenderCnt).toBe(0);
      expect(eventRenderCnt).toBe(0); // event will be out of view
      calendar.changeView('listWeek'); // switch away
      resetCounts();
      calendar.changeView('timeGridWeek'); // return to view
      expect(dayHeaderRenderCnt).toBe(7);
      expect(dayCellRenderCnt).toBe(14);
      expect(slotLabelRenderCnt).toBe(24);
      expect(slotLaneRenderCnt).toBe(48);
      expect(eventRenderCnt).toBe(0); // event still out of view
      resetCounts();
      $(window).simulate('resize');
      setTimeout(() => {
          expect(dayHeaderRenderCnt).toBe(0);
          expect(dayCellRenderCnt).toBe(0);
          expect(slotLabelRenderCnt).toBe(0);
          expect(slotLaneRenderCnt).toBe(0);
          expect(eventRenderCnt).toBe(0);
          done();
      }, 1); // more than windowResizeDelay
  });

  var ical = createCommonjsModule$1(function (module) {
  /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at http://mozilla.org/MPL/2.0/.
   * Portions Copyright (C) Philipp Kewisch, 2021 */

  /* jshint ignore:start */
  var ICAL;
  (function() {
    /* istanbul ignore next */
    {
      // CommonJS, where exports may be different each time.
      ICAL = module.exports;
    }
  })();
  /* jshint ignore:end */
  /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at http://mozilla.org/MPL/2.0/.
   * Portions Copyright (C) Philipp Kewisch, 2011-2015 */

  /**
   * The number of characters before iCalendar line folding should occur
   * @type {Number}
   * @default 75
   */
  ICAL.foldLength = 75;


  /**
   * The character(s) to be used for a newline. The default value is provided by
   * rfc5545.
   * @type {String}
   * @default "\r\n"
   */
  ICAL.newLineChar = '\r\n';


  /**
   * Helper functions used in various places within ical.js
   * @namespace
   */
  ICAL.helpers = {
    /**
     * Compiles a list of all referenced TZIDs in all subcomponents and
     * removes any extra VTIMEZONE subcomponents. In addition, if any TZIDs
     * are referenced by a component, but a VTIMEZONE does not exist,
     * an attempt will be made to generate a VTIMEZONE using ICAL.TimezoneService.
     *
     * @param {ICAL.Component} vcal     The top-level VCALENDAR component.
     * @return {ICAL.Component}         The ICAL.Component that was passed in.
     */
    updateTimezones: function(vcal) {
      var allsubs, properties, vtimezones, reqTzid, i, tzid;

      if (!vcal || vcal.name !== "vcalendar") {
        //not a top-level vcalendar component
        return vcal;
      }

      //Store vtimezone subcomponents in an object reference by tzid.
      //Store properties from everything else in another array
      allsubs = vcal.getAllSubcomponents();
      properties = [];
      vtimezones = {};
      for (i = 0; i < allsubs.length; i++) {
        if (allsubs[i].name === "vtimezone") {
          tzid = allsubs[i].getFirstProperty("tzid").getFirstValue();
          vtimezones[tzid] = allsubs[i];
        } else {
          properties = properties.concat(allsubs[i].getAllProperties());
        }
      }

      //create an object with one entry for each required tz
      reqTzid = {};
      for (i = 0; i < properties.length; i++) {
        if ((tzid = properties[i].getParameter("tzid"))) {
          reqTzid[tzid] = true;
        }
      }

      //delete any vtimezones that are not on the reqTzid list.
      for (i in vtimezones) {
        if (vtimezones.hasOwnProperty(i) && !reqTzid[i]) {
          vcal.removeSubcomponent(vtimezones[i]);
        }
      }

      //create any missing, but registered timezones
      for (i in reqTzid) {
        if (
          reqTzid.hasOwnProperty(i) &&
          !vtimezones[i] &&
          ICAL.TimezoneService.has(i)
        ) {
          vcal.addSubcomponent(ICAL.TimezoneService.get(i).component);
        }
      }

      return vcal;
    },

    /**
     * Checks if the given type is of the number type and also NaN.
     *
     * @param {Number} number     The number to check
     * @return {Boolean}          True, if the number is strictly NaN
     */
    isStrictlyNaN: function(number) {
      return typeof(number) === 'number' && isNaN(number);
    },

    /**
     * Parses a string value that is expected to be an integer, when the valid is
     * not an integer throws a decoration error.
     *
     * @param {String} string     Raw string input
     * @return {Number}           Parsed integer
     */
    strictParseInt: function(string) {
      var result = parseInt(string, 10);

      if (ICAL.helpers.isStrictlyNaN(result)) {
        throw new Error(
          'Could not extract integer from "' + string + '"'
        );
      }

      return result;
    },

    /**
     * Creates or returns a class instance of a given type with the initialization
     * data if the data is not already an instance of the given type.
     *
     * @example
     * var time = new ICAL.Time(...);
     * var result = ICAL.helpers.formatClassType(time, ICAL.Time);
     *
     * (result instanceof ICAL.Time)
     * // => true
     *
     * result = ICAL.helpers.formatClassType({}, ICAL.Time);
     * (result isntanceof ICAL.Time)
     * // => true
     *
     *
     * @param {Object} data       object initialization data
     * @param {Object} type       object type (like ICAL.Time)
     * @return {?}                An instance of the found type.
     */
    formatClassType: function formatClassType(data, type) {
      if (typeof(data) === 'undefined') {
        return undefined;
      }

      if (data instanceof type) {
        return data;
      }
      return new type(data);
    },

    /**
     * Identical to indexOf but will only match values when they are not preceded
     * by a backslash character.
     *
     * @param {String} buffer         String to search
     * @param {String} search         Value to look for
     * @param {Number} pos            Start position
     * @return {Number}               The position, or -1 if not found
     */
    unescapedIndexOf: function(buffer, search, pos) {
      while ((pos = buffer.indexOf(search, pos)) !== -1) {
        if (pos > 0 && buffer[pos - 1] === '\\') {
          pos += 1;
        } else {
          return pos;
        }
      }
      return -1;
    },

    /**
     * Find the index for insertion using binary search.
     *
     * @param {Array} list            The list to search
     * @param {?} seekVal             The value to insert
     * @param {function(?,?)} cmpfunc The comparison func, that can
     *                                  compare two seekVals
     * @return {Number}               The insert position
     */
    binsearchInsert: function(list, seekVal, cmpfunc) {
      if (!list.length)
        return 0;

      var low = 0, high = list.length - 1,
          mid, cmpval;

      while (low <= high) {
        mid = low + Math.floor((high - low) / 2);
        cmpval = cmpfunc(seekVal, list[mid]);

        if (cmpval < 0)
          high = mid - 1;
        else if (cmpval > 0)
          low = mid + 1;
        else
          break;
      }

      if (cmpval < 0)
        return mid; // insertion is displacing, so use mid outright.
      else if (cmpval > 0)
        return mid + 1;
      else
        return mid;
    },

    /**
     * Convenience function for debug output
     * @private
     */
    dumpn: /* istanbul ignore next */ function() {
      if (!ICAL.debug) {
        return;
      }

      if (typeof (console) !== 'undefined' && 'log' in console) {
        ICAL.helpers.dumpn = function consoleDumpn(input) {
          console.log(input);
        };
      } else {
        ICAL.helpers.dumpn = function geckoDumpn(input) {
          dump(input + '\n');
        };
      }

      ICAL.helpers.dumpn(arguments[0]);
    },

    /**
     * Clone the passed object or primitive. By default a shallow clone will be
     * executed.
     *
     * @param {*} aSrc            The thing to clone
     * @param {Boolean=} aDeep    If true, a deep clone will be performed
     * @return {*}                The copy of the thing
     */
    clone: function(aSrc, aDeep) {
      if (!aSrc || typeof aSrc != "object") {
        return aSrc;
      } else if (aSrc instanceof Date) {
        return new Date(aSrc.getTime());
      } else if ("clone" in aSrc) {
        return aSrc.clone();
      } else if (Array.isArray(aSrc)) {
        var arr = [];
        for (var i = 0; i < aSrc.length; i++) {
          arr.push(aDeep ? ICAL.helpers.clone(aSrc[i], true) : aSrc[i]);
        }
        return arr;
      } else {
        var obj = {};
        for (var name in aSrc) {
          // uses prototype method to allow use of Object.create(null);
          /* istanbul ignore else */
          if (Object.prototype.hasOwnProperty.call(aSrc, name)) {
            if (aDeep) {
              obj[name] = ICAL.helpers.clone(aSrc[name], true);
            } else {
              obj[name] = aSrc[name];
            }
          }
        }
        return obj;
      }
    },

    /**
     * Performs iCalendar line folding. A line ending character is inserted and
     * the next line begins with a whitespace.
     *
     * @example
     * SUMMARY:This line will be fold
     *  ed right in the middle of a word.
     *
     * @param {String} aLine      The line to fold
     * @return {String}           The folded line
     */
    foldline: function foldline(aLine) {
      var result = "";
      var line = aLine || "", pos = 0, line_length = 0;
      //pos counts position in line for the UTF-16 presentation
      //line_length counts the bytes for the UTF-8 presentation
      while (line.length) {
        var cp = line.codePointAt(pos);
        if (cp < 128) ++line_length;
        else if (cp < 2048) line_length += 2;//needs 2 UTF-8 bytes
        else if (cp < 65536) line_length += 3;
        else line_length += 4; //cp is less than 1114112
        if (line_length < ICAL.foldLength + 1)
          pos += cp > 65535 ? 2 : 1;
        else {
          result += ICAL.newLineChar + " " + line.substring(0, pos);
          line = line.substring(pos);
          pos = line_length = 0;
        }
      }
      return result.substr(ICAL.newLineChar.length + 1);
    },

    /**
     * Pads the given string or number with zeros so it will have at least two
     * characters.
     *
     * @param {String|Number} data    The string or number to pad
     * @return {String}               The number padded as a string
     */
    pad2: function pad(data) {
      if (typeof(data) !== 'string') {
        // handle fractions.
        if (typeof(data) === 'number') {
          data = parseInt(data);
        }
        data = String(data);
      }

      var len = data.length;

      switch (len) {
        case 0:
          return '00';
        case 1:
          return '0' + data;
        default:
          return data;
      }
    },

    /**
     * Truncates the given number, correctly handling negative numbers.
     *
     * @param {Number} number     The number to truncate
     * @return {Number}           The truncated number
     */
    trunc: function trunc(number) {
      return (number < 0 ? Math.ceil(number) : Math.floor(number));
    },

    /**
     * Poor-man's cross-browser inheritance for JavaScript. Doesn't support all
     * the features, but enough for our usage.
     *
     * @param {Function} base     The base class constructor function.
     * @param {Function} child    The child class constructor function.
     * @param {Object} extra      Extends the prototype with extra properties
     *                              and methods
     */
    inherits: function(base, child, extra) {
      function F() {}
      F.prototype = base.prototype;
      child.prototype = new F();

      if (extra) {
        ICAL.helpers.extend(extra, child.prototype);
      }
    },

    /**
     * Poor-man's cross-browser object extension. Doesn't support all the
     * features, but enough for our usage. Note that the target's properties are
     * not overwritten with the source properties.
     *
     * @example
     * var child = ICAL.helpers.extend(parent, {
     *   "bar": 123
     * });
     *
     * @param {Object} source     The object to extend
     * @param {Object} target     The object to extend with
     * @return {Object}           Returns the target.
     */
    extend: function(source, target) {
      for (var key in source) {
        var descr = Object.getOwnPropertyDescriptor(source, key);
        if (descr && !Object.getOwnPropertyDescriptor(target, key)) {
          Object.defineProperty(target, key, descr);
        }
      }
      return target;
    }
  };
  /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at http://mozilla.org/MPL/2.0/.
   * Portions Copyright (C) Philipp Kewisch, 2011-2015 */

  /** @namespace ICAL */


  /**
   * This symbol is further described later on
   * @ignore
   */
  ICAL.design = (function() {

    var FROM_ICAL_NEWLINE = /\\\\|\\;|\\,|\\[Nn]/g;
    var TO_ICAL_NEWLINE = /\\|;|,|\n/g;
    var FROM_VCARD_NEWLINE = /\\\\|\\,|\\[Nn]/g;
    var TO_VCARD_NEWLINE = /\\|,|\n/g;

    function createTextType(fromNewline, toNewline) {
      var result = {
        matches: /.*/,

        fromICAL: function(aValue, structuredEscape) {
          return replaceNewline(aValue, fromNewline, structuredEscape);
        },

        toICAL: function(aValue, structuredEscape) {
          var regEx = toNewline;
          if (structuredEscape)
            regEx = new RegExp(regEx.source + '|' + structuredEscape);
          return aValue.replace(regEx, function(str) {
            switch (str) {
            case "\\":
              return "\\\\";
            case ";":
              return "\\;";
            case ",":
              return "\\,";
            case "\n":
              return "\\n";
            /* istanbul ignore next */
            default:
              return str;
            }
          });
        }
      };
      return result;
    }

    // default types used multiple times
    var DEFAULT_TYPE_TEXT = { defaultType: "text" };
    var DEFAULT_TYPE_TEXT_MULTI = { defaultType: "text", multiValue: "," };
    var DEFAULT_TYPE_TEXT_STRUCTURED = { defaultType: "text", structuredValue: ";" };
    var DEFAULT_TYPE_INTEGER = { defaultType: "integer" };
    var DEFAULT_TYPE_DATETIME_DATE = { defaultType: "date-time", allowedTypes: ["date-time", "date"] };
    var DEFAULT_TYPE_DATETIME = { defaultType: "date-time" };
    var DEFAULT_TYPE_URI = { defaultType: "uri" };
    var DEFAULT_TYPE_UTCOFFSET = { defaultType: "utc-offset" };
    var DEFAULT_TYPE_RECUR = { defaultType: "recur" };
    var DEFAULT_TYPE_DATE_ANDOR_TIME = { defaultType: "date-and-or-time", allowedTypes: ["date-time", "date", "text"] };

    function replaceNewlineReplace(string) {
      switch (string) {
        case "\\\\":
          return "\\";
        case "\\;":
          return ";";
        case "\\,":
          return ",";
        case "\\n":
        case "\\N":
          return "\n";
        /* istanbul ignore next */
        default:
          return string;
      }
    }

    function replaceNewline(value, newline, structuredEscape) {
      // avoid regex when possible.
      if (value.indexOf('\\') === -1) {
        return value;
      }
      if (structuredEscape)
        newline = new RegExp(newline.source + '|\\\\' + structuredEscape);
      return value.replace(newline, replaceNewlineReplace);
    }

    var commonProperties = {
      "categories": DEFAULT_TYPE_TEXT_MULTI,
      "url": DEFAULT_TYPE_URI,
      "version": DEFAULT_TYPE_TEXT,
      "uid": DEFAULT_TYPE_TEXT
    };

    var commonValues = {
      "boolean": {
        values: ["TRUE", "FALSE"],

        fromICAL: function(aValue) {
          switch (aValue) {
            case 'TRUE':
              return true;
            case 'FALSE':
              return false;
            default:
              //TODO: parser warning
              return false;
          }
        },

        toICAL: function(aValue) {
          if (aValue) {
            return 'TRUE';
          }
          return 'FALSE';
        }

      },
      float: {
        matches: /^[+-]?\d+\.\d+$/,

        fromICAL: function(aValue) {
          var parsed = parseFloat(aValue);
          if (ICAL.helpers.isStrictlyNaN(parsed)) {
            // TODO: parser warning
            return 0.0;
          }
          return parsed;
        },

        toICAL: function(aValue) {
          return String(aValue);
        }
      },
      integer: {
        fromICAL: function(aValue) {
          var parsed = parseInt(aValue);
          if (ICAL.helpers.isStrictlyNaN(parsed)) {
            return 0;
          }
          return parsed;
        },

        toICAL: function(aValue) {
          return String(aValue);
        }
      },
      "utc-offset": {
        toICAL: function(aValue) {
          if (aValue.length < 7) {
            // no seconds
            // -0500
            return aValue.substr(0, 3) +
                   aValue.substr(4, 2);
          } else {
            // seconds
            // -050000
            return aValue.substr(0, 3) +
                   aValue.substr(4, 2) +
                   aValue.substr(7, 2);
          }
        },

        fromICAL: function(aValue) {
          if (aValue.length < 6) {
            // no seconds
            // -05:00
            return aValue.substr(0, 3) + ':' +
                   aValue.substr(3, 2);
          } else {
            // seconds
            // -05:00:00
            return aValue.substr(0, 3) + ':' +
                   aValue.substr(3, 2) + ':' +
                   aValue.substr(5, 2);
          }
        },

        decorate: function(aValue) {
          return ICAL.UtcOffset.fromString(aValue);
        },

        undecorate: function(aValue) {
          return aValue.toString();
        }
      }
    };

    var icalParams = {
      // Although the syntax is DQUOTE uri DQUOTE, I don't think we should
      // enfoce anything aside from it being a valid content line.
      //
      // At least some params require - if multi values are used - DQUOTEs
      // for each of its values - e.g. delegated-from="uri1","uri2"
      // To indicate this, I introduced the new k/v pair
      // multiValueSeparateDQuote: true
      //
      // "ALTREP": { ... },

      // CN just wants a param-value
      // "CN": { ... }

      "cutype": {
        values: ["INDIVIDUAL", "GROUP", "RESOURCE", "ROOM", "UNKNOWN"],
        allowXName: true,
        allowIanaToken: true
      },

      "delegated-from": {
        valueType: "cal-address",
        multiValue: ",",
        multiValueSeparateDQuote: true
      },
      "delegated-to": {
        valueType: "cal-address",
        multiValue: ",",
        multiValueSeparateDQuote: true
      },
      // "DIR": { ... }, // See ALTREP
      "encoding": {
        values: ["8BIT", "BASE64"]
      },
      // "FMTTYPE": { ... }, // See ALTREP
      "fbtype": {
        values: ["FREE", "BUSY", "BUSY-UNAVAILABLE", "BUSY-TENTATIVE"],
        allowXName: true,
        allowIanaToken: true
      },
      // "LANGUAGE": { ... }, // See ALTREP
      "member": {
        valueType: "cal-address",
        multiValue: ",",
        multiValueSeparateDQuote: true
      },
      "partstat": {
        // TODO These values are actually different per-component
        values: ["NEEDS-ACTION", "ACCEPTED", "DECLINED", "TENTATIVE",
                 "DELEGATED", "COMPLETED", "IN-PROCESS"],
        allowXName: true,
        allowIanaToken: true
      },
      "range": {
        values: ["THISANDFUTURE"]
      },
      "related": {
        values: ["START", "END"]
      },
      "reltype": {
        values: ["PARENT", "CHILD", "SIBLING"],
        allowXName: true,
        allowIanaToken: true
      },
      "role": {
        values: ["REQ-PARTICIPANT", "CHAIR",
                 "OPT-PARTICIPANT", "NON-PARTICIPANT"],
        allowXName: true,
        allowIanaToken: true
      },
      "rsvp": {
        values: ["TRUE", "FALSE"]
      },
      "sent-by": {
        valueType: "cal-address"
      },
      "tzid": {
        matches: /^\//
      },
      "value": {
        // since the value here is a 'type' lowercase is used.
        values: ["binary", "boolean", "cal-address", "date", "date-time",
                 "duration", "float", "integer", "period", "recur", "text",
                 "time", "uri", "utc-offset"],
        allowXName: true,
        allowIanaToken: true
      }
    };

    // When adding a value here, be sure to add it to the parameter types!
    var icalValues = ICAL.helpers.extend(commonValues, {
      text: createTextType(FROM_ICAL_NEWLINE, TO_ICAL_NEWLINE),

      uri: {
        // TODO
        /* ... */
      },

      "binary": {
        decorate: function(aString) {
          return ICAL.Binary.fromString(aString);
        },

        undecorate: function(aBinary) {
          return aBinary.toString();
        }
      },
      "cal-address": {
        // needs to be an uri
      },
      "date": {
        decorate: function(aValue, aProp) {
          if (design.strict) {
            return ICAL.Time.fromDateString(aValue, aProp);
          } else {
            return ICAL.Time.fromString(aValue, aProp);
          }
        },

        /**
         * undecorates a time object.
         */
        undecorate: function(aValue) {
          return aValue.toString();
        },

        fromICAL: function(aValue) {
          // from: 20120901
          // to: 2012-09-01
          if (!design.strict && aValue.length >= 15) {
            // This is probably a date-time, e.g. 20120901T130000Z
            return icalValues["date-time"].fromICAL(aValue);
          } else {
            return aValue.substr(0, 4) + '-' +
                   aValue.substr(4, 2) + '-' +
                   aValue.substr(6, 2);
          }
        },

        toICAL: function(aValue) {
          // from: 2012-09-01
          // to: 20120901
          var len = aValue.length;

          if (len == 10) {
            return aValue.substr(0, 4) +
                   aValue.substr(5, 2) +
                   aValue.substr(8, 2);
          } else if (len >= 19) {
            return icalValues["date-time"].toICAL(aValue);
          } else {
            //TODO: serialize warning?
            return aValue;
          }

        }
      },
      "date-time": {
        fromICAL: function(aValue) {
          // from: 20120901T130000
          // to: 2012-09-01T13:00:00
          if (!design.strict && aValue.length == 8) {
            // This is probably a date, e.g. 20120901
            return icalValues.date.fromICAL(aValue);
          } else {
            var result = aValue.substr(0, 4) + '-' +
                         aValue.substr(4, 2) + '-' +
                         aValue.substr(6, 2) + 'T' +
                         aValue.substr(9, 2) + ':' +
                         aValue.substr(11, 2) + ':' +
                         aValue.substr(13, 2);

            if (aValue[15] && aValue[15] === 'Z') {
              result += 'Z';
            }

            return result;
          }
        },

        toICAL: function(aValue) {
          // from: 2012-09-01T13:00:00
          // to: 20120901T130000
          var len = aValue.length;

          if (len == 10 && !design.strict) {
            return icalValues.date.toICAL(aValue);
          } else if (len >= 19) {
            var result = aValue.substr(0, 4) +
                         aValue.substr(5, 2) +
                         // grab the (DDTHH) segment
                         aValue.substr(8, 5) +
                         // MM
                         aValue.substr(14, 2) +
                         // SS
                         aValue.substr(17, 2);

            if (aValue[19] && aValue[19] === 'Z') {
              result += 'Z';
            }
            return result;
          } else {
            // TODO: error
            return aValue;
          }
        },

        decorate: function(aValue, aProp) {
          if (design.strict) {
            return ICAL.Time.fromDateTimeString(aValue, aProp);
          } else {
            return ICAL.Time.fromString(aValue, aProp);
          }
        },

        undecorate: function(aValue) {
          return aValue.toString();
        }
      },
      duration: {
        decorate: function(aValue) {
          return ICAL.Duration.fromString(aValue);
        },
        undecorate: function(aValue) {
          return aValue.toString();
        }
      },
      period: {

        fromICAL: function(string) {
          var parts = string.split('/');
          parts[0] = icalValues['date-time'].fromICAL(parts[0]);

          if (!ICAL.Duration.isValueString(parts[1])) {
            parts[1] = icalValues['date-time'].fromICAL(parts[1]);
          }

          return parts;
        },

        toICAL: function(parts) {
          if (!design.strict && parts[0].length == 10) {
            parts[0] = icalValues.date.toICAL(parts[0]);
          } else {
            parts[0] = icalValues['date-time'].toICAL(parts[0]);
          }

          if (!ICAL.Duration.isValueString(parts[1])) {
            if (!design.strict && parts[1].length == 10) {
              parts[1] = icalValues.date.toICAL(parts[1]);
            } else {
              parts[1] = icalValues['date-time'].toICAL(parts[1]);
            }
          }

          return parts.join("/");
        },

        decorate: function(aValue, aProp) {
          return ICAL.Period.fromJSON(aValue, aProp, !design.strict);
        },

        undecorate: function(aValue) {
          return aValue.toJSON();
        }
      },
      recur: {
        fromICAL: function(string) {
          return ICAL.Recur._stringToData(string, true);
        },

        toICAL: function(data) {
          var str = "";
          for (var k in data) {
            /* istanbul ignore if */
            if (!Object.prototype.hasOwnProperty.call(data, k)) {
              continue;
            }
            var val = data[k];
            if (k == "until") {
              if (val.length > 10) {
                val = icalValues['date-time'].toICAL(val);
              } else {
                val = icalValues.date.toICAL(val);
              }
            } else if (k == "wkst") {
              if (typeof val === 'number') {
                val = ICAL.Recur.numericDayToIcalDay(val);
              }
            } else if (Array.isArray(val)) {
              val = val.join(",");
            }
            str += k.toUpperCase() + "=" + val + ";";
          }
          return str.substr(0, str.length - 1);
        },

        decorate: function decorate(aValue) {
          return ICAL.Recur.fromData(aValue);
        },

        undecorate: function(aRecur) {
          return aRecur.toJSON();
        }
      },

      time: {
        fromICAL: function(aValue) {
          // from: MMHHSS(Z)?
          // to: HH:MM:SS(Z)?
          if (aValue.length < 6) {
            // TODO: parser exception?
            return aValue;
          }

          // HH::MM::SSZ?
          var result = aValue.substr(0, 2) + ':' +
                       aValue.substr(2, 2) + ':' +
                       aValue.substr(4, 2);

          if (aValue[6] === 'Z') {
            result += 'Z';
          }

          return result;
        },

        toICAL: function(aValue) {
          // from: HH:MM:SS(Z)?
          // to: MMHHSS(Z)?
          if (aValue.length < 8) {
            //TODO: error
            return aValue;
          }

          var result = aValue.substr(0, 2) +
                       aValue.substr(3, 2) +
                       aValue.substr(6, 2);

          if (aValue[8] === 'Z') {
            result += 'Z';
          }

          return result;
        }
      }
    });

    var icalProperties = ICAL.helpers.extend(commonProperties, {

      "action": DEFAULT_TYPE_TEXT,
      "attach": { defaultType: "uri" },
      "attendee": { defaultType: "cal-address" },
      "calscale": DEFAULT_TYPE_TEXT,
      "class": DEFAULT_TYPE_TEXT,
      "comment": DEFAULT_TYPE_TEXT,
      "completed": DEFAULT_TYPE_DATETIME,
      "contact": DEFAULT_TYPE_TEXT,
      "created": DEFAULT_TYPE_DATETIME,
      "description": DEFAULT_TYPE_TEXT,
      "dtend": DEFAULT_TYPE_DATETIME_DATE,
      "dtstamp": DEFAULT_TYPE_DATETIME,
      "dtstart": DEFAULT_TYPE_DATETIME_DATE,
      "due": DEFAULT_TYPE_DATETIME_DATE,
      "duration": { defaultType: "duration" },
      "exdate": {
        defaultType: "date-time",
        allowedTypes: ["date-time", "date"],
        multiValue: ','
      },
      "exrule": DEFAULT_TYPE_RECUR,
      "freebusy": { defaultType: "period", multiValue: "," },
      "geo": { defaultType: "float", structuredValue: ";" },
      "last-modified": DEFAULT_TYPE_DATETIME,
      "location": DEFAULT_TYPE_TEXT,
      "method": DEFAULT_TYPE_TEXT,
      "organizer": { defaultType: "cal-address" },
      "percent-complete": DEFAULT_TYPE_INTEGER,
      "priority": DEFAULT_TYPE_INTEGER,
      "prodid": DEFAULT_TYPE_TEXT,
      "related-to": DEFAULT_TYPE_TEXT,
      "repeat": DEFAULT_TYPE_INTEGER,
      "rdate": {
        defaultType: "date-time",
        allowedTypes: ["date-time", "date", "period"],
        multiValue: ',',
        detectType: function(string) {
          if (string.indexOf('/') !== -1) {
            return 'period';
          }
          return (string.indexOf('T') === -1) ? 'date' : 'date-time';
        }
      },
      "recurrence-id": DEFAULT_TYPE_DATETIME_DATE,
      "resources": DEFAULT_TYPE_TEXT_MULTI,
      "request-status": DEFAULT_TYPE_TEXT_STRUCTURED,
      "rrule": DEFAULT_TYPE_RECUR,
      "sequence": DEFAULT_TYPE_INTEGER,
      "status": DEFAULT_TYPE_TEXT,
      "summary": DEFAULT_TYPE_TEXT,
      "transp": DEFAULT_TYPE_TEXT,
      "trigger": { defaultType: "duration", allowedTypes: ["duration", "date-time"] },
      "tzoffsetfrom": DEFAULT_TYPE_UTCOFFSET,
      "tzoffsetto": DEFAULT_TYPE_UTCOFFSET,
      "tzurl": DEFAULT_TYPE_URI,
      "tzid": DEFAULT_TYPE_TEXT,
      "tzname": DEFAULT_TYPE_TEXT
    });

    // When adding a value here, be sure to add it to the parameter types!
    var vcardValues = ICAL.helpers.extend(commonValues, {
      text: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),
      uri: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),

      date: {
        decorate: function(aValue) {
          return ICAL.VCardTime.fromDateAndOrTimeString(aValue, "date");
        },
        undecorate: function(aValue) {
          return aValue.toString();
        },
        fromICAL: function(aValue) {
          if (aValue.length == 8) {
            return icalValues.date.fromICAL(aValue);
          } else if (aValue[0] == '-' && aValue.length == 6) {
            return aValue.substr(0, 4) + '-' + aValue.substr(4);
          } else {
            return aValue;
          }
        },
        toICAL: function(aValue) {
          if (aValue.length == 10) {
            return icalValues.date.toICAL(aValue);
          } else if (aValue[0] == '-' && aValue.length == 7) {
            return aValue.substr(0, 4) + aValue.substr(5);
          } else {
            return aValue;
          }
        }
      },

      time: {
        decorate: function(aValue) {
          return ICAL.VCardTime.fromDateAndOrTimeString("T" + aValue, "time");
        },
        undecorate: function(aValue) {
          return aValue.toString();
        },
        fromICAL: function(aValue) {
          var splitzone = vcardValues.time._splitZone(aValue, true);
          var zone = splitzone[0], value = splitzone[1];

          //console.log("SPLIT: ",splitzone);

          if (value.length == 6) {
            value = value.substr(0, 2) + ':' +
                    value.substr(2, 2) + ':' +
                    value.substr(4, 2);
          } else if (value.length == 4 && value[0] != '-') {
            value = value.substr(0, 2) + ':' + value.substr(2, 2);
          } else if (value.length == 5) {
            value = value.substr(0, 3) + ':' + value.substr(3, 2);
          }

          if (zone.length == 5 && (zone[0] == '-' || zone[0] == '+')) {
            zone = zone.substr(0, 3) + ':' + zone.substr(3);
          }

          return value + zone;
        },

        toICAL: function(aValue) {
          var splitzone = vcardValues.time._splitZone(aValue);
          var zone = splitzone[0], value = splitzone[1];

          if (value.length == 8) {
            value = value.substr(0, 2) +
                    value.substr(3, 2) +
                    value.substr(6, 2);
          } else if (value.length == 5 && value[0] != '-') {
            value = value.substr(0, 2) + value.substr(3, 2);
          } else if (value.length == 6) {
            value = value.substr(0, 3) + value.substr(4, 2);
          }

          if (zone.length == 6 && (zone[0] == '-' || zone[0] == '+')) {
            zone = zone.substr(0, 3) + zone.substr(4);
          }

          return value + zone;
        },

        _splitZone: function(aValue, isFromIcal) {
          var lastChar = aValue.length - 1;
          var signChar = aValue.length - (isFromIcal ? 5 : 6);
          var sign = aValue[signChar];
          var zone, value;

          if (aValue[lastChar] == 'Z') {
            zone = aValue[lastChar];
            value = aValue.substr(0, lastChar);
          } else if (aValue.length > 6 && (sign == '-' || sign == '+')) {
            zone = aValue.substr(signChar);
            value = aValue.substr(0, signChar);
          } else {
            zone = "";
            value = aValue;
          }

          return [zone, value];
        }
      },

      "date-time": {
        decorate: function(aValue) {
          return ICAL.VCardTime.fromDateAndOrTimeString(aValue, "date-time");
        },

        undecorate: function(aValue) {
          return aValue.toString();
        },

        fromICAL: function(aValue) {
          return vcardValues['date-and-or-time'].fromICAL(aValue);
        },

        toICAL: function(aValue) {
          return vcardValues['date-and-or-time'].toICAL(aValue);
        }
      },

      "date-and-or-time": {
        decorate: function(aValue) {
          return ICAL.VCardTime.fromDateAndOrTimeString(aValue, "date-and-or-time");
        },

        undecorate: function(aValue) {
          return aValue.toString();
        },

        fromICAL: function(aValue) {
          var parts = aValue.split('T');
          return (parts[0] ? vcardValues.date.fromICAL(parts[0]) : '') +
                 (parts[1] ? 'T' + vcardValues.time.fromICAL(parts[1]) : '');
        },

        toICAL: function(aValue) {
          var parts = aValue.split('T');
          return vcardValues.date.toICAL(parts[0]) +
                 (parts[1] ? 'T' + vcardValues.time.toICAL(parts[1]) : '');

        }
      },
      timestamp: icalValues['date-time'],
      "language-tag": {
        matches: /^[a-zA-Z0-9-]+$/ // Could go with a more strict regex here
      }
    });

    var vcardParams = {
      "type": {
        valueType: "text",
        multiValue: ","
      },
      "value": {
        // since the value here is a 'type' lowercase is used.
        values: ["text", "uri", "date", "time", "date-time", "date-and-or-time",
                 "timestamp", "boolean", "integer", "float", "utc-offset",
                 "language-tag"],
        allowXName: true,
        allowIanaToken: true
      }
    };

    var vcardProperties = ICAL.helpers.extend(commonProperties, {
      "adr": { defaultType: "text", structuredValue: ";", multiValue: "," },
      "anniversary": DEFAULT_TYPE_DATE_ANDOR_TIME,
      "bday": DEFAULT_TYPE_DATE_ANDOR_TIME,
      "caladruri": DEFAULT_TYPE_URI,
      "caluri": DEFAULT_TYPE_URI,
      "clientpidmap": DEFAULT_TYPE_TEXT_STRUCTURED,
      "email": DEFAULT_TYPE_TEXT,
      "fburl": DEFAULT_TYPE_URI,
      "fn": DEFAULT_TYPE_TEXT,
      "gender": DEFAULT_TYPE_TEXT_STRUCTURED,
      "geo": DEFAULT_TYPE_URI,
      "impp": DEFAULT_TYPE_URI,
      "key": DEFAULT_TYPE_URI,
      "kind": DEFAULT_TYPE_TEXT,
      "lang": { defaultType: "language-tag" },
      "logo": DEFAULT_TYPE_URI,
      "member": DEFAULT_TYPE_URI,
      "n": { defaultType: "text", structuredValue: ";", multiValue: "," },
      "nickname": DEFAULT_TYPE_TEXT_MULTI,
      "note": DEFAULT_TYPE_TEXT,
      "org": { defaultType: "text", structuredValue: ";" },
      "photo": DEFAULT_TYPE_URI,
      "related": DEFAULT_TYPE_URI,
      "rev": { defaultType: "timestamp" },
      "role": DEFAULT_TYPE_TEXT,
      "sound": DEFAULT_TYPE_URI,
      "source": DEFAULT_TYPE_URI,
      "tel": { defaultType: "uri", allowedTypes: ["uri", "text"] },
      "title": DEFAULT_TYPE_TEXT,
      "tz": { defaultType: "text", allowedTypes: ["text", "utc-offset", "uri"] },
      "xml": DEFAULT_TYPE_TEXT
    });

    var vcard3Values = ICAL.helpers.extend(commonValues, {
      binary: icalValues.binary,
      date: vcardValues.date,
      "date-time": vcardValues["date-time"],
      "phone-number": {
        // TODO
        /* ... */
      },
      uri: icalValues.uri,
      text: icalValues.text,
      time: icalValues.time,
      vcard: icalValues.text,
      "utc-offset": {
        toICAL: function(aValue) {
          return aValue.substr(0, 7);
        },

        fromICAL: function(aValue) {
          return aValue.substr(0, 7);
        },

        decorate: function(aValue) {
          return ICAL.UtcOffset.fromString(aValue);
        },

        undecorate: function(aValue) {
          return aValue.toString();
        }
      }
    });

    var vcard3Params = {
      "type": {
        valueType: "text",
        multiValue: ","
      },
      "value": {
        // since the value here is a 'type' lowercase is used.
        values: ["text", "uri", "date", "date-time", "phone-number", "time",
                 "boolean", "integer", "float", "utc-offset", "vcard", "binary"],
        allowXName: true,
        allowIanaToken: true
      }
    };

    var vcard3Properties = ICAL.helpers.extend(commonProperties, {
      fn: DEFAULT_TYPE_TEXT,
      n: { defaultType: "text", structuredValue: ";", multiValue: "," },
      nickname: DEFAULT_TYPE_TEXT_MULTI,
      photo: { defaultType: "binary", allowedTypes: ["binary", "uri"] },
      bday: {
        defaultType: "date-time",
        allowedTypes: ["date-time", "date"],
        detectType: function(string) {
          return (string.indexOf('T') === -1) ? 'date' : 'date-time';
        }
      },

      adr: { defaultType: "text", structuredValue: ";", multiValue: "," },
      label: DEFAULT_TYPE_TEXT,

      tel: { defaultType: "phone-number" },
      email: DEFAULT_TYPE_TEXT,
      mailer: DEFAULT_TYPE_TEXT,

      tz: { defaultType: "utc-offset", allowedTypes: ["utc-offset", "text"] },
      geo: { defaultType: "float", structuredValue: ";" },

      title: DEFAULT_TYPE_TEXT,
      role: DEFAULT_TYPE_TEXT,
      logo: { defaultType: "binary", allowedTypes: ["binary", "uri"] },
      agent: { defaultType: "vcard", allowedTypes: ["vcard", "text", "uri"] },
      org: DEFAULT_TYPE_TEXT_STRUCTURED,

      note: DEFAULT_TYPE_TEXT_MULTI,
      prodid: DEFAULT_TYPE_TEXT,
      rev: {
        defaultType: "date-time",
        allowedTypes: ["date-time", "date"],
        detectType: function(string) {
          return (string.indexOf('T') === -1) ? 'date' : 'date-time';
        }
      },
      "sort-string": DEFAULT_TYPE_TEXT,
      sound: { defaultType: "binary", allowedTypes: ["binary", "uri"] },

      class: DEFAULT_TYPE_TEXT,
      key: { defaultType: "binary", allowedTypes: ["binary", "text"] }
    });

    /**
     * iCalendar design set
     * @type {ICAL.design.designSet}
     */
    var icalSet = {
      value: icalValues,
      param: icalParams,
      property: icalProperties
    };

    /**
     * vCard 4.0 design set
     * @type {ICAL.design.designSet}
     */
    var vcardSet = {
      value: vcardValues,
      param: vcardParams,
      property: vcardProperties
    };

    /**
     * vCard 3.0 design set
     * @type {ICAL.design.designSet}
     */
    var vcard3Set = {
      value: vcard3Values,
      param: vcard3Params,
      property: vcard3Properties
    };

    /**
     * The design data, used by the parser to determine types for properties and
     * other metadata needed to produce correct jCard/jCal data.
     *
     * @alias ICAL.design
     * @namespace
     */
    var design = {
      /**
       * A designSet describes value, parameter and property data. It is used by
       * ther parser and stringifier in components and properties to determine they
       * should be represented.
       *
       * @typedef {Object} designSet
       * @memberOf ICAL.design
       * @property {Object} value       Definitions for value types, keys are type names
       * @property {Object} param       Definitions for params, keys are param names
       * @property {Object} property    Defintions for properties, keys are property names
       */

      /**
       * Can be set to false to make the parser more lenient.
       */
      strict: true,

      /**
       * The default set for new properties and components if none is specified.
       * @type {ICAL.design.designSet}
       */
      defaultSet: icalSet,

      /**
       * The default type for unknown properties
       * @type {String}
       */
      defaultType: 'unknown',

      /**
       * Holds the design set for known top-level components
       *
       * @type {Object}
       * @property {ICAL.design.designSet} vcard       vCard VCARD
       * @property {ICAL.design.designSet} vevent      iCalendar VEVENT
       * @property {ICAL.design.designSet} vtodo       iCalendar VTODO
       * @property {ICAL.design.designSet} vjournal    iCalendar VJOURNAL
       * @property {ICAL.design.designSet} valarm      iCalendar VALARM
       * @property {ICAL.design.designSet} vtimezone   iCalendar VTIMEZONE
       * @property {ICAL.design.designSet} daylight    iCalendar DAYLIGHT
       * @property {ICAL.design.designSet} standard    iCalendar STANDARD
       *
       * @example
       * var propertyName = 'fn';
       * var componentDesign = ICAL.design.components.vcard;
       * var propertyDetails = componentDesign.property[propertyName];
       * if (propertyDetails.defaultType == 'text') {
       *   // Yep, sure is...
       * }
       */
      components: {
        vcard: vcardSet,
        vcard3: vcard3Set,
        vevent: icalSet,
        vtodo: icalSet,
        vjournal: icalSet,
        valarm: icalSet,
        vtimezone: icalSet,
        daylight: icalSet,
        standard: icalSet
      },


      /**
       * The design set for iCalendar (rfc5545/rfc7265) components.
       * @type {ICAL.design.designSet}
       */
      icalendar: icalSet,

      /**
       * The design set for vCard (rfc6350/rfc7095) components.
       * @type {ICAL.design.designSet}
       */
      vcard: vcardSet,

      /**
       * The design set for vCard (rfc2425/rfc2426/rfc7095) components.
       * @type {ICAL.design.designSet}
       */
      vcard3: vcard3Set,

      /**
       * Gets the design set for the given component name.
       *
       * @param {String} componentName        The name of the component
       * @return {ICAL.design.designSet}      The design set for the component
       */
      getDesignSet: function(componentName) {
        var isInDesign = componentName && componentName in design.components;
        return isInDesign ? design.components[componentName] : design.defaultSet;
      }
    };

    return design;
  }());
  /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at http://mozilla.org/MPL/2.0/.
   * Portions Copyright (C) Philipp Kewisch, 2011-2015 */


  /**
   * Contains various functions to convert jCal and jCard data back into
   * iCalendar and vCard.
   * @namespace
   */
  ICAL.stringify = (function() {

    var LINE_ENDING = '\r\n';
    var DEFAULT_VALUE_TYPE = 'unknown';

    var design = ICAL.design;
    var helpers = ICAL.helpers;

    /**
     * Convert a full jCal/jCard array into a iCalendar/vCard string.
     *
     * @function ICAL.stringify
     * @variation function
     * @param {Array} jCal    The jCal/jCard document
     * @return {String}       The stringified iCalendar/vCard document
     */
    function stringify(jCal) {
      if (typeof jCal[0] == "string") {
        // This is a single component
        jCal = [jCal];
      }

      var i = 0;
      var len = jCal.length;
      var result = '';

      for (; i < len; i++) {
        result += stringify.component(jCal[i]) + LINE_ENDING;
      }

      return result;
    }

    /**
     * Converts an jCal component array into a ICAL string.
     * Recursive will resolve sub-components.
     *
     * Exact component/property order is not saved all
     * properties will come before subcomponents.
     *
     * @function ICAL.stringify.component
     * @param {Array} component
     *        jCal/jCard fragment of a component
     * @param {ICAL.design.designSet} designSet
     *        The design data to use for this component
     * @return {String}       The iCalendar/vCard string
     */
    stringify.component = function(component, designSet) {
      var name = component[0].toUpperCase();
      var result = 'BEGIN:' + name + LINE_ENDING;

      var props = component[1];
      var propIdx = 0;
      var propLen = props.length;

      var designSetName = component[0];
      // rfc6350 requires that in vCard 4.0 the first component is the VERSION
      // component with as value 4.0, note that 3.0 does not have this requirement.
      if (designSetName === 'vcard' && component[1].length > 0 &&
              !(component[1][0][0] === "version" && component[1][0][3] === "4.0")) {
        designSetName = "vcard3";
      }
      designSet = designSet || design.getDesignSet(designSetName);

      for (; propIdx < propLen; propIdx++) {
        result += stringify.property(props[propIdx], designSet) + LINE_ENDING;
      }

      // Ignore subcomponents if none exist, e.g. in vCard.
      var comps = component[2] || [];
      var compIdx = 0;
      var compLen = comps.length;

      for (; compIdx < compLen; compIdx++) {
        result += stringify.component(comps[compIdx], designSet) + LINE_ENDING;
      }

      result += 'END:' + name;
      return result;
    };

    /**
     * Converts a single jCal/jCard property to a iCalendar/vCard string.
     *
     * @function ICAL.stringify.property
     * @param {Array} property
     *        jCal/jCard property array
     * @param {ICAL.design.designSet} designSet
     *        The design data to use for this property
     * @param {Boolean} noFold
     *        If true, the line is not folded
     * @return {String}       The iCalendar/vCard string
     */
    stringify.property = function(property, designSet, noFold) {
      var name = property[0].toUpperCase();
      var jsName = property[0];
      var params = property[1];

      var line = name;

      var paramName;
      for (paramName in params) {
        var value = params[paramName];

        /* istanbul ignore else */
        if (params.hasOwnProperty(paramName)) {
          var multiValue = (paramName in designSet.param) && designSet.param[paramName].multiValue;
          if (multiValue && Array.isArray(value)) {
            if (designSet.param[paramName].multiValueSeparateDQuote) {
              multiValue = '"' + multiValue + '"';
            }
            value = value.map(stringify._rfc6868Unescape);
            value = stringify.multiValue(value, multiValue, "unknown", null, designSet);
          } else {
            value = stringify._rfc6868Unescape(value);
          }


          line += ';' + paramName.toUpperCase();
          line += '=' + stringify.propertyValue(value);
        }
      }

      if (property.length === 3) {
        // If there are no values, we must assume a blank value
        return line + ':';
      }

      var valueType = property[2];

      if (!designSet) {
        designSet = design.defaultSet;
      }

      var propDetails;
      var multiValue = false;
      var structuredValue = false;
      var isDefault = false;

      if (jsName in designSet.property) {
        propDetails = designSet.property[jsName];

        if ('multiValue' in propDetails) {
          multiValue = propDetails.multiValue;
        }

        if (('structuredValue' in propDetails) && Array.isArray(property[3])) {
          structuredValue = propDetails.structuredValue;
        }

        if ('defaultType' in propDetails) {
          if (valueType === propDetails.defaultType) {
            isDefault = true;
          }
        } else {
          if (valueType === DEFAULT_VALUE_TYPE) {
            isDefault = true;
          }
        }
      } else {
        if (valueType === DEFAULT_VALUE_TYPE) {
          isDefault = true;
        }
      }

      // push the VALUE property if type is not the default
      // for the current property.
      if (!isDefault) {
        // value will never contain ;/:/, so we don't escape it here.
        line += ';VALUE=' + valueType.toUpperCase();
      }

      line += ':';

      if (multiValue && structuredValue) {
        line += stringify.multiValue(
          property[3], structuredValue, valueType, multiValue, designSet, structuredValue
        );
      } else if (multiValue) {
        line += stringify.multiValue(
          property.slice(3), multiValue, valueType, null, designSet, false
        );
      } else if (structuredValue) {
        line += stringify.multiValue(
          property[3], structuredValue, valueType, null, designSet, structuredValue
        );
      } else {
        line += stringify.value(property[3], valueType, designSet, false);
      }

      return noFold ? line : ICAL.helpers.foldline(line);
    };

    /**
     * Handles escaping of property values that may contain:
     *
     *    COLON (:), SEMICOLON (;), or COMMA (,)
     *
     * If any of the above are present the result is wrapped
     * in double quotes.
     *
     * @function ICAL.stringify.propertyValue
     * @param {String} value      Raw property value
     * @return {String}           Given or escaped value when needed
     */
    stringify.propertyValue = function(value) {

      if ((helpers.unescapedIndexOf(value, ',') === -1) &&
          (helpers.unescapedIndexOf(value, ':') === -1) &&
          (helpers.unescapedIndexOf(value, ';') === -1)) {

        return value;
      }

      return '"' + value + '"';
    };

    /**
     * Converts an array of ical values into a single
     * string based on a type and a delimiter value (like ",").
     *
     * @function ICAL.stringify.multiValue
     * @param {Array} values      List of values to convert
     * @param {String} delim      Used to join the values (",", ";", ":")
     * @param {String} type       Lowecase ical value type
     *        (like boolean, date-time, etc..)
     * @param {?String} innerMulti If set, each value will again be processed
     *        Used for structured values
     * @param {ICAL.design.designSet} designSet
     *        The design data to use for this property
     *
     * @return {String}           iCalendar/vCard string for value
     */
    stringify.multiValue = function(values, delim, type, innerMulti, designSet, structuredValue) {
      var result = '';
      var len = values.length;
      var i = 0;

      for (; i < len; i++) {
        if (innerMulti && Array.isArray(values[i])) {
          result += stringify.multiValue(values[i], innerMulti, type, null, designSet, structuredValue);
        } else {
          result += stringify.value(values[i], type, designSet, structuredValue);
        }

        if (i !== (len - 1)) {
          result += delim;
        }
      }

      return result;
    };

    /**
     * Processes a single ical value runs the associated "toICAL" method from the
     * design value type if available to convert the value.
     *
     * @function ICAL.stringify.value
     * @param {String|Number} value       A formatted value
     * @param {String} type               Lowercase iCalendar/vCard value type
     *  (like boolean, date-time, etc..)
     * @return {String}                   iCalendar/vCard value for single value
     */
    stringify.value = function(value, type, designSet, structuredValue) {
      if (type in designSet.value && 'toICAL' in designSet.value[type]) {
        return designSet.value[type].toICAL(value, structuredValue);
      }
      return value;
    };

    /**
     * Internal helper for rfc6868. Exposing this on ICAL.stringify so that
     * hackers can disable the rfc6868 parsing if the really need to.
     *
     * @param {String} val        The value to unescape
     * @return {String}           The escaped value
     */
    stringify._rfc6868Unescape = function(val) {
      return val.replace(/[\n^"]/g, function(x) {
        return RFC6868_REPLACE_MAP[x];
      });
    };
    var RFC6868_REPLACE_MAP = { '"': "^'", "\n": "^n", "^": "^^" };

    return stringify;
  }());
  /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at http://mozilla.org/MPL/2.0/.
   * Portions Copyright (C) Philipp Kewisch, 2011-2015 */


  /**
   * Contains various functions to parse iCalendar and vCard data.
   * @namespace
   */
  ICAL.parse = (function() {

    var CHAR = /[^ \t]/;
    var VALUE_DELIMITER = ':';
    var PARAM_DELIMITER = ';';
    var PARAM_NAME_DELIMITER = '=';
    var DEFAULT_VALUE_TYPE = 'unknown';
    var DEFAULT_PARAM_TYPE = 'text';

    var design = ICAL.design;
    var helpers = ICAL.helpers;

    /**
     * An error that occurred during parsing.
     *
     * @param {String} message        The error message
     * @memberof ICAL.parse
     * @extends {Error}
     * @class
     */
    function ParserError(message) {
      this.message = message;
      this.name = 'ParserError';

      try {
        throw new Error();
      } catch (e) {
        if (e.stack) {
          var split = e.stack.split('\n');
          split.shift();
          this.stack = split.join('\n');
        }
      }
    }

    ParserError.prototype = Error.prototype;

    /**
     * Parses iCalendar or vCard data into a raw jCal object. Consult
     * documentation on the {@tutorial layers|layers of parsing} for more
     * details.
     *
     * @function ICAL.parse
     * @variation function
     * @todo Fix the API to be more clear on the return type
     * @param {String} input      The string data to parse
     * @return {Object|Object[]}  A single jCal object, or an array thereof
     */
    function parser(input) {
      var state = {};
      var root = state.component = [];

      state.stack = [root];

      parser._eachLine(input, function(err, line) {
        parser._handleContentLine(line, state);
      });


      // when there are still items on the stack
      // throw a fatal error, a component was not closed
      // correctly in that case.
      if (state.stack.length > 1) {
        throw new ParserError(
          'invalid ical body. component began but did not end'
        );
      }

      state = null;

      return (root.length == 1 ? root[0] : root);
    }

    /**
     * Parse an iCalendar property value into the jCal for a single property
     *
     * @function ICAL.parse.property
     * @param {String} str
     *   The iCalendar property string to parse
     * @param {ICAL.design.designSet=} designSet
     *   The design data to use for this property
     * @return {Object}
     *   The jCal Object containing the property
     */
    parser.property = function(str, designSet) {
      var state = {
        component: [[], []],
        designSet: designSet || design.defaultSet
      };
      parser._handleContentLine(str, state);
      return state.component[1][0];
    };

    /**
     * Convenience method to parse a component. You can use ICAL.parse() directly
     * instead.
     *
     * @function ICAL.parse.component
     * @see ICAL.parse(function)
     * @param {String} str    The iCalendar component string to parse
     * @return {Object}       The jCal Object containing the component
     */
    parser.component = function(str) {
      return parser(str);
    };

    // classes & constants
    parser.ParserError = ParserError;

    /**
     * The state for parsing content lines from an iCalendar/vCard string.
     *
     * @private
     * @memberof ICAL.parse
     * @typedef {Object} parserState
     * @property {ICAL.design.designSet} designSet    The design set to use for parsing
     * @property {ICAL.Component[]} stack             The stack of components being processed
     * @property {ICAL.Component} component           The currently active component
     */


    /**
     * Handles a single line of iCalendar/vCard, updating the state.
     *
     * @private
     * @function ICAL.parse._handleContentLine
     * @param {String} line               The content line to process
     * @param {ICAL.parse.parserState}    The current state of the line parsing
     */
    parser._handleContentLine = function(line, state) {
      // break up the parts of the line
      var valuePos = line.indexOf(VALUE_DELIMITER);
      var paramPos = line.indexOf(PARAM_DELIMITER);

      var lastParamIndex;
      var lastValuePos;

      // name of property or begin/end
      var name;
      var value;
      // params is only overridden if paramPos !== -1.
      // we can't do params = params || {} later on
      // because it sacrifices ops.
      var params = {};

      /**
       * Different property cases
       *
       *
       * 1. RRULE:FREQ=foo
       *    // FREQ= is not a param but the value
       *
       * 2. ATTENDEE;ROLE=REQ-PARTICIPANT;
       *    // ROLE= is a param because : has not happened yet
       */
        // when the parameter delimiter is after the
        // value delimiter then it is not a parameter.

      if ((paramPos !== -1 && valuePos !== -1)) {
        // when the parameter delimiter is after the
        // value delimiter then it is not a parameter.
        if (paramPos > valuePos) {
          paramPos = -1;
        }
      }

      var parsedParams;
      if (paramPos !== -1) {
        name = line.substring(0, paramPos).toLowerCase();
        parsedParams = parser._parseParameters(line.substring(paramPos), 0, state.designSet);
        if (parsedParams[2] == -1) {
          throw new ParserError("Invalid parameters in '" + line + "'");
        }
        params = parsedParams[0];
        lastParamIndex = parsedParams[1].length + parsedParams[2] + paramPos;
        if ((lastValuePos =
          line.substring(lastParamIndex).indexOf(VALUE_DELIMITER)) !== -1) {
          value = line.substring(lastParamIndex + lastValuePos + 1);
        } else {
          throw new ParserError("Missing parameter value in '" + line + "'");
        }
      } else if (valuePos !== -1) {
        // without parmeters (BEGIN:VCAENDAR, CLASS:PUBLIC)
        name = line.substring(0, valuePos).toLowerCase();
        value = line.substring(valuePos + 1);

        if (name === 'begin') {
          var newComponent = [value.toLowerCase(), [], []];
          if (state.stack.length === 1) {
            state.component.push(newComponent);
          } else {
            state.component[2].push(newComponent);
          }
          state.stack.push(state.component);
          state.component = newComponent;
          if (!state.designSet) {
            state.designSet = design.getDesignSet(state.component[0]);
          }
          return;
        } else if (name === 'end') {
          state.component = state.stack.pop();
          return;
        }
        // If it is not begin/end, then this is a property with an empty value,
        // which should be considered valid.
      } else {
        /**
         * Invalid line.
         * The rational to throw an error is we will
         * never be certain that the rest of the file
         * is sane and it is unlikely that we can serialize
         * the result correctly either.
         */
        throw new ParserError(
          'invalid line (no token ";" or ":") "' + line + '"'
        );
      }

      var valueType;
      var multiValue = false;
      var structuredValue = false;
      var propertyDetails;

      if (name in state.designSet.property) {
        propertyDetails = state.designSet.property[name];

        if ('multiValue' in propertyDetails) {
          multiValue = propertyDetails.multiValue;
        }

        if ('structuredValue' in propertyDetails) {
          structuredValue = propertyDetails.structuredValue;
        }

        if (value && 'detectType' in propertyDetails) {
          valueType = propertyDetails.detectType(value);
        }
      }

      // attempt to determine value
      if (!valueType) {
        if (!('value' in params)) {
          if (propertyDetails) {
            valueType = propertyDetails.defaultType;
          } else {
            valueType = DEFAULT_VALUE_TYPE;
          }
        } else {
          // possible to avoid this?
          valueType = params.value.toLowerCase();
        }
      }

      delete params.value;

      /**
       * Note on `var result` juggling:
       *
       * I observed that building the array in pieces has adverse
       * effects on performance, so where possible we inline the creation.
       * It is a little ugly but resulted in ~2000 additional ops/sec.
       */

      var result;
      if (multiValue && structuredValue) {
        value = parser._parseMultiValue(value, structuredValue, valueType, [], multiValue, state.designSet, structuredValue);
        result = [name, params, valueType, value];
      } else if (multiValue) {
        result = [name, params, valueType];
        parser._parseMultiValue(value, multiValue, valueType, result, null, state.designSet, false);
      } else if (structuredValue) {
        value = parser._parseMultiValue(value, structuredValue, valueType, [], null, state.designSet, structuredValue);
        result = [name, params, valueType, value];
      } else {
        value = parser._parseValue(value, valueType, state.designSet, false);
        result = [name, params, valueType, value];
      }
      // rfc6350 requires that in vCard 4.0 the first component is the VERSION
      // component with as value 4.0, note that 3.0 does not have this requirement.
      if (state.component[0] === 'vcard' && state.component[1].length === 0 &&
              !(name === 'version' && value === '4.0')) {
        state.designSet = design.getDesignSet("vcard3");
      }
      state.component[1].push(result);
    };

    /**
     * Parse a value from the raw value into the jCard/jCal value.
     *
     * @private
     * @function ICAL.parse._parseValue
     * @param {String} value          Original value
     * @param {String} type           Type of value
     * @param {Object} designSet      The design data to use for this value
     * @return {Object} varies on type
     */
    parser._parseValue = function(value, type, designSet, structuredValue) {
      if (type in designSet.value && 'fromICAL' in designSet.value[type]) {
        return designSet.value[type].fromICAL(value, structuredValue);
      }
      return value;
    };

    /**
     * Parse parameters from a string to object.
     *
     * @function ICAL.parse._parseParameters
     * @private
     * @param {String} line           A single unfolded line
     * @param {Numeric} start         Position to start looking for properties
     * @param {Object} designSet      The design data to use for this property
     * @return {Object} key/value pairs
     */
    parser._parseParameters = function(line, start, designSet) {
      var lastParam = start;
      var pos = 0;
      var delim = PARAM_NAME_DELIMITER;
      var result = {};
      var name, lcname;
      var value, valuePos = -1;
      var type, multiValue, mvdelim;

      // find the next '=' sign
      // use lastParam and pos to find name
      // check if " is used if so get value from "->"
      // then increment pos to find next ;

      while ((pos !== false) &&
             (pos = helpers.unescapedIndexOf(line, delim, pos + 1)) !== -1) {

        name = line.substr(lastParam + 1, pos - lastParam - 1);
        if (name.length == 0) {
          throw new ParserError("Empty parameter name in '" + line + "'");
        }
        lcname = name.toLowerCase();
        mvdelim = false;
        multiValue = false;

        if (lcname in designSet.param && designSet.param[lcname].valueType) {
          type = designSet.param[lcname].valueType;
        } else {
          type = DEFAULT_PARAM_TYPE;
        }

        if (lcname in designSet.param) {
          multiValue = designSet.param[lcname].multiValue;
          if (designSet.param[lcname].multiValueSeparateDQuote) {
            mvdelim = parser._rfc6868Escape('"' + multiValue + '"');
          }
        }

        var nextChar = line[pos + 1];
        if (nextChar === '"') {
          valuePos = pos + 2;
          pos = helpers.unescapedIndexOf(line, '"', valuePos);
          if (multiValue && pos != -1) {
              var extendedValue = true;
              while (extendedValue) {
                if (line[pos + 1] == multiValue && line[pos + 2] == '"') {
                  pos = helpers.unescapedIndexOf(line, '"', pos + 3);
                } else {
                  extendedValue = false;
                }
              }
            }
          if (pos === -1) {
            throw new ParserError(
              'invalid line (no matching double quote) "' + line + '"'
            );
          }
          value = line.substr(valuePos, pos - valuePos);
          lastParam = helpers.unescapedIndexOf(line, PARAM_DELIMITER, pos);
          if (lastParam === -1) {
            pos = false;
          }
        } else {
          valuePos = pos + 1;

          // move to next ";"
          var nextPos = helpers.unescapedIndexOf(line, PARAM_DELIMITER, valuePos);
          var propValuePos = helpers.unescapedIndexOf(line, VALUE_DELIMITER, valuePos);
          if (propValuePos !== -1 && nextPos > propValuePos) {
            // this is a delimiter in the property value, let's stop here
            nextPos = propValuePos;
            pos = false;
          } else if (nextPos === -1) {
            // no ";"
            if (propValuePos === -1) {
              nextPos = line.length;
            } else {
              nextPos = propValuePos;
            }
            pos = false;
          } else {
            lastParam = nextPos;
            pos = nextPos;
          }

          value = line.substr(valuePos, nextPos - valuePos);
        }

        value = parser._rfc6868Escape(value);
        if (multiValue) {
          var delimiter = mvdelim || multiValue;
          value = parser._parseMultiValue(value, delimiter, type, [], null, designSet);
        } else {
          value = parser._parseValue(value, type, designSet);
        }

        if (multiValue && (lcname in result)) {
          if (Array.isArray(result[lcname])) {
            result[lcname].push(value);
          } else {
            result[lcname] = [
              result[lcname],
              value
            ];
          }
        } else {
          result[lcname] = value;
        }
      }
      return [result, value, valuePos];
    };

    /**
     * Internal helper for rfc6868. Exposing this on ICAL.parse so that
     * hackers can disable the rfc6868 parsing if the really need to.
     *
     * @function ICAL.parse._rfc6868Escape
     * @param {String} val        The value to escape
     * @return {String}           The escaped value
     */
    parser._rfc6868Escape = function(val) {
      return val.replace(/\^['n^]/g, function(x) {
        return RFC6868_REPLACE_MAP[x];
      });
    };
    var RFC6868_REPLACE_MAP = { "^'": '"', "^n": "\n", "^^": "^" };

    /**
     * Parse a multi value string. This function is used either for parsing
     * actual multi-value property's values, or for handling parameter values. It
     * can be used for both multi-value properties and structured value properties.
     *
     * @private
     * @function ICAL.parse._parseMultiValue
     * @param {String} buffer     The buffer containing the full value
     * @param {String} delim      The multi-value delimiter
     * @param {String} type       The value type to be parsed
     * @param {Array.<?>} result        The array to append results to, varies on value type
     * @param {String} innerMulti The inner delimiter to split each value with
     * @param {ICAL.design.designSet} designSet   The design data for this value
     * @return {?|Array.<?>}            Either an array of results, or the first result
     */
    parser._parseMultiValue = function(buffer, delim, type, result, innerMulti, designSet, structuredValue) {
      var pos = 0;
      var lastPos = 0;
      var value;
      if (delim.length === 0) {
        return buffer;
      }

      // split each piece
      while ((pos = helpers.unescapedIndexOf(buffer, delim, lastPos)) !== -1) {
        value = buffer.substr(lastPos, pos - lastPos);
        if (innerMulti) {
          value = parser._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);
        } else {
          value = parser._parseValue(value, type, designSet, structuredValue);
        }
        result.push(value);
        lastPos = pos + delim.length;
      }

      // on the last piece take the rest of string
      value = buffer.substr(lastPos);
      if (innerMulti) {
        value = parser._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);
      } else {
        value = parser._parseValue(value, type, designSet, structuredValue);
      }
      result.push(value);

      return result.length == 1 ? result[0] : result;
    };

    /**
     * Process a complete buffer of iCalendar/vCard data line by line, correctly
     * unfolding content. Each line will be processed with the given callback
     *
     * @private
     * @function ICAL.parse._eachLine
     * @param {String} buffer                         The buffer to process
     * @param {function(?String, String)} callback    The callback for each line
     */
    parser._eachLine = function(buffer, callback) {
      var len = buffer.length;
      var lastPos = buffer.search(CHAR);
      var pos = lastPos;
      var line;
      var firstChar;

      var newlineOffset;

      do {
        pos = buffer.indexOf('\n', lastPos) + 1;

        if (pos > 1 && buffer[pos - 2] === '\r') {
          newlineOffset = 2;
        } else {
          newlineOffset = 1;
        }

        if (pos === 0) {
          pos = len;
          newlineOffset = 0;
        }

        firstChar = buffer[lastPos];

        if (firstChar === ' ' || firstChar === '\t') {
          // add to line
          line += buffer.substr(
            lastPos + 1,
            pos - lastPos - (newlineOffset + 1)
          );
        } else {
          if (line)
            callback(null, line);
          // push line
          line = buffer.substr(
            lastPos,
            pos - lastPos - newlineOffset
          );
        }

        lastPos = pos;
      } while (pos !== len);

      // extra ending line
      line = line.trim();

      if (line.length)
        callback(null, line);
    };

    return parser;

  }());
  /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at http://mozilla.org/MPL/2.0/.
   * Portions Copyright (C) Philipp Kewisch, 2011-2015 */


  /**
   * This symbol is further described later on
   * @ignore
   */
  ICAL.Component = (function() {

    var PROPERTY_INDEX = 1;
    var COMPONENT_INDEX = 2;
    var NAME_INDEX = 0;

    /**
     * @classdesc
     * Wraps a jCal component, adding convenience methods to add, remove and
     * update subcomponents and properties.
     *
     * @class
     * @alias ICAL.Component
     * @param {Array|String} jCal         Raw jCal component data OR name of new
     *                                      component
     * @param {ICAL.Component} parent     Parent component to associate
     */
    function Component(jCal, parent) {
      if (typeof(jCal) === 'string') {
        // jCal spec (name, properties, components)
        jCal = [jCal, [], []];
      }

      // mostly for legacy reasons.
      this.jCal = jCal;

      this.parent = parent || null;
    }

    Component.prototype = {
      /**
       * Hydrated properties are inserted into the _properties array at the same
       * position as in the jCal array, so it is possible that the array contains
       * undefined values for unhydrdated properties. To avoid iterating the
       * array when checking if all properties have been hydrated, we save the
       * count here.
       *
       * @type {Number}
       * @private
       */
      _hydratedPropertyCount: 0,

      /**
       * The same count as for _hydratedPropertyCount, but for subcomponents
       *
       * @type {Number}
       * @private
       */
      _hydratedComponentCount: 0,

      /**
       * The name of this component
       * @readonly
       */
      get name() {
        return this.jCal[NAME_INDEX];
      },

      /**
       * The design set for this component, e.g. icalendar vs vcard
       *
       * @type {ICAL.design.designSet}
       * @private
       */
      get _designSet() {
        var parentDesign = this.parent && this.parent._designSet;
        return parentDesign || ICAL.design.getDesignSet(this.name);
      },

      _hydrateComponent: function(index) {
        if (!this._components) {
          this._components = [];
          this._hydratedComponentCount = 0;
        }

        if (this._components[index]) {
          return this._components[index];
        }

        var comp = new Component(
          this.jCal[COMPONENT_INDEX][index],
          this
        );

        this._hydratedComponentCount++;
        return (this._components[index] = comp);
      },

      _hydrateProperty: function(index) {
        if (!this._properties) {
          this._properties = [];
          this._hydratedPropertyCount = 0;
        }

        if (this._properties[index]) {
          return this._properties[index];
        }

        var prop = new ICAL.Property(
          this.jCal[PROPERTY_INDEX][index],
          this
        );

        this._hydratedPropertyCount++;
        return (this._properties[index] = prop);
      },

      /**
       * Finds first sub component, optionally filtered by name.
       *
       * @param {String=} name        Optional name to filter by
       * @return {?ICAL.Component}     The found subcomponent
       */
      getFirstSubcomponent: function(name) {
        if (name) {
          var i = 0;
          var comps = this.jCal[COMPONENT_INDEX];
          var len = comps.length;

          for (; i < len; i++) {
            if (comps[i][NAME_INDEX] === name) {
              var result = this._hydrateComponent(i);
              return result;
            }
          }
        } else {
          if (this.jCal[COMPONENT_INDEX].length) {
            return this._hydrateComponent(0);
          }
        }

        // ensure we return a value (strict mode)
        return null;
      },

      /**
       * Finds all sub components, optionally filtering by name.
       *
       * @param {String=} name            Optional name to filter by
       * @return {ICAL.Component[]}       The found sub components
       */
      getAllSubcomponents: function(name) {
        var jCalLen = this.jCal[COMPONENT_INDEX].length;
        var i = 0;

        if (name) {
          var comps = this.jCal[COMPONENT_INDEX];
          var result = [];

          for (; i < jCalLen; i++) {
            if (name === comps[i][NAME_INDEX]) {
              result.push(
                this._hydrateComponent(i)
              );
            }
          }
          return result;
        } else {
          if (!this._components ||
              (this._hydratedComponentCount !== jCalLen)) {
            for (; i < jCalLen; i++) {
              this._hydrateComponent(i);
            }
          }

          return this._components || [];
        }
      },

      /**
       * Returns true when a named property exists.
       *
       * @param {String} name     The property name
       * @return {Boolean}        True, when property is found
       */
      hasProperty: function(name) {
        var props = this.jCal[PROPERTY_INDEX];
        var len = props.length;

        var i = 0;
        for (; i < len; i++) {
          // 0 is property name
          if (props[i][NAME_INDEX] === name) {
            return true;
          }
        }

        return false;
      },

      /**
       * Finds the first property, optionally with the given name.
       *
       * @param {String=} name        Lowercase property name
       * @return {?ICAL.Property}     The found property
       */
      getFirstProperty: function(name) {
        if (name) {
          var i = 0;
          var props = this.jCal[PROPERTY_INDEX];
          var len = props.length;

          for (; i < len; i++) {
            if (props[i][NAME_INDEX] === name) {
              var result = this._hydrateProperty(i);
              return result;
            }
          }
        } else {
          if (this.jCal[PROPERTY_INDEX].length) {
            return this._hydrateProperty(0);
          }
        }

        return null;
      },

      /**
       * Returns first property's value, if available.
       *
       * @param {String=} name    Lowercase property name
       * @return {?String}        The found property value.
       */
      getFirstPropertyValue: function(name) {
        var prop = this.getFirstProperty(name);
        if (prop) {
          return prop.getFirstValue();
        }

        return null;
      },

      /**
       * Get all properties in the component, optionally filtered by name.
       *
       * @param {String=} name        Lowercase property name
       * @return {ICAL.Property[]}    List of properties
       */
      getAllProperties: function(name) {
        var jCalLen = this.jCal[PROPERTY_INDEX].length;
        var i = 0;

        if (name) {
          var props = this.jCal[PROPERTY_INDEX];
          var result = [];

          for (; i < jCalLen; i++) {
            if (name === props[i][NAME_INDEX]) {
              result.push(
                this._hydrateProperty(i)
              );
            }
          }
          return result;
        } else {
          if (!this._properties ||
              (this._hydratedPropertyCount !== jCalLen)) {
            for (; i < jCalLen; i++) {
              this._hydrateProperty(i);
            }
          }

          return this._properties || [];
        }
      },

      _removeObjectByIndex: function(jCalIndex, cache, index) {
        cache = cache || [];
        // remove cached version
        if (cache[index]) {
          var obj = cache[index];
          if ("parent" in obj) {
              obj.parent = null;
          }
        }

        cache.splice(index, 1);

        // remove it from the jCal
        this.jCal[jCalIndex].splice(index, 1);
      },

      _removeObject: function(jCalIndex, cache, nameOrObject) {
        var i = 0;
        var objects = this.jCal[jCalIndex];
        var len = objects.length;
        var cached = this[cache];

        if (typeof(nameOrObject) === 'string') {
          for (; i < len; i++) {
            if (objects[i][NAME_INDEX] === nameOrObject) {
              this._removeObjectByIndex(jCalIndex, cached, i);
              return true;
            }
          }
        } else if (cached) {
          for (; i < len; i++) {
            if (cached[i] && cached[i] === nameOrObject) {
              this._removeObjectByIndex(jCalIndex, cached, i);
              return true;
            }
          }
        }

        return false;
      },

      _removeAllObjects: function(jCalIndex, cache, name) {
        var cached = this[cache];

        // Unfortunately we have to run through all children to reset their
        // parent property.
        var objects = this.jCal[jCalIndex];
        var i = objects.length - 1;

        // descending search required because splice
        // is used and will effect the indices.
        for (; i >= 0; i--) {
          if (!name || objects[i][NAME_INDEX] === name) {
            this._removeObjectByIndex(jCalIndex, cached, i);
          }
        }
      },

      /**
       * Adds a single sub component.
       *
       * @param {ICAL.Component} component        The component to add
       * @return {ICAL.Component}                 The passed in component
       */
      addSubcomponent: function(component) {
        if (!this._components) {
          this._components = [];
          this._hydratedComponentCount = 0;
        }

        if (component.parent) {
          component.parent.removeSubcomponent(component);
        }

        var idx = this.jCal[COMPONENT_INDEX].push(component.jCal);
        this._components[idx - 1] = component;
        this._hydratedComponentCount++;
        component.parent = this;
        return component;
      },

      /**
       * Removes a single component by name or the instance of a specific
       * component.
       *
       * @param {ICAL.Component|String} nameOrComp    Name of component, or component
       * @return {Boolean}                            True when comp is removed
       */
      removeSubcomponent: function(nameOrComp) {
        var removed = this._removeObject(COMPONENT_INDEX, '_components', nameOrComp);
        if (removed) {
          this._hydratedComponentCount--;
        }
        return removed;
      },

      /**
       * Removes all components or (if given) all components by a particular
       * name.
       *
       * @param {String=} name            Lowercase component name
       */
      removeAllSubcomponents: function(name) {
        var removed = this._removeAllObjects(COMPONENT_INDEX, '_components', name);
        this._hydratedComponentCount = 0;
        return removed;
      },

      /**
       * Adds an {@link ICAL.Property} to the component.
       *
       * @param {ICAL.Property} property      The property to add
       * @return {ICAL.Property}              The passed in property
       */
      addProperty: function(property) {
        if (!(property instanceof ICAL.Property)) {
          throw new TypeError('must instance of ICAL.Property');
        }

        if (!this._properties) {
          this._properties = [];
          this._hydratedPropertyCount = 0;
        }

        if (property.parent) {
          property.parent.removeProperty(property);
        }

        var idx = this.jCal[PROPERTY_INDEX].push(property.jCal);
        this._properties[idx - 1] = property;
        this._hydratedPropertyCount++;
        property.parent = this;
        return property;
      },

      /**
       * Helper method to add a property with a value to the component.
       *
       * @param {String}               name         Property name to add
       * @param {String|Number|Object} value        Property value
       * @return {ICAL.Property}                    The created property
       */
      addPropertyWithValue: function(name, value) {
        var prop = new ICAL.Property(name);
        prop.setValue(value);

        this.addProperty(prop);

        return prop;
      },

      /**
       * Helper method that will update or create a property of the given name
       * and sets its value. If multiple properties with the given name exist,
       * only the first is updated.
       *
       * @param {String}               name         Property name to update
       * @param {String|Number|Object} value        Property value
       * @return {ICAL.Property}                    The created property
       */
      updatePropertyWithValue: function(name, value) {
        var prop = this.getFirstProperty(name);

        if (prop) {
          prop.setValue(value);
        } else {
          prop = this.addPropertyWithValue(name, value);
        }

        return prop;
      },

      /**
       * Removes a single property by name or the instance of the specific
       * property.
       *
       * @param {String|ICAL.Property} nameOrProp     Property name or instance to remove
       * @return {Boolean}                            True, when deleted
       */
      removeProperty: function(nameOrProp) {
        var removed = this._removeObject(PROPERTY_INDEX, '_properties', nameOrProp);
        if (removed) {
          this._hydratedPropertyCount--;
        }
        return removed;
      },

      /**
       * Removes all properties associated with this component, optionally
       * filtered by name.
       *
       * @param {String=} name        Lowercase property name
       * @return {Boolean}            True, when deleted
       */
      removeAllProperties: function(name) {
        var removed = this._removeAllObjects(PROPERTY_INDEX, '_properties', name);
        this._hydratedPropertyCount = 0;
        return removed;
      },

      /**
       * Returns the Object representation of this component. The returned object
       * is a live jCal object and should be cloned if modified.
       * @return {Object}
       */
      toJSON: function() {
        return this.jCal;
      },

      /**
       * The string representation of this component.
       * @return {String}
       */
      toString: function() {
        return ICAL.stringify.component(
          this.jCal, this._designSet
        );
      }
    };

    /**
     * Create an {@link ICAL.Component} by parsing the passed iCalendar string.
     *
     * @param {String} str        The iCalendar string to parse
     */
    Component.fromString = function(str) {
      return new Component(ICAL.parse.component(str));
    };

    return Component;
  }());
  /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at http://mozilla.org/MPL/2.0/.
   * Portions Copyright (C) Philipp Kewisch, 2011-2015 */


  /**
   * This symbol is further described later on
   * @ignore
   */
  ICAL.Property = (function() {

    var NAME_INDEX = 0;
    var PROP_INDEX = 1;
    var TYPE_INDEX = 2;
    var VALUE_INDEX = 3;

    var design = ICAL.design;

    /**
     * @classdesc
     * Provides a layer on top of the raw jCal object for manipulating a single
     * property, with its parameters and value.
     *
     * @description
     * It is important to note that mutations done in the wrapper
     * directly mutate the jCal object used to initialize.
     *
     * Can also be used to create new properties by passing
     * the name of the property (as a String).
     *
     * @class
     * @alias ICAL.Property
     * @param {Array|String} jCal         Raw jCal representation OR
     *  the new name of the property
     *
     * @param {ICAL.Component=} parent    Parent component
     */
    function Property(jCal, parent) {
      this._parent = parent || null;

      if (typeof(jCal) === 'string') {
        // We are creating the property by name and need to detect the type
        this.jCal = [jCal, {}, design.defaultType];
        this.jCal[TYPE_INDEX] = this.getDefaultType();
      } else {
        this.jCal = jCal;
      }
      this._updateType();
    }

    Property.prototype = {

      /**
       * The value type for this property
       * @readonly
       * @type {String}
       */
      get type() {
        return this.jCal[TYPE_INDEX];
      },

      /**
       * The name of this property, in lowercase.
       * @readonly
       * @type {String}
       */
      get name() {
        return this.jCal[NAME_INDEX];
      },

      /**
       * The parent component for this property.
       * @type {ICAL.Component}
       */
      get parent() {
        return this._parent;
      },

      set parent(p) {
        // Before setting the parent, check if the design set has changed. If it
        // has, we later need to update the type if it was unknown before.
        var designSetChanged = !this._parent || (p && p._designSet != this._parent._designSet);

        this._parent = p;

        if (this.type == design.defaultType && designSetChanged) {
          this.jCal[TYPE_INDEX] = this.getDefaultType();
          this._updateType();
        }

        return p;
      },

      /**
       * The design set for this property, e.g. icalendar vs vcard
       *
       * @type {ICAL.design.designSet}
       * @private
       */
      get _designSet() {
        return this.parent ? this.parent._designSet : design.defaultSet;
      },

      /**
       * Updates the type metadata from the current jCal type and design set.
       *
       * @private
       */
      _updateType: function() {
        var designSet = this._designSet;

        if (this.type in designSet.value) {
          designSet.value[this.type];

          if ('decorate' in designSet.value[this.type]) {
            this.isDecorated = true;
          } else {
            this.isDecorated = false;
          }

          if (this.name in designSet.property) {
            this.isMultiValue = ('multiValue' in designSet.property[this.name]);
            this.isStructuredValue = ('structuredValue' in designSet.property[this.name]);
          }
        }
      },

      /**
       * Hydrate a single value. The act of hydrating means turning the raw jCal
       * value into a potentially wrapped object, for example {@link ICAL.Time}.
       *
       * @private
       * @param {Number} index        The index of the value to hydrate
       * @return {Object}             The decorated value.
       */
      _hydrateValue: function(index) {
        if (this._values && this._values[index]) {
          return this._values[index];
        }

        // for the case where there is no value.
        if (this.jCal.length <= (VALUE_INDEX + index)) {
          return null;
        }

        if (this.isDecorated) {
          if (!this._values) {
            this._values = [];
          }
          return (this._values[index] = this._decorate(
            this.jCal[VALUE_INDEX + index]
          ));
        } else {
          return this.jCal[VALUE_INDEX + index];
        }
      },

      /**
       * Decorate a single value, returning its wrapped object. This is used by
       * the hydrate function to actually wrap the value.
       *
       * @private
       * @param {?} value         The value to decorate
       * @return {Object}         The decorated value
       */
      _decorate: function(value) {
        return this._designSet.value[this.type].decorate(value, this);
      },

      /**
       * Undecorate a single value, returning its raw jCal data.
       *
       * @private
       * @param {Object} value         The value to undecorate
       * @return {?}                   The undecorated value
       */
      _undecorate: function(value) {
        return this._designSet.value[this.type].undecorate(value, this);
      },

      /**
       * Sets the value at the given index while also hydrating it. The passed
       * value can either be a decorated or undecorated value.
       *
       * @private
       * @param {?} value             The value to set
       * @param {Number} index        The index to set it at
       */
      _setDecoratedValue: function(value, index) {
        if (!this._values) {
          this._values = [];
        }

        if (typeof(value) === 'object' && 'icaltype' in value) {
          // decorated value
          this.jCal[VALUE_INDEX + index] = this._undecorate(value);
          this._values[index] = value;
        } else {
          // undecorated value
          this.jCal[VALUE_INDEX + index] = value;
          this._values[index] = this._decorate(value);
        }
      },

      /**
       * Gets a parameter on the property.
       *
       * @param {String}        name   Parameter name (lowercase)
       * @return {Array|String}        Parameter value
       */
      getParameter: function(name) {
        if (name in this.jCal[PROP_INDEX]) {
          return this.jCal[PROP_INDEX][name];
        } else {
          return undefined;
        }
      },

      /**
       * Gets first parameter on the property.
       *
       * @param {String}        name   Parameter name (lowercase)
       * @return {String}        Parameter value
       */
      getFirstParameter: function(name) {
        var parameters = this.getParameter(name);

        if (Array.isArray(parameters)) {
          return parameters[0];
        }

        return parameters;
      },

      /**
       * Sets a parameter on the property.
       *
       * @param {String}       name     The parameter name
       * @param {Array|String} value    The parameter value
       */
      setParameter: function(name, value) {
        var lcname = name.toLowerCase();
        if (typeof value === "string" &&
            lcname in this._designSet.param &&
            'multiValue' in this._designSet.param[lcname]) {
            value = [value];
        }
        this.jCal[PROP_INDEX][name] = value;
      },

      /**
       * Removes a parameter
       *
       * @param {String} name     The parameter name
       */
      removeParameter: function(name) {
        delete this.jCal[PROP_INDEX][name];
      },

      /**
       * Get the default type based on this property's name.
       *
       * @return {String}     The default type for this property
       */
      getDefaultType: function() {
        var name = this.jCal[NAME_INDEX];
        var designSet = this._designSet;

        if (name in designSet.property) {
          var details = designSet.property[name];
          if ('defaultType' in details) {
            return details.defaultType;
          }
        }
        return design.defaultType;
      },

      /**
       * Sets type of property and clears out any existing values of the current
       * type.
       *
       * @param {String} type     New iCAL type (see design.*.values)
       */
      resetType: function(type) {
        this.removeAllValues();
        this.jCal[TYPE_INDEX] = type;
        this._updateType();
      },

      /**
       * Finds the first property value.
       *
       * @return {String}         First property value
       */
      getFirstValue: function() {
        return this._hydrateValue(0);
      },

      /**
       * Gets all values on the property.
       *
       * NOTE: this creates an array during each call.
       *
       * @return {Array}          List of values
       */
      getValues: function() {
        var len = this.jCal.length - VALUE_INDEX;

        if (len < 1) {
          // it is possible for a property to have no value.
          return [];
        }

        var i = 0;
        var result = [];

        for (; i < len; i++) {
          result[i] = this._hydrateValue(i);
        }

        return result;
      },

      /**
       * Removes all values from this property
       */
      removeAllValues: function() {
        if (this._values) {
          this._values.length = 0;
        }
        this.jCal.length = 3;
      },

      /**
       * Sets the values of the property.  Will overwrite the existing values.
       * This can only be used for multi-value properties.
       *
       * @param {Array} values    An array of values
       */
      setValues: function(values) {
        if (!this.isMultiValue) {
          throw new Error(
            this.name + ': does not not support mulitValue.\n' +
            'override isMultiValue'
          );
        }

        var len = values.length;
        var i = 0;
        this.removeAllValues();

        if (len > 0 &&
            typeof(values[0]) === 'object' &&
            'icaltype' in values[0]) {
          this.resetType(values[0].icaltype);
        }

        if (this.isDecorated) {
          for (; i < len; i++) {
            this._setDecoratedValue(values[i], i);
          }
        } else {
          for (; i < len; i++) {
            this.jCal[VALUE_INDEX + i] = values[i];
          }
        }
      },

      /**
       * Sets the current value of the property. If this is a multi-value
       * property, all other values will be removed.
       *
       * @param {String|Object} value     New property value.
       */
      setValue: function(value) {
        this.removeAllValues();
        if (typeof(value) === 'object' && 'icaltype' in value) {
          this.resetType(value.icaltype);
        }

        if (this.isDecorated) {
          this._setDecoratedValue(value, 0);
        } else {
          this.jCal[VALUE_INDEX] = value;
        }
      },

      /**
       * Returns the Object representation of this component. The returned object
       * is a live jCal object and should be cloned if modified.
       * @return {Object}
       */
      toJSON: function() {
        return this.jCal;
      },

      /**
       * The string representation of this component.
       * @return {String}
       */
      toICALString: function() {
        return ICAL.stringify.property(
          this.jCal, this._designSet, true
        );
      }
    };

    /**
     * Create an {@link ICAL.Property} by parsing the passed iCalendar string.
     *
     * @param {String} str                        The iCalendar string to parse
     * @param {ICAL.design.designSet=} designSet  The design data to use for this property
     * @return {ICAL.Property}                    The created iCalendar property
     */
    Property.fromString = function(str, designSet) {
      return new Property(ICAL.parse.property(str, designSet));
    };

    return Property;
  }());
  /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at http://mozilla.org/MPL/2.0/.
   * Portions Copyright (C) Philipp Kewisch, 2011-2015 */


  /**
   * This symbol is further described later on
   * @ignore
   */
  ICAL.UtcOffset = (function() {

    /**
     * @classdesc
     * This class represents the "duration" value type, with various calculation
     * and manipulation methods.
     *
     * @class
     * @alias ICAL.UtcOffset
     * @param {Object} aData          An object with members of the utc offset
     * @param {Number=} aData.hours   The hours for the utc offset
     * @param {Number=} aData.minutes The minutes in the utc offset
     * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1
     */
    function UtcOffset(aData) {
      this.fromData(aData);
    }

    UtcOffset.prototype = {

      /**
       * The hours in the utc-offset
       * @type {Number}
       */
      hours: 0,

      /**
       * The minutes in the utc-offset
       * @type {Number}
       */
      minutes: 0,

      /**
       * The sign of the utc offset, 1 for positive offset, -1 for negative
       * offsets.
       * @type {Number}
       */
      factor: 1,

      /**
       * The type name, to be used in the jCal object.
       * @constant
       * @type {String}
       * @default "utc-offset"
       */
      icaltype: "utc-offset",

      /**
       * Returns a clone of the utc offset object.
       *
       * @return {ICAL.UtcOffset}     The cloned object
       */
      clone: function() {
        return ICAL.UtcOffset.fromSeconds(this.toSeconds());
      },

      /**
       * Sets up the current instance using members from the passed data object.
       *
       * @param {Object} aData          An object with members of the utc offset
       * @param {Number=} aData.hours   The hours for the utc offset
       * @param {Number=} aData.minutes The minutes in the utc offset
       * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1
       */
      fromData: function(aData) {
        if (aData) {
          for (var key in aData) {
            /* istanbul ignore else */
            if (aData.hasOwnProperty(key)) {
              this[key] = aData[key];
            }
          }
        }
        this._normalize();
      },

      /**
       * Sets up the current instance from the given seconds value. The seconds
       * value is truncated to the minute. Offsets are wrapped when the world
       * ends, the hour after UTC+14:00 is UTC-12:00.
       *
       * @param {Number} aSeconds         The seconds to convert into an offset
       */
      fromSeconds: function(aSeconds) {
        var secs = Math.abs(aSeconds);

        this.factor = aSeconds < 0 ? -1 : 1;
        this.hours = ICAL.helpers.trunc(secs / 3600);

        secs -= (this.hours * 3600);
        this.minutes = ICAL.helpers.trunc(secs / 60);
        return this;
      },

      /**
       * Convert the current offset to a value in seconds
       *
       * @return {Number}                 The offset in seconds
       */
      toSeconds: function() {
        return this.factor * (60 * this.minutes + 3600 * this.hours);
      },

      /**
       * Compare this utc offset with another one.
       *
       * @param {ICAL.UtcOffset} other        The other offset to compare with
       * @return {Number}                     -1, 0 or 1 for less/equal/greater
       */
      compare: function icaltime_compare(other) {
        var a = this.toSeconds();
        var b = other.toSeconds();
        return (a > b) - (b > a);
      },

      _normalize: function() {
        // Range: 97200 seconds (with 1 hour inbetween)
        var secs = this.toSeconds();
        var factor = this.factor;
        while (secs < -43200) { // = UTC-12:00
          secs += 97200;
        }
        while (secs > 50400) { // = UTC+14:00
          secs -= 97200;
        }

        this.fromSeconds(secs);

        // Avoid changing the factor when on zero seconds
        if (secs == 0) {
          this.factor = factor;
        }
      },

      /**
       * The iCalendar string representation of this utc-offset.
       * @return {String}
       */
      toICALString: function() {
        return ICAL.design.icalendar.value['utc-offset'].toICAL(this.toString());
      },

      /**
       * The string representation of this utc-offset.
       * @return {String}
       */
      toString: function toString() {
        return (this.factor == 1 ? "+" : "-") +
                ICAL.helpers.pad2(this.hours) + ':' +
                ICAL.helpers.pad2(this.minutes);
      }
    };

    /**
     * Creates a new {@link ICAL.UtcOffset} instance from the passed string.
     *
     * @param {String} aString    The string to parse
     * @return {ICAL.Duration}    The created utc-offset instance
     */
    UtcOffset.fromString = function(aString) {
      // -05:00
      var options = {};
      //TODO: support seconds per rfc5545 ?
      options.factor = (aString[0] === '+') ? 1 : -1;
      options.hours = ICAL.helpers.strictParseInt(aString.substr(1, 2));
      options.minutes = ICAL.helpers.strictParseInt(aString.substr(4, 2));

      return new ICAL.UtcOffset(options);
    };

    /**
     * Creates a new {@link ICAL.UtcOffset} instance from the passed seconds
     * value.
     *
     * @param {Number} aSeconds       The number of seconds to convert
     */
    UtcOffset.fromSeconds = function(aSeconds) {
      var instance = new UtcOffset();
      instance.fromSeconds(aSeconds);
      return instance;
    };

    return UtcOffset;
  }());
  /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at http://mozilla.org/MPL/2.0/.
   * Portions Copyright (C) Philipp Kewisch, 2011-2015 */


  /**
   * This symbol is further described later on
   * @ignore
   */
  ICAL.Binary = (function() {

    /**
     * @classdesc
     * Represents the BINARY value type, which contains extra methods for
     * encoding and decoding.
     *
     * @class
     * @alias ICAL.Binary
     * @param {String} aValue     The binary data for this value
     */
    function Binary(aValue) {
      this.value = aValue;
    }

    Binary.prototype = {
      /**
       * The type name, to be used in the jCal object.
       * @default "binary"
       * @constant
       */
      icaltype: "binary",

      /**
       * Base64 decode the current value
       *
       * @return {String}         The base64-decoded value
       */
      decodeValue: function decodeValue() {
        return this._b64_decode(this.value);
      },

      /**
       * Encodes the passed parameter with base64 and sets the internal
       * value to the result.
       *
       * @param {String} aValue      The raw binary value to encode
       */
      setEncodedValue: function setEncodedValue(aValue) {
        this.value = this._b64_encode(aValue);
      },

      _b64_encode: function base64_encode(data) {
        // http://kevin.vanzonneveld.net
        // +   original by: Tyler Akins (http://rumkin.com)
        // +   improved by: Bayron Guevara
        // +   improved by: Thunder.m
        // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        // +   bugfixed by: Pellentesque Malesuada
        // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        // +   improved by: Rafał Kukawski (http://kukawski.pl)
        // *     example 1: base64_encode('Kevin van Zonneveld');
        // *     returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='
        // mozilla has this native
        // - but breaks in 2.0.0.12!
        //if (typeof this.window['atob'] == 'function') {
        //    return atob(data);
        //}
        var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ" +
                  "abcdefghijklmnopqrstuvwxyz0123456789+/=";
        var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
          ac = 0,
          enc = "",
          tmp_arr = [];

        if (!data) {
          return data;
        }

        do { // pack three octets into four hexets
          o1 = data.charCodeAt(i++);
          o2 = data.charCodeAt(i++);
          o3 = data.charCodeAt(i++);

          bits = o1 << 16 | o2 << 8 | o3;

          h1 = bits >> 18 & 0x3f;
          h2 = bits >> 12 & 0x3f;
          h3 = bits >> 6 & 0x3f;
          h4 = bits & 0x3f;

          // use hexets to index into b64, and append result to encoded string
          tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
        } while (i < data.length);

        enc = tmp_arr.join('');

        var r = data.length % 3;

        return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);

      },

      _b64_decode: function base64_decode(data) {
        // http://kevin.vanzonneveld.net
        // +   original by: Tyler Akins (http://rumkin.com)
        // +   improved by: Thunder.m
        // +      input by: Aman Gupta
        // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        // +   bugfixed by: Onno Marsman
        // +   bugfixed by: Pellentesque Malesuada
        // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        // +      input by: Brett Zamir (http://brett-zamir.me)
        // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        // *     example 1: base64_decode('S2V2aW4gdmFuIFpvbm5ldmVsZA==');
        // *     returns 1: 'Kevin van Zonneveld'
        // mozilla has this native
        // - but breaks in 2.0.0.12!
        //if (typeof this.window['btoa'] == 'function') {
        //    return btoa(data);
        //}
        var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ" +
                  "abcdefghijklmnopqrstuvwxyz0123456789+/=";
        var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
          ac = 0,
          dec = "",
          tmp_arr = [];

        if (!data) {
          return data;
        }

        data += '';

        do { // unpack four hexets into three octets using index points in b64
          h1 = b64.indexOf(data.charAt(i++));
          h2 = b64.indexOf(data.charAt(i++));
          h3 = b64.indexOf(data.charAt(i++));
          h4 = b64.indexOf(data.charAt(i++));

          bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;

          o1 = bits >> 16 & 0xff;
          o2 = bits >> 8 & 0xff;
          o3 = bits & 0xff;

          if (h3 == 64) {
            tmp_arr[ac++] = String.fromCharCode(o1);
          } else if (h4 == 64) {
            tmp_arr[ac++] = String.fromCharCode(o1, o2);
          } else {
            tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);
          }
        } while (i < data.length);

        dec = tmp_arr.join('');

        return dec;
      },

      /**
       * The string representation of this value
       * @return {String}
       */
      toString: function() {
        return this.value;
      }
    };

    /**
     * Creates a binary value from the given string.
     *
     * @param {String} aString        The binary value string
     * @return {ICAL.Binary}          The binary value instance
     */
    Binary.fromString = function(aString) {
      return new Binary(aString);
    };

    return Binary;
  }());
  /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at http://mozilla.org/MPL/2.0/.
   * Portions Copyright (C) Philipp Kewisch, 2011-2015 */



  (function() {
    /**
     * @classdesc
     * This class represents the "period" value type, with various calculation
     * and manipulation methods.
     *
     * @description
     * The passed data object cannot contain both and end date and a duration.
     *
     * @class
     * @param {Object} aData                  An object with members of the period
     * @param {ICAL.Time=} aData.start        The start of the period
     * @param {ICAL.Time=} aData.end          The end of the period
     * @param {ICAL.Duration=} aData.duration The duration of the period
     */
    ICAL.Period = function icalperiod(aData) {
      this.wrappedJSObject = this;

      if (aData && 'start' in aData) {
        if (aData.start && !(aData.start instanceof ICAL.Time)) {
          throw new TypeError('.start must be an instance of ICAL.Time');
        }
        this.start = aData.start;
      }

      if (aData && aData.end && aData.duration) {
        throw new Error('cannot accept both end and duration');
      }

      if (aData && 'end' in aData) {
        if (aData.end && !(aData.end instanceof ICAL.Time)) {
          throw new TypeError('.end must be an instance of ICAL.Time');
        }
        this.end = aData.end;
      }

      if (aData && 'duration' in aData) {
        if (aData.duration && !(aData.duration instanceof ICAL.Duration)) {
          throw new TypeError('.duration must be an instance of ICAL.Duration');
        }
        this.duration = aData.duration;
      }
    };

    ICAL.Period.prototype = {

      /**
       * The start of the period
       * @type {ICAL.Time}
       */
      start: null,

      /**
       * The end of the period
       * @type {ICAL.Time}
       */
      end: null,

      /**
       * The duration of the period
       * @type {ICAL.Duration}
       */
      duration: null,

      /**
       * The class identifier.
       * @constant
       * @type {String}
       * @default "icalperiod"
       */
      icalclass: "icalperiod",

      /**
       * The type name, to be used in the jCal object.
       * @constant
       * @type {String}
       * @default "period"
       */
      icaltype: "period",

      /**
       * Returns a clone of the duration object.
       *
       * @return {ICAL.Period}      The cloned object
       */
      clone: function() {
        return ICAL.Period.fromData({
          start: this.start ? this.start.clone() : null,
          end: this.end ? this.end.clone() : null,
          duration: this.duration ? this.duration.clone() : null
        });
      },

      /**
       * Calculates the duration of the period, either directly or by subtracting
       * start from end date.
       *
       * @return {ICAL.Duration}      The calculated duration
       */
      getDuration: function duration() {
        if (this.duration) {
          return this.duration;
        } else {
          return this.end.subtractDate(this.start);
        }
      },

      /**
       * Calculates the end date of the period, either directly or by adding
       * duration to start date.
       *
       * @return {ICAL.Time}          The calculated end date
       */
      getEnd: function() {
        if (this.end) {
          return this.end;
        } else {
          var end = this.start.clone();
          end.addDuration(this.duration);
          return end;
        }
      },

      /**
       * The string representation of this period.
       * @return {String}
       */
      toString: function toString() {
        return this.start + "/" + (this.end || this.duration);
      },

      /**
       * The jCal representation of this period type.
       * @return {Object}
       */
      toJSON: function() {
        return [this.start.toString(), (this.end || this.duration).toString()];
      },

      /**
       * The iCalendar string representation of this period.
       * @return {String}
       */
      toICALString: function() {
        return this.start.toICALString() + "/" +
               (this.end || this.duration).toICALString();
      }
    };

    /**
     * Creates a new {@link ICAL.Period} instance from the passed string.
     *
     * @param {String} str            The string to parse
     * @param {ICAL.Property} prop    The property this period will be on
     * @return {ICAL.Period}          The created period instance
     */
    ICAL.Period.fromString = function fromString(str, prop) {
      var parts = str.split('/');

      if (parts.length !== 2) {
        throw new Error(
          'Invalid string value: "' + str + '" must contain a "/" char.'
        );
      }

      var options = {
        start: ICAL.Time.fromDateTimeString(parts[0], prop)
      };

      var end = parts[1];

      if (ICAL.Duration.isValueString(end)) {
        options.duration = ICAL.Duration.fromString(end);
      } else {
        options.end = ICAL.Time.fromDateTimeString(end, prop);
      }

      return new ICAL.Period(options);
    };

    /**
     * Creates a new {@link ICAL.Period} instance from the given data object.
     * The passed data object cannot contain both and end date and a duration.
     *
     * @param {Object} aData                  An object with members of the period
     * @param {ICAL.Time=} aData.start        The start of the period
     * @param {ICAL.Time=} aData.end          The end of the period
     * @param {ICAL.Duration=} aData.duration The duration of the period
     * @return {ICAL.Period}                  The period instance
     */
    ICAL.Period.fromData = function fromData(aData) {
      return new ICAL.Period(aData);
    };

    /**
     * Returns a new period instance from the given jCal data array. The first
     * member is always the start date string, the second member is either a
     * duration or end date string.
     *
     * @param {Array<String,String>} aData    The jCal data array
     * @param {ICAL.Property} aProp           The property this jCal data is on
     * @param {Boolean} aLenient              If true, data value can be both date and date-time
     * @return {ICAL.Period}                  The period instance
     */
    ICAL.Period.fromJSON = function(aData, aProp, aLenient) {
      function fromDateOrDateTimeString(aValue, aProp) {
        if (aLenient) {
          return ICAL.Time.fromString(aValue, aProp);
        } else {
          return ICAL.Time.fromDateTimeString(aValue, aProp);
        }
      }

      if (ICAL.Duration.isValueString(aData[1])) {
        return ICAL.Period.fromData({
          start: fromDateOrDateTimeString(aData[0], aProp),
          duration: ICAL.Duration.fromString(aData[1])
        });
      } else {
        return ICAL.Period.fromData({
          start: fromDateOrDateTimeString(aData[0], aProp),
          end: fromDateOrDateTimeString(aData[1], aProp)
        });
      }
    };
  })();
  /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at http://mozilla.org/MPL/2.0/.
   * Portions Copyright (C) Philipp Kewisch, 2011-2015 */



  (function() {
    var DURATION_LETTERS = /([PDWHMTS]{1,1})/;

    /**
     * @classdesc
     * This class represents the "duration" value type, with various calculation
     * and manipulation methods.
     *
     * @class
     * @alias ICAL.Duration
     * @param {Object} data               An object with members of the duration
     * @param {Number} data.weeks         Duration in weeks
     * @param {Number} data.days          Duration in days
     * @param {Number} data.hours         Duration in hours
     * @param {Number} data.minutes       Duration in minutes
     * @param {Number} data.seconds       Duration in seconds
     * @param {Boolean} data.isNegative   If true, the duration is negative
     */
    ICAL.Duration = function icalduration(data) {
      this.wrappedJSObject = this;
      this.fromData(data);
    };

    ICAL.Duration.prototype = {
      /**
       * The weeks in this duration
       * @type {Number}
       * @default 0
       */
      weeks: 0,

      /**
       * The days in this duration
       * @type {Number}
       * @default 0
       */
      days: 0,

      /**
       * The days in this duration
       * @type {Number}
       * @default 0
       */
      hours: 0,

      /**
       * The minutes in this duration
       * @type {Number}
       * @default 0
       */
      minutes: 0,

      /**
       * The seconds in this duration
       * @type {Number}
       * @default 0
       */
      seconds: 0,

      /**
       * The seconds in this duration
       * @type {Boolean}
       * @default false
       */
      isNegative: false,

      /**
       * The class identifier.
       * @constant
       * @type {String}
       * @default "icalduration"
       */
      icalclass: "icalduration",

      /**
       * The type name, to be used in the jCal object.
       * @constant
       * @type {String}
       * @default "duration"
       */
      icaltype: "duration",

      /**
       * Returns a clone of the duration object.
       *
       * @return {ICAL.Duration}      The cloned object
       */
      clone: function clone() {
        return ICAL.Duration.fromData(this);
      },

      /**
       * The duration value expressed as a number of seconds.
       *
       * @return {Number}             The duration value in seconds
       */
      toSeconds: function toSeconds() {
        var seconds = this.seconds + 60 * this.minutes + 3600 * this.hours +
                      86400 * this.days + 7 * 86400 * this.weeks;
        return (this.isNegative ? -seconds : seconds);
      },

      /**
       * Reads the passed seconds value into this duration object. Afterwards,
       * members like {@link ICAL.Duration#days days} and {@link ICAL.Duration#weeks weeks} will be set up
       * accordingly.
       *
       * @param {Number} aSeconds     The duration value in seconds
       * @return {ICAL.Duration}      Returns this instance
       */
      fromSeconds: function fromSeconds(aSeconds) {
        var secs = Math.abs(aSeconds);

        this.isNegative = (aSeconds < 0);
        this.days = ICAL.helpers.trunc(secs / 86400);

        // If we have a flat number of weeks, use them.
        if (this.days % 7 == 0) {
          this.weeks = this.days / 7;
          this.days = 0;
        } else {
          this.weeks = 0;
        }

        secs -= (this.days + 7 * this.weeks) * 86400;

        this.hours = ICAL.helpers.trunc(secs / 3600);
        secs -= this.hours * 3600;

        this.minutes = ICAL.helpers.trunc(secs / 60);
        secs -= this.minutes * 60;

        this.seconds = secs;
        return this;
      },

      /**
       * Sets up the current instance using members from the passed data object.
       *
       * @param {Object} aData               An object with members of the duration
       * @param {Number} aData.weeks         Duration in weeks
       * @param {Number} aData.days          Duration in days
       * @param {Number} aData.hours         Duration in hours
       * @param {Number} aData.minutes       Duration in minutes
       * @param {Number} aData.seconds       Duration in seconds
       * @param {Boolean} aData.isNegative   If true, the duration is negative
       */
      fromData: function fromData(aData) {
        var propsToCopy = ["weeks", "days", "hours",
                           "minutes", "seconds", "isNegative"];
        for (var key in propsToCopy) {
          /* istanbul ignore if */
          if (!propsToCopy.hasOwnProperty(key)) {
            continue;
          }
          var prop = propsToCopy[key];
          if (aData && prop in aData) {
            this[prop] = aData[prop];
          } else {
            this[prop] = 0;
          }
        }
      },

      /**
       * Resets the duration instance to the default values, i.e. PT0S
       */
      reset: function reset() {
        this.isNegative = false;
        this.weeks = 0;
        this.days = 0;
        this.hours = 0;
        this.minutes = 0;
        this.seconds = 0;
      },

      /**
       * Compares the duration instance with another one.
       *
       * @param {ICAL.Duration} aOther        The instance to compare with
       * @return {Number}                     -1, 0 or 1 for less/equal/greater
       */
      compare: function compare(aOther) {
        var thisSeconds = this.toSeconds();
        var otherSeconds = aOther.toSeconds();
        return (thisSeconds > otherSeconds) - (thisSeconds < otherSeconds);
      },

      /**
       * Normalizes the duration instance. For example, a duration with a value
       * of 61 seconds will be normalized to 1 minute and 1 second.
       */
      normalize: function normalize() {
        this.fromSeconds(this.toSeconds());
      },

      /**
       * The string representation of this duration.
       * @return {String}
       */
      toString: function toString() {
        if (this.toSeconds() == 0) {
          return "PT0S";
        } else {
          var str = "";
          if (this.isNegative) str += "-";
          str += "P";
          if (this.weeks) str += this.weeks + "W";
          if (this.days) str += this.days + "D";

          if (this.hours || this.minutes || this.seconds) {
            str += "T";
            if (this.hours) str += this.hours + "H";
            if (this.minutes) str += this.minutes + "M";
            if (this.seconds) str += this.seconds + "S";
          }
          return str;
        }
      },

      /**
       * The iCalendar string representation of this duration.
       * @return {String}
       */
      toICALString: function() {
        return this.toString();
      }
    };

    /**
     * Returns a new ICAL.Duration instance from the passed seconds value.
     *
     * @param {Number} aSeconds       The seconds to create the instance from
     * @return {ICAL.Duration}        The newly created duration instance
     */
    ICAL.Duration.fromSeconds = function icalduration_from_seconds(aSeconds) {
      return (new ICAL.Duration()).fromSeconds(aSeconds);
    };

    /**
     * Internal helper function to handle a chunk of a duration.
     *
     * @param {String} letter type of duration chunk
     * @param {String} number numeric value or -/+
     * @param {Object} dict target to assign values to
     */
    function parseDurationChunk(letter, number, object) {
      var type;
      switch (letter) {
        case 'P':
          if (number && number === '-') {
            object.isNegative = true;
          } else {
            object.isNegative = false;
          }
          // period
          break;
        case 'D':
          type = 'days';
          break;
        case 'W':
          type = 'weeks';
          break;
        case 'H':
          type = 'hours';
          break;
        case 'M':
          type = 'minutes';
          break;
        case 'S':
          type = 'seconds';
          break;
        default:
          // Not a valid chunk
          return 0;
      }

      if (type) {
        if (!number && number !== 0) {
          throw new Error(
            'invalid duration value: Missing number before "' + letter + '"'
          );
        }
        var num = parseInt(number, 10);
        if (ICAL.helpers.isStrictlyNaN(num)) {
          throw new Error(
            'invalid duration value: Invalid number "' + number + '" before "' + letter + '"'
          );
        }
        object[type] = num;
      }

      return 1;
    }

    /**
     * Checks if the given string is an iCalendar duration value.
     *
     * @param {String} value      The raw ical value
     * @return {Boolean}          True, if the given value is of the
     *                              duration ical type
     */
    ICAL.Duration.isValueString = function(string) {
      return (string[0] === 'P' || string[1] === 'P');
    };

    /**
     * Creates a new {@link ICAL.Duration} instance from the passed string.
     *
     * @param {String} aStr       The string to parse
     * @return {ICAL.Duration}    The created duration instance
     */
    ICAL.Duration.fromString = function icalduration_from_string(aStr) {
      var pos = 0;
      var dict = Object.create(null);
      var chunks = 0;

      while ((pos = aStr.search(DURATION_LETTERS)) !== -1) {
        var type = aStr[pos];
        var numeric = aStr.substr(0, pos);
        aStr = aStr.substr(pos + 1);

        chunks += parseDurationChunk(type, numeric, dict);
      }

      if (chunks < 2) {
        // There must be at least a chunk with "P" and some unit chunk
        throw new Error(
          'invalid duration value: Not enough duration components in "' + aStr + '"'
        );
      }

      return new ICAL.Duration(dict);
    };

    /**
     * Creates a new ICAL.Duration instance from the given data object.
     *
     * @param {Object} aData               An object with members of the duration
     * @param {Number} aData.weeks         Duration in weeks
     * @param {Number} aData.days          Duration in days
     * @param {Number} aData.hours         Duration in hours
     * @param {Number} aData.minutes       Duration in minutes
     * @param {Number} aData.seconds       Duration in seconds
     * @param {Boolean} aData.isNegative   If true, the duration is negative
     * @return {ICAL.Duration}             The createad duration instance
     */
    ICAL.Duration.fromData = function icalduration_from_data(aData) {
      return new ICAL.Duration(aData);
    };
  })();
  /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at http://mozilla.org/MPL/2.0/.
   * Portions Copyright (C) Philipp Kewisch, 2011-2012 */



  (function() {
    var OPTIONS = ["tzid", "location", "tznames",
                   "latitude", "longitude"];

    /**
     * @classdesc
     * Timezone representation, created by passing in a tzid and component.
     *
     * @example
     * var vcalendar;
     * var timezoneComp = vcalendar.getFirstSubcomponent('vtimezone');
     * var tzid = timezoneComp.getFirstPropertyValue('tzid');
     *
     * var timezone = new ICAL.Timezone({
     *   component: timezoneComp,
     *   tzid
     * });
     *
     * @class
     * @param {ICAL.Component|Object} data options for class
     * @param {String|ICAL.Component} data.component
     *        If data is a simple object, then this member can be set to either a
     *        string containing the component data, or an already parsed
     *        ICAL.Component
     * @param {String} data.tzid      The timezone identifier
     * @param {String} data.location  The timezone locationw
     * @param {String} data.tznames   An alternative string representation of the
     *                                  timezone
     * @param {Number} data.latitude  The latitude of the timezone
     * @param {Number} data.longitude The longitude of the timezone
     */
    ICAL.Timezone = function icaltimezone(data) {
      this.wrappedJSObject = this;
      this.fromData(data);
    };

    ICAL.Timezone.prototype = {

      /**
       * Timezone identifier
       * @type {String}
       */
      tzid: "",

      /**
       * Timezone location
       * @type {String}
       */
      location: "",

      /**
       * Alternative timezone name, for the string representation
       * @type {String}
       */
      tznames: "",

      /**
       * The primary latitude for the timezone.
       * @type {Number}
       */
      latitude: 0.0,

      /**
       * The primary longitude for the timezone.
       * @type {Number}
       */
      longitude: 0.0,

      /**
       * The vtimezone component for this timezone.
       * @type {ICAL.Component}
       */
      component: null,

      /**
       * The year this timezone has been expanded to. All timezone transition
       * dates until this year are known and can be used for calculation
       *
       * @private
       * @type {Number}
       */
      expandedUntilYear: 0,

      /**
       * The class identifier.
       * @constant
       * @type {String}
       * @default "icaltimezone"
       */
      icalclass: "icaltimezone",

      /**
       * Sets up the current instance using members from the passed data object.
       *
       * @param {ICAL.Component|Object} aData options for class
       * @param {String|ICAL.Component} aData.component
       *        If aData is a simple object, then this member can be set to either a
       *        string containing the component data, or an already parsed
       *        ICAL.Component
       * @param {String} aData.tzid      The timezone identifier
       * @param {String} aData.location  The timezone locationw
       * @param {String} aData.tznames   An alternative string representation of the
       *                                  timezone
       * @param {Number} aData.latitude  The latitude of the timezone
       * @param {Number} aData.longitude The longitude of the timezone
       */
      fromData: function fromData(aData) {
        this.expandedUntilYear = 0;
        this.changes = [];

        if (aData instanceof ICAL.Component) {
          // Either a component is passed directly
          this.component = aData;
        } else {
          // Otherwise the component may be in the data object
          if (aData && "component" in aData) {
            if (typeof aData.component == "string") {
              // If a string was passed, parse it as a component
              var jCal = ICAL.parse(aData.component);
              this.component = new ICAL.Component(jCal);
            } else if (aData.component instanceof ICAL.Component) {
              // If it was a component already, then just set it
              this.component = aData.component;
            } else {
              // Otherwise just null out the component
              this.component = null;
            }
          }

          // Copy remaining passed properties
          for (var key in OPTIONS) {
            /* istanbul ignore else */
            if (OPTIONS.hasOwnProperty(key)) {
              var prop = OPTIONS[key];
              if (aData && prop in aData) {
                this[prop] = aData[prop];
              }
            }
          }
        }

        // If we have a component but no TZID, attempt to get it from the
        // component's properties.
        if (this.component instanceof ICAL.Component && !this.tzid) {
          this.tzid = this.component.getFirstPropertyValue('tzid');
        }

        return this;
      },

      /**
       * Finds the utcOffset the given time would occur in this timezone.
       *
       * @param {ICAL.Time} tt        The time to check for
       * @return {Number} utc offset in seconds
       */
      utcOffset: function utcOffset(tt) {
        if (this == ICAL.Timezone.utcTimezone || this == ICAL.Timezone.localTimezone) {
          return 0;
        }

        this._ensureCoverage(tt.year);

        if (!this.changes.length) {
          return 0;
        }

        var tt_change = {
          year: tt.year,
          month: tt.month,
          day: tt.day,
          hour: tt.hour,
          minute: tt.minute,
          second: tt.second
        };

        var change_num = this._findNearbyChange(tt_change);
        var change_num_to_use = -1;
        var step = 1;

        // TODO: replace with bin search?
        for (;;) {
          var change = ICAL.helpers.clone(this.changes[change_num], true);
          if (change.utcOffset < change.prevUtcOffset) {
            ICAL.Timezone.adjust_change(change, 0, 0, 0, change.utcOffset);
          } else {
            ICAL.Timezone.adjust_change(change, 0, 0, 0,
                                            change.prevUtcOffset);
          }

          var cmp = ICAL.Timezone._compare_change_fn(tt_change, change);

          if (cmp >= 0) {
            change_num_to_use = change_num;
          } else {
            step = -1;
          }

          if (step == -1 && change_num_to_use != -1) {
            break;
          }

          change_num += step;

          if (change_num < 0) {
            return 0;
          }

          if (change_num >= this.changes.length) {
            break;
          }
        }

        var zone_change = this.changes[change_num_to_use];
        var utcOffset_change = zone_change.utcOffset - zone_change.prevUtcOffset;

        if (utcOffset_change < 0 && change_num_to_use > 0) {
          var tmp_change = ICAL.helpers.clone(zone_change, true);
          ICAL.Timezone.adjust_change(tmp_change, 0, 0, 0,
                                          tmp_change.prevUtcOffset);

          if (ICAL.Timezone._compare_change_fn(tt_change, tmp_change) < 0) {
            var prev_zone_change = this.changes[change_num_to_use - 1];

            var want_daylight = false; // TODO

            if (zone_change.is_daylight != want_daylight &&
                prev_zone_change.is_daylight == want_daylight) {
              zone_change = prev_zone_change;
            }
          }
        }

        // TODO return is_daylight?
        return zone_change.utcOffset;
      },

      _findNearbyChange: function icaltimezone_find_nearby_change(change) {
        // find the closest match
        var idx = ICAL.helpers.binsearchInsert(
          this.changes,
          change,
          ICAL.Timezone._compare_change_fn
        );

        if (idx >= this.changes.length) {
          return this.changes.length - 1;
        }

        return idx;
      },

      _ensureCoverage: function(aYear) {
        if (ICAL.Timezone._minimumExpansionYear == -1) {
          var today = ICAL.Time.now();
          ICAL.Timezone._minimumExpansionYear = today.year;
        }

        var changesEndYear = aYear;
        if (changesEndYear < ICAL.Timezone._minimumExpansionYear) {
          changesEndYear = ICAL.Timezone._minimumExpansionYear;
        }

        changesEndYear += ICAL.Timezone.EXTRA_COVERAGE;

        if (changesEndYear > ICAL.Timezone.MAX_YEAR) {
          changesEndYear = ICAL.Timezone.MAX_YEAR;
        }

        if (!this.changes.length || this.expandedUntilYear < aYear) {
          var subcomps = this.component.getAllSubcomponents();
          var compLen = subcomps.length;
          var compIdx = 0;

          for (; compIdx < compLen; compIdx++) {
            this._expandComponent(
              subcomps[compIdx], changesEndYear, this.changes
            );
          }

          this.changes.sort(ICAL.Timezone._compare_change_fn);
          this.expandedUntilYear = changesEndYear;
        }
      },

      _expandComponent: function(aComponent, aYear, changes) {
        if (!aComponent.hasProperty("dtstart") ||
            !aComponent.hasProperty("tzoffsetto") ||
            !aComponent.hasProperty("tzoffsetfrom")) {
          return null;
        }

        var dtstart = aComponent.getFirstProperty("dtstart").getFirstValue();
        var change;

        function convert_tzoffset(offset) {
          return offset.factor * (offset.hours * 3600 + offset.minutes * 60);
        }

        function init_changes() {
          var changebase = {};
          changebase.is_daylight = (aComponent.name == "daylight");
          changebase.utcOffset = convert_tzoffset(
            aComponent.getFirstProperty("tzoffsetto").getFirstValue()
          );

          changebase.prevUtcOffset = convert_tzoffset(
            aComponent.getFirstProperty("tzoffsetfrom").getFirstValue()
          );

          return changebase;
        }

        if (!aComponent.hasProperty("rrule") && !aComponent.hasProperty("rdate")) {
          change = init_changes();
          change.year = dtstart.year;
          change.month = dtstart.month;
          change.day = dtstart.day;
          change.hour = dtstart.hour;
          change.minute = dtstart.minute;
          change.second = dtstart.second;

          ICAL.Timezone.adjust_change(change, 0, 0, 0,
                                          -change.prevUtcOffset);
          changes.push(change);
        } else {
          var props = aComponent.getAllProperties("rdate");
          for (var rdatekey in props) {
            /* istanbul ignore if */
            if (!props.hasOwnProperty(rdatekey)) {
              continue;
            }
            var rdate = props[rdatekey];
            var time = rdate.getFirstValue();
            change = init_changes();

            change.year = time.year;
            change.month = time.month;
            change.day = time.day;

            if (time.isDate) {
              change.hour = dtstart.hour;
              change.minute = dtstart.minute;
              change.second = dtstart.second;

              if (dtstart.zone != ICAL.Timezone.utcTimezone) {
                ICAL.Timezone.adjust_change(change, 0, 0, 0,
                                                -change.prevUtcOffset);
              }
            } else {
              change.hour = time.hour;
              change.minute = time.minute;
              change.second = time.second;

              if (time.zone != ICAL.Timezone.utcTimezone) {
                ICAL.Timezone.adjust_change(change, 0, 0, 0,
                                                -change.prevUtcOffset);
              }
            }

            changes.push(change);
          }

          var rrule = aComponent.getFirstProperty("rrule");

          if (rrule) {
            rrule = rrule.getFirstValue();
            change = init_changes();

            if (rrule.until && rrule.until.zone == ICAL.Timezone.utcTimezone) {
              rrule.until.adjust(0, 0, 0, change.prevUtcOffset);
              rrule.until.zone = ICAL.Timezone.localTimezone;
            }

            var iterator = rrule.iterator(dtstart);

            var occ;
            while ((occ = iterator.next())) {
              change = init_changes();
              if (occ.year > aYear || !occ) {
                break;
              }

              change.year = occ.year;
              change.month = occ.month;
              change.day = occ.day;
              change.hour = occ.hour;
              change.minute = occ.minute;
              change.second = occ.second;
              change.isDate = occ.isDate;

              ICAL.Timezone.adjust_change(change, 0, 0, 0,
                                              -change.prevUtcOffset);
              changes.push(change);
            }
          }
        }

        return changes;
      },

      /**
       * The string representation of this timezone.
       * @return {String}
       */
      toString: function toString() {
        return (this.tznames ? this.tznames : this.tzid);
      }
    };

    ICAL.Timezone._compare_change_fn = function icaltimezone_compare_change_fn(a, b) {
      if (a.year < b.year) return -1;
      else if (a.year > b.year) return 1;

      if (a.month < b.month) return -1;
      else if (a.month > b.month) return 1;

      if (a.day < b.day) return -1;
      else if (a.day > b.day) return 1;

      if (a.hour < b.hour) return -1;
      else if (a.hour > b.hour) return 1;

      if (a.minute < b.minute) return -1;
      else if (a.minute > b.minute) return 1;

      if (a.second < b.second) return -1;
      else if (a.second > b.second) return 1;

      return 0;
    };

    /**
     * Convert the date/time from one zone to the next.
     *
     * @param {ICAL.Time} tt                  The time to convert
     * @param {ICAL.Timezone} from_zone       The source zone to convert from
     * @param {ICAL.Timezone} to_zone         The target zone to convert to
     * @return {ICAL.Time}                    The converted date/time object
     */
    ICAL.Timezone.convert_time = function icaltimezone_convert_time(tt, from_zone, to_zone) {
      if (tt.isDate ||
          from_zone.tzid == to_zone.tzid ||
          from_zone == ICAL.Timezone.localTimezone ||
          to_zone == ICAL.Timezone.localTimezone) {
        tt.zone = to_zone;
        return tt;
      }

      var utcOffset = from_zone.utcOffset(tt);
      tt.adjust(0, 0, 0, - utcOffset);

      utcOffset = to_zone.utcOffset(tt);
      tt.adjust(0, 0, 0, utcOffset);

      return null;
    };

    /**
     * Creates a new ICAL.Timezone instance from the passed data object.
     *
     * @param {ICAL.Component|Object} aData options for class
     * @param {String|ICAL.Component} aData.component
     *        If aData is a simple object, then this member can be set to either a
     *        string containing the component data, or an already parsed
     *        ICAL.Component
     * @param {String} aData.tzid      The timezone identifier
     * @param {String} aData.location  The timezone locationw
     * @param {String} aData.tznames   An alternative string representation of the
     *                                  timezone
     * @param {Number} aData.latitude  The latitude of the timezone
     * @param {Number} aData.longitude The longitude of the timezone
     */
    ICAL.Timezone.fromData = function icaltimezone_fromData(aData) {
      var tt = new ICAL.Timezone();
      return tt.fromData(aData);
    };

    /**
     * The instance describing the UTC timezone
     * @type {ICAL.Timezone}
     * @constant
     * @instance
     */
    ICAL.Timezone.utcTimezone = ICAL.Timezone.fromData({
      tzid: "UTC"
    });

    /**
     * The instance describing the local timezone
     * @type {ICAL.Timezone}
     * @constant
     * @instance
     */
    ICAL.Timezone.localTimezone = ICAL.Timezone.fromData({
      tzid: "floating"
    });

    /**
     * Adjust a timezone change object.
     * @private
     * @param {Object} change     The timezone change object
     * @param {Number} days       The extra amount of days
     * @param {Number} hours      The extra amount of hours
     * @param {Number} minutes    The extra amount of minutes
     * @param {Number} seconds    The extra amount of seconds
     */
    ICAL.Timezone.adjust_change = function icaltimezone_adjust_change(change, days, hours, minutes, seconds) {
      return ICAL.Time.prototype.adjust.call(
        change,
        days,
        hours,
        minutes,
        seconds,
        change
      );
    };

    ICAL.Timezone._minimumExpansionYear = -1;
    ICAL.Timezone.MAX_YEAR = 2035; // TODO this is because of time_t, which we don't need. Still usefull?
    ICAL.Timezone.EXTRA_COVERAGE = 5;
  })();
  /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at http://mozilla.org/MPL/2.0/.
   * Portions Copyright (C) Philipp Kewisch, 2011-2015 */


  /**
   * This symbol is further described later on
   * @ignore
   */
  ICAL.TimezoneService = (function() {
    var zones;

    /**
     * @classdesc
     * Singleton class to contain timezones.  Right now it is all manual registry in
     * the future we may use this class to download timezone information or handle
     * loading pre-expanded timezones.
     *
     * @namespace
     * @alias ICAL.TimezoneService
     */
    var TimezoneService = {
      get count() {
        return Object.keys(zones).length;
      },

      reset: function() {
        zones = Object.create(null);
        var utc = ICAL.Timezone.utcTimezone;

        zones.Z = utc;
        zones.UTC = utc;
        zones.GMT = utc;
      },

      /**
       * Checks if timezone id has been registered.
       *
       * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)
       * @return {Boolean}        False, when not present
       */
      has: function(tzid) {
        return !!zones[tzid];
      },

      /**
       * Returns a timezone by its tzid if present.
       *
       * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)
       * @return {?ICAL.Timezone} The timezone, or null if not found
       */
      get: function(tzid) {
        return zones[tzid];
      },

      /**
       * Registers a timezone object or component.
       *
       * @param {String=} name
       *        The name of the timezone. Defaults to the component's TZID if not
       *        passed.
       * @param {ICAL.Component|ICAL.Timezone} zone
       *        The initialized zone or vtimezone.
       */
      register: function(name, timezone) {
        if (name instanceof ICAL.Component) {
          if (name.name === 'vtimezone') {
            timezone = new ICAL.Timezone(name);
            name = timezone.tzid;
          }
        }

        if (timezone instanceof ICAL.Timezone) {
          zones[name] = timezone;
        } else {
          throw new TypeError('timezone must be ICAL.Timezone or ICAL.Component');
        }
      },

      /**
       * Removes a timezone by its tzid from the list.
       *
       * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)
       * @return {?ICAL.Timezone} The removed timezone, or null if not registered
       */
      remove: function(tzid) {
        return (delete zones[tzid]);
      }
    };

    // initialize defaults
    TimezoneService.reset();

    return TimezoneService;
  }());
  /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at http://mozilla.org/MPL/2.0/.
   * Portions Copyright (C) Philipp Kewisch, 2011-2015 */



  (function() {

    /**
     * @classdesc
     * iCalendar Time representation (similar to JS Date object).  Fully
     * independent of system (OS) timezone / time.  Unlike JS Date, the month
     * January is 1, not zero.
     *
     * @example
     * var time = new ICAL.Time({
     *   year: 2012,
     *   month: 10,
     *   day: 11
     *   minute: 0,
     *   second: 0,
     *   isDate: false
     * });
     *
     *
     * @alias ICAL.Time
     * @class
     * @param {Object} data           Time initialization
     * @param {Number=} data.year     The year for this date
     * @param {Number=} data.month    The month for this date
     * @param {Number=} data.day      The day for this date
     * @param {Number=} data.hour     The hour for this date
     * @param {Number=} data.minute   The minute for this date
     * @param {Number=} data.second   The second for this date
     * @param {Boolean=} data.isDate  If true, the instance represents a date (as
     *                                  opposed to a date-time)
     * @param {ICAL.Timezone} zone timezone this position occurs in
     */
    ICAL.Time = function icaltime(data, zone) {
      this.wrappedJSObject = this;
      var time = this._time = Object.create(null);

      /* time defaults */
      time.year = 0;
      time.month = 1;
      time.day = 1;
      time.hour = 0;
      time.minute = 0;
      time.second = 0;
      time.isDate = false;

      this.fromData(data, zone);
    };

    ICAL.Time._dowCache = {};
    ICAL.Time._wnCache = {};

    ICAL.Time.prototype = {

      /**
       * The class identifier.
       * @constant
       * @type {String}
       * @default "icaltime"
       */
      icalclass: "icaltime",
      _cachedUnixTime: null,

      /**
       * The type name, to be used in the jCal object. This value may change and
       * is strictly defined by the {@link ICAL.Time#isDate isDate} member.
       * @readonly
       * @type {String}
       * @default "date-time"
       */
      get icaltype() {
        return this.isDate ? 'date' : 'date-time';
      },

      /**
       * The timezone for this time.
       * @type {ICAL.Timezone}
       */
      zone: null,

      /**
       * Internal uses to indicate that a change has been made and the next read
       * operation must attempt to normalize the value (for example changing the
       * day to 33).
       *
       * @type {Boolean}
       * @private
       */
      _pendingNormalization: false,

      /**
       * Returns a clone of the time object.
       *
       * @return {ICAL.Time}              The cloned object
       */
      clone: function() {
        return new ICAL.Time(this._time, this.zone);
      },

      /**
       * Reset the time instance to epoch time
       */
      reset: function icaltime_reset() {
        this.fromData(ICAL.Time.epochTime);
        this.zone = ICAL.Timezone.utcTimezone;
      },

      /**
       * Reset the time instance to the given date/time values.
       *
       * @param {Number} year             The year to set
       * @param {Number} month            The month to set
       * @param {Number} day              The day to set
       * @param {Number} hour             The hour to set
       * @param {Number} minute           The minute to set
       * @param {Number} second           The second to set
       * @param {ICAL.Timezone} timezone  The timezone to set
       */
      resetTo: function icaltime_resetTo(year, month, day,
                                         hour, minute, second, timezone) {
        this.fromData({
          year: year,
          month: month,
          day: day,
          hour: hour,
          minute: minute,
          second: second,
          zone: timezone
        });
      },

      /**
       * Set up the current instance from the Javascript date value.
       *
       * @param {?Date} aDate     The Javascript Date to read, or null to reset
       * @param {Boolean} useUTC  If true, the UTC values of the date will be used
       */
      fromJSDate: function icaltime_fromJSDate(aDate, useUTC) {
        if (!aDate) {
          this.reset();
        } else {
          if (useUTC) {
            this.zone = ICAL.Timezone.utcTimezone;
            this.year = aDate.getUTCFullYear();
            this.month = aDate.getUTCMonth() + 1;
            this.day = aDate.getUTCDate();
            this.hour = aDate.getUTCHours();
            this.minute = aDate.getUTCMinutes();
            this.second = aDate.getUTCSeconds();
          } else {
            this.zone = ICAL.Timezone.localTimezone;
            this.year = aDate.getFullYear();
            this.month = aDate.getMonth() + 1;
            this.day = aDate.getDate();
            this.hour = aDate.getHours();
            this.minute = aDate.getMinutes();
            this.second = aDate.getSeconds();
          }
        }
        this._cachedUnixTime = null;
        return this;
      },

      /**
       * Sets up the current instance using members from the passed data object.
       *
       * @param {Object} aData            Time initialization
       * @param {Number=} aData.year      The year for this date
       * @param {Number=} aData.month     The month for this date
       * @param {Number=} aData.day       The day for this date
       * @param {Number=} aData.hour      The hour for this date
       * @param {Number=} aData.minute    The minute for this date
       * @param {Number=} aData.second    The second for this date
       * @param {Boolean=} aData.isDate   If true, the instance represents a date
       *                                    (as opposed to a date-time)
       * @param {ICAL.Timezone=} aZone    Timezone this position occurs in
       */
      fromData: function fromData(aData, aZone) {
        if (aData) {
          for (var key in aData) {
            /* istanbul ignore else */
            if (Object.prototype.hasOwnProperty.call(aData, key)) {
              // ical type cannot be set
              if (key === 'icaltype') continue;
              this[key] = aData[key];
            }
          }
        }

        if (aZone) {
          this.zone = aZone;
        }

        if (aData && !("isDate" in aData)) {
          this.isDate = !("hour" in aData);
        } else if (aData && ("isDate" in aData)) {
          this.isDate = aData.isDate;
        }

        if (aData && "timezone" in aData) {
          var zone = ICAL.TimezoneService.get(
            aData.timezone
          );

          this.zone = zone || ICAL.Timezone.localTimezone;
        }

        if (aData && "zone" in aData) {
          this.zone = aData.zone;
        }

        if (!this.zone) {
          this.zone = ICAL.Timezone.localTimezone;
        }

        this._cachedUnixTime = null;
        return this;
      },

      /**
       * Calculate the day of week.
       * @param {ICAL.Time.weekDay=} aWeekStart
       *        The week start weekday, defaults to SUNDAY
       * @return {ICAL.Time.weekDay}
       */
      dayOfWeek: function icaltime_dayOfWeek(aWeekStart) {
        var firstDow = aWeekStart || ICAL.Time.SUNDAY;
        var dowCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + firstDow;
        if (dowCacheKey in ICAL.Time._dowCache) {
          return ICAL.Time._dowCache[dowCacheKey];
        }

        // Using Zeller's algorithm
        var q = this.day;
        var m = this.month + (this.month < 3 ? 12 : 0);
        var Y = this.year - (this.month < 3 ? 1 : 0);

        var h = (q + Y + ICAL.helpers.trunc(((m + 1) * 26) / 10) + ICAL.helpers.trunc(Y / 4));
        /* istanbul ignore else */
        {
          h += ICAL.helpers.trunc(Y / 100) * 6 + ICAL.helpers.trunc(Y / 400);
        }

        // Normalize to 1 = wkst
        h = ((h + 7 - firstDow) % 7) + 1;
        ICAL.Time._dowCache[dowCacheKey] = h;
        return h;
      },

      /**
       * Calculate the day of year.
       * @return {Number}
       */
      dayOfYear: function dayOfYear() {
        var is_leap = (ICAL.Time.isLeapYear(this.year) ? 1 : 0);
        var diypm = ICAL.Time.daysInYearPassedMonth;
        return diypm[is_leap][this.month - 1] + this.day;
      },

      /**
       * Returns a copy of the current date/time, rewound to the start of the
       * week. The resulting ICAL.Time instance is of icaltype date, even if this
       * is a date-time.
       *
       * @param {ICAL.Time.weekDay=} aWeekStart
       *        The week start weekday, defaults to SUNDAY
       * @return {ICAL.Time}      The start of the week (cloned)
       */
      startOfWeek: function startOfWeek(aWeekStart) {
        var firstDow = aWeekStart || ICAL.Time.SUNDAY;
        var result = this.clone();
        result.day -= ((this.dayOfWeek() + 7 - firstDow) % 7);
        result.isDate = true;
        result.hour = 0;
        result.minute = 0;
        result.second = 0;
        return result;
      },

      /**
       * Returns a copy of the current date/time, shifted to the end of the week.
       * The resulting ICAL.Time instance is of icaltype date, even if this is a
       * date-time.
       *
       * @param {ICAL.Time.weekDay=} aWeekStart
       *        The week start weekday, defaults to SUNDAY
       * @return {ICAL.Time}      The end of the week (cloned)
       */
      endOfWeek: function endOfWeek(aWeekStart) {
        var firstDow = aWeekStart || ICAL.Time.SUNDAY;
        var result = this.clone();
        result.day += (7 - this.dayOfWeek() + firstDow - ICAL.Time.SUNDAY) % 7;
        result.isDate = true;
        result.hour = 0;
        result.minute = 0;
        result.second = 0;
        return result;
      },

      /**
       * Returns a copy of the current date/time, rewound to the start of the
       * month. The resulting ICAL.Time instance is of icaltype date, even if
       * this is a date-time.
       *
       * @return {ICAL.Time}      The start of the month (cloned)
       */
      startOfMonth: function startOfMonth() {
        var result = this.clone();
        result.day = 1;
        result.isDate = true;
        result.hour = 0;
        result.minute = 0;
        result.second = 0;
        return result;
      },

      /**
       * Returns a copy of the current date/time, shifted to the end of the
       * month.  The resulting ICAL.Time instance is of icaltype date, even if
       * this is a date-time.
       *
       * @return {ICAL.Time}      The end of the month (cloned)
       */
      endOfMonth: function endOfMonth() {
        var result = this.clone();
        result.day = ICAL.Time.daysInMonth(result.month, result.year);
        result.isDate = true;
        result.hour = 0;
        result.minute = 0;
        result.second = 0;
        return result;
      },

      /**
       * Returns a copy of the current date/time, rewound to the start of the
       * year. The resulting ICAL.Time instance is of icaltype date, even if
       * this is a date-time.
       *
       * @return {ICAL.Time}      The start of the year (cloned)
       */
      startOfYear: function startOfYear() {
        var result = this.clone();
        result.day = 1;
        result.month = 1;
        result.isDate = true;
        result.hour = 0;
        result.minute = 0;
        result.second = 0;
        return result;
      },

      /**
       * Returns a copy of the current date/time, shifted to the end of the
       * year.  The resulting ICAL.Time instance is of icaltype date, even if
       * this is a date-time.
       *
       * @return {ICAL.Time}      The end of the year (cloned)
       */
      endOfYear: function endOfYear() {
        var result = this.clone();
        result.day = 31;
        result.month = 12;
        result.isDate = true;
        result.hour = 0;
        result.minute = 0;
        result.second = 0;
        return result;
      },

      /**
       * First calculates the start of the week, then returns the day of year for
       * this date. If the day falls into the previous year, the day is zero or negative.
       *
       * @param {ICAL.Time.weekDay=} aFirstDayOfWeek
       *        The week start weekday, defaults to SUNDAY
       * @return {Number}     The calculated day of year
       */
      startDoyWeek: function startDoyWeek(aFirstDayOfWeek) {
        var firstDow = aFirstDayOfWeek || ICAL.Time.SUNDAY;
        var delta = this.dayOfWeek() - firstDow;
        if (delta < 0) delta += 7;
        return this.dayOfYear() - delta;
      },

      /**
       * Get the dominical letter for the current year. Letters range from A - G
       * for common years, and AG to GF for leap years.
       *
       * @param {Number} yr           The year to retrieve the letter for
       * @return {String}             The dominical letter.
       */
      getDominicalLetter: function() {
        return ICAL.Time.getDominicalLetter(this.year);
      },

      /**
       * Finds the nthWeekDay relative to the current month (not day).  The
       * returned value is a day relative the month that this month belongs to so
       * 1 would indicate the first of the month and 40 would indicate a day in
       * the following month.
       *
       * @param {Number} aDayOfWeek   Day of the week see the day name constants
       * @param {Number} aPos         Nth occurrence of a given week day values
       *        of 1 and 0 both indicate the first weekday of that type. aPos may
       *        be either positive or negative
       *
       * @return {Number} numeric value indicating a day relative
       *                   to the current month of this time object
       */
      nthWeekDay: function icaltime_nthWeekDay(aDayOfWeek, aPos) {
        var daysInMonth = ICAL.Time.daysInMonth(this.month, this.year);
        var weekday;
        var pos = aPos;

        var start = 0;

        var otherDay = this.clone();

        if (pos >= 0) {
          otherDay.day = 1;

          // because 0 means no position has been given
          // 1 and 0 indicate the same day.
          if (pos != 0) {
            // remove the extra numeric value
            pos--;
          }

          // set current start offset to current day.
          start = otherDay.day;

          // find the current day of week
          var startDow = otherDay.dayOfWeek();

          // calculate the difference between current
          // day of the week and desired day of the week
          var offset = aDayOfWeek - startDow;


          // if the offset goes into the past
          // week we add 7 so it goes into the next
          // week. We only want to go forward in time here.
          if (offset < 0)
            // this is really important otherwise we would
            // end up with dates from in the past.
            offset += 7;

          // add offset to start so start is the same
          // day of the week as the desired day of week.
          start += offset;

          // because we are going to add (and multiply)
          // the numeric value of the day we subtract it
          // from the start position so not to add it twice.
          start -= aDayOfWeek;

          // set week day
          weekday = aDayOfWeek;
        } else {

          // then we set it to the last day in the current month
          otherDay.day = daysInMonth;

          // find the ends weekday
          var endDow = otherDay.dayOfWeek();

          pos++;

          weekday = (endDow - aDayOfWeek);

          if (weekday < 0) {
            weekday += 7;
          }

          weekday = daysInMonth - weekday;
        }

        weekday += pos * 7;

        return start + weekday;
      },

      /**
       * Checks if current time is the nth weekday, relative to the current
       * month.  Will always return false when rule resolves outside of current
       * month.
       *
       * @param {ICAL.Time.weekDay} aDayOfWeek       Day of week to check
       * @param {Number} aPos                        Relative position
       * @return {Boolean}                           True, if it is the nth weekday
       */
      isNthWeekDay: function(aDayOfWeek, aPos) {
        var dow = this.dayOfWeek();

        if (aPos === 0 && dow === aDayOfWeek) {
          return true;
        }

        // get pos
        var day = this.nthWeekDay(aDayOfWeek, aPos);

        if (day === this.day) {
          return true;
        }

        return false;
      },

      /**
       * Calculates the ISO 8601 week number. The first week of a year is the
       * week that contains the first Thursday. The year can have 53 weeks, if
       * January 1st is a Friday.
       *
       * Note there are regions where the first week of the year is the one that
       * starts on January 1st, which may offset the week number. Also, if a
       * different week start is specified, this will also affect the week
       * number.
       *
       * @see ICAL.Time.weekOneStarts
       * @param {ICAL.Time.weekDay} aWeekStart        The weekday the week starts with
       * @return {Number}                             The ISO week number
       */
      weekNumber: function weekNumber(aWeekStart) {
        var wnCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + aWeekStart;
        if (wnCacheKey in ICAL.Time._wnCache) {
          return ICAL.Time._wnCache[wnCacheKey];
        }
        // This function courtesty of Julian Bucknall, published under the MIT license
        // http://www.boyet.com/articles/publishedarticles/calculatingtheisoweeknumb.html
        // plus some fixes to be able to use different week starts.
        var week1;

        var dt = this.clone();
        dt.isDate = true;
        var isoyear = this.year;

        if (dt.month == 12 && dt.day > 25) {
          week1 = ICAL.Time.weekOneStarts(isoyear + 1, aWeekStart);
          if (dt.compare(week1) < 0) {
            week1 = ICAL.Time.weekOneStarts(isoyear, aWeekStart);
          } else {
            isoyear++;
          }
        } else {
          week1 = ICAL.Time.weekOneStarts(isoyear, aWeekStart);
          if (dt.compare(week1) < 0) {
            week1 = ICAL.Time.weekOneStarts(--isoyear, aWeekStart);
          }
        }

        var daysBetween = (dt.subtractDate(week1).toSeconds() / 86400);
        var answer = ICAL.helpers.trunc(daysBetween / 7) + 1;
        ICAL.Time._wnCache[wnCacheKey] = answer;
        return answer;
      },

      /**
       * Adds the duration to the current time. The instance is modified in
       * place.
       *
       * @param {ICAL.Duration} aDuration         The duration to add
       */
      addDuration: function icaltime_add(aDuration) {
        var mult = (aDuration.isNegative ? -1 : 1);

        // because of the duration optimizations it is much
        // more efficient to grab all the values up front
        // then set them directly (which will avoid a normalization call).
        // So we don't actually normalize until we need it.
        var second = this.second;
        var minute = this.minute;
        var hour = this.hour;
        var day = this.day;

        second += mult * aDuration.seconds;
        minute += mult * aDuration.minutes;
        hour += mult * aDuration.hours;
        day += mult * aDuration.days;
        day += mult * 7 * aDuration.weeks;

        this.second = second;
        this.minute = minute;
        this.hour = hour;
        this.day = day;

        this._cachedUnixTime = null;
      },

      /**
       * Subtract the date details (_excluding_ timezone).  Useful for finding
       * the relative difference between two time objects excluding their
       * timezone differences.
       *
       * @param {ICAL.Time} aDate     The date to substract
       * @return {ICAL.Duration}      The difference as a duration
       */
      subtractDate: function icaltime_subtract(aDate) {
        var unixTime = this.toUnixTime() + this.utcOffset();
        var other = aDate.toUnixTime() + aDate.utcOffset();
        return ICAL.Duration.fromSeconds(unixTime - other);
      },

      /**
       * Subtract the date details, taking timezones into account.
       *
       * @param {ICAL.Time} aDate  The date to subtract
       * @return {ICAL.Duration}  The difference in duration
       */
      subtractDateTz: function icaltime_subtract_abs(aDate) {
        var unixTime = this.toUnixTime();
        var other = aDate.toUnixTime();
        return ICAL.Duration.fromSeconds(unixTime - other);
      },

      /**
       * Compares the ICAL.Time instance with another one.
       *
       * @param {ICAL.Duration} aOther        The instance to compare with
       * @return {Number}                     -1, 0 or 1 for less/equal/greater
       */
      compare: function icaltime_compare(other) {
        var a = this.toUnixTime();
        var b = other.toUnixTime();

        if (a > b) return 1;
        if (b > a) return -1;
        return 0;
      },

      /**
       * Compares only the date part of this instance with another one.
       *
       * @param {ICAL.Duration} other         The instance to compare with
       * @param {ICAL.Timezone} tz            The timezone to compare in
       * @return {Number}                     -1, 0 or 1 for less/equal/greater
       */
      compareDateOnlyTz: function icaltime_compareDateOnlyTz(other, tz) {
        function cmp(attr) {
          return ICAL.Time._cmp_attr(a, b, attr);
        }
        var a = this.convertToZone(tz);
        var b = other.convertToZone(tz);
        var rc = 0;

        if ((rc = cmp("year")) != 0) return rc;
        if ((rc = cmp("month")) != 0) return rc;
        if ((rc = cmp("day")) != 0) return rc;

        return rc;
      },

      /**
       * Convert the instance into another timezone. The returned ICAL.Time
       * instance is always a copy.
       *
       * @param {ICAL.Timezone} zone      The zone to convert to
       * @return {ICAL.Time}              The copy, converted to the zone
       */
      convertToZone: function convertToZone(zone) {
        var copy = this.clone();
        var zone_equals = (this.zone.tzid == zone.tzid);

        if (!this.isDate && !zone_equals) {
          ICAL.Timezone.convert_time(copy, this.zone, zone);
        }

        copy.zone = zone;
        return copy;
      },

      /**
       * Calculates the UTC offset of the current date/time in the timezone it is
       * in.
       *
       * @return {Number}     UTC offset in seconds
       */
      utcOffset: function utc_offset() {
        if (this.zone == ICAL.Timezone.localTimezone ||
            this.zone == ICAL.Timezone.utcTimezone) {
          return 0;
        } else {
          return this.zone.utcOffset(this);
        }
      },

      /**
       * Returns an RFC 5545 compliant ical representation of this object.
       *
       * @return {String} ical date/date-time
       */
      toICALString: function() {
        var string = this.toString();

        if (string.length > 10) {
          return ICAL.design.icalendar.value['date-time'].toICAL(string);
        } else {
          return ICAL.design.icalendar.value.date.toICAL(string);
        }
      },

      /**
       * The string representation of this date/time, in jCal form
       * (including : and - separators).
       * @return {String}
       */
      toString: function toString() {
        var result = this.year + '-' +
                     ICAL.helpers.pad2(this.month) + '-' +
                     ICAL.helpers.pad2(this.day);

        if (!this.isDate) {
            result += 'T' + ICAL.helpers.pad2(this.hour) + ':' +
                      ICAL.helpers.pad2(this.minute) + ':' +
                      ICAL.helpers.pad2(this.second);

          if (this.zone === ICAL.Timezone.utcTimezone) {
            result += 'Z';
          }
        }

        return result;
      },

      /**
       * Converts the current instance to a Javascript date
       * @return {Date}
       */
      toJSDate: function toJSDate() {
        if (this.zone == ICAL.Timezone.localTimezone) {
          if (this.isDate) {
            return new Date(this.year, this.month - 1, this.day);
          } else {
            return new Date(this.year, this.month - 1, this.day,
                            this.hour, this.minute, this.second, 0);
          }
        } else {
          return new Date(this.toUnixTime() * 1000);
        }
      },

      _normalize: function icaltime_normalize() {
        this._time.isDate;
        if (this._time.isDate) {
          this._time.hour = 0;
          this._time.minute = 0;
          this._time.second = 0;
        }
        this.adjust(0, 0, 0, 0);

        return this;
      },

      /**
       * Adjust the date/time by the given offset
       *
       * @param {Number} aExtraDays       The extra amount of days
       * @param {Number} aExtraHours      The extra amount of hours
       * @param {Number} aExtraMinutes    The extra amount of minutes
       * @param {Number} aExtraSeconds    The extra amount of seconds
       * @param {Number=} aTime           The time to adjust, defaults to the
       *                                    current instance.
       */
      adjust: function icaltime_adjust(aExtraDays, aExtraHours,
                                       aExtraMinutes, aExtraSeconds, aTime) {

        var minutesOverflow, hoursOverflow,
            daysOverflow = 0, yearsOverflow = 0;

        var second, minute, hour, day;
        var daysInMonth;

        var time = aTime || this._time;

        if (!time.isDate) {
          second = time.second + aExtraSeconds;
          time.second = second % 60;
          minutesOverflow = ICAL.helpers.trunc(second / 60);
          if (time.second < 0) {
            time.second += 60;
            minutesOverflow--;
          }

          minute = time.minute + aExtraMinutes + minutesOverflow;
          time.minute = minute % 60;
          hoursOverflow = ICAL.helpers.trunc(minute / 60);
          if (time.minute < 0) {
            time.minute += 60;
            hoursOverflow--;
          }

          hour = time.hour + aExtraHours + hoursOverflow;

          time.hour = hour % 24;
          daysOverflow = ICAL.helpers.trunc(hour / 24);
          if (time.hour < 0) {
            time.hour += 24;
            daysOverflow--;
          }
        }


        // Adjust month and year first, because we need to know what month the day
        // is in before adjusting it.
        if (time.month > 12) {
          yearsOverflow = ICAL.helpers.trunc((time.month - 1) / 12);
        } else if (time.month < 1) {
          yearsOverflow = ICAL.helpers.trunc(time.month / 12) - 1;
        }

        time.year += yearsOverflow;
        time.month -= 12 * yearsOverflow;

        // Now take care of the days (and adjust month if needed)
        day = time.day + aExtraDays + daysOverflow;

        if (day > 0) {
          for (;;) {
            daysInMonth = ICAL.Time.daysInMonth(time.month, time.year);
            if (day <= daysInMonth) {
              break;
            }

            time.month++;
            if (time.month > 12) {
              time.year++;
              time.month = 1;
            }

            day -= daysInMonth;
          }
        } else {
          while (day <= 0) {
            if (time.month == 1) {
              time.year--;
              time.month = 12;
            } else {
              time.month--;
            }

            day += ICAL.Time.daysInMonth(time.month, time.year);
          }
        }

        time.day = day;

        this._cachedUnixTime = null;
        return this;
      },

      /**
       * Sets up the current instance from unix time, the number of seconds since
       * January 1st, 1970.
       *
       * @param {Number} seconds      The seconds to set up with
       */
      fromUnixTime: function fromUnixTime(seconds) {
        this.zone = ICAL.Timezone.utcTimezone;
        var epoch = ICAL.Time.epochTime.clone();
        epoch.adjust(0, 0, 0, seconds);

        this.year = epoch.year;
        this.month = epoch.month;
        this.day = epoch.day;
        this.hour = epoch.hour;
        this.minute = epoch.minute;
        this.second = Math.floor(epoch.second);

        this._cachedUnixTime = null;
      },

      /**
       * Converts the current instance to seconds since January 1st 1970.
       *
       * @return {Number}         Seconds since 1970
       */
      toUnixTime: function toUnixTime() {
        if (this._cachedUnixTime !== null) {
          return this._cachedUnixTime;
        }
        var offset = this.utcOffset();

        // we use the offset trick to ensure
        // that we are getting the actual UTC time
        var ms = Date.UTC(
          this.year,
          this.month - 1,
          this.day,
          this.hour,
          this.minute,
          this.second - offset
        );

        // seconds
        this._cachedUnixTime = ms / 1000;
        return this._cachedUnixTime;
      },

      /**
       * Converts time to into Object which can be serialized then re-created
       * using the constructor.
       *
       * @example
       * // toJSON will automatically be called
       * var json = JSON.stringify(mytime);
       *
       * var deserialized = JSON.parse(json);
       *
       * var time = new ICAL.Time(deserialized);
       *
       * @return {Object}
       */
      toJSON: function() {
        var copy = [
          'year',
          'month',
          'day',
          'hour',
          'minute',
          'second',
          'isDate'
        ];

        var result = Object.create(null);

        var i = 0;
        var len = copy.length;
        var prop;

        for (; i < len; i++) {
          prop = copy[i];
          result[prop] = this[prop];
        }

        if (this.zone) {
          result.timezone = this.zone.tzid;
        }

        return result;
      }

    };

    (function setupNormalizeAttributes() {
      // This needs to run before any instances are created!
      function defineAttr(attr) {
        Object.defineProperty(ICAL.Time.prototype, attr, {
          get: function getTimeAttr() {
            if (this._pendingNormalization) {
              this._normalize();
              this._pendingNormalization = false;
            }

            return this._time[attr];
          },
          set: function setTimeAttr(val) {
            // Check if isDate will be set and if was not set to normalize date.
            // This avoids losing days when seconds, minutes and hours are zeroed
            // what normalize will do when time is a date.
            if (attr === "isDate" && val && !this._time.isDate) {
              this.adjust(0, 0, 0, 0);
            }
            this._cachedUnixTime = null;
            this._pendingNormalization = true;
            this._time[attr] = val;

            return val;
          }
        });

      }

      /* istanbul ignore else */
      if ("defineProperty" in Object) {
        defineAttr("year");
        defineAttr("month");
        defineAttr("day");
        defineAttr("hour");
        defineAttr("minute");
        defineAttr("second");
        defineAttr("isDate");
      }
    })();

    /**
     * Returns the days in the given month
     *
     * @param {Number} month      The month to check
     * @param {Number} year       The year to check
     * @return {Number}           The number of days in the month
     */
    ICAL.Time.daysInMonth = function icaltime_daysInMonth(month, year) {
      var _daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      var days = 30;

      if (month < 1 || month > 12) return days;

      days = _daysInMonth[month];

      if (month == 2) {
        days += ICAL.Time.isLeapYear(year);
      }

      return days;
    };

    /**
     * Checks if the year is a leap year
     *
     * @param {Number} year       The year to check
     * @return {Boolean}          True, if the year is a leap year
     */
    ICAL.Time.isLeapYear = function isLeapYear(year) {
      if (year <= 1752) {
        return ((year % 4) == 0);
      } else {
        return (((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0));
      }
    };

    /**
     * Create a new ICAL.Time from the day of year and year. The date is returned
     * in floating timezone.
     *
     * @param {Number} aDayOfYear     The day of year
     * @param {Number} aYear          The year to create the instance in
     * @return {ICAL.Time}            The created instance with the calculated date
     */
    ICAL.Time.fromDayOfYear = function icaltime_fromDayOfYear(aDayOfYear, aYear) {
      var year = aYear;
      var doy = aDayOfYear;
      var tt = new ICAL.Time();
      tt.auto_normalize = false;
      var is_leap = (ICAL.Time.isLeapYear(year) ? 1 : 0);

      if (doy < 1) {
        year--;
        is_leap = (ICAL.Time.isLeapYear(year) ? 1 : 0);
        doy += ICAL.Time.daysInYearPassedMonth[is_leap][12];
        return ICAL.Time.fromDayOfYear(doy, year);
      } else if (doy > ICAL.Time.daysInYearPassedMonth[is_leap][12]) {
        is_leap = (ICAL.Time.isLeapYear(year) ? 1 : 0);
        doy -= ICAL.Time.daysInYearPassedMonth[is_leap][12];
        year++;
        return ICAL.Time.fromDayOfYear(doy, year);
      }

      tt.year = year;
      tt.isDate = true;

      for (var month = 11; month >= 0; month--) {
        if (doy > ICAL.Time.daysInYearPassedMonth[is_leap][month]) {
          tt.month = month + 1;
          tt.day = doy - ICAL.Time.daysInYearPassedMonth[is_leap][month];
          break;
        }
      }

      tt.auto_normalize = true;
      return tt;
    };

    /**
     * Returns a new ICAL.Time instance from a date string, e.g 2015-01-02.
     *
     * @deprecated                Use {@link ICAL.Time.fromDateString} instead
     * @param {String} str        The string to create from
     * @return {ICAL.Time}        The date/time instance
     */
    ICAL.Time.fromStringv2 = function fromString(str) {
      return new ICAL.Time({
        year: parseInt(str.substr(0, 4), 10),
        month: parseInt(str.substr(5, 2), 10),
        day: parseInt(str.substr(8, 2), 10),
        isDate: true
      });
    };

    /**
     * Returns a new ICAL.Time instance from a date string, e.g 2015-01-02.
     *
     * @param {String} aValue     The string to create from
     * @return {ICAL.Time}        The date/time instance
     */
    ICAL.Time.fromDateString = function(aValue) {
      // Dates should have no timezone.
      // Google likes to sometimes specify Z on dates
      // we specifically ignore that to avoid issues.

      // YYYY-MM-DD
      // 2012-10-10
      return new ICAL.Time({
        year: ICAL.helpers.strictParseInt(aValue.substr(0, 4)),
        month: ICAL.helpers.strictParseInt(aValue.substr(5, 2)),
        day: ICAL.helpers.strictParseInt(aValue.substr(8, 2)),
        isDate: true
      });
    };

    /**
     * Returns a new ICAL.Time instance from a date-time string, e.g
     * 2015-01-02T03:04:05. If a property is specified, the timezone is set up
     * from the property's TZID parameter.
     *
     * @param {String} aValue         The string to create from
     * @param {ICAL.Property=} prop   The property the date belongs to
     * @return {ICAL.Time}            The date/time instance
     */
    ICAL.Time.fromDateTimeString = function(aValue, prop) {
      if (aValue.length < 19) {
        throw new Error(
          'invalid date-time value: "' + aValue + '"'
        );
      }

      var zone;

      if (aValue[19] && aValue[19] === 'Z') {
        zone = 'Z';
      } else if (prop) {
        zone = prop.getParameter('tzid');
      }

      // 2012-10-10T10:10:10(Z)?
      var time = new ICAL.Time({
        year: ICAL.helpers.strictParseInt(aValue.substr(0, 4)),
        month: ICAL.helpers.strictParseInt(aValue.substr(5, 2)),
        day: ICAL.helpers.strictParseInt(aValue.substr(8, 2)),
        hour: ICAL.helpers.strictParseInt(aValue.substr(11, 2)),
        minute: ICAL.helpers.strictParseInt(aValue.substr(14, 2)),
        second: ICAL.helpers.strictParseInt(aValue.substr(17, 2)),
        timezone: zone
      });

      return time;
    };

    /**
     * Returns a new ICAL.Time instance from a date or date-time string,
     *
     * @param {String} aValue         The string to create from
     * @param {ICAL.Property=} prop   The property the date belongs to
     * @return {ICAL.Time}            The date/time instance
     */
    ICAL.Time.fromString = function fromString(aValue, aProperty) {
      if (aValue.length > 10) {
        return ICAL.Time.fromDateTimeString(aValue, aProperty);
      } else {
        return ICAL.Time.fromDateString(aValue);
      }
    };

    /**
     * Creates a new ICAL.Time instance from the given Javascript Date.
     *
     * @param {?Date} aDate     The Javascript Date to read, or null to reset
     * @param {Boolean} useUTC  If true, the UTC values of the date will be used
     */
    ICAL.Time.fromJSDate = function fromJSDate(aDate, useUTC) {
      var tt = new ICAL.Time();
      return tt.fromJSDate(aDate, useUTC);
    };

    /**
     * Creates a new ICAL.Time instance from the the passed data object.
     *
     * @param {Object} aData            Time initialization
     * @param {Number=} aData.year      The year for this date
     * @param {Number=} aData.month     The month for this date
     * @param {Number=} aData.day       The day for this date
     * @param {Number=} aData.hour      The hour for this date
     * @param {Number=} aData.minute    The minute for this date
     * @param {Number=} aData.second    The second for this date
     * @param {Boolean=} aData.isDate   If true, the instance represents a date
     *                                    (as opposed to a date-time)
     * @param {ICAL.Timezone=} aZone    Timezone this position occurs in
     */
    ICAL.Time.fromData = function fromData(aData, aZone) {
      var t = new ICAL.Time();
      return t.fromData(aData, aZone);
    };

    /**
     * Creates a new ICAL.Time instance from the current moment.
     * The instance is “floating” - has no timezone relation.
     * To create an instance considering the time zone, call
     * ICAL.Time.fromJSDate(new Date(), true)
     * @return {ICAL.Time}
     */
    ICAL.Time.now = function icaltime_now() {
      return ICAL.Time.fromJSDate(new Date(), false);
    };

    /**
     * Returns the date on which ISO week number 1 starts.
     *
     * @see ICAL.Time#weekNumber
     * @param {Number} aYear                  The year to search in
     * @param {ICAL.Time.weekDay=} aWeekStart The week start weekday, used for calculation.
     * @return {ICAL.Time}                    The date on which week number 1 starts
     */
    ICAL.Time.weekOneStarts = function weekOneStarts(aYear, aWeekStart) {
      var t = ICAL.Time.fromData({
        year: aYear,
        month: 1,
        day: 1,
        isDate: true
      });

      var dow = t.dayOfWeek();
      var wkst = aWeekStart || ICAL.Time.DEFAULT_WEEK_START;
      if (dow > ICAL.Time.THURSDAY) {
        t.day += 7;
      }
      if (wkst > ICAL.Time.THURSDAY) {
        t.day -= 7;
      }

      t.day -= dow - wkst;

      return t;
    };

    /**
     * Get the dominical letter for the given year. Letters range from A - G for
     * common years, and AG to GF for leap years.
     *
     * @param {Number} yr           The year to retrieve the letter for
     * @return {String}             The dominical letter.
     */
    ICAL.Time.getDominicalLetter = function(yr) {
      var LTRS = "GFEDCBA";
      var dom = (yr + (yr / 4 | 0) + (yr / 400 | 0) - (yr / 100 | 0) - 1) % 7;
      var isLeap = ICAL.Time.isLeapYear(yr);
      if (isLeap) {
        return LTRS[(dom + 6) % 7] + LTRS[dom];
      } else {
        return LTRS[dom];
      }
    };

    /**
     * January 1st, 1970 as an ICAL.Time.
     * @type {ICAL.Time}
     * @constant
     * @instance
     */
    ICAL.Time.epochTime = ICAL.Time.fromData({
      year: 1970,
      month: 1,
      day: 1,
      hour: 0,
      minute: 0,
      second: 0,
      isDate: false,
      timezone: "Z"
    });

    ICAL.Time._cmp_attr = function _cmp_attr(a, b, attr) {
      if (a[attr] > b[attr]) return 1;
      if (a[attr] < b[attr]) return -1;
      return 0;
    };

    /**
     * The days that have passed in the year after a given month. The array has
     * two members, one being an array of passed days for non-leap years, the
     * other analog for leap years.
     * @example
     * var isLeapYear = ICAL.Time.isLeapYear(year);
     * var passedDays = ICAL.Time.daysInYearPassedMonth[isLeapYear][month];
     * @type {Array.<Array.<Number>>}
     */
    ICAL.Time.daysInYearPassedMonth = [
      [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365],
      [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366]
    ];

    /**
     * The weekday, 1 = SUNDAY, 7 = SATURDAY. Access via
     * ICAL.Time.MONDAY, ICAL.Time.TUESDAY, ...
     *
     * @typedef {Number} weekDay
     * @memberof ICAL.Time
     */

    ICAL.Time.SUNDAY = 1;
    ICAL.Time.MONDAY = 2;
    ICAL.Time.TUESDAY = 3;
    ICAL.Time.WEDNESDAY = 4;
    ICAL.Time.THURSDAY = 5;
    ICAL.Time.FRIDAY = 6;
    ICAL.Time.SATURDAY = 7;

    /**
     * The default weekday for the WKST part.
     * @constant
     * @default ICAL.Time.MONDAY
     */
    ICAL.Time.DEFAULT_WEEK_START = ICAL.Time.MONDAY;
  })();
  /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at http://mozilla.org/MPL/2.0/.
   * Portions Copyright (C) Philipp Kewisch, 2015 */



  (function() {

    /**
     * Describes a vCard time, which has slight differences to the ICAL.Time.
     * Properties can be null if not specified, for example for dates with
     * reduced accuracy or truncation.
     *
     * Note that currently not all methods are correctly re-implemented for
     * VCardTime. For example, comparison will have undefined results when some
     * members are null.
     *
     * Also, normalization is not yet implemented for this class!
     *
     * @alias ICAL.VCardTime
     * @class
     * @extends {ICAL.Time}
     * @param {Object} data                           The data for the time instance
     * @param {Number=} data.year                     The year for this date
     * @param {Number=} data.month                    The month for this date
     * @param {Number=} data.day                      The day for this date
     * @param {Number=} data.hour                     The hour for this date
     * @param {Number=} data.minute                   The minute for this date
     * @param {Number=} data.second                   The second for this date
     * @param {ICAL.Timezone|ICAL.UtcOffset} zone     The timezone to use
     * @param {String} icaltype                       The type for this date/time object
     */
    ICAL.VCardTime = function(data, zone, icaltype) {
      this.wrappedJSObject = this;
      var time = this._time = Object.create(null);

      time.year = null;
      time.month = null;
      time.day = null;
      time.hour = null;
      time.minute = null;
      time.second = null;

      this.icaltype = icaltype || "date-and-or-time";

      this.fromData(data, zone);
    };
    ICAL.helpers.inherits(ICAL.Time, ICAL.VCardTime, /** @lends ICAL.VCardTime */ {

      /**
       * The class identifier.
       * @constant
       * @type {String}
       * @default "vcardtime"
       */
      icalclass: "vcardtime",

      /**
       * The type name, to be used in the jCal object.
       * @type {String}
       * @default "date-and-or-time"
       */
      icaltype: "date-and-or-time",

      /**
       * The timezone. This can either be floating, UTC, or an instance of
       * ICAL.UtcOffset.
       * @type {ICAL.Timezone|ICAL.UtcOFfset}
       */
      zone: null,

      /**
       * Returns a clone of the vcard date/time object.
       *
       * @return {ICAL.VCardTime}     The cloned object
       */
      clone: function() {
        return new ICAL.VCardTime(this._time, this.zone, this.icaltype);
      },

      _normalize: function() {
        return this;
      },

      /**
       * @inheritdoc
       */
      utcOffset: function() {
        if (this.zone instanceof ICAL.UtcOffset) {
          return this.zone.toSeconds();
        } else {
          return ICAL.Time.prototype.utcOffset.apply(this, arguments);
        }
      },

      /**
       * Returns an RFC 6350 compliant representation of this object.
       *
       * @return {String}         vcard date/time string
       */
      toICALString: function() {
        return ICAL.design.vcard.value[this.icaltype].toICAL(this.toString());
      },

      /**
       * The string representation of this date/time, in jCard form
       * (including : and - separators).
       * @return {String}
       */
      toString: function toString() {
        var p2 = ICAL.helpers.pad2;
        var y = this.year, m = this.month, d = this.day;
        var h = this.hour, mm = this.minute, s = this.second;

        var hasYear = y !== null, hasMonth = m !== null, hasDay = d !== null;
        var hasHour = h !== null, hasMinute = mm !== null, hasSecond = s !== null;

        var datepart = (hasYear ? p2(y) + (hasMonth || hasDay ? '-' : '') : (hasMonth || hasDay ? '--' : '')) +
                       (hasMonth ? p2(m) : '') +
                       (hasDay ? '-' + p2(d) : '');
        var timepart = (hasHour ? p2(h) : '-') + (hasHour && hasMinute ? ':' : '') +
                       (hasMinute ? p2(mm) : '') + (!hasHour && !hasMinute ? '-' : '') +
                       (hasMinute && hasSecond ? ':' : '') +
                       (hasSecond ? p2(s) : '');

        var zone;
        if (this.zone === ICAL.Timezone.utcTimezone) {
          zone = 'Z';
        } else if (this.zone instanceof ICAL.UtcOffset) {
          zone = this.zone.toString();
        } else if (this.zone === ICAL.Timezone.localTimezone) {
          zone = '';
        } else if (this.zone instanceof ICAL.Timezone) {
          var offset = ICAL.UtcOffset.fromSeconds(this.zone.utcOffset(this));
          zone = offset.toString();
        } else {
          zone = '';
        }

        switch (this.icaltype) {
          case "time":
            return timepart + zone;
          case "date-and-or-time":
          case "date-time":
            return datepart + (timepart == '--' ? '' : 'T' + timepart + zone);
          case "date":
            return datepart;
        }
        return null;
      }
    });

    /**
     * Returns a new ICAL.VCardTime instance from a date and/or time string.
     *
     * @param {String} aValue     The string to create from
     * @param {String} aIcalType  The type for this instance, e.g. date-and-or-time
     * @return {ICAL.VCardTime}   The date/time instance
     */
    ICAL.VCardTime.fromDateAndOrTimeString = function(aValue, aIcalType) {
      function part(v, s, e) {
        return v ? ICAL.helpers.strictParseInt(v.substr(s, e)) : null;
      }
      var parts = aValue.split('T');
      var dt = parts[0], tmz = parts[1];
      var splitzone = tmz ? ICAL.design.vcard.value.time._splitZone(tmz) : [];
      var zone = splitzone[0], tm = splitzone[1];

      ICAL.helpers.strictParseInt;
      var dtlen = dt ? dt.length : 0;
      var tmlen = tm ? tm.length : 0;

      var hasDashDate = dt && dt[0] == '-' && dt[1] == '-';
      var hasDashTime = tm && tm[0] == '-';

      var o = {
        year: hasDashDate ? null : part(dt, 0, 4),
        month: hasDashDate && (dtlen == 4 || dtlen == 7) ? part(dt, 2, 2) : dtlen == 7 ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 5, 2) : null,
        day: dtlen == 5 ? part(dt, 3, 2) : dtlen == 7 && hasDashDate ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 8, 2) : null,

        hour: hasDashTime ? null : part(tm, 0, 2),
        minute: hasDashTime && tmlen == 3 ? part(tm, 1, 2) : tmlen > 4 ? hasDashTime ? part(tm, 1, 2) : part(tm, 3, 2) : null,
        second: tmlen == 4 ? part(tm, 2, 2) : tmlen == 6 ? part(tm, 4, 2) : tmlen == 8 ? part(tm, 6, 2) : null
      };

      if (zone == 'Z') {
        zone = ICAL.Timezone.utcTimezone;
      } else if (zone && zone[3] == ':') {
        zone = ICAL.UtcOffset.fromString(zone);
      } else {
        zone = null;
      }

      return new ICAL.VCardTime(o, zone, aIcalType);
    };
  })();
  /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at http://mozilla.org/MPL/2.0/.
   * Portions Copyright (C) Philipp Kewisch, 2011-2015 */



  (function() {
    var DOW_MAP = {
      SU: ICAL.Time.SUNDAY,
      MO: ICAL.Time.MONDAY,
      TU: ICAL.Time.TUESDAY,
      WE: ICAL.Time.WEDNESDAY,
      TH: ICAL.Time.THURSDAY,
      FR: ICAL.Time.FRIDAY,
      SA: ICAL.Time.SATURDAY
    };

    var REVERSE_DOW_MAP = {};
    for (var key in DOW_MAP) {
      /* istanbul ignore else */
      if (DOW_MAP.hasOwnProperty(key)) {
        REVERSE_DOW_MAP[DOW_MAP[key]] = key;
      }
    }

    /**
     * @classdesc
     * This class represents the "recur" value type, with various calculation
     * and manipulation methods.
     *
     * @class
     * @alias ICAL.Recur
     * @param {Object} data                               An object with members of the recurrence
     * @param {ICAL.Recur.frequencyValues=} data.freq     The frequency value
     * @param {Number=} data.interval                     The INTERVAL value
     * @param {ICAL.Time.weekDay=} data.wkst              The week start value
     * @param {ICAL.Time=} data.until                     The end of the recurrence set
     * @param {Number=} data.count                        The number of occurrences
     * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part
     * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part
     * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part
     * @param {Array.<String>=} data.byday                The BYDAY values
     * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part
     * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part
     * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part
     * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part
     * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part
     */
    ICAL.Recur = function icalrecur(data) {
      this.wrappedJSObject = this;
      this.parts = {};

      if (data && typeof(data) === 'object') {
        this.fromData(data);
      }
    };

    ICAL.Recur.prototype = {
      /**
       * An object holding the BY-parts of the recurrence rule
       * @type {Object}
       */
      parts: null,

      /**
       * The interval value for the recurrence rule.
       * @type {Number}
       */
      interval: 1,

      /**
       * The week start day
       *
       * @type {ICAL.Time.weekDay}
       * @default ICAL.Time.MONDAY
       */
      wkst: ICAL.Time.MONDAY,

      /**
       * The end of the recurrence
       * @type {?ICAL.Time}
       */
      until: null,

      /**
       * The maximum number of occurrences
       * @type {?Number}
       */
      count: null,

      /**
       * The frequency value.
       * @type {ICAL.Recur.frequencyValues}
       */
      freq: null,

      /**
       * The class identifier.
       * @constant
       * @type {String}
       * @default "icalrecur"
       */
      icalclass: "icalrecur",

      /**
       * The type name, to be used in the jCal object.
       * @constant
       * @type {String}
       * @default "recur"
       */
      icaltype: "recur",

      /**
       * Create a new iterator for this recurrence rule. The passed start date
       * must be the start date of the event, not the start of the range to
       * search in.
       *
       * @example
       * var recur = comp.getFirstPropertyValue('rrule');
       * var dtstart = comp.getFirstPropertyValue('dtstart');
       * var iter = recur.iterator(dtstart);
       * for (var next = iter.next(); next; next = iter.next()) {
       *   if (next.compare(rangeStart) < 0) {
       *     continue;
       *   }
       *   console.log(next.toString());
       * }
       *
       * @param {ICAL.Time} aStart        The item's start date
       * @return {ICAL.RecurIterator}     The recurrence iterator
       */
      iterator: function(aStart) {
        return new ICAL.RecurIterator({
          rule: this,
          dtstart: aStart
        });
      },

      /**
       * Returns a clone of the recurrence object.
       *
       * @return {ICAL.Recur}      The cloned object
       */
      clone: function clone() {
        return new ICAL.Recur(this.toJSON());
      },

      /**
       * Checks if the current rule is finite, i.e. has a count or until part.
       *
       * @return {Boolean}        True, if the rule is finite
       */
      isFinite: function isfinite() {
        return !!(this.count || this.until);
      },

      /**
       * Checks if the current rule has a count part, and not limited by an until
       * part.
       *
       * @return {Boolean}        True, if the rule is by count
       */
      isByCount: function isbycount() {
        return !!(this.count && !this.until);
      },

      /**
       * Adds a component (part) to the recurrence rule. This is not a component
       * in the sense of {@link ICAL.Component}, but a part of the recurrence
       * rule, i.e. BYMONTH.
       *
       * @param {String} aType            The name of the component part
       * @param {Array|String} aValue     The component value
       */
      addComponent: function addPart(aType, aValue) {
        var ucname = aType.toUpperCase();
        if (ucname in this.parts) {
          this.parts[ucname].push(aValue);
        } else {
          this.parts[ucname] = [aValue];
        }
      },

      /**
       * Sets the component value for the given by-part.
       *
       * @param {String} aType        The component part name
       * @param {Array} aValues       The component values
       */
      setComponent: function setComponent(aType, aValues) {
        this.parts[aType.toUpperCase()] = aValues.slice();
      },

      /**
       * Gets (a copy) of the requested component value.
       *
       * @param {String} aType        The component part name
       * @return {Array}              The component part value
       */
      getComponent: function getComponent(aType) {
        var ucname = aType.toUpperCase();
        return (ucname in this.parts ? this.parts[ucname].slice() : []);
      },

      /**
       * Retrieves the next occurrence after the given recurrence id. See the
       * guide on {@tutorial terminology} for more details.
       *
       * NOTE: Currently, this method iterates all occurrences from the start
       * date. It should not be called in a loop for performance reasons. If you
       * would like to get more than one occurrence, you can iterate the
       * occurrences manually, see the example on the
       * {@link ICAL.Recur#iterator iterator} method.
       *
       * @param {ICAL.Time} aStartTime        The start of the event series
       * @param {ICAL.Time} aRecurrenceId     The date of the last occurrence
       * @return {ICAL.Time}                  The next occurrence after
       */
      getNextOccurrence: function getNextOccurrence(aStartTime, aRecurrenceId) {
        var iter = this.iterator(aStartTime);
        var next;

        do {
          next = iter.next();
        } while (next && next.compare(aRecurrenceId) <= 0);

        if (next && aRecurrenceId.zone) {
          next.zone = aRecurrenceId.zone;
        }

        return next;
      },

      /**
       * Sets up the current instance using members from the passed data object.
       *
       * @param {Object} data                               An object with members of the recurrence
       * @param {ICAL.Recur.frequencyValues=} data.freq     The frequency value
       * @param {Number=} data.interval                     The INTERVAL value
       * @param {ICAL.Time.weekDay=} data.wkst              The week start value
       * @param {ICAL.Time=} data.until                     The end of the recurrence set
       * @param {Number=} data.count                        The number of occurrences
       * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part
       * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part
       * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part
       * @param {Array.<String>=} data.byday                The BYDAY values
       * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part
       * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part
       * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part
       * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part
       * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part
       */
      fromData: function(data) {
        for (var key in data) {
          var uckey = key.toUpperCase();

          if (uckey in partDesign) {
            if (Array.isArray(data[key])) {
              this.parts[uckey] = data[key];
            } else {
              this.parts[uckey] = [data[key]];
            }
          } else {
            this[key] = data[key];
          }
        }

        if (this.interval && typeof this.interval != "number") {
          optionDesign.INTERVAL(this.interval, this);
        }

        if (this.wkst && typeof this.wkst != "number") {
          this.wkst = ICAL.Recur.icalDayToNumericDay(this.wkst);
        }

        if (this.until && !(this.until instanceof ICAL.Time)) {
          this.until = ICAL.Time.fromString(this.until);
        }
      },

      /**
       * The jCal representation of this recurrence type.
       * @return {Object}
       */
      toJSON: function() {
        var res = Object.create(null);
        res.freq = this.freq;

        if (this.count) {
          res.count = this.count;
        }

        if (this.interval > 1) {
          res.interval = this.interval;
        }

        for (var k in this.parts) {
          /* istanbul ignore if */
          if (!this.parts.hasOwnProperty(k)) {
            continue;
          }
          var kparts = this.parts[k];
          if (Array.isArray(kparts) && kparts.length == 1) {
            res[k.toLowerCase()] = kparts[0];
          } else {
            res[k.toLowerCase()] = ICAL.helpers.clone(this.parts[k]);
          }
        }

        if (this.until) {
          res.until = this.until.toString();
        }
        if ('wkst' in this && this.wkst !== ICAL.Time.DEFAULT_WEEK_START) {
          res.wkst = ICAL.Recur.numericDayToIcalDay(this.wkst);
        }
        return res;
      },

      /**
       * The string representation of this recurrence rule.
       * @return {String}
       */
      toString: function icalrecur_toString() {
        // TODO retain order
        var str = "FREQ=" + this.freq;
        if (this.count) {
          str += ";COUNT=" + this.count;
        }
        if (this.interval > 1) {
          str += ";INTERVAL=" + this.interval;
        }
        for (var k in this.parts) {
          /* istanbul ignore else */
          if (this.parts.hasOwnProperty(k)) {
            str += ";" + k + "=" + this.parts[k];
          }
        }
        if (this.until) {
          str += ';UNTIL=' + this.until.toICALString();
        }
        if ('wkst' in this && this.wkst !== ICAL.Time.DEFAULT_WEEK_START) {
          str += ';WKST=' + ICAL.Recur.numericDayToIcalDay(this.wkst);
        }
        return str;
      }
    };

    function parseNumericValue(type, min, max, value) {
      var result = value;

      if (value[0] === '+') {
        result = value.substr(1);
      }

      result = ICAL.helpers.strictParseInt(result);

      if (min !== undefined && value < min) {
        throw new Error(
          type + ': invalid value "' + value + '" must be > ' + min
        );
      }

      if (max !== undefined && value > max) {
        throw new Error(
          type + ': invalid value "' + value + '" must be < ' + min
        );
      }

      return result;
    }

    /**
     * Convert an ical representation of a day (SU, MO, etc..)
     * into a numeric value of that day.
     *
     * @param {String} string     The iCalendar day name
     * @param {ICAL.Time.weekDay=} aWeekStart
     *        The week start weekday, defaults to SUNDAY
     * @return {Number}           Numeric value of given day
     */
    ICAL.Recur.icalDayToNumericDay = function toNumericDay(string, aWeekStart) {
      //XXX: this is here so we can deal
      //     with possibly invalid string values.
      var firstDow = aWeekStart || ICAL.Time.SUNDAY;
      return ((DOW_MAP[string] - firstDow + 7) % 7) + 1;
    };

    /**
     * Convert a numeric day value into its ical representation (SU, MO, etc..)
     *
     * @param {Number} num        Numeric value of given day
     * @param {ICAL.Time.weekDay=} aWeekStart
     *        The week start weekday, defaults to SUNDAY
     * @return {String}           The ICAL day value, e.g SU,MO,...
     */
    ICAL.Recur.numericDayToIcalDay = function toIcalDay(num, aWeekStart) {
      //XXX: this is here so we can deal with possibly invalid number values.
      //     Also, this allows consistent mapping between day numbers and day
      //     names for external users.
      var firstDow = aWeekStart || ICAL.Time.SUNDAY;
      var dow = (num + firstDow - ICAL.Time.SUNDAY);
      if (dow > 7) {
        dow -= 7;
      }
      return REVERSE_DOW_MAP[dow];
    };

    var VALID_DAY_NAMES = /^(SU|MO|TU|WE|TH|FR|SA)$/;
    var VALID_BYDAY_PART = /^([+-])?(5[0-3]|[1-4][0-9]|[1-9])?(SU|MO|TU|WE|TH|FR|SA)$/;

    /**
     * Possible frequency values for the FREQ part
     * (YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY, SECONDLY)
     *
     * @typedef {String} frequencyValues
     * @memberof ICAL.Recur
     */

    var ALLOWED_FREQ = ['SECONDLY', 'MINUTELY', 'HOURLY',
                        'DAILY', 'WEEKLY', 'MONTHLY', 'YEARLY'];

    var optionDesign = {
      FREQ: function(value, dict, fmtIcal) {
        // yes this is actually equal or faster then regex.
        // upside here is we can enumerate the valid values.
        if (ALLOWED_FREQ.indexOf(value) !== -1) {
          dict.freq = value;
        } else {
          throw new Error(
            'invalid frequency "' + value + '" expected: "' +
            ALLOWED_FREQ.join(', ') + '"'
          );
        }
      },

      COUNT: function(value, dict, fmtIcal) {
        dict.count = ICAL.helpers.strictParseInt(value);
      },

      INTERVAL: function(value, dict, fmtIcal) {
        dict.interval = ICAL.helpers.strictParseInt(value);
        if (dict.interval < 1) {
          // 0 or negative values are not allowed, some engines seem to generate
          // it though. Assume 1 instead.
          dict.interval = 1;
        }
      },

      UNTIL: function(value, dict, fmtIcal) {
        if (value.length > 10) {
          dict.until = ICAL.design.icalendar.value['date-time'].fromICAL(value);
        } else {
          dict.until = ICAL.design.icalendar.value.date.fromICAL(value);
        }
        if (!fmtIcal) {
          dict.until = ICAL.Time.fromString(dict.until);
        }
      },

      WKST: function(value, dict, fmtIcal) {
        if (VALID_DAY_NAMES.test(value)) {
          dict.wkst = ICAL.Recur.icalDayToNumericDay(value);
        } else {
          throw new Error('invalid WKST value "' + value + '"');
        }
      }
    };

    var partDesign = {
      BYSECOND: parseNumericValue.bind(this, 'BYSECOND', 0, 60),
      BYMINUTE: parseNumericValue.bind(this, 'BYMINUTE', 0, 59),
      BYHOUR: parseNumericValue.bind(this, 'BYHOUR', 0, 23),
      BYDAY: function(value) {
        if (VALID_BYDAY_PART.test(value)) {
          return value;
        } else {
          throw new Error('invalid BYDAY value "' + value + '"');
        }
      },
      BYMONTHDAY: parseNumericValue.bind(this, 'BYMONTHDAY', -31, 31),
      BYYEARDAY: parseNumericValue.bind(this, 'BYYEARDAY', -366, 366),
      BYWEEKNO: parseNumericValue.bind(this, 'BYWEEKNO', -53, 53),
      BYMONTH: parseNumericValue.bind(this, 'BYMONTH', 1, 12),
      BYSETPOS: parseNumericValue.bind(this, 'BYSETPOS', -366, 366)
    };


    /**
     * Creates a new {@link ICAL.Recur} instance from the passed string.
     *
     * @param {String} string         The string to parse
     * @return {ICAL.Recur}           The created recurrence instance
     */
    ICAL.Recur.fromString = function(string) {
      var data = ICAL.Recur._stringToData(string, false);
      return new ICAL.Recur(data);
    };

    /**
     * Creates a new {@link ICAL.Recur} instance using members from the passed
     * data object.
     *
     * @param {Object} aData                              An object with members of the recurrence
     * @param {ICAL.Recur.frequencyValues=} aData.freq    The frequency value
     * @param {Number=} aData.interval                    The INTERVAL value
     * @param {ICAL.Time.weekDay=} aData.wkst             The week start value
     * @param {ICAL.Time=} aData.until                    The end of the recurrence set
     * @param {Number=} aData.count                       The number of occurrences
     * @param {Array.<Number>=} aData.bysecond            The seconds for the BYSECOND part
     * @param {Array.<Number>=} aData.byminute            The minutes for the BYMINUTE part
     * @param {Array.<Number>=} aData.byhour              The hours for the BYHOUR part
     * @param {Array.<String>=} aData.byday               The BYDAY values
     * @param {Array.<Number>=} aData.bymonthday          The days for the BYMONTHDAY part
     * @param {Array.<Number>=} aData.byyearday           The days for the BYYEARDAY part
     * @param {Array.<Number>=} aData.byweekno            The weeks for the BYWEEKNO part
     * @param {Array.<Number>=} aData.bymonth             The month for the BYMONTH part
     * @param {Array.<Number>=} aData.bysetpos            The positionals for the BYSETPOS part
     */
    ICAL.Recur.fromData = function(aData) {
      return new ICAL.Recur(aData);
    };

    /**
     * Converts a recurrence string to a data object, suitable for the fromData
     * method.
     *
     * @param {String} string     The string to parse
     * @param {Boolean} fmtIcal   If true, the string is considered to be an
     *                              iCalendar string
     * @return {ICAL.Recur}       The recurrence instance
     */
    ICAL.Recur._stringToData = function(string, fmtIcal) {
      var dict = Object.create(null);

      // split is slower in FF but fast enough.
      // v8 however this is faster then manual split?
      var values = string.split(';');
      var len = values.length;

      for (var i = 0; i < len; i++) {
        var parts = values[i].split('=');
        var ucname = parts[0].toUpperCase();
        var lcname = parts[0].toLowerCase();
        var name = (fmtIcal ? lcname : ucname);
        var value = parts[1];

        if (ucname in partDesign) {
          var partArr = value.split(',');
          var partArrIdx = 0;
          var partArrLen = partArr.length;

          for (; partArrIdx < partArrLen; partArrIdx++) {
            partArr[partArrIdx] = partDesign[ucname](partArr[partArrIdx]);
          }
          dict[name] = (partArr.length == 1 ? partArr[0] : partArr);
        } else if (ucname in optionDesign) {
          optionDesign[ucname](value, dict, fmtIcal);
        } else {
          // Don't swallow unknown values. Just set them as they are.
          dict[lcname] = value;
        }
      }

      return dict;
    };
  })();
  /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at http://mozilla.org/MPL/2.0/.
   * Portions Copyright (C) Philipp Kewisch, 2011-2015 */


  /**
   * This symbol is further described later on
   * @ignore
   */
  ICAL.RecurIterator = (function() {

    /**
     * @classdesc
     * An iterator for a single recurrence rule. This class usually doesn't have
     * to be instanciated directly, the convenience method
     * {@link ICAL.Recur#iterator} can be used.
     *
     * @description
     * The options object may contain additional members when resuming iteration from a previous run
     *
     * @description
     * The options object may contain additional members when resuming iteration
     * from a previous run.
     *
     * @class
     * @alias ICAL.RecurIterator
     * @param {Object} options                The iterator options
     * @param {ICAL.Recur} options.rule       The rule to iterate.
     * @param {ICAL.Time} options.dtstart     The start date of the event.
     * @param {Boolean=} options.initialized  When true, assume that options are
     *        from a previously constructed iterator. Initialization will not be
     *        repeated.
     */
    function icalrecur_iterator(options) {
      this.fromData(options);
    }

    icalrecur_iterator.prototype = {

      /**
       * True when iteration is finished.
       * @type {Boolean}
       */
      completed: false,

      /**
       * The rule that is being iterated
       * @type {ICAL.Recur}
       */
      rule: null,

      /**
       * The start date of the event being iterated.
       * @type {ICAL.Time}
       */
      dtstart: null,

      /**
       * The last occurrence that was returned from the
       * {@link ICAL.RecurIterator#next} method.
       * @type {ICAL.Time}
       */
      last: null,

      /**
       * The sequence number from the occurrence
       * @type {Number}
       */
      occurrence_number: 0,

      /**
       * The indices used for the {@link ICAL.RecurIterator#by_data} object.
       * @type {Object}
       * @private
       */
      by_indices: null,

      /**
       * If true, the iterator has already been initialized
       * @type {Boolean}
       * @private
       */
      initialized: false,

      /**
       * The initializd by-data.
       * @type {Object}
       * @private
       */
      by_data: null,

      /**
       * The expanded yeardays
       * @type {Array}
       * @private
       */
      days: null,

      /**
       * The index in the {@link ICAL.RecurIterator#days} array.
       * @type {Number}
       * @private
       */
      days_index: 0,

      /**
       * Initialize the recurrence iterator from the passed data object. This
       * method is usually not called directly, you can initialize the iterator
       * through the constructor.
       *
       * @param {Object} options                The iterator options
       * @param {ICAL.Recur} options.rule       The rule to iterate.
       * @param {ICAL.Time} options.dtstart     The start date of the event.
       * @param {Boolean=} options.initialized  When true, assume that options are
       *        from a previously constructed iterator. Initialization will not be
       *        repeated.
       */
      fromData: function(options) {
        this.rule = ICAL.helpers.formatClassType(options.rule, ICAL.Recur);

        if (!this.rule) {
          throw new Error('iterator requires a (ICAL.Recur) rule');
        }

        this.dtstart = ICAL.helpers.formatClassType(options.dtstart, ICAL.Time);

        if (!this.dtstart) {
          throw new Error('iterator requires a (ICAL.Time) dtstart');
        }

        if (options.by_data) {
          this.by_data = options.by_data;
        } else {
          this.by_data = ICAL.helpers.clone(this.rule.parts, true);
        }

        if (options.occurrence_number)
          this.occurrence_number = options.occurrence_number;

        this.days = options.days || [];
        if (options.last) {
          this.last = ICAL.helpers.formatClassType(options.last, ICAL.Time);
        }

        this.by_indices = options.by_indices;

        if (!this.by_indices) {
          this.by_indices = {
            "BYSECOND": 0,
            "BYMINUTE": 0,
            "BYHOUR": 0,
            "BYDAY": 0,
            "BYMONTH": 0,
            "BYWEEKNO": 0,
            "BYMONTHDAY": 0
          };
        }

        this.initialized = options.initialized || false;

        if (!this.initialized) {
          this.init();
        }
      },

      /**
       * Intialize the iterator
       * @private
       */
      init: function icalrecur_iterator_init() {
        this.initialized = true;
        this.last = this.dtstart.clone();
        var parts = this.by_data;

        if ("BYDAY" in parts) {
          // libical does this earlier when the rule is loaded, but we postpone to
          // now so we can preserve the original order.
          this.sort_byday_rules(parts.BYDAY);
        }

        // If the BYYEARDAY appares, no other date rule part may appear
        if ("BYYEARDAY" in parts) {
          if ("BYMONTH" in parts || "BYWEEKNO" in parts ||
              "BYMONTHDAY" in parts || "BYDAY" in parts) {
            throw new Error("Invalid BYYEARDAY rule");
          }
        }

        // BYWEEKNO and BYMONTHDAY rule parts may not both appear
        if ("BYWEEKNO" in parts && "BYMONTHDAY" in parts) {
          throw new Error("BYWEEKNO does not fit to BYMONTHDAY");
        }

        // For MONTHLY recurrences (FREQ=MONTHLY) neither BYYEARDAY nor
        // BYWEEKNO may appear.
        if (this.rule.freq == "MONTHLY" &&
            ("BYYEARDAY" in parts || "BYWEEKNO" in parts)) {
          throw new Error("For MONTHLY recurrences neither BYYEARDAY nor BYWEEKNO may appear");
        }

        // For WEEKLY recurrences (FREQ=WEEKLY) neither BYMONTHDAY nor
        // BYYEARDAY may appear.
        if (this.rule.freq == "WEEKLY" &&
            ("BYYEARDAY" in parts || "BYMONTHDAY" in parts)) {
          throw new Error("For WEEKLY recurrences neither BYMONTHDAY nor BYYEARDAY may appear");
        }

        // BYYEARDAY may only appear in YEARLY rules
        if (this.rule.freq != "YEARLY" && "BYYEARDAY" in parts) {
          throw new Error("BYYEARDAY may only appear in YEARLY rules");
        }

        this.last.second = this.setup_defaults("BYSECOND", "SECONDLY", this.dtstart.second);
        this.last.minute = this.setup_defaults("BYMINUTE", "MINUTELY", this.dtstart.minute);
        this.last.hour = this.setup_defaults("BYHOUR", "HOURLY", this.dtstart.hour);
        this.last.day = this.setup_defaults("BYMONTHDAY", "DAILY", this.dtstart.day);
        this.last.month = this.setup_defaults("BYMONTH", "MONTHLY", this.dtstart.month);

        if (this.rule.freq == "WEEKLY") {
          if ("BYDAY" in parts) {
            var bydayParts = this.ruleDayOfWeek(parts.BYDAY[0], this.rule.wkst);
            var pos = bydayParts[0];
            var dow = bydayParts[1];
            var wkdy = dow - this.last.dayOfWeek(this.rule.wkst);
            if ((this.last.dayOfWeek(this.rule.wkst) < dow && wkdy >= 0) || wkdy < 0) {
              // Initial time is after first day of BYDAY data
              this.last.day += wkdy;
            }
          } else {
            var dayName = ICAL.Recur.numericDayToIcalDay(this.dtstart.dayOfWeek());
            parts.BYDAY = [dayName];
          }
        }

        if (this.rule.freq == "YEARLY") {
          for (;;) {
            this.expand_year_days(this.last.year);
            if (this.days.length > 0) {
              break;
            }
            this.increment_year(this.rule.interval);
          }

          this._nextByYearDay();
        }

        if (this.rule.freq == "MONTHLY" && this.has_by_data("BYDAY")) {
          var tempLast = null;
          var initLast = this.last.clone();
          var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);

          // Check every weekday in BYDAY with relative dow and pos.
          for (var i in this.by_data.BYDAY) {
            /* istanbul ignore if */
            if (!this.by_data.BYDAY.hasOwnProperty(i)) {
              continue;
            }
            this.last = initLast.clone();
            var bydayParts = this.ruleDayOfWeek(this.by_data.BYDAY[i]);
            var pos = bydayParts[0];
            var dow = bydayParts[1];
            var dayOfMonth = this.last.nthWeekDay(dow, pos);

            // If |pos| >= 6, the byday is invalid for a monthly rule.
            if (pos >= 6 || pos <= -6) {
              throw new Error("Malformed values in BYDAY part");
            }

            // If a Byday with pos=+/-5 is not in the current month it
            // must be searched in the next months.
            if (dayOfMonth > daysInMonth || dayOfMonth <= 0) {
              // Skip if we have already found a "last" in this month.
              if (tempLast && tempLast.month == initLast.month) {
                continue;
              }
              while (dayOfMonth > daysInMonth || dayOfMonth <= 0) {
                this.increment_month();
                daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);
                dayOfMonth = this.last.nthWeekDay(dow, pos);
              }
            }

            this.last.day = dayOfMonth;
            if (!tempLast || this.last.compare(tempLast) < 0) {
              tempLast = this.last.clone();
            }
          }
          this.last = tempLast.clone();

          //XXX: This feels like a hack, but we need to initialize
          //     the BYMONTHDAY case correctly and byDayAndMonthDay handles
          //     this case. It accepts a special flag which will avoid incrementing
          //     the initial value without the flag days that match the start time
          //     would be missed.
          if (this.has_by_data('BYMONTHDAY')) {
            this._byDayAndMonthDay(true);
          }

          if (this.last.day > daysInMonth || this.last.day == 0) {
            throw new Error("Malformed values in BYDAY part");
          }

        } else if (this.has_by_data("BYMONTHDAY")) {
          if (this.last.day < 0) {
            var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);
            this.last.day = daysInMonth + this.last.day + 1;
          }
        }

      },

      /**
       * Retrieve the next occurrence from the iterator.
       * @return {ICAL.Time}
       */
      next: function icalrecur_iterator_next() {
        var before = (this.last ? this.last.clone() : null);

        if ((this.rule.count && this.occurrence_number >= this.rule.count) ||
            (this.rule.until && this.last.compare(this.rule.until) > 0)) {

          //XXX: right now this is just a flag and has no impact
          //     we can simplify the above case to check for completed later.
          this.completed = true;

          return null;
        }

        if (this.occurrence_number == 0 && this.last.compare(this.dtstart) >= 0) {
          // First of all, give the instance that was initialized
          this.occurrence_number++;
          return this.last;
        }


        var valid;
        do {
          valid = 1;

          switch (this.rule.freq) {
          case "SECONDLY":
            this.next_second();
            break;
          case "MINUTELY":
            this.next_minute();
            break;
          case "HOURLY":
            this.next_hour();
            break;
          case "DAILY":
            this.next_day();
            break;
          case "WEEKLY":
            this.next_week();
            break;
          case "MONTHLY":
            valid = this.next_month();
            break;
          case "YEARLY":
            this.next_year();
            break;

          default:
            return null;
          }
        } while (!this.check_contracting_rules() ||
                 this.last.compare(this.dtstart) < 0 ||
                 !valid);

        // TODO is this valid?
        if (this.last.compare(before) == 0) {
          throw new Error("Same occurrence found twice, protecting " +
                          "you from death by recursion");
        }

        if (this.rule.until && this.last.compare(this.rule.until) > 0) {
          this.completed = true;
          return null;
        } else {
          this.occurrence_number++;
          return this.last;
        }
      },

      next_second: function next_second() {
        return this.next_generic("BYSECOND", "SECONDLY", "second", "minute");
      },

      increment_second: function increment_second(inc) {
        return this.increment_generic(inc, "second", 60, "minute");
      },

      next_minute: function next_minute() {
        return this.next_generic("BYMINUTE", "MINUTELY",
                                 "minute", "hour", "next_second");
      },

      increment_minute: function increment_minute(inc) {
        return this.increment_generic(inc, "minute", 60, "hour");
      },

      next_hour: function next_hour() {
        return this.next_generic("BYHOUR", "HOURLY", "hour",
                                 "monthday", "next_minute");
      },

      increment_hour: function increment_hour(inc) {
        this.increment_generic(inc, "hour", 24, "monthday");
      },

      next_day: function next_day() {
        ("BYDAY" in this.by_data);
        var this_freq = (this.rule.freq == "DAILY");

        if (this.next_hour() == 0) {
          return 0;
        }

        if (this_freq) {
          this.increment_monthday(this.rule.interval);
        } else {
          this.increment_monthday(1);
        }

        return 0;
      },

      next_week: function next_week() {
        var end_of_data = 0;

        if (this.next_weekday_by_week() == 0) {
          return end_of_data;
        }

        if (this.has_by_data("BYWEEKNO")) {
          ++this.by_indices.BYWEEKNO;

          if (this.by_indices.BYWEEKNO == this.by_data.BYWEEKNO.length) {
            this.by_indices.BYWEEKNO = 0;
            end_of_data = 1;
          }

          // HACK should be first month of the year
          this.last.month = 1;
          this.last.day = 1;

          var week_no = this.by_data.BYWEEKNO[this.by_indices.BYWEEKNO];

          this.last.day += 7 * week_no;

          if (end_of_data) {
            this.increment_year(1);
          }
        } else {
          // Jump to the next week
          this.increment_monthday(7 * this.rule.interval);
        }

        return end_of_data;
      },

      /**
       * Normalize each by day rule for a given year/month.
       * Takes into account ordering and negative rules
       *
       * @private
       * @param {Number} year         Current year.
       * @param {Number} month        Current month.
       * @param {Array}  rules        Array of rules.
       *
       * @return {Array} sorted and normalized rules.
       *                 Negative rules will be expanded to their
       *                 correct positive values for easier processing.
       */
      normalizeByMonthDayRules: function(year, month, rules) {
        var daysInMonth = ICAL.Time.daysInMonth(month, year);

        // XXX: This is probably bad for performance to allocate
        //      a new array for each month we scan, if possible
        //      we should try to optimize this...
        var newRules = [];

        var ruleIdx = 0;
        var len = rules.length;
        var rule;

        for (; ruleIdx < len; ruleIdx++) {
          rule = rules[ruleIdx];

          // if this rule falls outside of given
          // month discard it.
          if (Math.abs(rule) > daysInMonth) {
            continue;
          }

          // negative case
          if (rule < 0) {
            // we add (not subtract it is a negative number)
            // one from the rule because 1 === last day of month
            rule = daysInMonth + (rule + 1);
          } else if (rule === 0) {
            // skip zero: it is invalid.
            continue;
          }

          // only add unique items...
          if (newRules.indexOf(rule) === -1) {
            newRules.push(rule);
          }

        }

        // unique and sort
        return newRules.sort(function(a, b) { return a - b; });
      },

      /**
       * NOTES:
       * We are given a list of dates in the month (BYMONTHDAY) (23, etc..)
       * Also we are given a list of days (BYDAY) (MO, 2SU, etc..) when
       * both conditions match a given date (this.last.day) iteration stops.
       *
       * @private
       * @param {Boolean=} isInit     When given true will not increment the
       *                                current day (this.last).
       */
      _byDayAndMonthDay: function(isInit) {
        var byMonthDay; // setup in initMonth
        var byDay = this.by_data.BYDAY;

        var date;
        var dateIdx = 0;
        var dateLen; // setup in initMonth
        var dayLen = byDay.length;

        // we are not valid by default
        var dataIsValid = 0;

        var daysInMonth;
        var self = this;
        // we need a copy of this, because a DateTime gets normalized
        // automatically if the day is out of range. At some points we
        // set the last day to 0 to start counting.
        var lastDay = this.last.day;

        function initMonth() {
          daysInMonth = ICAL.Time.daysInMonth(
            self.last.month, self.last.year
          );

          byMonthDay = self.normalizeByMonthDayRules(
            self.last.year,
            self.last.month,
            self.by_data.BYMONTHDAY
          );

          dateLen = byMonthDay.length;

          // For the case of more than one occurrence in one month
          // we have to be sure to start searching after the last
          // found date or at the last BYMONTHDAY, unless we are
          // initializing the iterator because in this case we have
          // to consider the last found date too.
          while (byMonthDay[dateIdx] <= lastDay &&
                 !(isInit && byMonthDay[dateIdx] == lastDay) &&
                 dateIdx < dateLen - 1) {
            dateIdx++;
          }
        }

        function nextMonth() {
          // since the day is incremented at the start
          // of the loop below, we need to start at 0
          lastDay = 0;
          self.increment_month();
          dateIdx = 0;
          initMonth();
        }

        initMonth();

        // should come after initMonth
        if (isInit) {
          lastDay -= 1;
        }

        // Use a counter to avoid an infinite loop with malformed rules.
        // Stop checking after 4 years so we consider also a leap year.
        var monthsCounter = 48;

        while (!dataIsValid && monthsCounter) {
          monthsCounter--;
          // increment the current date. This is really
          // important otherwise we may fall into the infinite
          // loop trap. The initial date takes care of the case
          // where the current date is the date we are looking
          // for.
          date = lastDay + 1;

          if (date > daysInMonth) {
            nextMonth();
            continue;
          }

          // find next date
          var next = byMonthDay[dateIdx++];

          // this logic is dependant on the BYMONTHDAYS
          // being in order (which is done by #normalizeByMonthDayRules)
          if (next >= date) {
            // if the next month day is in the future jump to it.
            lastDay = next;
          } else {
            // in this case the 'next' monthday has past
            // we must move to the month.
            nextMonth();
            continue;
          }

          // Now we can loop through the day rules to see
          // if one matches the current month date.
          for (var dayIdx = 0; dayIdx < dayLen; dayIdx++) {
            var parts = this.ruleDayOfWeek(byDay[dayIdx]);
            var pos = parts[0];
            var dow = parts[1];

            this.last.day = lastDay;
            if (this.last.isNthWeekDay(dow, pos)) {
              // when we find the valid one we can mark
              // the conditions as met and break the loop.
              // (Because we have this condition above
              //  it will also break the parent loop).
              dataIsValid = 1;
              break;
            }
          }

          // It is completely possible that the combination
          // cannot be matched in the current month.
          // When we reach the end of possible combinations
          // in the current month we iterate to the next one.
          // since dateIdx is incremented right after getting
          // "next", we don't need dateLen -1 here.
          if (!dataIsValid && dateIdx === dateLen) {
            nextMonth();
            continue;
          }
        }

        if (monthsCounter <= 0) {
          // Checked 4 years without finding a Byday that matches
          // a Bymonthday. Maybe the rule is not correct.
          throw new Error("Malformed values in BYDAY combined with BYMONTHDAY parts");
        }


        return dataIsValid;
      },

      next_month: function next_month() {
        (this.rule.freq == "MONTHLY");
        var data_valid = 1;

        if (this.next_hour() == 0) {
          return data_valid;
        }

        if (this.has_by_data("BYDAY") && this.has_by_data("BYMONTHDAY")) {
          data_valid = this._byDayAndMonthDay();
        } else if (this.has_by_data("BYDAY")) {
          var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);
          var setpos = 0;
          var setpos_total = 0;

          if (this.has_by_data("BYSETPOS")) {
            var last_day = this.last.day;
            for (var day = 1; day <= daysInMonth; day++) {
              this.last.day = day;
              if (this.is_day_in_byday(this.last)) {
                setpos_total++;
                if (day <= last_day) {
                  setpos++;
                }
              }
            }
            this.last.day = last_day;
          }

          data_valid = 0;
          for (var day = this.last.day + 1; day <= daysInMonth; day++) {
            this.last.day = day;

            if (this.is_day_in_byday(this.last)) {
              if (!this.has_by_data("BYSETPOS") ||
                  this.check_set_position(++setpos) ||
                  this.check_set_position(setpos - setpos_total - 1)) {

                data_valid = 1;
                break;
              }
            }
          }

          if (day > daysInMonth) {
            this.last.day = 1;
            this.increment_month();

            if (this.is_day_in_byday(this.last)) {
              if (!this.has_by_data("BYSETPOS") || this.check_set_position(1)) {
                data_valid = 1;
              }
            } else {
              data_valid = 0;
            }
          }
        } else if (this.has_by_data("BYMONTHDAY")) {
          this.by_indices.BYMONTHDAY++;

          if (this.by_indices.BYMONTHDAY >= this.by_data.BYMONTHDAY.length) {
            this.by_indices.BYMONTHDAY = 0;
            this.increment_month();
          }

          var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);
          var day = this.by_data.BYMONTHDAY[this.by_indices.BYMONTHDAY];

          if (day < 0) {
            day = daysInMonth + day + 1;
          }

          if (day > daysInMonth) {
            this.last.day = 1;
            data_valid = this.is_day_in_byday(this.last);
          } else {
            this.last.day = day;
          }

        } else {
          this.increment_month();
          var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);
          if (this.by_data.BYMONTHDAY[0] > daysInMonth) {
            data_valid = 0;
          } else {
            this.last.day = this.by_data.BYMONTHDAY[0];
          }
        }

        return data_valid;
      },

      next_weekday_by_week: function next_weekday_by_week() {
        var end_of_data = 0;

        if (this.next_hour() == 0) {
          return end_of_data;
        }

        if (!this.has_by_data("BYDAY")) {
          return 1;
        }

        for (;;) {
          var tt = new ICAL.Time();
          this.by_indices.BYDAY++;

          if (this.by_indices.BYDAY == Object.keys(this.by_data.BYDAY).length) {
            this.by_indices.BYDAY = 0;
            end_of_data = 1;
          }

          var coded_day = this.by_data.BYDAY[this.by_indices.BYDAY];
          var parts = this.ruleDayOfWeek(coded_day);
          var dow = parts[1];

          dow -= this.rule.wkst;

          if (dow < 0) {
            dow += 7;
          }

          tt.year = this.last.year;
          tt.month = this.last.month;
          tt.day = this.last.day;

          var startOfWeek = tt.startDoyWeek(this.rule.wkst);

          if (dow + startOfWeek < 1) {
            // The selected date is in the previous year
            if (!end_of_data) {
              continue;
            }
          }

          var next = ICAL.Time.fromDayOfYear(startOfWeek + dow,
                                                    this.last.year);

          /**
           * The normalization horrors below are due to
           * the fact that when the year/month/day changes
           * it can effect the other operations that come after.
           */
          this.last.year = next.year;
          this.last.month = next.month;
          this.last.day = next.day;

          return end_of_data;
        }
      },

      next_year: function next_year() {

        if (this.next_hour() == 0) {
          return 0;
        }

        if (++this.days_index == this.days.length) {
          this.days_index = 0;
          do {
            this.increment_year(this.rule.interval);
            this.expand_year_days(this.last.year);
          } while (this.days.length == 0);
        }

        this._nextByYearDay();

        return 1;
      },

      _nextByYearDay: function _nextByYearDay() {
          var doy = this.days[this.days_index];
          var year = this.last.year;
          if (doy < 1) {
              // Time.fromDayOfYear(doy, year) indexes relative to the
              // start of the given year. That is different from the
              // semantics of BYYEARDAY where negative indexes are an
              // offset from the end of the given year.
              doy += 1;
              year += 1;
          }
          var next = ICAL.Time.fromDayOfYear(doy, year);
          this.last.day = next.day;
          this.last.month = next.month;
      },

      /**
       * @param dow (eg: '1TU', '-1MO')
       * @param {ICAL.Time.weekDay=} aWeekStart The week start weekday
       * @return [pos, numericDow] (eg: [1, 3]) numericDow is relative to aWeekStart
       */
      ruleDayOfWeek: function ruleDayOfWeek(dow, aWeekStart) {
        var matches = dow.match(/([+-]?[0-9])?(MO|TU|WE|TH|FR|SA|SU)/);
        if (matches) {
          var pos = parseInt(matches[1] || 0, 10);
          dow = ICAL.Recur.icalDayToNumericDay(matches[2], aWeekStart);
          return [pos, dow];
        } else {
          return [0, 0];
        }
      },

      next_generic: function next_generic(aRuleType, aInterval, aDateAttr,
                                          aFollowingAttr, aPreviousIncr) {
        var has_by_rule = (aRuleType in this.by_data);
        var this_freq = (this.rule.freq == aInterval);
        var end_of_data = 0;

        if (aPreviousIncr && this[aPreviousIncr]() == 0) {
          return end_of_data;
        }

        if (has_by_rule) {
          this.by_indices[aRuleType]++;
          this.by_indices[aRuleType];
          var dta = this.by_data[aRuleType];

          if (this.by_indices[aRuleType] == dta.length) {
            this.by_indices[aRuleType] = 0;
            end_of_data = 1;
          }
          this.last[aDateAttr] = dta[this.by_indices[aRuleType]];
        } else if (this_freq) {
          this["increment_" + aDateAttr](this.rule.interval);
        }

        if (has_by_rule && end_of_data && this_freq) {
          this["increment_" + aFollowingAttr](1);
        }

        return end_of_data;
      },

      increment_monthday: function increment_monthday(inc) {
        for (var i = 0; i < inc; i++) {
          var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);
          this.last.day++;

          if (this.last.day > daysInMonth) {
            this.last.day -= daysInMonth;
            this.increment_month();
          }
        }
      },

      increment_month: function increment_month() {
        this.last.day = 1;
        if (this.has_by_data("BYMONTH")) {
          this.by_indices.BYMONTH++;

          if (this.by_indices.BYMONTH == this.by_data.BYMONTH.length) {
            this.by_indices.BYMONTH = 0;
            this.increment_year(1);
          }

          this.last.month = this.by_data.BYMONTH[this.by_indices.BYMONTH];
        } else {
          if (this.rule.freq == "MONTHLY") {
            this.last.month += this.rule.interval;
          } else {
            this.last.month++;
          }

          this.last.month--;
          var years = ICAL.helpers.trunc(this.last.month / 12);
          this.last.month %= 12;
          this.last.month++;

          if (years != 0) {
            this.increment_year(years);
          }
        }
      },

      increment_year: function increment_year(inc) {
        this.last.year += inc;
      },

      increment_generic: function increment_generic(inc, aDateAttr,
                                                    aFactor, aNextIncrement) {
        this.last[aDateAttr] += inc;
        var nextunit = ICAL.helpers.trunc(this.last[aDateAttr] / aFactor);
        this.last[aDateAttr] %= aFactor;
        if (nextunit != 0) {
          this["increment_" + aNextIncrement](nextunit);
        }
      },

      has_by_data: function has_by_data(aRuleType) {
        return (aRuleType in this.rule.parts);
      },

      expand_year_days: function expand_year_days(aYear) {
        var t = new ICAL.Time();
        this.days = [];

        // We need our own copy with a few keys set
        var parts = {};
        var rules = ["BYDAY", "BYWEEKNO", "BYMONTHDAY", "BYMONTH", "BYYEARDAY"];
        for (var p in rules) {
          /* istanbul ignore else */
          if (rules.hasOwnProperty(p)) {
            var part = rules[p];
            if (part in this.rule.parts) {
              parts[part] = this.rule.parts[part];
            }
          }
        }

        if ("BYMONTH" in parts && "BYWEEKNO" in parts) {
          var valid = 1;
          var validWeeks = {};
          t.year = aYear;
          t.isDate = true;

          for (var monthIdx = 0; monthIdx < this.by_data.BYMONTH.length; monthIdx++) {
            var month = this.by_data.BYMONTH[monthIdx];
            t.month = month;
            t.day = 1;
            var first_week = t.weekNumber(this.rule.wkst);
            t.day = ICAL.Time.daysInMonth(month, aYear);
            var last_week = t.weekNumber(this.rule.wkst);
            for (monthIdx = first_week; monthIdx < last_week; monthIdx++) {
              validWeeks[monthIdx] = 1;
            }
          }

          for (var weekIdx = 0; weekIdx < this.by_data.BYWEEKNO.length && valid; weekIdx++) {
            var weekno = this.by_data.BYWEEKNO[weekIdx];
            if (weekno < 52) {
              valid &= validWeeks[weekIdx];
            } else {
              valid = 0;
            }
          }

          if (valid) {
            delete parts.BYMONTH;
          } else {
            delete parts.BYWEEKNO;
          }
        }

        var partCount = Object.keys(parts).length;

        if (partCount == 0) {
          var t1 = this.dtstart.clone();
          t1.year = this.last.year;
          this.days.push(t1.dayOfYear());
        } else if (partCount == 1 && "BYMONTH" in parts) {
          for (var monthkey in this.by_data.BYMONTH) {
            /* istanbul ignore if */
            if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {
              continue;
            }
            var t2 = this.dtstart.clone();
            t2.year = aYear;
            t2.month = this.by_data.BYMONTH[monthkey];
            t2.isDate = true;
            this.days.push(t2.dayOfYear());
          }
        } else if (partCount == 1 && "BYMONTHDAY" in parts) {
          for (var monthdaykey in this.by_data.BYMONTHDAY) {
            /* istanbul ignore if */
            if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {
              continue;
            }
            var t3 = this.dtstart.clone();
            var day_ = this.by_data.BYMONTHDAY[monthdaykey];
            if (day_ < 0) {
              var daysInMonth = ICAL.Time.daysInMonth(t3.month, aYear);
              day_ = day_ + daysInMonth + 1;
            }
            t3.day = day_;
            t3.year = aYear;
            t3.isDate = true;
            this.days.push(t3.dayOfYear());
          }
        } else if (partCount == 2 &&
                   "BYMONTHDAY" in parts &&
                   "BYMONTH" in parts) {
          for (var monthkey in this.by_data.BYMONTH) {
            /* istanbul ignore if */
            if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {
              continue;
            }
            var month_ = this.by_data.BYMONTH[monthkey];
            var daysInMonth = ICAL.Time.daysInMonth(month_, aYear);
            for (var monthdaykey in this.by_data.BYMONTHDAY) {
              /* istanbul ignore if */
              if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {
                continue;
              }
              var day_ = this.by_data.BYMONTHDAY[monthdaykey];
              if (day_ < 0) {
                day_ = day_ + daysInMonth + 1;
              }
              t.day = day_;
              t.month = month_;
              t.year = aYear;
              t.isDate = true;

              this.days.push(t.dayOfYear());
            }
          }
        } else if (partCount == 1 && "BYWEEKNO" in parts) ; else if (partCount == 2 &&
                   "BYWEEKNO" in parts &&
                   "BYMONTHDAY" in parts) ; else if (partCount == 1 && "BYDAY" in parts) {
          this.days = this.days.concat(this.expand_by_day(aYear));
        } else if (partCount == 2 && "BYDAY" in parts && "BYMONTH" in parts) {
          for (var monthkey in this.by_data.BYMONTH) {
            /* istanbul ignore if */
            if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {
              continue;
            }
            var month = this.by_data.BYMONTH[monthkey];
            var daysInMonth = ICAL.Time.daysInMonth(month, aYear);

            t.year = aYear;
            t.month = this.by_data.BYMONTH[monthkey];
            t.day = 1;
            t.isDate = true;

            var first_dow = t.dayOfWeek();
            var doy_offset = t.dayOfYear() - 1;

            t.day = daysInMonth;
            var last_dow = t.dayOfWeek();

            if (this.has_by_data("BYSETPOS")) {
              var by_month_day = [];
              for (var day = 1; day <= daysInMonth; day++) {
                t.day = day;
                if (this.is_day_in_byday(t)) {
                  by_month_day.push(day);
                }
              }

              for (var spIndex = 0; spIndex < by_month_day.length; spIndex++) {
                if (this.check_set_position(spIndex + 1) ||
                    this.check_set_position(spIndex - by_month_day.length)) {
                  this.days.push(doy_offset + by_month_day[spIndex]);
                }
              }
            } else {
              for (var daycodedkey in this.by_data.BYDAY) {
                /* istanbul ignore if */
                if (!this.by_data.BYDAY.hasOwnProperty(daycodedkey)) {
                  continue;
                }
                var coded_day = this.by_data.BYDAY[daycodedkey];
                var bydayParts = this.ruleDayOfWeek(coded_day);
                var pos = bydayParts[0];
                var dow = bydayParts[1];
                var month_day;

                var first_matching_day = ((dow + 7 - first_dow) % 7) + 1;
                var last_matching_day = daysInMonth - ((last_dow + 7 - dow) % 7);

                if (pos == 0) {
                  for (var day = first_matching_day; day <= daysInMonth; day += 7) {
                    this.days.push(doy_offset + day);
                  }
                } else if (pos > 0) {
                  month_day = first_matching_day + (pos - 1) * 7;

                  if (month_day <= daysInMonth) {
                    this.days.push(doy_offset + month_day);
                  }
                } else {
                  month_day = last_matching_day + (pos + 1) * 7;

                  if (month_day > 0) {
                    this.days.push(doy_offset + month_day);
                  }
                }
              }
            }
          }
          // Return dates in order of occurrence (1,2,3,...) instead
          // of by groups of weekdays (1,8,15,...,2,9,16,...).
          this.days.sort(function(a, b) { return a - b; }); // Comparator function allows to sort numbers.
        } else if (partCount == 2 && "BYDAY" in parts && "BYMONTHDAY" in parts) {
          var expandedDays = this.expand_by_day(aYear);

          for (var daykey in expandedDays) {
            /* istanbul ignore if */
            if (!expandedDays.hasOwnProperty(daykey)) {
              continue;
            }
            var day = expandedDays[daykey];
            var tt = ICAL.Time.fromDayOfYear(day, aYear);
            if (this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {
              this.days.push(day);
            }
          }
        } else if (partCount == 3 &&
                   "BYDAY" in parts &&
                   "BYMONTHDAY" in parts &&
                   "BYMONTH" in parts) {
          var expandedDays = this.expand_by_day(aYear);

          for (var daykey in expandedDays) {
            /* istanbul ignore if */
            if (!expandedDays.hasOwnProperty(daykey)) {
              continue;
            }
            var day = expandedDays[daykey];
            var tt = ICAL.Time.fromDayOfYear(day, aYear);

            if (this.by_data.BYMONTH.indexOf(tt.month) >= 0 &&
                this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {
              this.days.push(day);
            }
          }
        } else if (partCount == 2 && "BYDAY" in parts && "BYWEEKNO" in parts) {
          var expandedDays = this.expand_by_day(aYear);

          for (var daykey in expandedDays) {
            /* istanbul ignore if */
            if (!expandedDays.hasOwnProperty(daykey)) {
              continue;
            }
            var day = expandedDays[daykey];
            var tt = ICAL.Time.fromDayOfYear(day, aYear);
            var weekno = tt.weekNumber(this.rule.wkst);

            if (this.by_data.BYWEEKNO.indexOf(weekno)) {
              this.days.push(day);
            }
          }
        } else if (partCount == 3 &&
                   "BYDAY" in parts &&
                   "BYWEEKNO" in parts &&
                   "BYMONTHDAY" in parts) ; else if (partCount == 1 && "BYYEARDAY" in parts) {
          this.days = this.days.concat(this.by_data.BYYEARDAY);
        } else {
          this.days = [];
        }
        return 0;
      },

      expand_by_day: function expand_by_day(aYear) {

        var days_list = [];
        var tmp = this.last.clone();

        tmp.year = aYear;
        tmp.month = 1;
        tmp.day = 1;
        tmp.isDate = true;

        var start_dow = tmp.dayOfWeek();

        tmp.month = 12;
        tmp.day = 31;
        tmp.isDate = true;

        var end_dow = tmp.dayOfWeek();
        var end_year_day = tmp.dayOfYear();

        for (var daykey in this.by_data.BYDAY) {
          /* istanbul ignore if */
          if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {
            continue;
          }
          var day = this.by_data.BYDAY[daykey];
          var parts = this.ruleDayOfWeek(day);
          var pos = parts[0];
          var dow = parts[1];

          if (pos == 0) {
            var tmp_start_doy = ((dow + 7 - start_dow) % 7) + 1;

            for (var doy = tmp_start_doy; doy <= end_year_day; doy += 7) {
              days_list.push(doy);
            }

          } else if (pos > 0) {
            var first;
            if (dow >= start_dow) {
              first = dow - start_dow + 1;
            } else {
              first = dow - start_dow + 8;
            }

            days_list.push(first + (pos - 1) * 7);
          } else {
            var last;
            pos = -pos;

            if (dow <= end_dow) {
              last = end_year_day - end_dow + dow;
            } else {
              last = end_year_day - end_dow + dow - 7;
            }

            days_list.push(last - (pos - 1) * 7);
          }
        }
        return days_list;
      },

      is_day_in_byday: function is_day_in_byday(tt) {
        for (var daykey in this.by_data.BYDAY) {
          /* istanbul ignore if */
          if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {
            continue;
          }
          var day = this.by_data.BYDAY[daykey];
          var parts = this.ruleDayOfWeek(day);
          var pos = parts[0];
          var dow = parts[1];
          var this_dow = tt.dayOfWeek();

          if ((pos == 0 && dow == this_dow) ||
              (tt.nthWeekDay(dow, pos) == tt.day)) {
            return 1;
          }
        }

        return 0;
      },

      /**
       * Checks if given value is in BYSETPOS.
       *
       * @private
       * @param {Numeric} aPos position to check for.
       * @return {Boolean} false unless BYSETPOS rules exist
       *                   and the given value is present in rules.
       */
      check_set_position: function check_set_position(aPos) {
        if (this.has_by_data('BYSETPOS')) {
          var idx = this.by_data.BYSETPOS.indexOf(aPos);
          // negative numbers are not false-y
          return idx !== -1;
        }
        return false;
      },

      sort_byday_rules: function icalrecur_sort_byday_rules(aRules) {
        for (var i = 0; i < aRules.length; i++) {
          for (var j = 0; j < i; j++) {
            var one = this.ruleDayOfWeek(aRules[j], this.rule.wkst)[1];
            var two = this.ruleDayOfWeek(aRules[i], this.rule.wkst)[1];

            if (one > two) {
              var tmp = aRules[i];
              aRules[i] = aRules[j];
              aRules[j] = tmp;
            }
          }
        }
      },

      check_contract_restriction: function check_contract_restriction(aRuleType, v) {
        var indexMapValue = icalrecur_iterator._indexMap[aRuleType];
        var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];
        var pass = false;

        if (aRuleType in this.by_data &&
            ruleMapValue == icalrecur_iterator.CONTRACT) {

          var ruleType = this.by_data[aRuleType];

          for (var bydatakey in ruleType) {
            /* istanbul ignore else */
            if (ruleType.hasOwnProperty(bydatakey)) {
              if (ruleType[bydatakey] == v) {
                pass = true;
                break;
              }
            }
          }
        } else {
          // Not a contracting byrule or has no data, test passes
          pass = true;
        }
        return pass;
      },

      check_contracting_rules: function check_contracting_rules() {
        var dow = this.last.dayOfWeek();
        var weekNo = this.last.weekNumber(this.rule.wkst);
        var doy = this.last.dayOfYear();

        return (this.check_contract_restriction("BYSECOND", this.last.second) &&
                this.check_contract_restriction("BYMINUTE", this.last.minute) &&
                this.check_contract_restriction("BYHOUR", this.last.hour) &&
                this.check_contract_restriction("BYDAY", ICAL.Recur.numericDayToIcalDay(dow)) &&
                this.check_contract_restriction("BYWEEKNO", weekNo) &&
                this.check_contract_restriction("BYMONTHDAY", this.last.day) &&
                this.check_contract_restriction("BYMONTH", this.last.month) &&
                this.check_contract_restriction("BYYEARDAY", doy));
      },

      setup_defaults: function setup_defaults(aRuleType, req, deftime) {
        var indexMapValue = icalrecur_iterator._indexMap[aRuleType];
        var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];

        if (ruleMapValue != icalrecur_iterator.CONTRACT) {
          if (!(aRuleType in this.by_data)) {
            this.by_data[aRuleType] = [deftime];
          }
          if (this.rule.freq != req) {
            return this.by_data[aRuleType][0];
          }
        }
        return deftime;
      },

      /**
       * Convert iterator into a serialize-able object.  Will preserve current
       * iteration sequence to ensure the seamless continuation of the recurrence
       * rule.
       * @return {Object}
       */
      toJSON: function() {
        var result = Object.create(null);

        result.initialized = this.initialized;
        result.rule = this.rule.toJSON();
        result.dtstart = this.dtstart.toJSON();
        result.by_data = this.by_data;
        result.days = this.days;
        result.last = this.last.toJSON();
        result.by_indices = this.by_indices;
        result.occurrence_number = this.occurrence_number;

        return result;
      }
    };

    icalrecur_iterator._indexMap = {
      "BYSECOND": 0,
      "BYMINUTE": 1,
      "BYHOUR": 2,
      "BYDAY": 3,
      "BYMONTHDAY": 4,
      "BYYEARDAY": 5,
      "BYWEEKNO": 6,
      "BYMONTH": 7,
      "BYSETPOS": 8
    };

    icalrecur_iterator._expandMap = {
      "SECONDLY": [1, 1, 1, 1, 1, 1, 1, 1],
      "MINUTELY": [2, 1, 1, 1, 1, 1, 1, 1],
      "HOURLY": [2, 2, 1, 1, 1, 1, 1, 1],
      "DAILY": [2, 2, 2, 1, 1, 1, 1, 1],
      "WEEKLY": [2, 2, 2, 2, 3, 3, 1, 1],
      "MONTHLY": [2, 2, 2, 2, 2, 3, 3, 1],
      "YEARLY": [2, 2, 2, 2, 2, 2, 2, 2]
    };
    icalrecur_iterator.UNKNOWN = 0;
    icalrecur_iterator.CONTRACT = 1;
    icalrecur_iterator.EXPAND = 2;
    icalrecur_iterator.ILLEGAL = 3;

    return icalrecur_iterator;

  }());
  /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at http://mozilla.org/MPL/2.0/.
   * Portions Copyright (C) Philipp Kewisch, 2011-2015 */


  /**
   * This symbol is further described later on
   * @ignore
   */
  ICAL.RecurExpansion = (function() {
    function formatTime(item) {
      return ICAL.helpers.formatClassType(item, ICAL.Time);
    }

    function compareTime(a, b) {
      return a.compare(b);
    }

    function isRecurringComponent(comp) {
      return comp.hasProperty('rdate') ||
             comp.hasProperty('rrule') ||
             comp.hasProperty('recurrence-id');
    }

    /**
     * @classdesc
     * Primary class for expanding recurring rules.  Can take multiple rrules,
     * rdates, exdate(s) and iterate (in order) over each next occurrence.
     *
     * Once initialized this class can also be serialized saved and continue
     * iteration from the last point.
     *
     * NOTE: it is intended that this class is to be used
     *       with ICAL.Event which handles recurrence exceptions.
     *
     * @example
     * // assuming event is a parsed ical component
     * var event;
     *
     * var expand = new ICAL.RecurExpansion({
     *   component: event,
     *   dtstart: event.getFirstPropertyValue('dtstart')
     * });
     *
     * // remember there are infinite rules
     * // so it is a good idea to limit the scope
     * // of the iterations then resume later on.
     *
     * // next is always an ICAL.Time or null
     * var next;
     *
     * while (someCondition && (next = expand.next())) {
     *   // do something with next
     * }
     *
     * // save instance for later
     * var json = JSON.stringify(expand);
     *
     * //...
     *
     * // NOTE: if the component's properties have
     * //       changed you will need to rebuild the
     * //       class and start over. This only works
     * //       when the component's recurrence info is the same.
     * var expand = new ICAL.RecurExpansion(JSON.parse(json));
     *
     * @description
     * The options object can be filled with the specified initial values. It can
     * also contain additional members, as a result of serializing a previous
     * expansion state, as shown in the example.
     *
     * @class
     * @alias ICAL.RecurExpansion
     * @param {Object} options
     *        Recurrence expansion options
     * @param {ICAL.Time} options.dtstart
     *        Start time of the event
     * @param {ICAL.Component=} options.component
     *        Component for expansion, required if not resuming.
     */
    function RecurExpansion(options) {
      this.ruleDates = [];
      this.exDates = [];
      this.fromData(options);
    }

    RecurExpansion.prototype = {
      /**
       * True when iteration is fully completed.
       * @type {Boolean}
       */
      complete: false,

      /**
       * Array of rrule iterators.
       *
       * @type {ICAL.RecurIterator[]}
       * @private
       */
      ruleIterators: null,

      /**
       * Array of rdate instances.
       *
       * @type {ICAL.Time[]}
       * @private
       */
      ruleDates: null,

      /**
       * Array of exdate instances.
       *
       * @type {ICAL.Time[]}
       * @private
       */
      exDates: null,

      /**
       * Current position in ruleDates array.
       * @type {Number}
       * @private
       */
      ruleDateInc: 0,

      /**
       * Current position in exDates array
       * @type {Number}
       * @private
       */
      exDateInc: 0,

      /**
       * Current negative date.
       *
       * @type {ICAL.Time}
       * @private
       */
      exDate: null,

      /**
       * Current additional date.
       *
       * @type {ICAL.Time}
       * @private
       */
      ruleDate: null,

      /**
       * Start date of recurring rules.
       *
       * @type {ICAL.Time}
       */
      dtstart: null,

      /**
       * Last expanded time
       *
       * @type {ICAL.Time}
       */
      last: null,

      /**
       * Initialize the recurrence expansion from the data object. The options
       * object may also contain additional members, see the
       * {@link ICAL.RecurExpansion constructor} for more details.
       *
       * @param {Object} options
       *        Recurrence expansion options
       * @param {ICAL.Time} options.dtstart
       *        Start time of the event
       * @param {ICAL.Component=} options.component
       *        Component for expansion, required if not resuming.
       */
      fromData: function(options) {
        var start = ICAL.helpers.formatClassType(options.dtstart, ICAL.Time);

        if (!start) {
          throw new Error('.dtstart (ICAL.Time) must be given');
        } else {
          this.dtstart = start;
        }

        if (options.component) {
          this._init(options.component);
        } else {
          this.last = formatTime(options.last) || start.clone();

          if (!options.ruleIterators) {
            throw new Error('.ruleIterators or .component must be given');
          }

          this.ruleIterators = options.ruleIterators.map(function(item) {
            return ICAL.helpers.formatClassType(item, ICAL.RecurIterator);
          });

          this.ruleDateInc = options.ruleDateInc;
          this.exDateInc = options.exDateInc;

          if (options.ruleDates) {
            this.ruleDates = options.ruleDates.map(formatTime);
            this.ruleDate = this.ruleDates[this.ruleDateInc];
          }

          if (options.exDates) {
            this.exDates = options.exDates.map(formatTime);
            this.exDate = this.exDates[this.exDateInc];
          }

          if (typeof(options.complete) !== 'undefined') {
            this.complete = options.complete;
          }
        }
      },

      /**
       * Retrieve the next occurrence in the series.
       * @return {ICAL.Time}
       */
      next: function() {
        var iter;
        var next;
        var compare;

        var maxTries = 500;
        var currentTry = 0;

        while (true) {
          if (currentTry++ > maxTries) {
            throw new Error(
              'max tries have occured, rule may be impossible to forfill.'
            );
          }

          next = this.ruleDate;
          iter = this._nextRecurrenceIter(this.last);

          // no more matches
          // because we increment the rule day or rule
          // _after_ we choose a value this should be
          // the only spot where we need to worry about the
          // end of events.
          if (!next && !iter) {
            // there are no more iterators or rdates
            this.complete = true;
            break;
          }

          // no next rule day or recurrence rule is first.
          if (!next || (iter && next.compare(iter.last) > 0)) {
            // must be cloned, recur will reuse the time element.
            next = iter.last.clone();
            // move to next so we can continue
            iter.next();
          }

          // if the ruleDate is still next increment it.
          if (this.ruleDate === next) {
            this._nextRuleDay();
          }

          this.last = next;

          // check the negative rules
          if (this.exDate) {
            compare = this.exDate.compare(this.last);

            if (compare < 0) {
              this._nextExDay();
            }

            // if the current rule is excluded skip it.
            if (compare === 0) {
              this._nextExDay();
              continue;
            }
          }

          //XXX: The spec states that after we resolve the final
          //     list of dates we execute exdate this seems somewhat counter
          //     intuitive to what I have seen most servers do so for now
          //     I exclude based on the original date not the one that may
          //     have been modified by the exception.
          return this.last;
        }
      },

      /**
       * Converts object into a serialize-able format. This format can be passed
       * back into the expansion to resume iteration.
       * @return {Object}
       */
      toJSON: function() {
        function toJSON(item) {
          return item.toJSON();
        }

        var result = Object.create(null);
        result.ruleIterators = this.ruleIterators.map(toJSON);

        if (this.ruleDates) {
          result.ruleDates = this.ruleDates.map(toJSON);
        }

        if (this.exDates) {
          result.exDates = this.exDates.map(toJSON);
        }

        result.ruleDateInc = this.ruleDateInc;
        result.exDateInc = this.exDateInc;
        result.last = this.last.toJSON();
        result.dtstart = this.dtstart.toJSON();
        result.complete = this.complete;

        return result;
      },

      /**
       * Extract all dates from the properties in the given component. The
       * properties will be filtered by the property name.
       *
       * @private
       * @param {ICAL.Component} component        The component to search in
       * @param {String} propertyName             The property name to search for
       * @return {ICAL.Time[]}                    The extracted dates.
       */
      _extractDates: function(component, propertyName) {
        function handleProp(prop) {
          idx = ICAL.helpers.binsearchInsert(
            result,
            prop,
            compareTime
          );

          // ordered insert
          result.splice(idx, 0, prop);
        }

        var result = [];
        var props = component.getAllProperties(propertyName);
        var len = props.length;
        var i = 0;

        var idx;

        for (; i < len; i++) {
          props[i].getValues().forEach(handleProp);
        }

        return result;
      },

      /**
       * Initialize the recurrence expansion.
       *
       * @private
       * @param {ICAL.Component} component    The component to initialize from.
       */
      _init: function(component) {
        this.ruleIterators = [];

        this.last = this.dtstart.clone();

        // to provide api consistency non-recurring
        // events can also use the iterator though it will
        // only return a single time.
        if (!isRecurringComponent(component)) {
          this.ruleDate = this.last.clone();
          this.complete = true;
          return;
        }

        if (component.hasProperty('rdate')) {
          this.ruleDates = this._extractDates(component, 'rdate');

          // special hack for cases where first rdate is prior
          // to the start date. We only check for the first rdate.
          // This is mostly for google's crazy recurring date logic
          // (contacts birthdays).
          if ((this.ruleDates[0]) &&
              (this.ruleDates[0].compare(this.dtstart) < 0)) {

            this.ruleDateInc = 0;
            this.last = this.ruleDates[0].clone();
          } else {
            this.ruleDateInc = ICAL.helpers.binsearchInsert(
              this.ruleDates,
              this.last,
              compareTime
            );
          }

          this.ruleDate = this.ruleDates[this.ruleDateInc];
        }

        if (component.hasProperty('rrule')) {
          var rules = component.getAllProperties('rrule');
          var i = 0;
          var len = rules.length;

          var rule;
          var iter;

          for (; i < len; i++) {
            rule = rules[i].getFirstValue();
            iter = rule.iterator(this.dtstart);
            this.ruleIterators.push(iter);

            // increment to the next occurrence so future
            // calls to next return times beyond the initial iteration.
            // XXX: I find this suspicious might be a bug?
            iter.next();
          }
        }

        if (component.hasProperty('exdate')) {
          this.exDates = this._extractDates(component, 'exdate');
          // if we have a .last day we increment the index to beyond it.
          this.exDateInc = ICAL.helpers.binsearchInsert(
            this.exDates,
            this.last,
            compareTime
          );

          this.exDate = this.exDates[this.exDateInc];
        }
      },

      /**
       * Advance to the next exdate
       * @private
       */
      _nextExDay: function() {
        this.exDate = this.exDates[++this.exDateInc];
      },

      /**
       * Advance to the next rule date
       * @private
       */
      _nextRuleDay: function() {
        this.ruleDate = this.ruleDates[++this.ruleDateInc];
      },

      /**
       * Find and return the recurrence rule with the most recent event and
       * return it.
       *
       * @private
       * @return {?ICAL.RecurIterator}    Found iterator.
       */
      _nextRecurrenceIter: function() {
        var iters = this.ruleIterators;

        if (iters.length === 0) {
          return null;
        }

        var len = iters.length;
        var iter;
        var iterTime;
        var iterIdx = 0;
        var chosenIter;

        // loop through each iterator
        for (; iterIdx < len; iterIdx++) {
          iter = iters[iterIdx];
          iterTime = iter.last;

          // if iteration is complete
          // then we must exclude it from
          // the search and remove it.
          if (iter.completed) {
            len--;
            if (iterIdx !== 0) {
              iterIdx--;
            }
            iters.splice(iterIdx, 1);
            continue;
          }

          // find the most recent possible choice
          if (!chosenIter || chosenIter.last.compare(iterTime) > 0) {
            // that iterator is saved
            chosenIter = iter;
          }
        }

        // the chosen iterator is returned but not mutated
        // this iterator contains the most recent event.
        return chosenIter;
      }
    };

    return RecurExpansion;
  }());
  /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at http://mozilla.org/MPL/2.0/.
   * Portions Copyright (C) Philipp Kewisch, 2011-2015 */


  /**
   * This symbol is further described later on
   * @ignore
   */
  ICAL.Event = (function() {

    /**
     * @classdesc
     * ICAL.js is organized into multiple layers. The bottom layer is a raw jCal
     * object, followed by the component/property layer. The highest level is the
     * event representation, which this class is part of. See the
     * {@tutorial layers} guide for more details.
     *
     * @class
     * @alias ICAL.Event
     * @param {ICAL.Component=} component         The ICAL.Component to base this event on
     * @param {Object} options                    Options for this event
     * @param {Boolean} options.strictExceptions
     *          When true, will verify exceptions are related by their UUID
     * @param {Array<ICAL.Component|ICAL.Event>} options.exceptions
     *          Exceptions to this event, either as components or events. If not
     *            specified exceptions will automatically be set in relation of
     *            component's parent
     */
    function Event(component, options) {
      if (!(component instanceof ICAL.Component)) {
        options = component;
        component = null;
      }

      if (component) {
        this.component = component;
      } else {
        this.component = new ICAL.Component('vevent');
      }

      this._rangeExceptionCache = Object.create(null);
      this.exceptions = Object.create(null);
      this.rangeExceptions = [];

      if (options && options.strictExceptions) {
        this.strictExceptions = options.strictExceptions;
      }

      if (options && options.exceptions) {
        options.exceptions.forEach(this.relateException, this);
      } else if (this.component.parent && !this.isRecurrenceException()) {
        this.component.parent.getAllSubcomponents('vevent').forEach(function(event) {
          if (event.hasProperty('recurrence-id')) {
            this.relateException(event);
          }
        }, this);
      }
    }

    Event.prototype = {

      THISANDFUTURE: 'THISANDFUTURE',

      /**
       * List of related event exceptions.
       *
       * @type {ICAL.Event[]}
       */
      exceptions: null,

      /**
       * When true, will verify exceptions are related by their UUID.
       *
       * @type {Boolean}
       */
      strictExceptions: false,

      /**
       * Relates a given event exception to this object.  If the given component
       * does not share the UID of this event it cannot be related and will throw
       * an exception.
       *
       * If this component is an exception it cannot have other exceptions
       * related to it.
       *
       * @param {ICAL.Component|ICAL.Event} obj       Component or event
       */
      relateException: function(obj) {
        if (this.isRecurrenceException()) {
          throw new Error('cannot relate exception to exceptions');
        }

        if (obj instanceof ICAL.Component) {
          obj = new ICAL.Event(obj);
        }

        if (this.strictExceptions && obj.uid !== this.uid) {
          throw new Error('attempted to relate unrelated exception');
        }

        var id = obj.recurrenceId.toString();

        // we don't sort or manage exceptions directly
        // here the recurrence expander handles that.
        this.exceptions[id] = obj;

        // index RANGE=THISANDFUTURE exceptions so we can
        // look them up later in getOccurrenceDetails.
        if (obj.modifiesFuture()) {
          var item = [
            obj.recurrenceId.toUnixTime(), id
          ];

          // we keep them sorted so we can find the nearest
          // value later on...
          var idx = ICAL.helpers.binsearchInsert(
            this.rangeExceptions,
            item,
            compareRangeException
          );

          this.rangeExceptions.splice(idx, 0, item);
        }
      },

      /**
       * Checks if this record is an exception and has the RANGE=THISANDFUTURE
       * value.
       *
       * @return {Boolean}        True, when exception is within range
       */
      modifiesFuture: function() {
        if (!this.component.hasProperty('recurrence-id')) {
          return false;
        }

        var range = this.component.getFirstProperty('recurrence-id').getParameter('range');
        return range === this.THISANDFUTURE;
      },

      /**
       * Finds the range exception nearest to the given date.
       *
       * @param {ICAL.Time} time usually an occurrence time of an event
       * @return {?ICAL.Event} the related event/exception or null
       */
      findRangeException: function(time) {
        if (!this.rangeExceptions.length) {
          return null;
        }

        var utc = time.toUnixTime();
        var idx = ICAL.helpers.binsearchInsert(
          this.rangeExceptions,
          [utc],
          compareRangeException
        );

        idx -= 1;

        // occurs before
        if (idx < 0) {
          return null;
        }

        var rangeItem = this.rangeExceptions[idx];

        /* istanbul ignore next: sanity check only */
        if (utc < rangeItem[0]) {
          return null;
        }

        return rangeItem[1];
      },

      /**
       * This object is returned by {@link ICAL.Event#getOccurrenceDetails getOccurrenceDetails}
       *
       * @typedef {Object} occurrenceDetails
       * @memberof ICAL.Event
       * @property {ICAL.Time} recurrenceId       The passed in recurrence id
       * @property {ICAL.Event} item              The occurrence
       * @property {ICAL.Time} startDate          The start of the occurrence
       * @property {ICAL.Time} endDate            The end of the occurrence
       */

      /**
       * Returns the occurrence details based on its start time.  If the
       * occurrence has an exception will return the details for that exception.
       *
       * NOTE: this method is intend to be used in conjunction
       *       with the {@link ICAL.Event#iterator iterator} method.
       *
       * @param {ICAL.Time} occurrence time occurrence
       * @return {ICAL.Event.occurrenceDetails} Information about the occurrence
       */
      getOccurrenceDetails: function(occurrence) {
        var id = occurrence.toString();
        var utcId = occurrence.convertToZone(ICAL.Timezone.utcTimezone).toString();
        var item;
        var result = {
          //XXX: Clone?
          recurrenceId: occurrence
        };

        if (id in this.exceptions) {
          item = result.item = this.exceptions[id];
          result.startDate = item.startDate;
          result.endDate = item.endDate;
          result.item = item;
        } else if (utcId in this.exceptions) {
          item = this.exceptions[utcId];
          result.startDate = item.startDate;
          result.endDate = item.endDate;
          result.item = item;
        } else {
          // range exceptions (RANGE=THISANDFUTURE) have a
          // lower priority then direct exceptions but
          // must be accounted for first. Their item is
          // always the first exception with the range prop.
          var rangeExceptionId = this.findRangeException(
            occurrence
          );
          var end;

          if (rangeExceptionId) {
            var exception = this.exceptions[rangeExceptionId];

            // range exception must modify standard time
            // by the difference (if any) in start/end times.
            result.item = exception;

            var startDiff = this._rangeExceptionCache[rangeExceptionId];

            if (!startDiff) {
              var original = exception.recurrenceId.clone();
              var newStart = exception.startDate.clone();

              // zones must be same otherwise subtract may be incorrect.
              original.zone = newStart.zone;
              startDiff = newStart.subtractDate(original);

              this._rangeExceptionCache[rangeExceptionId] = startDiff;
            }

            var start = occurrence.clone();
            start.zone = exception.startDate.zone;
            start.addDuration(startDiff);

            end = start.clone();
            end.addDuration(exception.duration);

            result.startDate = start;
            result.endDate = end;
          } else {
            // no range exception standard expansion
            end = occurrence.clone();
            end.addDuration(this.duration);

            result.endDate = end;
            result.startDate = occurrence;
            result.item = this;
          }
        }

        return result;
      },

      /**
       * Builds a recur expansion instance for a specific point in time (defaults
       * to startDate).
       *
       * @param {ICAL.Time} startTime     Starting point for expansion
       * @return {ICAL.RecurExpansion}    Expansion object
       */
      iterator: function(startTime) {
        return new ICAL.RecurExpansion({
          component: this.component,
          dtstart: startTime || this.startDate
        });
      },

      /**
       * Checks if the event is recurring
       *
       * @return {Boolean}        True, if event is recurring
       */
      isRecurring: function() {
        var comp = this.component;
        return comp.hasProperty('rrule') || comp.hasProperty('rdate');
      },

      /**
       * Checks if the event describes a recurrence exception. See
       * {@tutorial terminology} for details.
       *
       * @return {Boolean}    True, if the event describes a recurrence exception
       */
      isRecurrenceException: function() {
        return this.component.hasProperty('recurrence-id');
      },

      /**
       * Returns the types of recurrences this event may have.
       *
       * Returned as an object with the following possible keys:
       *
       *    - YEARLY
       *    - MONTHLY
       *    - WEEKLY
       *    - DAILY
       *    - MINUTELY
       *    - SECONDLY
       *
       * @return {Object.<ICAL.Recur.frequencyValues, Boolean>}
       *          Object of recurrence flags
       */
      getRecurrenceTypes: function() {
        var rules = this.component.getAllProperties('rrule');
        var i = 0;
        var len = rules.length;
        var result = Object.create(null);

        for (; i < len; i++) {
          var value = rules[i].getFirstValue();
          result[value.freq] = true;
        }

        return result;
      },

      /**
       * The uid of this event
       * @type {String}
       */
      get uid() {
        return this._firstProp('uid');
      },

      set uid(value) {
        this._setProp('uid', value);
      },

      /**
       * The start date
       * @type {ICAL.Time}
       */
      get startDate() {
        return this._firstProp('dtstart');
      },

      set startDate(value) {
        this._setTime('dtstart', value);
      },

      /**
       * The end date. This can be the result directly from the property, or the
       * end date calculated from start date and duration. Setting the property
       * will remove any duration properties.
       * @type {ICAL.Time}
       */
      get endDate() {
        var endDate = this._firstProp('dtend');
        if (!endDate) {
            var duration = this._firstProp('duration');
            endDate = this.startDate.clone();
            if (duration) {
                endDate.addDuration(duration);
            } else if (endDate.isDate) {
                endDate.day += 1;
            }
        }
        return endDate;
      },

      set endDate(value) {
        if (this.component.hasProperty('duration')) {
          this.component.removeProperty('duration');
        }
        this._setTime('dtend', value);
      },

      /**
       * The duration. This can be the result directly from the property, or the
       * duration calculated from start date and end date. Setting the property
       * will remove any `dtend` properties.
       * @type {ICAL.Duration}
       */
      get duration() {
        var duration = this._firstProp('duration');
        if (!duration) {
          return this.endDate.subtractDateTz(this.startDate);
        }
        return duration;
      },

      set duration(value) {
        if (this.component.hasProperty('dtend')) {
          this.component.removeProperty('dtend');
        }

        this._setProp('duration', value);
      },

      /**
       * The location of the event.
       * @type {String}
       */
      get location() {
        return this._firstProp('location');
      },

      set location(value) {
        return this._setProp('location', value);
      },

      /**
       * The attendees in the event
       * @type {ICAL.Property[]}
       * @readonly
       */
      get attendees() {
        //XXX: This is way lame we should have a better
        //     data structure for this later.
        return this.component.getAllProperties('attendee');
      },


      /**
       * The event summary
       * @type {String}
       */
      get summary() {
        return this._firstProp('summary');
      },

      set summary(value) {
        this._setProp('summary', value);
      },

      /**
       * The event description.
       * @type {String}
       */
      get description() {
        return this._firstProp('description');
      },

      set description(value) {
        this._setProp('description', value);
      },

      /**
       * The event color from [rfc7986](https://datatracker.ietf.org/doc/html/rfc7986)
       * @type {String}
       */
      get color() {
        return this._firstProp('color');
      },

      set color(value) {
        this._setProp('color', value);
      },

      /**
       * The organizer value as an uri. In most cases this is a mailto: uri, but
       * it can also be something else, like urn:uuid:...
       * @type {String}
       */
      get organizer() {
        return this._firstProp('organizer');
      },

      set organizer(value) {
        this._setProp('organizer', value);
      },

      /**
       * The sequence value for this event. Used for scheduling
       * see {@tutorial terminology}.
       * @type {Number}
       */
      get sequence() {
        return this._firstProp('sequence');
      },

      set sequence(value) {
        this._setProp('sequence', value);
      },

      /**
       * The recurrence id for this event. See {@tutorial terminology} for details.
       * @type {ICAL.Time}
       */
      get recurrenceId() {
        return this._firstProp('recurrence-id');
      },

      set recurrenceId(value) {
        this._setTime('recurrence-id', value);
      },

      /**
       * Set/update a time property's value.
       * This will also update the TZID of the property.
       *
       * TODO: this method handles the case where we are switching
       * from a known timezone to an implied timezone (one without TZID).
       * This does _not_ handle the case of moving between a known
       *  (by TimezoneService) timezone to an unknown timezone...
       *
       * We will not add/remove/update the VTIMEZONE subcomponents
       *  leading to invalid ICAL data...
       * @private
       * @param {String} propName     The property name
       * @param {ICAL.Time} time      The time to set
       */
      _setTime: function(propName, time) {
        var prop = this.component.getFirstProperty(propName);

        if (!prop) {
          prop = new ICAL.Property(propName);
          this.component.addProperty(prop);
        }

        // utc and local don't get a tzid
        if (
          time.zone === ICAL.Timezone.localTimezone ||
          time.zone === ICAL.Timezone.utcTimezone
        ) {
          // remove the tzid
          prop.removeParameter('tzid');
        } else {
          prop.setParameter('tzid', time.zone.tzid);
        }

        prop.setValue(time);
      },

      _setProp: function(name, value) {
        this.component.updatePropertyWithValue(name, value);
      },

      _firstProp: function(name) {
        return this.component.getFirstPropertyValue(name);
      },

      /**
       * The string representation of this event.
       * @return {String}
       */
      toString: function() {
        return this.component.toString();
      }

    };

    function compareRangeException(a, b) {
      if (a[0] > b[0]) return 1;
      if (b[0] > a[0]) return -1;
      return 0;
    }

    return Event;
  }());
  /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at http://mozilla.org/MPL/2.0/.
   * Portions Copyright (C) Philipp Kewisch, 2011-2015 */


  /**
   * This symbol is further described later on
   * @ignore
   */
  ICAL.ComponentParser = (function() {
    /**
     * @classdesc
     * The ComponentParser is used to process a String or jCal Object,
     * firing callbacks for various found components, as well as completion.
     *
     * @example
     * var options = {
     *   // when false no events will be emitted for type
     *   parseEvent: true,
     *   parseTimezone: true
     * };
     *
     * var parser = new ICAL.ComponentParser(options);
     *
     * parser.onevent(eventComponent) {
     *   //...
     * }
     *
     * // ontimezone, etc...
     *
     * parser.oncomplete = function() {
     *
     * };
     *
     * parser.process(stringOrComponent);
     *
     * @class
     * @alias ICAL.ComponentParser
     * @param {Object=} options        Component parser options
     * @param {Boolean} options.parseEvent        Whether events should be parsed
     * @param {Boolean} options.parseTimezeone    Whether timezones should be parsed
     */
    function ComponentParser(options) {
      if (typeof(options) === 'undefined') {
        options = {};
      }

      var key;
      for (key in options) {
        /* istanbul ignore else */
        if (options.hasOwnProperty(key)) {
          this[key] = options[key];
        }
      }
    }

    ComponentParser.prototype = {

      /**
       * When true, parse events
       *
       * @type {Boolean}
       */
      parseEvent: true,

      /**
       * When true, parse timezones
       *
       * @type {Boolean}
       */
      parseTimezone: true,


      /* SAX like events here for reference */

      /**
       * Fired when parsing is complete
       * @callback
       */
      oncomplete: /* istanbul ignore next */ function() {},

      /**
       * Fired if an error occurs during parsing.
       *
       * @callback
       * @param {Error} err details of error
       */
      onerror: /* istanbul ignore next */ function(err) {},

      /**
       * Fired when a top level component (VTIMEZONE) is found
       *
       * @callback
       * @param {ICAL.Timezone} component     Timezone object
       */
      ontimezone: /* istanbul ignore next */ function(component) {},

      /**
       * Fired when a top level component (VEVENT) is found.
       *
       * @callback
       * @param {ICAL.Event} component    Top level component
       */
      onevent: /* istanbul ignore next */ function(component) {},

      /**
       * Process a string or parse ical object.  This function itself will return
       * nothing but will start the parsing process.
       *
       * Events must be registered prior to calling this method.
       *
       * @param {ICAL.Component|String|Object} ical      The component to process,
       *        either in its final form, as a jCal Object, or string representation
       */
      process: function(ical) {
        //TODO: this is sync now in the future we will have a incremental parser.
        if (typeof(ical) === 'string') {
          ical = ICAL.parse(ical);
        }

        if (!(ical instanceof ICAL.Component)) {
          ical = new ICAL.Component(ical);
        }

        var components = ical.getAllSubcomponents();
        var i = 0;
        var len = components.length;
        var component;

        for (; i < len; i++) {
          component = components[i];

          switch (component.name) {
            case 'vtimezone':
              if (this.parseTimezone) {
                var tzid = component.getFirstPropertyValue('tzid');
                if (tzid) {
                  this.ontimezone(new ICAL.Timezone({
                    tzid: tzid,
                    component: component
                  }));
                }
              }
              break;
            case 'vevent':
              if (this.parseEvent) {
                this.onevent(new ICAL.Event(component));
              }
              break;
            default:
              continue;
          }
        }

        //XXX: ideally we should do a "nextTick" here
        //     so in all cases this is actually async.
        this.oncomplete();
      }
    };

    return ComponentParser;
  }());
  });

  /* eslint-disable */
  class IcalExpander {
      constructor(opts) {
          this.maxIterations = opts.maxIterations != null ? opts.maxIterations : 1000;
          this.skipInvalidDates = opts.skipInvalidDates != null ? opts.skipInvalidDates : false;
          this.jCalData = ical.parse(opts.ics);
          this.component = new ical.Component(this.jCalData);
          this.events = this.component.getAllSubcomponents('vevent').map(vevent => new ical.Event(vevent));
          if (this.skipInvalidDates) {
              this.events = this.events.filter((evt) => {
                  try {
                      evt.startDate.toJSDate();
                      evt.endDate.toJSDate();
                      return true;
                  }
                  catch (err) {
                      // skipping events with invalid time
                      return false;
                  }
              });
          }
      }
      between(after, before) {
          function isEventWithinRange(startTime, endTime) {
              return (!after || endTime >= after.getTime()) &&
                  (!before || startTime <= before.getTime());
          }
          function getTimes(eventOrOccurrence) {
              const startTime = eventOrOccurrence.startDate.toJSDate().getTime();
              let endTime = eventOrOccurrence.endDate.toJSDate().getTime();
              // If it is an all day event, the end date is set to 00:00 of the next day
              // So we need to make it be 23:59:59 to compare correctly with the given range
              if (eventOrOccurrence.endDate.isDate && (endTime > startTime)) {
                  endTime -= 1;
              }
              return { startTime, endTime };
          }
          const exceptions = [];
          this.events.forEach((event) => {
              if (event.isRecurrenceException())
                  exceptions.push(event);
          });
          const ret = {
              events: [],
              occurrences: [],
          };
          this.events.filter(e => !e.isRecurrenceException()).forEach((event) => {
              const exdates = [];
              event.component.getAllProperties('exdate').forEach((exdateProp) => {
                  const exdate = exdateProp.getFirstValue();
                  exdates.push(exdate.toJSDate().getTime());
              });
              // Recurring event is handled differently
              if (event.isRecurring()) {
                  const iterator = event.iterator();
                  let next;
                  let i = 0;
                  do {
                      i += 1;
                      next = iterator.next();
                      if (next) {
                          const occurrence = event.getOccurrenceDetails(next);
                          const { startTime, endTime } = getTimes(occurrence);
                          const isOccurrenceExcluded = exdates.indexOf(startTime) !== -1;
                          // TODO check that within same day?
                          const exception = exceptions.find(ex => ex.uid === event.uid && ex.recurrenceId.toJSDate().getTime() === occurrence.startDate.toJSDate().getTime());
                          // We have passed the max date, stop
                          if (before && startTime > before.getTime())
                              break;
                          // Check that we are within our range
                          if (isEventWithinRange(startTime, endTime)) {
                              if (exception) {
                                  ret.events.push(exception);
                              }
                              else if (!isOccurrenceExcluded) {
                                  ret.occurrences.push(occurrence);
                              }
                          }
                      }
                  } while (next && (!this.maxIterations || i < this.maxIterations));
                  return;
              }
              // Non-recurring event:
              const { startTime, endTime } = getTimes(event);
              if (isEventWithinRange(startTime, endTime))
                  ret.events.push(event);
          });
          return ret;
      }
      before(before) {
          return this.between(undefined, before);
      }
      after(after) {
          return this.between(after);
      }
      all() {
          return this.between();
      }
  }

  const eventSourceDef = {
      parseMeta(refined) {
          if (refined.url && refined.format === 'ics') {
              return {
                  url: refined.url,
                  format: 'ics',
              };
          }
          return null;
      },
      fetch(arg, successCallback, errorCallback) {
          let meta = arg.eventSource.meta;
          let { internalState } = meta;
          /*
          NOTE: isRefetch is a HACK. we would do the recurring-expanding in a separate plugin hook,
          but we couldn't leverage built-in allDay-guessing, among other things.
          */
          if (!internalState || arg.isRefetch) {
              internalState = meta.internalState = {
                  response: null,
                  iCalExpanderPromise: fetch(meta.url, { method: 'GET' }).then((response) => {
                      return response.text().then((icsText) => {
                          internalState.response = response;
                          return new IcalExpander({
                              ics: icsText,
                              skipInvalidDates: true,
                          });
                      });
                  }),
              };
          }
          internalState.iCalExpanderPromise.then((iCalExpander) => {
              successCallback({
                  rawEvents: expandICalEvents(iCalExpander, arg.range),
                  response: internalState.response,
              });
          }, errorCallback);
      },
  };
  function expandICalEvents(iCalExpander, range) {
      // expand the range. because our `range` is timeZone-agnostic UTC
      // or maybe because ical.js always produces dates in local time? i forget
      let rangeStart = addDays(range.start, -1);
      let rangeEnd = addDays(range.end, 1);
      let iCalRes = iCalExpander.between(rangeStart, rangeEnd); // end inclusive. will give extra results
      let expanded = [];
      // TODO: instead of using startDate/endDate.toString to communicate allDay,
      // we can query startDate/endDate.isDate. More efficient to avoid formatting/reparsing.
      // single events
      for (let iCalEvent of iCalRes.events) {
          expanded.push(Object.assign(Object.assign({}, buildNonDateProps(iCalEvent)), { start: iCalEvent.startDate.toString(), end: (specifiesEnd(iCalEvent) && iCalEvent.endDate)
                  ? iCalEvent.endDate.toString()
                  : null }));
      }
      // recurring event instances
      for (let iCalOccurence of iCalRes.occurrences) {
          let iCalEvent = iCalOccurence.item;
          expanded.push(Object.assign(Object.assign({}, buildNonDateProps(iCalEvent)), { start: iCalOccurence.startDate.toString(), end: (specifiesEnd(iCalEvent) && iCalOccurence.endDate)
                  ? iCalOccurence.endDate.toString()
                  : null }));
      }
      return expanded;
  }
  function buildNonDateProps(iCalEvent) {
      return {
          title: iCalEvent.summary,
          url: extractEventUrl(iCalEvent),
          extendedProps: {
              location: iCalEvent.location,
              organizer: iCalEvent.organizer,
              description: iCalEvent.description,
          },
      };
  }
  function extractEventUrl(iCalEvent) {
      let urlProp = iCalEvent.component.getFirstProperty('url');
      return urlProp ? urlProp.getFirstValue() : '';
  }
  function specifiesEnd(iCalEvent) {
      return Boolean(iCalEvent.component.getFirstProperty('dtend')) ||
          Boolean(iCalEvent.component.getFirstProperty('duration'));
  }

  var index = createPlugin({
      name: '@fullcalendar/icalendar',
      eventSourceDefs: [eventSourceDef],
  });

  var alldayEvent = `BEGIN:VCALENDAR
VERSION:2.0
CALSCALE:GREGORIAN
METHOD:PUBLISH
X-WR-CALNAME:events@fullcalendar.test
X-WR-TIMEZONE:Europe/Paris
BEGIN:VEVENT
DTSTART;VALUE=DATE:20190415
DTSTAMP:20201006T124223Z
UID:1234578
CREATED:20190408T110429Z
DESCRIPTION:this is the description
URL:https://fullcalendar.io/
LAST-MODIFIED:20190409T110738Z
LOCATION:this is the location
SEQUENCE:0
STATUS:CONFIRMED
SUMMARY:First conference
TRANSP:OPAQUE
END:VEVENT
END:VCALENDAR`;

  var multidayEvent = `BEGIN:VCALENDAR
VERSION:2.0
CALSCALE:GREGORIAN
METHOD:PUBLISH
X-WR-CALNAME:events@fullcalendar.test
X-WR-TIMEZONE:Europe/Paris
BEGIN:VEVENT
DTSTART;VALUE=DATE:20190410
DTSTAMP:20201006T124223Z
DTEND;VALUE=DATE:20190413
UID:1234578
CREATED:20190408T110429Z
DESCRIPTION:
LAST-MODIFIED:20190409T110738Z
LOCATION:
SEQUENCE:0
STATUS:CONFIRMED
SUMMARY:First conference
TRANSP:OPAQUE
END:VEVENT
END:VCALENDAR`;

  var multipleMultidayEvents = `BEGIN:VCALENDAR
VERSION:2.0
CALSCALE:GREGORIAN
METHOD:PUBLISH
X-WR-CALNAME:events@fullcalendar.test
X-WR-TIMEZONE:Europe/Paris
BEGIN:VEVENT
DTSTART;VALUE=DATE:20190410
DTEND;VALUE=DATE:20190413
DTSTAMP:20201006T124223Z
UID:1234578
CREATED:20190408T110429Z
DESCRIPTION:
LAST-MODIFIED:20190409T110738Z
LOCATION:
SEQUENCE:0
STATUS:CONFIRMED
SUMMARY:First conference
TRANSP:OPAQUE
END:VEVENT
BEGIN:VEVENT
DTSTART;VALUE=DATE:20190416
DTEND;VALUE=DATE:20190417
DTSTAMP:20201008T153019Z
UID:1234578
DTSTAMP:20201008T153019Z
DESCRIPTION:
LAST-MODIFIED:20190409T110738Z
LOCATION:
SEQUENCE:0
STATUS:CONFIRMED
SUMMARY:Second conference
TRANSP:OPAQUE
END:VEVENT
END:VCALENDAR`;

  var multipleEventsOneMunged = `BEGIN:VCALENDAR
VERSION:2.0
CALSCALE:GREGORIAN
METHOD:PUBLISH
X-WR-CALNAME:events@fullcalendar.test
X-WR-TIMEZONE:Europe/Paris
BEGIN:VEVENT
DTEND;VALUE=DATE:20190413
DTSTAMP:20201006T124223Z
UID:1234578
CREATED:20190408T110429Z
DESCRIPTION:
LAST-MODIFIED:20190409T110738Z
LOCATION:
SEQUENCE:0
STATUS:CONFIRMED
SUMMARY:Munged conference (No DTSTART)
TRANSP:OPAQUE
END:VEVENT
BEGIN:VEVENT
DTSTART;VALUE=DATE:20190416
DTEND;VALUE=DATE:20190417
DTSTAMP:20201008T153019Z
UID:1234578
DTSTAMP:20201008T153019Z
DESCRIPTION:
LAST-MODIFIED:20190409T110738Z
LOCATION:
SEQUENCE:0
STATUS:CONFIRMED
SUMMARY:Valid conference
TRANSP:OPAQUE
END:VEVENT
END:VCALENDAR`;

  var oneHourMeeting = `BEGIN:VCALENDAR
VERSION:2.0
CALSCALE:GREGORIAN
METHOD:PUBLISH
X-WR-CALNAME:events@fullcalendar.test
X-WR-TIMEZONE:Europe/Paris
BEGIN:VEVENT
DTSTART:20190415T093000Z
DTEND:20190415T103000Z
DTSTAMP:20201006T124223Z
UID:12345678
ATTENDEE;CUTYPE=INDIVIDUAL;ROLE=REQ-PARTICIPANT;PARTSTAT=ACCEPTED;CN=test@fullcalendar.test;X-NUM-GUESTS=0:mailto:test@fullcalendar.test
CREATED:20190412T223947Z
DESCRIPTION:
LAST-MODIFIED:20190412T223947Z
LOCATION:
SEQUENCE:0
STATUS:CONFIRMED
SUMMARY:Hour long meeting
TRANSP:OPAQUE
END:VEVENT
END:VCALENDAR`;

  var recurringWeekly = `BEGIN:VCALENDAR
VERSION:2.0
CALSCALE:GREGORIAN
METHOD:PUBLISH
X-WR-CALNAME:events@fullcalendar.test
X-WR-TIMEZONE:Europe/Paris
BEGIN:VEVENT
DTSTART;TZID=Europe/Zurich:20190401T173000
DTEND;TZID=Europe/Zurich:20190401T183000
RRULE:FREQ=WEEKLY;WKST=MO;BYDAY=MO
DTSTAMP:20201006T124223Z
ORGANIZER;CN=Testy McTestface:mailto:test@fullcalendar.test
UID:12345678
CREATED:20181210T150458Z
DESCRIPTION:this is the description
URL:https://fullcalendar.io/
LAST-MODIFIED:20190508T170523Z
LOCATION:this is the location
SEQUENCE:0
STATUS:CONFIRMED
SUMMARY:Weekly Monday meeting
TRANSP:OPAQUE
END:VEVENT
END:VCALENDAR`;

  var recurringWeeklyWithoutEnd = `BEGIN:VCALENDAR
VERSION:2.0
CALSCALE:GREGORIAN
METHOD:PUBLISH
X-WR-CALNAME:events@fullcalendar.test
X-WR-TIMEZONE:Europe/Paris
BEGIN:VEVENT
DTSTART;TZID=Europe/Zurich:20190401T173000
RRULE:FREQ=WEEKLY;WKST=MO;BYDAY=MO
DTSTAMP:20201006T124223Z
ORGANIZER;CN=Testy McTestface:mailto:test@fullcalendar.test
UID:12345678
CREATED:20181210T150458Z
DESCRIPTION:
LAST-MODIFIED:20190508T170523Z
LOCATION:
SEQUENCE:0
STATUS:CONFIRMED
SUMMARY:Weekly Monday meeting
TRANSP:OPAQUE
END:VEVENT
END:VCALENDAR`;

  var recurringWeeklyWithCount = `BEGIN:VCALENDAR
VERSION:2.0
CALSCALE:GREGORIAN
METHOD:PUBLISH
X-WR-CALNAME:events@fullcalendar.test
X-WR-TIMEZONE:Europe/Paris
BEGIN:VEVENT
DTSTART;TZID=Europe/Zurich:20190301T173000
DTEND;TZID=Europe/Zurich:20190301T183000
RRULE:FREQ=WEEKLY;WKST=MO;BYDAY=MO;COUNT=9
DTSTAMP:20201006T124223Z
ORGANIZER;CN=Testy McTestface:mailto:test@fullcalendar.test
UID:12345678
CREATED:20181210T150458Z
DESCRIPTION:
LAST-MODIFIED:20190508T170523Z
LOCATION:
SEQUENCE:0
STATUS:CONFIRMED
SUMMARY:Weekly Monday meeting
TRANSP:OPAQUE
END:VEVENT
END:VCALENDAR`;

  var mungedOneHourMeeting = `BEGIN:VCALENDAR
VERSION:2.0
CALSCALE:GREGORIAN
METHOD:PUBLISH
X-WR-CALNAME:events@fullcalendar.test
X-WR-TIMEZONE:Europe/Paris
BEGIN:VEVENT
DTEND:20190415T109900Z
DTSTAMP:20201006T124223Z
UID:12345678
ATTENDEE;CUTYPE=INDIVIDUAL;ROLE=REQ-PARTICIPANT;PARTSTAT=ACCEPTED;CN=test@fullcalendar.test;X-NUM-GUESTS=0:mailto:test@fullcalendar.test
CREATED:20190412T223947Z
DESCRIPTION:
LAST-MODIFIED:20190412T223947Z
LOCATION:
SEQUENCE:0
STATUS:CONFIRMED
SUMMARY:Munged meeting (No DTSTART)
TRANSP:OPAQUE
END:VEVENT
END:VCALENDAR`;

  describe('addICalEventSource with month view', () => {
      const ICAL_MIME_TYPE = 'text/calendar';
      pushOptions({
          plugins: [index, index$a],
          initialDate: '2019-04-10',
          initialView: 'dayGridMonth',
      });
      afterEach(() => {
          client.restore();
      });
      it('adds an all day event', (done) => {
          loadICalendarWith(alldayEvent, () => {
              setTimeout(() => {
                  let events = currentCalendar.getEvents();
                  expect(events[0].end).toBe(null);
                  events.forEach((event) => expect(event.allDay).toBeTruthy());
                  assertEventCount(1);
                  done();
              }, 100);
          });
      });
      it('adds a single multi-day event', (done) => {
          loadICalendarWith(multidayEvent, () => {
              setTimeout(() => {
                  assertEventCount(1);
                  currentCalendar.getEvents().forEach((event) => expect(event.allDay).toBeTruthy());
                  done();
              }, 100);
          });
      });
      it('adds multiple multi-day events', (done) => {
          loadICalendarWith(multipleMultidayEvents, () => {
              setTimeout(() => {
                  assertEventCount(2);
                  currentCalendar.getEvents().forEach((event) => expect(event.allDay).toBeTruthy());
                  done();
              }, 100);
          });
      });
      it('adds a one-hour long meeting', (done) => {
          loadICalendarWith(oneHourMeeting, () => {
              setTimeout(() => {
                  let events = currentCalendar.getEvents();
                  expect(events[0].start).toEqualDate('2019-04-15T09:30:00');
                  expect(events[0].end).toEqualDate('2019-04-15T10:30:00');
                  assertEventCount(1);
                  currentCalendar.getEvents().forEach((event) => expect(event.allDay).not.toBeTruthy());
                  done();
              }, 100);
          });
      });
      it('adds a repeating weekly meeting', (done) => {
          loadICalendarWith(recurringWeekly, () => {
              setTimeout(() => {
                  let events = currentCalendar.getEvents();
                  expect(events[0].start).toEqualDate('2019-04-01T17:30:00');
                  expect(events[0].end).toEqualDate('2019-04-01T18:30:00');
                  assertEventCount(6);
                  done();
              }, 100);
          });
      });
      it('adds a repeating weekly meeting, with null end', (done) => {
          loadICalendarWith(recurringWeeklyWithoutEnd, () => {
              setTimeout(() => {
                  let events = currentCalendar.getEvents();
                  expect(events[0].start).toEqualDate('2019-04-01T17:30:00');
                  expect(events[0].end).toBe(null);
                  assertEventCount(6);
                  done();
              }, 100);
          });
      });
      // https://github.com/fullcalendar/fullcalendar/issues/6190
      // this feed starts at beginning of previous month (March 2019) and has 9 total occurences,
      // 5 of which will be visible in the current month (April 2019)
      it('adds a repeating weekly meeting, limited by COUNT, but across months', (done) => {
          loadICalendarWith(recurringWeeklyWithCount, () => {
              setTimeout(() => {
                  assertEventCount(5);
                  done();
              }, 100);
          });
      });
      it('ignores a munged event', (done) => {
          loadICalendarWith(mungedOneHourMeeting, () => {
              setTimeout(() => {
                  assertEventCount(0);
                  done();
              }, 100);
          });
      });
      it('adds a valid event and ignores a munged event', (done) => {
          loadICalendarWith(multipleEventsOneMunged, () => {
              setTimeout(() => {
                  assertEventCount(1);
                  done();
              }, 100);
          });
      });
      it('defaultAllDayEventDuration overrides ical default all day length of one day', (done) => {
          loadICalendarWith(alldayEvent, () => {
              setTimeout(() => {
                  assertEventCount(1);
                  const event = currentCalendar.getEvents()[0];
                  expect(event.end.getDate()).toEqual(event.start.getDate() + 2);
                  done();
              }, 100);
          }, (source) => {
              initCalendar({
                  forceEventDuration: true,
                  defaultAllDayEventDuration: { days: 2 },
              }).addEventSource(source);
          });
      });
      it('calling refetchEvents request ical feed again', (done) => {
          let requestCnt = 0;
          const givenUrl = window.location.href + '/my-feed.php';
          client.get(/my-feed\.php/, () => {
              requestCnt++;
              return {
                  headers: { 'content-type': ICAL_MIME_TYPE },
                  body: oneHourMeeting,
              };
          });
          const calendar = initCalendar({
              events: {
                  url: givenUrl,
                  format: 'ics',
              },
          });
          setTimeout(() => {
              expect(requestCnt).toBe(1);
              expect(calendar.getEvents().length).toBe(1);
              calendar.refetchEvents();
              setTimeout(() => {
                  expect(requestCnt).toBe(2);
                  expect(calendar.getEvents().length).toBe(1);
                  done();
              }, 100);
          }, 100);
      });
      function loadICalendarWith(rawICal, assertions, calendarSetup) {
          const givenUrl = window.location.href + '/my-feed.php';
          client.get(/my-feed\.php/, {
              headers: { 'content-type': ICAL_MIME_TYPE },
              body: rawICal,
          });
          const source = { url: givenUrl, format: 'ics' };
          if (calendarSetup) {
              calendarSetup(source);
          }
          else {
              initCalendar().addEventSource(source);
          }
          const [requestUrl] = client.lastCall();
          const requestParamStr = new URL(requestUrl).searchParams.toString();
          expect(requestParamStr).toBe('');
          assertions();
      }
      // Checks to make sure all events have been rendered and that the calendar
      // has internal info on all the events.
      // TODO: don't use currentCalendar
      function assertEventCount(expectedCount) {
          expect(currentCalendar.getEvents().length).toEqual(expectedCount);
          let calendarWrapper = new CalendarWrapper(currentCalendar);
          expect(calendarWrapper.getEventEls().length).toEqual(expectedCount);
      }
  });

  var meetingWithMungedStart = `BEGIN:VCALENDAR
VERSION:2.0
CALSCALE:GREGORIAN
METHOD:PUBLISH
X-WR-CALNAME:events@fullcalendar.test
X-WR-TIMEZONE:Europe/Paris
BEGIN:VEVENT
DTSTART:20190415TRRRRRRZ
DTEND:20190415T109900Z
DTSTAMP:20201006T124223Z
UID:12345678
ATTENDEE;CUTYPE=INDIVIDUAL;ROLE=REQ-PARTICIPANT;PARTSTAT=ACCEPTED;CN=test@fullcalendar.test;X-NUM-GUESTS=0:mailto:test@fullcalendar.test
CREATED:20190412T223947Z
DESCRIPTION:
LAST-MODIFIED:20190412T223947Z
LOCATION:
SEQUENCE:0
STATUS:CONFIRMED
SUMMARY:Munged meeting (No DTSTART)
TRANSP:OPAQUE
END:VEVENT
END:VCALENDAR`;

  var timedMeetingWithoutEnd = `BEGIN:VCALENDAR
VERSION:2.0
CALSCALE:GREGORIAN
METHOD:PUBLISH
X-WR-CALNAME:events@fullcalendar.test
X-WR-TIMEZONE:Europe/Paris
BEGIN:VEVENT
DTSTART:20190415T093000Z
DTSTAMP:20201006T124223Z
UID:12345678
ATTENDEE;CUTYPE=INDIVIDUAL;ROLE=REQ-PARTICIPANT;PARTSTAT=ACCEPTED;CN=test@fullcalendar.test;X-NUM-GUESTS=0:mailto:test@fullcalendar.test
CREATED:20190412T223947Z
DESCRIPTION:
LAST-MODIFIED:20190412T223947Z
LOCATION:
SEQUENCE:0
STATUS:CONFIRMED
SUMMARY:Hour long meeting
TRANSP:OPAQUE
END:VEVENT
END:VCALENDAR`;

  var timedMeetingWithDuration = `BEGIN:VCALENDAR
VERSION:2.0
CALSCALE:GREGORIAN
METHOD:PUBLISH
X-WR-CALNAME:events@fullcalendar.test
X-WR-TIMEZONE:Europe/Paris
BEGIN:VEVENT
DTSTART:20190415T093000Z
DURATION:PT4H
DTSTAMP:20201006T124223Z
UID:12345678
ATTENDEE;CUTYPE=INDIVIDUAL;ROLE=REQ-PARTICIPANT;PARTSTAT=ACCEPTED;CN=test@fullcalendar.test;X-NUM-GUESTS=0:mailto:test@fullcalendar.test
CREATED:20190412T223947Z
DESCRIPTION:
LAST-MODIFIED:20190412T223947Z
LOCATION:
SEQUENCE:0
STATUS:CONFIRMED
SUMMARY:Hour long meeting
TRANSP:OPAQUE
END:VEVENT
END:VCALENDAR`;

  var dataWithRecurrenceId = `BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//vereinify.com//NONSGML kigkonsult.se iCalcreator 2.39.1//
CALSCALE:GREGORIAN
METHOD:PUBLISH
UID:3ddaed11-9b03-4b3b-a90b-4aa1b8742fff
REFRESH-INTERVAL;VALUE=DURATION:PT15M
X-WR-CALNAME:Example
X-WR-CALDESC:Description
X-WR-RELCALID:3ddaed11-9b03-4b3b-a90b-4aa1b8742fff
X-WR-TIMEZONE:Europe/Berlin
X-LIC-LOCATION:Europe/Berlin
X-PUBLISHED-TTL:PT15M:
BEGIN:VTIMEZONE
TZID:Europe/Berlin
BEGIN:STANDARD
TZNAME:CET
DTSTART:20201025T030000
TZOFFSETFROM:+0200
TZOFFSETTO:+0100
RDATE:20211031T030000
RDATE:20221030T030000
END:STANDARD
BEGIN:DAYLIGHT
TZNAME:CEST
DTSTART:20210328T020000
TZOFFSETFROM:+0100
TZOFFSETTO:+0200
RDATE:20220327T020000
END:DAYLIGHT
END:VTIMEZONE
BEGIN:VEVENT
UID:af80d1e9-2adb-4e06-8483-3130c18305b1
DTSTAMP:20210713T065637Z
CLASS:PUBLIC
CREATED:20210712T150845Z
DTSTART;TZID=Europe/Berlin:20210705T140000
DTEND;TZID=Europe/Berlin:20210705T143000
EXDATE;TZID=Europe/Berlin:20210713T140000
EXDATE;TZID=Europe/Berlin:20210715T140000
LAST-MODIFIED:20210712T150845Z
RRULE:FREQ=DAILY
SEQUENCE:1
SUMMARY:Daily Recurring
TRANSP:OPAQUE
END:VEVENT
BEGIN:VEVENT
UID:af80d1e9-2adb-4e06-8483-3130c18305b1
DTSTAMP:20210713T065637Z
CLASS:PUBLIC
CREATED:20210712T150845Z
DTSTART;TZID=Europe/Berlin:20210708T141500
DTEND;TZID=Europe/Berlin:20210708T144500
LAST-MODIFIED:20210712T150845Z
RECURRENCE-ID;TZID=Europe/Berlin:20210708T140000
SEQUENCE:0
SUMMARY:Daily Recurring (Update-1)
TRANSP:OPAQUE
END:VEVENT
END:VCALENDAR`;

  describe('addICalEventSource with day view', () => {
      const ICAL_MIME_TYPE = 'text/calendar';
      pushOptions({
          plugins: [index, index$9],
          initialDate: '2019-04-15',
          initialView: 'timeGridDay',
          timeZone: 'Europe/Paris',
      });
      afterEach(() => {
          client.restore();
      });
      it('adds a one-hour long meeting', (done) => {
          loadICalendarWith(oneHourMeeting, () => {
              setTimeout(() => {
                  assertEventCount(1);
                  done();
              }, 100);
          });
      });
      it('adds a repeating weekly meeting', (done) => {
          loadICalendarWith(recurringWeekly, () => {
              setTimeout(() => {
                  assertEventCount(1);
                  const event = currentCalendar.getEvents()[0];
                  // test non-date props
                  expect(event.title).toBe('Weekly Monday meeting');
                  expect(event.url).toBe('https://fullcalendar.io/');
                  expect(event.extendedProps.description).toBe('this is the description');
                  expect(event.extendedProps.location).toBe('this is the location');
                  done();
              }, 100);
          });
      });
      it('adds an all day event', (done) => {
          loadICalendarWith(alldayEvent, () => {
              setTimeout(() => {
                  assertEventCount(1);
                  const events = currentCalendar.getEvents();
                  events.forEach((event) => expect(event.allDay).toBeTruthy());
                  // test non-date props
                  expect(events[0].title).toBe('First conference');
                  expect(events[0].url).toBe('https://fullcalendar.io/');
                  expect(events[0].extendedProps.description).toBe('this is the description');
                  expect(events[0].extendedProps.location).toBe('this is the location');
                  done();
              }, 100);
          });
      });
      it('ignores a munged event', (done) => {
          loadICalendarWith(mungedOneHourMeeting, () => {
              setTimeout(() => {
                  assertEventCount(0);
                  done();
              }, 100);
          });
      });
      it('ignores a meeting with a munged start', (done) => {
          loadICalendarWith(meetingWithMungedStart, () => {
              setTimeout(() => {
                  assertEventCount(0);
                  done();
              }, 100);
          });
      });
      it('sets default duration when forceEventDuration is enabled and no end or duration included in the VEVENT', (done) => {
          loadICalendarWith(timedMeetingWithoutEnd, () => {
              setTimeout(() => {
                  assertEventCount(1);
                  const event = currentCalendar.getEvents()[0];
                  expect(event.end.getHours()).toEqual(event.start.getHours() + 3);
                  done();
              }, 100);
          }, (source) => {
              initCalendar({
                  forceEventDuration: true,
                  defaultTimedEventDuration: '03:00',
              }).addEventSource(source);
          });
      });
      it('sets end to null when forceEventDuration is disabled and no end or duration included in the VEVENT', (done) => {
          loadICalendarWith(timedMeetingWithoutEnd, () => {
              setTimeout(() => {
                  assertEventCount(1);
                  const event = currentCalendar.getEvents()[0];
                  expect(event.end).toBe(null);
                  done();
              }, 100);
          }, (source) => {
              initCalendar({
                  defaultTimedEventDuration: '03:00',
                  forceEventDuration: false,
              }).addEventSource(source);
          });
      });
      it('does not override iCal DURATION in VEVENT', (done) => {
          loadICalendarWith(timedMeetingWithDuration, () => {
              setTimeout(() => {
                  assertEventCount(1);
                  const event = currentCalendar.getEvents()[0];
                  expect(event.end.getHours()).toEqual(event.start.getHours() + 4);
                  done();
              }, 100);
          }, (source) => {
              initCalendar({
                  forceEventDuration: true,
                  defaultTimedEventDuration: '03:00',
              }).addEventSource(source);
          });
      });
      // https://github.com/fullcalendar/fullcalendar/issues/6451
      it('respects RECURRENCE-ID and does not render double events', (done) => {
          loadICalendarWith(dataWithRecurrenceId, () => {
              setTimeout(() => {
                  let timeGridWrapper = new TimeGridViewWrapper(currentCalendar).timeGrid;
                  let eventEls = timeGridWrapper.getEventEls();
                  expect(eventEls.length).toBe(1);
                  done();
              }, 100);
          }, (source) => {
              initCalendar({
                  initialDate: '2021-07-08',
              }).addEventSource(source);
          });
      });
      it('does not reload data on next', (done) => {
          let requestCnt = 0;
          const givenUrl = window.location.href + '/my-feed.php';
          client.get(/my-feed\.php/, () => {
              requestCnt++;
              return {
                  headers: { 'content-type': ICAL_MIME_TYPE },
                  body: timedMeetingWithDuration,
              };
          });
          initCalendar().addEventSource({ url: givenUrl, format: 'ics' });
          setTimeout(() => {
              assertEventCount(1);
              currentCalendar.next();
              expect(requestCnt).toBe(1);
              done();
          }, 100);
      });
      function loadICalendarWith(rawICal, assertions, calendarSetup) {
          const givenUrl = window.location.href + '/my-feed.php';
          client.get(/my-feed\.php/, {
              headers: { 'content-type': ICAL_MIME_TYPE },
              body: rawICal,
          });
          const source = { url: givenUrl, format: 'ics' };
          if (calendarSetup) {
              calendarSetup(source);
          }
          else {
              initCalendar().addEventSource(source);
          }
          const [requestUrl] = client.lastCall();
          const requestParamStr = new URL(requestUrl).searchParams.toString();
          expect(requestParamStr).toBe('');
          assertions();
      }
      // Checks to make sure all events have been rendered and that the calendar
      // has internal info on all the events.
      function assertEventCount(expectedCount) {
          expect(currentCalendar.getEvents().length).toEqual(expectedCount);
          let calendarWrapper = new CalendarWrapper(currentCalendar);
          expect(calendarWrapper.getEventEls().length).toEqual(expectedCount);
      }
  });

  describe('event source refetch', () => {
      const OPTIONS = {
          now: '2015-08-07',
          initialView: 'timeGridDay',
          scrollTime: '00:00',
      };
      describe('with a single event source', () => {
          it('will be refetched', () => {
              let fetchConfig = { eventCount: 1, fetchId: 7 };
              let calendar = initWithSources(fetchConfig);
              expect($('.source1-7').length).toEqual(1);
              expect($('.source2-7').length).toEqual(1);
              expect($('.source3-7').length).toEqual(1);
              fetchConfig.eventCount = 2;
              fetchConfig.fetchId = 8;
              calendar.getEventSourceById('blue').refetch();
              // events from unaffected sources remain
              expect($('.source1-7').length).toEqual(1);
              expect($('.source3-7').length).toEqual(1);
              // events from old fetch were cleared
              expect($('.source2-7').length).toEqual(0);
              // events from new fetch were rendered
              expect($('.source2-8').length).toEqual(2);
          });
      });
      describe('multiple event sources', () => {
          it('will be refetched', () => {
              let fetchConfig = { eventCount: 1, fetchId: 7 };
              let calendar = initWithSources(fetchConfig);
              expect($('.source1-7').length).toEqual(1);
              expect($('.source2-7').length).toEqual(1);
              expect($('.source3-7').length).toEqual(1);
              fetchConfig.eventCount = 2;
              fetchConfig.fetchId = 8;
              calendar.getEventSourceById('green0').refetch();
              calendar.getEventSourceById('green1').refetch();
              // events from unaffected sources remain
              expect($('.source2-7').length).toEqual(1);
              // events from old fetch were cleared
              expect($('.source1-7').length).toEqual(0);
              expect($('.source3-7').length).toEqual(0);
              // events from new fetch were rendered
              expect($('.source1-8').length).toEqual(2);
              expect($('.source3-8').length).toEqual(2);
          });
      });
      describe('when called while initial fetch is still pending', () => {
          it('keeps old events and rerenders new', (done) => {
              let fetchConfig = { eventCount: 1, fetchId: 7, fetchDelay: 100 };
              let calendar = initWithSources(fetchConfig);
              fetchConfig.eventCount = 2;
              fetchConfig.fetchId = 8;
              calendar.getEventSourceById('green0').refetch();
              calendar.getEventSourceById('green1').refetch();
              setTimeout(() => {
                  // events from unaffected sources remain
                  expect($('.source2-7').length).toEqual(1);
                  // events from old fetch were cleared
                  expect($('.source1-7').length).toEqual(0);
                  expect($('.source3-7').length).toEqual(0);
                  // events from new fetch were rendered
                  expect($('.source1-8').length).toEqual(2);
                  expect($('.source3-8').length).toEqual(2);
                  done();
              }, fetchConfig.fetchDelay + 1);
          });
      });
      function initWithSources(fetchConfig) {
          return initCalendar(Object.assign(Object.assign({}, OPTIONS), { eventSources: [
                  {
                      id: 'green0',
                      events: createEventGenerator('source1-', fetchConfig),
                      color: 'green',
                  },
                  {
                      id: 'blue',
                      events: createEventGenerator('source2-', fetchConfig),
                      color: 'blue',
                  },
                  {
                      id: 'green1',
                      events: createEventGenerator('source3-', fetchConfig),
                      color: 'green',
                  },
              ] }));
      }
      function createEventGenerator(classNamePrefix, fetchConfig) {
          return (arg, callback) => {
              let events = [];
              for (let i = 0; i < fetchConfig.eventCount; i += 1) {
                  events.push({
                      start: '2015-08-07T02:00:00',
                      end: '2015-08-07T03:00:00',
                      className: classNamePrefix + fetchConfig.fetchId,
                      title: classNamePrefix + fetchConfig.fetchId, // also make it the title
                  });
              }
              if (fetchConfig.fetchDelay) {
                  setTimeout(() => {
                      callback(events);
                  }, fetchConfig.fetchDelay);
              }
              else {
                  callback(events);
              }
          };
      }
  });

  describe('event fetching while date-navigating', () => {
      // https://github.com/fullcalendar/fullcalendar/issues/4975
      it('renders events when doing next() and then prev()', (done) => {
          let calendar = initCalendar({
              initialView: 'dayGridMonth',
              initialDate: '2020-02-11',
              events(arg, callback) {
                  if (arg.startStr.indexOf('2020-01-26') === 0) { // for Feb
                      setTimeout(() => {
                          callback([
                              { start: '2020-02-15' }, // middle of month
                          ]);
                      }, 100);
                  }
                  else if (arg.startStr.indexOf('2020-03-01') === 0) { // for March
                      setTimeout(() => {
                          callback([
                              { start: '2020-03-15' }, // middle of month
                          ]);
                      }, 100);
                  }
                  else {
                      throw new Error('bad range');
                  }
              },
          });
          let calendarWrapper = new CalendarWrapper(calendar);
          setTimeout(() => {
              currentCalendar.next();
              setTimeout(() => {
                  currentCalendar.prev();
                  setTimeout(() => {
                      expect(calendarWrapper.getEventEls().length).toBe(1);
                      done();
                  }, 1000); // after everything
              }, 50); // before second fetch finishes
          }, 200); // let first fetch finish
      });
  });

  describe('getEventSources', () => {
      xit('correctly retrieves event sources provided via `events` at initialization', () => {
      });
      xit('correctly retrieves event sources provided via `eventSources` at initialization', () => {
      });
      xit('correctly retrieves event sources provided via `addEventSource` method', () => {
      });
  });

  describe('eventSourceSuccess', () => {
      const FETCH_FUNC = (info, successCallback) => {
          successCallback({
              something: [
                  { title: 'hi', start: '2018-10-01' },
              ],
          });
      };
      const TRANSFORM = (input) => input.something;
      pushOptions({
          initialDate: '2018-10-01',
      });
      it('massages event data with calendar-wide setting', () => {
          initCalendar({
              eventSources: [FETCH_FUNC],
              eventSourceSuccess: TRANSFORM,
          });
          expect(currentCalendar.getEvents().length).toBe(1);
      });
      it('massages event data with source setting', () => {
          initCalendar({
              eventSources: [
                  {
                      events: FETCH_FUNC,
                      success: TRANSFORM,
                  },
              ],
          });
          expect(currentCalendar.getEvents().length).toBe(1);
      });
  });

  describe('addEventSource', () => {
      it('will accept a processed api object after it was removed', () => {
          initCalendar({
              eventSources: [
                  { id: 'sourceA', events: [] },
              ],
          });
          expect(currentCalendar.getEventSources().length).toBe(1);
          let source = currentCalendar.getEventSourceById('sourceA');
          source.remove();
          expect(currentCalendar.getEventSources().length).toBe(0);
          let newSource = currentCalendar.addEventSource(source);
          expect(currentCalendar.getEventSources().length).toBe(1);
          expect(newSource).toBe(source);
      });
      it('won\'t re-add a source that it already has', () => {
          initCalendar({
              eventSources: [
                  { id: 'sourceA', events: [] },
              ],
          });
          expect(currentCalendar.getEventSources().length).toBe(1);
          let source = currentCalendar.getEventSourceById('sourceA');
          let newSource = currentCalendar.addEventSource(source);
          expect(currentCalendar.getEventSources().length).toBe(1);
          expect(newSource).toBe(source);
      });
  });

  describe('event source remove', () => {
      pushOptions({
          initialDate: '2014-08-01',
      });
      it('correctly removes events provided via `eventSources` at initialization', () => {
          let calendar = initCalendar({
              eventSources: [{
                      id: '5',
                      events: [
                          { title: 'event1', start: '2014-08-01' },
                          { title: 'event2', start: '2014-08-02' },
                      ],
                  }],
          });
          let calendarWrapper = new CalendarWrapper(calendar);
          expect(calendar.getEvents().length).toBe(2);
          expect(calendarWrapper.getEventEls().length).toBe(2);
          calendar.getEventSourceById('5').remove();
          expect(calendar.getEvents().length).toBe(0);
          expect(calendarWrapper.getEventEls().length).toBe(0);
      });
      it('won\'t render removed events when subsequent addEventSource', (done) => {
          let source1 = {
              id: '1',
              events(arg, callback) {
                  setTimeout(() => {
                      callback([{
                              title: 'event1',
                              className: 'event1',
                              start: '2014-08-01T02:00:00',
                          }]);
                  }, 100);
              },
          };
          let source2 = {
              id: '2',
              events(arg, callback) {
                  setTimeout(() => {
                      callback([{
                              title: 'event2',
                              className: 'event2',
                              start: '2014-08-01T02:00:00',
                          }]);
                  }, 100);
              },
          };
          let calendar = initCalendar({
              eventSources: [source1],
          });
          calendar.getEventSourceById('1').remove();
          calendar.addEventSource(source2);
          setTimeout(() => {
              expect($('.event1').length).toBe(0);
              expect($('.event2').length).toBe(1);
              done();
          }, 101);
      });
  });

  describe('getEventSourceById', () => {
      xit('correctly retrieves an event source provided via `events` at initialization', () => {
      });
      xit('correctly retrieves an event source provided via `eventSources` at initialization', () => {
      });
      xit('correctly retrieves an event source provided via `addEventSource` method', () => {
      });
  });

})();
//# sourceMappingURL=index.global.js.map
